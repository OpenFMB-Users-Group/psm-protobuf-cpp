// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: breakermodule/breakermodule.proto

#ifndef PROTOBUF_INCLUDED_breakermodule_2fbreakermodule_2eproto
#define PROTOBUF_INCLUDED_breakermodule_2fbreakermodule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "uml.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_breakermodule_2fbreakermodule_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_breakermodule_2fbreakermodule_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_breakermodule_2fbreakermodule_2eproto();
namespace breakermodule {
class Breaker;
class BreakerDefaultTypeInternal;
extern BreakerDefaultTypeInternal _Breaker_default_instance_;
class BreakerDiscreteControl;
class BreakerDiscreteControlDefaultTypeInternal;
extern BreakerDiscreteControlDefaultTypeInternal _BreakerDiscreteControl_default_instance_;
class BreakerDiscreteControlProfile;
class BreakerDiscreteControlProfileDefaultTypeInternal;
extern BreakerDiscreteControlProfileDefaultTypeInternal _BreakerDiscreteControlProfile_default_instance_;
class BreakerDiscreteControlXCBR;
class BreakerDiscreteControlXCBRDefaultTypeInternal;
extern BreakerDiscreteControlXCBRDefaultTypeInternal _BreakerDiscreteControlXCBR_default_instance_;
class BreakerEvent;
class BreakerEventDefaultTypeInternal;
extern BreakerEventDefaultTypeInternal _BreakerEvent_default_instance_;
class BreakerEventProfile;
class BreakerEventProfileDefaultTypeInternal;
extern BreakerEventProfileDefaultTypeInternal _BreakerEventProfile_default_instance_;
class BreakerReading;
class BreakerReadingDefaultTypeInternal;
extern BreakerReadingDefaultTypeInternal _BreakerReading_default_instance_;
class BreakerReadingProfile;
class BreakerReadingProfileDefaultTypeInternal;
extern BreakerReadingProfileDefaultTypeInternal _BreakerReadingProfile_default_instance_;
class BreakerStatus;
class BreakerStatusDefaultTypeInternal;
extern BreakerStatusDefaultTypeInternal _BreakerStatus_default_instance_;
class BreakerStatusProfile;
class BreakerStatusProfileDefaultTypeInternal;
extern BreakerStatusProfileDefaultTypeInternal _BreakerStatusProfile_default_instance_;
}  // namespace breakermodule
namespace google {
namespace protobuf {
template<> ::breakermodule::Breaker* Arena::CreateMaybeMessage<::breakermodule::Breaker>(Arena*);
template<> ::breakermodule::BreakerDiscreteControl* Arena::CreateMaybeMessage<::breakermodule::BreakerDiscreteControl>(Arena*);
template<> ::breakermodule::BreakerDiscreteControlProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerDiscreteControlProfile>(Arena*);
template<> ::breakermodule::BreakerDiscreteControlXCBR* Arena::CreateMaybeMessage<::breakermodule::BreakerDiscreteControlXCBR>(Arena*);
template<> ::breakermodule::BreakerEvent* Arena::CreateMaybeMessage<::breakermodule::BreakerEvent>(Arena*);
template<> ::breakermodule::BreakerEventProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerEventProfile>(Arena*);
template<> ::breakermodule::BreakerReading* Arena::CreateMaybeMessage<::breakermodule::BreakerReading>(Arena*);
template<> ::breakermodule::BreakerReadingProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerReadingProfile>(Arena*);
template<> ::breakermodule::BreakerStatus* Arena::CreateMaybeMessage<::breakermodule::BreakerStatus>(Arena*);
template<> ::breakermodule::BreakerStatusProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerStatusProfile>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace breakermodule {

// ===================================================================

class BreakerDiscreteControlXCBR :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerDiscreteControlXCBR) */ {
 public:
  BreakerDiscreteControlXCBR();
  virtual ~BreakerDiscreteControlXCBR();

  BreakerDiscreteControlXCBR(const BreakerDiscreteControlXCBR& from);

  inline BreakerDiscreteControlXCBR& operator=(const BreakerDiscreteControlXCBR& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerDiscreteControlXCBR(BreakerDiscreteControlXCBR&& from) noexcept
    : BreakerDiscreteControlXCBR() {
    *this = ::std::move(from);
  }

  inline BreakerDiscreteControlXCBR& operator=(BreakerDiscreteControlXCBR&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerDiscreteControlXCBR& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerDiscreteControlXCBR* internal_default_instance() {
    return reinterpret_cast<const BreakerDiscreteControlXCBR*>(
               &_BreakerDiscreteControlXCBR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BreakerDiscreteControlXCBR* other);
  friend void swap(BreakerDiscreteControlXCBR& a, BreakerDiscreteControlXCBR& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerDiscreteControlXCBR* New() const final {
    return CreateMaybeMessage<BreakerDiscreteControlXCBR>(nullptr);
  }

  BreakerDiscreteControlXCBR* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerDiscreteControlXCBR>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerDiscreteControlXCBR& from);
  void MergeFrom(const BreakerDiscreteControlXCBR& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerDiscreteControlXCBR* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol();
  static const int kLogicalNodeForControlFieldNumber = 1;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);

  // .commonmodule.ControlDPC Pos = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::commonmodule::ControlDPC& pos() const;
  ::commonmodule::ControlDPC* release_pos();
  ::commonmodule::ControlDPC* mutable_pos();
  void set_allocated_pos(::commonmodule::ControlDPC* pos);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerDiscreteControlXCBR)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
  ::commonmodule::ControlDPC* pos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerDiscreteControl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerDiscreteControl) */ {
 public:
  BreakerDiscreteControl();
  virtual ~BreakerDiscreteControl();

  BreakerDiscreteControl(const BreakerDiscreteControl& from);

  inline BreakerDiscreteControl& operator=(const BreakerDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerDiscreteControl(BreakerDiscreteControl&& from) noexcept
    : BreakerDiscreteControl() {
    *this = ::std::move(from);
  }

  inline BreakerDiscreteControl& operator=(BreakerDiscreteControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerDiscreteControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerDiscreteControl* internal_default_instance() {
    return reinterpret_cast<const BreakerDiscreteControl*>(
               &_BreakerDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BreakerDiscreteControl* other);
  friend void swap(BreakerDiscreteControl& a, BreakerDiscreteControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerDiscreteControl* New() const final {
    return CreateMaybeMessage<BreakerDiscreteControl>(nullptr);
  }

  BreakerDiscreteControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerDiscreteControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerDiscreteControl& from);
  void MergeFrom(const BreakerDiscreteControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerDiscreteControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue();
  static const int kControlValueFieldNumber = 1;
  const ::commonmodule::ControlValue& controlvalue() const;
  ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);

  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 2;
  const ::commonmodule::CheckConditions& check() const;
  ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);

  // .breakermodule.BreakerDiscreteControlXCBR breakerDiscreteControlXCBR = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breakerdiscretecontrolxcbr() const;
  void clear_breakerdiscretecontrolxcbr();
  static const int kBreakerDiscreteControlXCBRFieldNumber = 3;
  const ::breakermodule::BreakerDiscreteControlXCBR& breakerdiscretecontrolxcbr() const;
  ::breakermodule::BreakerDiscreteControlXCBR* release_breakerdiscretecontrolxcbr();
  ::breakermodule::BreakerDiscreteControlXCBR* mutable_breakerdiscretecontrolxcbr();
  void set_allocated_breakerdiscretecontrolxcbr(::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerDiscreteControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlValue* controlvalue_;
  ::commonmodule::CheckConditions* check_;
  ::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class Breaker :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.Breaker) */ {
 public:
  Breaker();
  virtual ~Breaker();

  Breaker(const Breaker& from);

  inline Breaker& operator=(const Breaker& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Breaker(Breaker&& from) noexcept
    : Breaker() {
    *this = ::std::move(from);
  }

  inline Breaker& operator=(Breaker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Breaker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Breaker* internal_default_instance() {
    return reinterpret_cast<const Breaker*>(
               &_Breaker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Breaker* other);
  friend void swap(Breaker& a, Breaker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Breaker* New() const final {
    return CreateMaybeMessage<Breaker>(nullptr);
  }

  Breaker* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Breaker>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Breaker& from);
  void MergeFrom(const Breaker& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Breaker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment();
  static const int kConductingEquipmentFieldNumber = 1;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);

  // @@protoc_insertion_point(class_scope:breakermodule.Breaker)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipment* conductingequipment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerDiscreteControlProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerDiscreteControlProfile) */ {
 public:
  BreakerDiscreteControlProfile();
  virtual ~BreakerDiscreteControlProfile();

  BreakerDiscreteControlProfile(const BreakerDiscreteControlProfile& from);

  inline BreakerDiscreteControlProfile& operator=(const BreakerDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerDiscreteControlProfile(BreakerDiscreteControlProfile&& from) noexcept
    : BreakerDiscreteControlProfile() {
    *this = ::std::move(from);
  }

  inline BreakerDiscreteControlProfile& operator=(BreakerDiscreteControlProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerDiscreteControlProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerDiscreteControlProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerDiscreteControlProfile*>(
               &_BreakerDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BreakerDiscreteControlProfile* other);
  friend void swap(BreakerDiscreteControlProfile& a, BreakerDiscreteControlProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerDiscreteControlProfile* New() const final {
    return CreateMaybeMessage<BreakerDiscreteControlProfile>(nullptr);
  }

  BreakerDiscreteControlProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerDiscreteControlProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerDiscreteControlProfile& from);
  void MergeFrom(const BreakerDiscreteControlProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerDiscreteControlProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo();
  static const int kControlMessageInfoFieldNumber = 1;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);

  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  void clear_breaker();
  static const int kBreakerFieldNumber = 2;
  const ::breakermodule::Breaker& breaker() const;
  ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);

  // .breakermodule.BreakerDiscreteControl breakerDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breakerdiscretecontrol() const;
  void clear_breakerdiscretecontrol();
  static const int kBreakerDiscreteControlFieldNumber = 3;
  const ::breakermodule::BreakerDiscreteControl& breakerdiscretecontrol() const;
  ::breakermodule::BreakerDiscreteControl* release_breakerdiscretecontrol();
  ::breakermodule::BreakerDiscreteControl* mutable_breakerdiscretecontrol();
  void set_allocated_breakerdiscretecontrol(::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerDiscreteControlProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlMessageInfo* controlmessageinfo_;
  ::breakermodule::Breaker* breaker_;
  ::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerEvent) */ {
 public:
  BreakerEvent();
  virtual ~BreakerEvent();

  BreakerEvent(const BreakerEvent& from);

  inline BreakerEvent& operator=(const BreakerEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerEvent(BreakerEvent&& from) noexcept
    : BreakerEvent() {
    *this = ::std::move(from);
  }

  inline BreakerEvent& operator=(BreakerEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerEvent* internal_default_instance() {
    return reinterpret_cast<const BreakerEvent*>(
               &_BreakerEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BreakerEvent* other);
  friend void swap(BreakerEvent& a, BreakerEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerEvent* New() const final {
    return CreateMaybeMessage<BreakerEvent>(nullptr);
  }

  BreakerEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerEvent& from);
  void MergeFrom(const BreakerEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  void clear_eventvalue();
  static const int kEventValueFieldNumber = 1;
  const ::commonmodule::EventValue& eventvalue() const;
  ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);

  // .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_statusandeventxcbr() const;
  void clear_statusandeventxcbr();
  static const int kStatusAndEventXCBRFieldNumber = 2;
  const ::commonmodule::StatusAndEventXCBR& statusandeventxcbr() const;
  ::commonmodule::StatusAndEventXCBR* release_statusandeventxcbr();
  ::commonmodule::StatusAndEventXCBR* mutable_statusandeventxcbr();
  void set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventValue* eventvalue_;
  ::commonmodule::StatusAndEventXCBR* statusandeventxcbr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerEventProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerEventProfile) */ {
 public:
  BreakerEventProfile();
  virtual ~BreakerEventProfile();

  BreakerEventProfile(const BreakerEventProfile& from);

  inline BreakerEventProfile& operator=(const BreakerEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerEventProfile(BreakerEventProfile&& from) noexcept
    : BreakerEventProfile() {
    *this = ::std::move(from);
  }

  inline BreakerEventProfile& operator=(BreakerEventProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerEventProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerEventProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerEventProfile*>(
               &_BreakerEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BreakerEventProfile* other);
  friend void swap(BreakerEventProfile& a, BreakerEventProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerEventProfile* New() const final {
    return CreateMaybeMessage<BreakerEventProfile>(nullptr);
  }

  BreakerEventProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerEventProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerEventProfile& from);
  void MergeFrom(const BreakerEventProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerEventProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  void clear_eventmessageinfo();
  static const int kEventMessageInfoFieldNumber = 1;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);

  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  void clear_breaker();
  static const int kBreakerFieldNumber = 2;
  const ::breakermodule::Breaker& breaker() const;
  ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);

  // .breakermodule.BreakerEvent breakerEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breakerevent() const;
  void clear_breakerevent();
  static const int kBreakerEventFieldNumber = 3;
  const ::breakermodule::BreakerEvent& breakerevent() const;
  ::breakermodule::BreakerEvent* release_breakerevent();
  ::breakermodule::BreakerEvent* mutable_breakerevent();
  void set_allocated_breakerevent(::breakermodule::BreakerEvent* breakerevent);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerEventProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventMessageInfo* eventmessageinfo_;
  ::breakermodule::Breaker* breaker_;
  ::breakermodule::BreakerEvent* breakerevent_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerReading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerReading) */ {
 public:
  BreakerReading();
  virtual ~BreakerReading();

  BreakerReading(const BreakerReading& from);

  inline BreakerReading& operator=(const BreakerReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerReading(BreakerReading&& from) noexcept
    : BreakerReading() {
    *this = ::std::move(from);
  }

  inline BreakerReading& operator=(BreakerReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerReading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerReading* internal_default_instance() {
    return reinterpret_cast<const BreakerReading*>(
               &_BreakerReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BreakerReading* other);
  friend void swap(BreakerReading& a, BreakerReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerReading* New() const final {
    return CreateMaybeMessage<BreakerReading>(nullptr);
  }

  BreakerReading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerReading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerReading& from);
  void MergeFrom(const BreakerReading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  void clear_conductingequipmentterminalreading();
  static const int kConductingEquipmentTerminalReadingFieldNumber = 1;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);

  // .commonmodule.ReadingMMXU diffReadingMMXU = 2;
  bool has_diffreadingmmxu() const;
  void clear_diffreadingmmxu();
  static const int kDiffReadingMMXUFieldNumber = 2;
  const ::commonmodule::ReadingMMXU& diffreadingmmxu() const;
  ::commonmodule::ReadingMMXU* release_diffreadingmmxu();
  ::commonmodule::ReadingMMXU* mutable_diffreadingmmxu();
  void set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu);

  // .commonmodule.PhaseMMTN phaseMMTN = 3;
  bool has_phasemmtn() const;
  void clear_phasemmtn();
  static const int kPhaseMMTNFieldNumber = 3;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);

  // .commonmodule.ReadingMMTR readingMMTR = 4;
  bool has_readingmmtr() const;
  void clear_readingmmtr();
  static const int kReadingMMTRFieldNumber = 4;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);

  // .commonmodule.ReadingMMXU readingMMXU = 5;
  bool has_readingmmxu() const;
  void clear_readingmmxu();
  static const int kReadingMMXUFieldNumber = 5;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerReading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
  ::commonmodule::ReadingMMXU* diffreadingmmxu_;
  ::commonmodule::PhaseMMTN* phasemmtn_;
  ::commonmodule::ReadingMMTR* readingmmtr_;
  ::commonmodule::ReadingMMXU* readingmmxu_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerReadingProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerReadingProfile) */ {
 public:
  BreakerReadingProfile();
  virtual ~BreakerReadingProfile();

  BreakerReadingProfile(const BreakerReadingProfile& from);

  inline BreakerReadingProfile& operator=(const BreakerReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerReadingProfile(BreakerReadingProfile&& from) noexcept
    : BreakerReadingProfile() {
    *this = ::std::move(from);
  }

  inline BreakerReadingProfile& operator=(BreakerReadingProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerReadingProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerReadingProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerReadingProfile*>(
               &_BreakerReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(BreakerReadingProfile* other);
  friend void swap(BreakerReadingProfile& a, BreakerReadingProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerReadingProfile* New() const final {
    return CreateMaybeMessage<BreakerReadingProfile>(nullptr);
  }

  BreakerReadingProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerReadingProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerReadingProfile& from);
  void MergeFrom(const BreakerReadingProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerReadingProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .breakermodule.BreakerReading breakerReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
  int breakerreading_size() const;
  void clear_breakerreading();
  static const int kBreakerReadingFieldNumber = 3;
  ::breakermodule::BreakerReading* mutable_breakerreading(int index);
  ::google::protobuf::RepeatedPtrField< ::breakermodule::BreakerReading >*
      mutable_breakerreading();
  const ::breakermodule::BreakerReading& breakerreading(int index) const;
  ::breakermodule::BreakerReading* add_breakerreading();
  const ::google::protobuf::RepeatedPtrField< ::breakermodule::BreakerReading >&
      breakerreading() const;

  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  void clear_readingmessageinfo();
  static const int kReadingMessageInfoFieldNumber = 1;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);

  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  void clear_breaker();
  static const int kBreakerFieldNumber = 2;
  const ::breakermodule::Breaker& breaker() const;
  ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerReadingProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::breakermodule::BreakerReading > breakerreading_;
  ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
  ::breakermodule::Breaker* breaker_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerStatus) */ {
 public:
  BreakerStatus();
  virtual ~BreakerStatus();

  BreakerStatus(const BreakerStatus& from);

  inline BreakerStatus& operator=(const BreakerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerStatus(BreakerStatus&& from) noexcept
    : BreakerStatus() {
    *this = ::std::move(from);
  }

  inline BreakerStatus& operator=(BreakerStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerStatus* internal_default_instance() {
    return reinterpret_cast<const BreakerStatus*>(
               &_BreakerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BreakerStatus* other);
  friend void swap(BreakerStatus& a, BreakerStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerStatus* New() const final {
    return CreateMaybeMessage<BreakerStatus>(nullptr);
  }

  BreakerStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerStatus& from);
  void MergeFrom(const BreakerStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  void clear_statusvalue();
  static const int kStatusValueFieldNumber = 1;
  const ::commonmodule::StatusValue& statusvalue() const;
  ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);

  // .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_statusandeventxcbr() const;
  void clear_statusandeventxcbr();
  static const int kStatusAndEventXCBRFieldNumber = 2;
  const ::commonmodule::StatusAndEventXCBR& statusandeventxcbr() const;
  ::commonmodule::StatusAndEventXCBR* release_statusandeventxcbr();
  ::commonmodule::StatusAndEventXCBR* mutable_statusandeventxcbr();
  void set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusValue* statusvalue_;
  ::commonmodule::StatusAndEventXCBR* statusandeventxcbr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// -------------------------------------------------------------------

class BreakerStatusProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerStatusProfile) */ {
 public:
  BreakerStatusProfile();
  virtual ~BreakerStatusProfile();

  BreakerStatusProfile(const BreakerStatusProfile& from);

  inline BreakerStatusProfile& operator=(const BreakerStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BreakerStatusProfile(BreakerStatusProfile&& from) noexcept
    : BreakerStatusProfile() {
    *this = ::std::move(from);
  }

  inline BreakerStatusProfile& operator=(BreakerStatusProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BreakerStatusProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BreakerStatusProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerStatusProfile*>(
               &_BreakerStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(BreakerStatusProfile* other);
  friend void swap(BreakerStatusProfile& a, BreakerStatusProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BreakerStatusProfile* New() const final {
    return CreateMaybeMessage<BreakerStatusProfile>(nullptr);
  }

  BreakerStatusProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BreakerStatusProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BreakerStatusProfile& from);
  void MergeFrom(const BreakerStatusProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerStatusProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  void clear_statusmessageinfo();
  static const int kStatusMessageInfoFieldNumber = 1;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);

  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  void clear_breaker();
  static const int kBreakerFieldNumber = 2;
  const ::breakermodule::Breaker& breaker() const;
  ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);

  // .breakermodule.BreakerStatus breakerStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breakerstatus() const;
  void clear_breakerstatus();
  static const int kBreakerStatusFieldNumber = 3;
  const ::breakermodule::BreakerStatus& breakerstatus() const;
  ::breakermodule::BreakerStatus* release_breakerstatus();
  ::breakermodule::BreakerStatus* mutable_breakerstatus();
  void set_allocated_breakerstatus(::breakermodule::BreakerStatus* breakerstatus);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:breakermodule.BreakerStatusProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusMessageInfo* statusmessageinfo_;
  ::breakermodule::Breaker* breaker_;
  ::breakermodule::BreakerStatus* breakerstatus_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BreakerDiscreteControlXCBR

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool BreakerDiscreteControlXCBR::has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && logicalnodeforcontrol_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForControl& BreakerDiscreteControlXCBR::logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = logicalnodeforcontrol_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlXCBR.logicalNodeForControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForControl*>(
      &::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline ::commonmodule::LogicalNodeForControl* BreakerDiscreteControlXCBR::release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlXCBR.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = logicalnodeforcontrol_;
  logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* BreakerDiscreteControlXCBR::mutable_logicalnodeforcontrol() {
  
  if (logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaNoVirtual());
    logicalnodeforcontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlXCBR.logicalNodeForControl)
  return logicalnodeforcontrol_;
}
inline void BreakerDiscreteControlXCBR::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlXCBR.logicalNodeForControl)
}

// .commonmodule.ControlDPC Pos = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerDiscreteControlXCBR::has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline const ::commonmodule::ControlDPC& BreakerDiscreteControlXCBR::pos() const {
  const ::commonmodule::ControlDPC* p = pos_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlXCBR.Pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* BreakerDiscreteControlXCBR::release_pos() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlXCBR.Pos)
  
  ::commonmodule::ControlDPC* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* BreakerDiscreteControlXCBR::mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlXCBR.Pos)
  return pos_;
}
inline void BreakerDiscreteControlXCBR::set_allocated_pos(::commonmodule::ControlDPC* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlXCBR.Pos)
}

// -------------------------------------------------------------------

// BreakerDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool BreakerDiscreteControl::has_controlvalue() const {
  return this != internal_default_instance() && controlvalue_ != nullptr;
}
inline const ::commonmodule::ControlValue& BreakerDiscreteControl::controlvalue() const {
  const ::commonmodule::ControlValue* p = controlvalue_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControl.controlValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlValue*>(
      &::commonmodule::_ControlValue_default_instance_);
}
inline ::commonmodule::ControlValue* BreakerDiscreteControl::release_controlvalue() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControl.controlValue)
  
  ::commonmodule::ControlValue* temp = controlvalue_;
  controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* BreakerDiscreteControl::mutable_controlvalue() {
  
  if (controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaNoVirtual());
    controlvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControl.controlValue)
  return controlvalue_;
}
inline void BreakerDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlvalue_);
  }
  if (controlvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }
    
  } else {
    
  }
  controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool BreakerDiscreteControl::has_check() const {
  return this != internal_default_instance() && check_ != nullptr;
}
inline const ::commonmodule::CheckConditions& BreakerDiscreteControl::check() const {
  const ::commonmodule::CheckConditions* p = check_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControl.check)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CheckConditions*>(
      &::commonmodule::_CheckConditions_default_instance_);
}
inline ::commonmodule::CheckConditions* BreakerDiscreteControl::release_check() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControl.check)
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* BreakerDiscreteControl::mutable_check() {
  
  if (check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaNoVirtual());
    check_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControl.check)
  return check_;
}
inline void BreakerDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(check_);
  }
  if (check) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControl.check)
}

// .breakermodule.BreakerDiscreteControlXCBR breakerDiscreteControlXCBR = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerDiscreteControl::has_breakerdiscretecontrolxcbr() const {
  return this != internal_default_instance() && breakerdiscretecontrolxcbr_ != nullptr;
}
inline void BreakerDiscreteControl::clear_breakerdiscretecontrolxcbr() {
  if (GetArenaNoVirtual() == nullptr && breakerdiscretecontrolxcbr_ != nullptr) {
    delete breakerdiscretecontrolxcbr_;
  }
  breakerdiscretecontrolxcbr_ = nullptr;
}
inline const ::breakermodule::BreakerDiscreteControlXCBR& BreakerDiscreteControl::breakerdiscretecontrolxcbr() const {
  const ::breakermodule::BreakerDiscreteControlXCBR* p = breakerdiscretecontrolxcbr_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::BreakerDiscreteControlXCBR*>(
      &::breakermodule::_BreakerDiscreteControlXCBR_default_instance_);
}
inline ::breakermodule::BreakerDiscreteControlXCBR* BreakerDiscreteControl::release_breakerdiscretecontrolxcbr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
  
  ::breakermodule::BreakerDiscreteControlXCBR* temp = breakerdiscretecontrolxcbr_;
  breakerdiscretecontrolxcbr_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerDiscreteControlXCBR* BreakerDiscreteControl::mutable_breakerdiscretecontrolxcbr() {
  
  if (breakerdiscretecontrolxcbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerDiscreteControlXCBR>(GetArenaNoVirtual());
    breakerdiscretecontrolxcbr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
  return breakerdiscretecontrolxcbr_;
}
inline void BreakerDiscreteControl::set_allocated_breakerdiscretecontrolxcbr(::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breakerdiscretecontrolxcbr_;
  }
  if (breakerdiscretecontrolxcbr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breakerdiscretecontrolxcbr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breakerdiscretecontrolxcbr, submessage_arena);
    }
    
  } else {
    
  }
  breakerdiscretecontrolxcbr_ = breakerdiscretecontrolxcbr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
}

// -------------------------------------------------------------------

// Breaker

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool Breaker::has_conductingequipment() const {
  return this != internal_default_instance() && conductingequipment_ != nullptr;
}
inline const ::commonmodule::ConductingEquipment& Breaker::conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = conductingequipment_;
  // @@protoc_insertion_point(field_get:breakermodule.Breaker.conductingEquipment)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipment*>(
      &::commonmodule::_ConductingEquipment_default_instance_);
}
inline ::commonmodule::ConductingEquipment* Breaker::release_conductingequipment() {
  // @@protoc_insertion_point(field_release:breakermodule.Breaker.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = conductingequipment_;
  conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* Breaker::mutable_conductingequipment() {
  
  if (conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaNoVirtual());
    conductingequipment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.Breaker.conductingEquipment)
  return conductingequipment_;
}
inline void Breaker::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipment_);
  }
  if (conductingequipment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.Breaker.conductingEquipment)
}

// -------------------------------------------------------------------

// BreakerDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerDiscreteControlProfile::has_controlmessageinfo() const {
  return this != internal_default_instance() && controlmessageinfo_ != nullptr;
}
inline const ::commonmodule::ControlMessageInfo& BreakerDiscreteControlProfile::controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = controlmessageinfo_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlMessageInfo*>(
      &::commonmodule::_ControlMessageInfo_default_instance_);
}
inline ::commonmodule::ControlMessageInfo* BreakerDiscreteControlProfile::release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* BreakerDiscreteControlProfile::mutable_controlmessageinfo() {
  
  if (controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaNoVirtual());
    controlmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
  return controlmessageinfo_;
}
inline void BreakerDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerDiscreteControlProfile::has_breaker() const {
  return this != internal_default_instance() && breaker_ != nullptr;
}
inline void BreakerDiscreteControlProfile::clear_breaker() {
  if (GetArenaNoVirtual() == nullptr && breaker_ != nullptr) {
    delete breaker_;
  }
  breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerDiscreteControlProfile::breaker() const {
  const ::breakermodule::Breaker* p = breaker_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlProfile.breaker)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::Breaker*>(
      &::breakermodule::_Breaker_default_instance_);
}
inline ::breakermodule::Breaker* BreakerDiscreteControlProfile::release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlProfile.breaker)
  
  ::breakermodule::Breaker* temp = breaker_;
  breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerDiscreteControlProfile::mutable_breaker() {
  
  if (breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaNoVirtual());
    breaker_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlProfile.breaker)
  return breaker_;
}
inline void BreakerDiscreteControlProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breaker_;
  }
  if (breaker) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breaker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }
    
  } else {
    
  }
  breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlProfile.breaker)
}

// .breakermodule.BreakerDiscreteControl breakerDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerDiscreteControlProfile::has_breakerdiscretecontrol() const {
  return this != internal_default_instance() && breakerdiscretecontrol_ != nullptr;
}
inline void BreakerDiscreteControlProfile::clear_breakerdiscretecontrol() {
  if (GetArenaNoVirtual() == nullptr && breakerdiscretecontrol_ != nullptr) {
    delete breakerdiscretecontrol_;
  }
  breakerdiscretecontrol_ = nullptr;
}
inline const ::breakermodule::BreakerDiscreteControl& BreakerDiscreteControlProfile::breakerdiscretecontrol() const {
  const ::breakermodule::BreakerDiscreteControl* p = breakerdiscretecontrol_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::BreakerDiscreteControl*>(
      &::breakermodule::_BreakerDiscreteControl_default_instance_);
}
inline ::breakermodule::BreakerDiscreteControl* BreakerDiscreteControlProfile::release_breakerdiscretecontrol() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
  
  ::breakermodule::BreakerDiscreteControl* temp = breakerdiscretecontrol_;
  breakerdiscretecontrol_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerDiscreteControl* BreakerDiscreteControlProfile::mutable_breakerdiscretecontrol() {
  
  if (breakerdiscretecontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerDiscreteControl>(GetArenaNoVirtual());
    breakerdiscretecontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
  return breakerdiscretecontrol_;
}
inline void BreakerDiscreteControlProfile::set_allocated_breakerdiscretecontrol(::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breakerdiscretecontrol_;
  }
  if (breakerdiscretecontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breakerdiscretecontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breakerdiscretecontrol, submessage_arena);
    }
    
  } else {
    
  }
  breakerdiscretecontrol_ = breakerdiscretecontrol;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerDiscreteControlProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& BreakerDiscreteControlProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* BreakerDiscreteControlProfile::release_ied() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* BreakerDiscreteControlProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlProfile.ied)
  return ied_;
}
inline void BreakerDiscreteControlProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlProfile.ied)
}

// -------------------------------------------------------------------

// BreakerEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool BreakerEvent::has_eventvalue() const {
  return this != internal_default_instance() && eventvalue_ != nullptr;
}
inline const ::commonmodule::EventValue& BreakerEvent::eventvalue() const {
  const ::commonmodule::EventValue* p = eventvalue_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEvent.eventValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventValue*>(
      &::commonmodule::_EventValue_default_instance_);
}
inline ::commonmodule::EventValue* BreakerEvent::release_eventvalue() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEvent.eventValue)
  
  ::commonmodule::EventValue* temp = eventvalue_;
  eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* BreakerEvent::mutable_eventvalue() {
  
  if (eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaNoVirtual());
    eventvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEvent.eventValue)
  return eventvalue_;
}
inline void BreakerEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventvalue_);
  }
  if (eventvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }
    
  } else {
    
  }
  eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEvent.eventValue)
}

// .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerEvent::has_statusandeventxcbr() const {
  return this != internal_default_instance() && statusandeventxcbr_ != nullptr;
}
inline const ::commonmodule::StatusAndEventXCBR& BreakerEvent::statusandeventxcbr() const {
  const ::commonmodule::StatusAndEventXCBR* p = statusandeventxcbr_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEvent.statusAndEventXCBR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusAndEventXCBR*>(
      &::commonmodule::_StatusAndEventXCBR_default_instance_);
}
inline ::commonmodule::StatusAndEventXCBR* BreakerEvent::release_statusandeventxcbr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEvent.statusAndEventXCBR)
  
  ::commonmodule::StatusAndEventXCBR* temp = statusandeventxcbr_;
  statusandeventxcbr_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerEvent::mutable_statusandeventxcbr() {
  
  if (statusandeventxcbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusAndEventXCBR>(GetArenaNoVirtual());
    statusandeventxcbr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEvent.statusAndEventXCBR)
  return statusandeventxcbr_;
}
inline void BreakerEvent::set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusandeventxcbr_);
  }
  if (statusandeventxcbr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusandeventxcbr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusandeventxcbr, submessage_arena);
    }
    
  } else {
    
  }
  statusandeventxcbr_ = statusandeventxcbr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEvent.statusAndEventXCBR)
}

// -------------------------------------------------------------------

// BreakerEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerEventProfile::has_eventmessageinfo() const {
  return this != internal_default_instance() && eventmessageinfo_ != nullptr;
}
inline const ::commonmodule::EventMessageInfo& BreakerEventProfile::eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = eventmessageinfo_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEventProfile.eventMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventMessageInfo*>(
      &::commonmodule::_EventMessageInfo_default_instance_);
}
inline ::commonmodule::EventMessageInfo* BreakerEventProfile::release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* BreakerEventProfile::mutable_eventmessageinfo() {
  
  if (eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaNoVirtual());
    eventmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEventProfile.eventMessageInfo)
  return eventmessageinfo_;
}
inline void BreakerEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEventProfile.eventMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerEventProfile::has_breaker() const {
  return this != internal_default_instance() && breaker_ != nullptr;
}
inline void BreakerEventProfile::clear_breaker() {
  if (GetArenaNoVirtual() == nullptr && breaker_ != nullptr) {
    delete breaker_;
  }
  breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerEventProfile::breaker() const {
  const ::breakermodule::Breaker* p = breaker_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEventProfile.breaker)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::Breaker*>(
      &::breakermodule::_Breaker_default_instance_);
}
inline ::breakermodule::Breaker* BreakerEventProfile::release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEventProfile.breaker)
  
  ::breakermodule::Breaker* temp = breaker_;
  breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerEventProfile::mutable_breaker() {
  
  if (breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaNoVirtual());
    breaker_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEventProfile.breaker)
  return breaker_;
}
inline void BreakerEventProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breaker_;
  }
  if (breaker) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breaker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }
    
  } else {
    
  }
  breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEventProfile.breaker)
}

// .breakermodule.BreakerEvent breakerEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerEventProfile::has_breakerevent() const {
  return this != internal_default_instance() && breakerevent_ != nullptr;
}
inline void BreakerEventProfile::clear_breakerevent() {
  if (GetArenaNoVirtual() == nullptr && breakerevent_ != nullptr) {
    delete breakerevent_;
  }
  breakerevent_ = nullptr;
}
inline const ::breakermodule::BreakerEvent& BreakerEventProfile::breakerevent() const {
  const ::breakermodule::BreakerEvent* p = breakerevent_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEventProfile.breakerEvent)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::BreakerEvent*>(
      &::breakermodule::_BreakerEvent_default_instance_);
}
inline ::breakermodule::BreakerEvent* BreakerEventProfile::release_breakerevent() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEventProfile.breakerEvent)
  
  ::breakermodule::BreakerEvent* temp = breakerevent_;
  breakerevent_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerEvent* BreakerEventProfile::mutable_breakerevent() {
  
  if (breakerevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerEvent>(GetArenaNoVirtual());
    breakerevent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEventProfile.breakerEvent)
  return breakerevent_;
}
inline void BreakerEventProfile::set_allocated_breakerevent(::breakermodule::BreakerEvent* breakerevent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breakerevent_;
  }
  if (breakerevent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breakerevent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breakerevent, submessage_arena);
    }
    
  } else {
    
  }
  breakerevent_ = breakerevent;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEventProfile.breakerEvent)
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerEventProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& BreakerEventProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEventProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* BreakerEventProfile::release_ied() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEventProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* BreakerEventProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEventProfile.ied)
  return ied_;
}
inline void BreakerEventProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEventProfile.ied)
}

// -------------------------------------------------------------------

// BreakerReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool BreakerReading::has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && conductingequipmentterminalreading_ != nullptr;
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& BreakerReading::conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = conductingequipmentterminalreading_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading*>(
      &::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline ::commonmodule::ConductingEquipmentTerminalReading* BreakerReading::release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = conductingequipmentterminalreading_;
  conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* BreakerReading::mutable_conductingequipmentterminalreading() {
  
  if (conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaNoVirtual());
    conductingequipmentterminalreading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
  return conductingequipmentterminalreading_;
}
inline void BreakerReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
}

// .commonmodule.ReadingMMXU diffReadingMMXU = 2;
inline bool BreakerReading::has_diffreadingmmxu() const {
  return this != internal_default_instance() && diffreadingmmxu_ != nullptr;
}
inline const ::commonmodule::ReadingMMXU& BreakerReading::diffreadingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = diffreadingmmxu_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.diffReadingMMXU)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMXU*>(
      &::commonmodule::_ReadingMMXU_default_instance_);
}
inline ::commonmodule::ReadingMMXU* BreakerReading::release_diffreadingmmxu() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.diffReadingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = diffreadingmmxu_;
  diffreadingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::mutable_diffreadingmmxu() {
  
  if (diffreadingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaNoVirtual());
    diffreadingmmxu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.diffReadingMMXU)
  return diffreadingmmxu_;
}
inline void BreakerReading::set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(diffreadingmmxu_);
  }
  if (diffreadingmmxu) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      diffreadingmmxu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, diffreadingmmxu, submessage_arena);
    }
    
  } else {
    
  }
  diffreadingmmxu_ = diffreadingmmxu;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.diffReadingMMXU)
}

// .commonmodule.PhaseMMTN phaseMMTN = 3;
inline bool BreakerReading::has_phasemmtn() const {
  return this != internal_default_instance() && phasemmtn_ != nullptr;
}
inline const ::commonmodule::PhaseMMTN& BreakerReading::phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = phasemmtn_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.phaseMMTN)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::PhaseMMTN*>(
      &::commonmodule::_PhaseMMTN_default_instance_);
}
inline ::commonmodule::PhaseMMTN* BreakerReading::release_phasemmtn() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = phasemmtn_;
  phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* BreakerReading::mutable_phasemmtn() {
  
  if (phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaNoVirtual());
    phasemmtn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.phaseMMTN)
  return phasemmtn_;
}
inline void BreakerReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(phasemmtn_);
  }
  if (phasemmtn) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phasemmtn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }
    
  } else {
    
  }
  phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 4;
inline bool BreakerReading::has_readingmmtr() const {
  return this != internal_default_instance() && readingmmtr_ != nullptr;
}
inline const ::commonmodule::ReadingMMTR& BreakerReading::readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = readingmmtr_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.readingMMTR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTR*>(
      &::commonmodule::_ReadingMMTR_default_instance_);
}
inline ::commonmodule::ReadingMMTR* BreakerReading::release_readingmmtr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = readingmmtr_;
  readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* BreakerReading::mutable_readingmmtr() {
  
  if (readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaNoVirtual());
    readingmmtr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.readingMMTR)
  return readingmmtr_;
}
inline void BreakerReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmtr_);
  }
  if (readingmmtr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmtr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }
    
  } else {
    
  }
  readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 5;
inline bool BreakerReading::has_readingmmxu() const {
  return this != internal_default_instance() && readingmmxu_ != nullptr;
}
inline const ::commonmodule::ReadingMMXU& BreakerReading::readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = readingmmxu_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.readingMMXU)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMXU*>(
      &::commonmodule::_ReadingMMXU_default_instance_);
}
inline ::commonmodule::ReadingMMXU* BreakerReading::release_readingmmxu() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = readingmmxu_;
  readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::mutable_readingmmxu() {
  
  if (readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaNoVirtual());
    readingmmxu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.readingMMXU)
  return readingmmxu_;
}
inline void BreakerReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmxu_);
  }
  if (readingmmxu) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmxu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }
    
  } else {
    
  }
  readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.readingMMXU)
}

// -------------------------------------------------------------------

// BreakerReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerReadingProfile::has_readingmessageinfo() const {
  return this != internal_default_instance() && readingmessageinfo_ != nullptr;
}
inline const ::commonmodule::ReadingMessageInfo& BreakerReadingProfile::readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = readingmessageinfo_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReadingProfile.readingMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMessageInfo*>(
      &::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline ::commonmodule::ReadingMessageInfo* BreakerReadingProfile::release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = readingmessageinfo_;
  readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* BreakerReadingProfile::mutable_readingmessageinfo() {
  
  if (readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaNoVirtual());
    readingmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReadingProfile.readingMessageInfo)
  return readingmessageinfo_;
}
inline void BreakerReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReadingProfile.readingMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerReadingProfile::has_breaker() const {
  return this != internal_default_instance() && breaker_ != nullptr;
}
inline void BreakerReadingProfile::clear_breaker() {
  if (GetArenaNoVirtual() == nullptr && breaker_ != nullptr) {
    delete breaker_;
  }
  breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerReadingProfile::breaker() const {
  const ::breakermodule::Breaker* p = breaker_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReadingProfile.breaker)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::Breaker*>(
      &::breakermodule::_Breaker_default_instance_);
}
inline ::breakermodule::Breaker* BreakerReadingProfile::release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReadingProfile.breaker)
  
  ::breakermodule::Breaker* temp = breaker_;
  breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerReadingProfile::mutable_breaker() {
  
  if (breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaNoVirtual());
    breaker_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReadingProfile.breaker)
  return breaker_;
}
inline void BreakerReadingProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breaker_;
  }
  if (breaker) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breaker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }
    
  } else {
    
  }
  breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReadingProfile.breaker)
}

// repeated .breakermodule.BreakerReading breakerReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
inline int BreakerReadingProfile::breakerreading_size() const {
  return breakerreading_.size();
}
inline void BreakerReadingProfile::clear_breakerreading() {
  breakerreading_.Clear();
}
inline ::breakermodule::BreakerReading* BreakerReadingProfile::mutable_breakerreading(int index) {
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReadingProfile.breakerReading)
  return breakerreading_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::breakermodule::BreakerReading >*
BreakerReadingProfile::mutable_breakerreading() {
  // @@protoc_insertion_point(field_mutable_list:breakermodule.BreakerReadingProfile.breakerReading)
  return &breakerreading_;
}
inline const ::breakermodule::BreakerReading& BreakerReadingProfile::breakerreading(int index) const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReadingProfile.breakerReading)
  return breakerreading_.Get(index);
}
inline ::breakermodule::BreakerReading* BreakerReadingProfile::add_breakerreading() {
  // @@protoc_insertion_point(field_add:breakermodule.BreakerReadingProfile.breakerReading)
  return breakerreading_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::breakermodule::BreakerReading >&
BreakerReadingProfile::breakerreading() const {
  // @@protoc_insertion_point(field_list:breakermodule.BreakerReadingProfile.breakerReading)
  return breakerreading_;
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerReadingProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& BreakerReadingProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReadingProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* BreakerReadingProfile::release_ied() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReadingProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* BreakerReadingProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReadingProfile.ied)
  return ied_;
}
inline void BreakerReadingProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReadingProfile.ied)
}

// -------------------------------------------------------------------

// BreakerStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool BreakerStatus::has_statusvalue() const {
  return this != internal_default_instance() && statusvalue_ != nullptr;
}
inline const ::commonmodule::StatusValue& BreakerStatus::statusvalue() const {
  const ::commonmodule::StatusValue* p = statusvalue_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatus.statusValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusValue*>(
      &::commonmodule::_StatusValue_default_instance_);
}
inline ::commonmodule::StatusValue* BreakerStatus::release_statusvalue() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = statusvalue_;
  statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* BreakerStatus::mutable_statusvalue() {
  
  if (statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaNoVirtual());
    statusvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatus.statusValue)
  return statusvalue_;
}
inline void BreakerStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusvalue_);
  }
  if (statusvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }
    
  } else {
    
  }
  statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatus.statusValue)
}

// .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerStatus::has_statusandeventxcbr() const {
  return this != internal_default_instance() && statusandeventxcbr_ != nullptr;
}
inline const ::commonmodule::StatusAndEventXCBR& BreakerStatus::statusandeventxcbr() const {
  const ::commonmodule::StatusAndEventXCBR* p = statusandeventxcbr_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatus.statusAndEventXCBR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusAndEventXCBR*>(
      &::commonmodule::_StatusAndEventXCBR_default_instance_);
}
inline ::commonmodule::StatusAndEventXCBR* BreakerStatus::release_statusandeventxcbr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatus.statusAndEventXCBR)
  
  ::commonmodule::StatusAndEventXCBR* temp = statusandeventxcbr_;
  statusandeventxcbr_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerStatus::mutable_statusandeventxcbr() {
  
  if (statusandeventxcbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusAndEventXCBR>(GetArenaNoVirtual());
    statusandeventxcbr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatus.statusAndEventXCBR)
  return statusandeventxcbr_;
}
inline void BreakerStatus::set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusandeventxcbr_);
  }
  if (statusandeventxcbr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusandeventxcbr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusandeventxcbr, submessage_arena);
    }
    
  } else {
    
  }
  statusandeventxcbr_ = statusandeventxcbr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatus.statusAndEventXCBR)
}

// -------------------------------------------------------------------

// BreakerStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerStatusProfile::has_statusmessageinfo() const {
  return this != internal_default_instance() && statusmessageinfo_ != nullptr;
}
inline const ::commonmodule::StatusMessageInfo& BreakerStatusProfile::statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = statusmessageinfo_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatusProfile.statusMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusMessageInfo*>(
      &::commonmodule::_StatusMessageInfo_default_instance_);
}
inline ::commonmodule::StatusMessageInfo* BreakerStatusProfile::release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = statusmessageinfo_;
  statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* BreakerStatusProfile::mutable_statusmessageinfo() {
  
  if (statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaNoVirtual());
    statusmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatusProfile.statusMessageInfo)
  return statusmessageinfo_;
}
inline void BreakerStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatusProfile.statusMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerStatusProfile::has_breaker() const {
  return this != internal_default_instance() && breaker_ != nullptr;
}
inline void BreakerStatusProfile::clear_breaker() {
  if (GetArenaNoVirtual() == nullptr && breaker_ != nullptr) {
    delete breaker_;
  }
  breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerStatusProfile::breaker() const {
  const ::breakermodule::Breaker* p = breaker_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatusProfile.breaker)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::Breaker*>(
      &::breakermodule::_Breaker_default_instance_);
}
inline ::breakermodule::Breaker* BreakerStatusProfile::release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatusProfile.breaker)
  
  ::breakermodule::Breaker* temp = breaker_;
  breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerStatusProfile::mutable_breaker() {
  
  if (breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaNoVirtual());
    breaker_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatusProfile.breaker)
  return breaker_;
}
inline void BreakerStatusProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breaker_;
  }
  if (breaker) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breaker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }
    
  } else {
    
  }
  breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatusProfile.breaker)
}

// .breakermodule.BreakerStatus breakerStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerStatusProfile::has_breakerstatus() const {
  return this != internal_default_instance() && breakerstatus_ != nullptr;
}
inline void BreakerStatusProfile::clear_breakerstatus() {
  if (GetArenaNoVirtual() == nullptr && breakerstatus_ != nullptr) {
    delete breakerstatus_;
  }
  breakerstatus_ = nullptr;
}
inline const ::breakermodule::BreakerStatus& BreakerStatusProfile::breakerstatus() const {
  const ::breakermodule::BreakerStatus* p = breakerstatus_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatusProfile.breakerStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::breakermodule::BreakerStatus*>(
      &::breakermodule::_BreakerStatus_default_instance_);
}
inline ::breakermodule::BreakerStatus* BreakerStatusProfile::release_breakerstatus() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatusProfile.breakerStatus)
  
  ::breakermodule::BreakerStatus* temp = breakerstatus_;
  breakerstatus_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerStatus* BreakerStatusProfile::mutable_breakerstatus() {
  
  if (breakerstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerStatus>(GetArenaNoVirtual());
    breakerstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatusProfile.breakerStatus)
  return breakerstatus_;
}
inline void BreakerStatusProfile::set_allocated_breakerstatus(::breakermodule::BreakerStatus* breakerstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete breakerstatus_;
  }
  if (breakerstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      breakerstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breakerstatus, submessage_arena);
    }
    
  } else {
    
  }
  breakerstatus_ = breakerstatus;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatusProfile.breakerStatus)
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerStatusProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& BreakerStatusProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatusProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* BreakerStatusProfile::release_ied() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatusProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* BreakerStatusProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatusProfile.ied)
  return ied_;
}
inline void BreakerStatusProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatusProfile.ied)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace breakermodule

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_breakermodule_2fbreakermodule_2eproto
