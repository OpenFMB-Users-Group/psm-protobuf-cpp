// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: breakermodule/breakermodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_breakermodule_2fbreakermodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_breakermodule_2fbreakermodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_breakermodule_2fbreakermodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_breakermodule_2fbreakermodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_breakermodule_2fbreakermodule_2eproto;
namespace breakermodule {
class Breaker;
struct BreakerDefaultTypeInternal;
extern BreakerDefaultTypeInternal _Breaker_default_instance_;
class BreakerDiscreteControl;
struct BreakerDiscreteControlDefaultTypeInternal;
extern BreakerDiscreteControlDefaultTypeInternal _BreakerDiscreteControl_default_instance_;
class BreakerDiscreteControlProfile;
struct BreakerDiscreteControlProfileDefaultTypeInternal;
extern BreakerDiscreteControlProfileDefaultTypeInternal _BreakerDiscreteControlProfile_default_instance_;
class BreakerDiscreteControlXCBR;
struct BreakerDiscreteControlXCBRDefaultTypeInternal;
extern BreakerDiscreteControlXCBRDefaultTypeInternal _BreakerDiscreteControlXCBR_default_instance_;
class BreakerEvent;
struct BreakerEventDefaultTypeInternal;
extern BreakerEventDefaultTypeInternal _BreakerEvent_default_instance_;
class BreakerEventProfile;
struct BreakerEventProfileDefaultTypeInternal;
extern BreakerEventProfileDefaultTypeInternal _BreakerEventProfile_default_instance_;
class BreakerReading;
struct BreakerReadingDefaultTypeInternal;
extern BreakerReadingDefaultTypeInternal _BreakerReading_default_instance_;
class BreakerReadingProfile;
struct BreakerReadingProfileDefaultTypeInternal;
extern BreakerReadingProfileDefaultTypeInternal _BreakerReadingProfile_default_instance_;
class BreakerStatus;
struct BreakerStatusDefaultTypeInternal;
extern BreakerStatusDefaultTypeInternal _BreakerStatus_default_instance_;
class BreakerStatusProfile;
struct BreakerStatusProfileDefaultTypeInternal;
extern BreakerStatusProfileDefaultTypeInternal _BreakerStatusProfile_default_instance_;
}  // namespace breakermodule
PROTOBUF_NAMESPACE_OPEN
template <>
::breakermodule::Breaker* Arena::CreateMaybeMessage<::breakermodule::Breaker>(Arena*);
template <>
::breakermodule::BreakerDiscreteControl* Arena::CreateMaybeMessage<::breakermodule::BreakerDiscreteControl>(Arena*);
template <>
::breakermodule::BreakerDiscreteControlProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerDiscreteControlProfile>(Arena*);
template <>
::breakermodule::BreakerDiscreteControlXCBR* Arena::CreateMaybeMessage<::breakermodule::BreakerDiscreteControlXCBR>(Arena*);
template <>
::breakermodule::BreakerEvent* Arena::CreateMaybeMessage<::breakermodule::BreakerEvent>(Arena*);
template <>
::breakermodule::BreakerEventProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerEventProfile>(Arena*);
template <>
::breakermodule::BreakerReading* Arena::CreateMaybeMessage<::breakermodule::BreakerReading>(Arena*);
template <>
::breakermodule::BreakerReadingProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerReadingProfile>(Arena*);
template <>
::breakermodule::BreakerStatus* Arena::CreateMaybeMessage<::breakermodule::BreakerStatus>(Arena*);
template <>
::breakermodule::BreakerStatusProfile* Arena::CreateMaybeMessage<::breakermodule::BreakerStatusProfile>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace breakermodule {

// ===================================================================


// -------------------------------------------------------------------

class BreakerDiscreteControlXCBR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerDiscreteControlXCBR) */ {
 public:
  inline BreakerDiscreteControlXCBR() : BreakerDiscreteControlXCBR(nullptr) {}
  ~BreakerDiscreteControlXCBR() override;
  explicit PROTOBUF_CONSTEXPR BreakerDiscreteControlXCBR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerDiscreteControlXCBR(const BreakerDiscreteControlXCBR& from);
  BreakerDiscreteControlXCBR(BreakerDiscreteControlXCBR&& from) noexcept
    : BreakerDiscreteControlXCBR() {
    *this = ::std::move(from);
  }

  inline BreakerDiscreteControlXCBR& operator=(const BreakerDiscreteControlXCBR& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerDiscreteControlXCBR& operator=(BreakerDiscreteControlXCBR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerDiscreteControlXCBR& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerDiscreteControlXCBR* internal_default_instance() {
    return reinterpret_cast<const BreakerDiscreteControlXCBR*>(
               &_BreakerDiscreteControlXCBR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BreakerDiscreteControlXCBR& a, BreakerDiscreteControlXCBR& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerDiscreteControlXCBR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerDiscreteControlXCBR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerDiscreteControlXCBR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerDiscreteControlXCBR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerDiscreteControlXCBR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerDiscreteControlXCBR& from) {
    BreakerDiscreteControlXCBR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerDiscreteControlXCBR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerDiscreteControlXCBR";
  }
  protected:
  explicit BreakerDiscreteControlXCBR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiscreteControlXCBRFieldNumber = 1,
  };
  // .commonmodule.DiscreteControlXCBR discreteControlXCBR = 1 [(.uml.option_parent_message) = true];
  bool has_discretecontrolxcbr() const;
  private:
  bool _internal_has_discretecontrolxcbr() const;

  public:
  void clear_discretecontrolxcbr() ;
  const ::commonmodule::DiscreteControlXCBR& discretecontrolxcbr() const;
  PROTOBUF_NODISCARD ::commonmodule::DiscreteControlXCBR* release_discretecontrolxcbr();
  ::commonmodule::DiscreteControlXCBR* mutable_discretecontrolxcbr();
  void set_allocated_discretecontrolxcbr(::commonmodule::DiscreteControlXCBR* discretecontrolxcbr);
  private:
  const ::commonmodule::DiscreteControlXCBR& _internal_discretecontrolxcbr() const;
  ::commonmodule::DiscreteControlXCBR* _internal_mutable_discretecontrolxcbr();
  public:
  void unsafe_arena_set_allocated_discretecontrolxcbr(
      ::commonmodule::DiscreteControlXCBR* discretecontrolxcbr);
  ::commonmodule::DiscreteControlXCBR* unsafe_arena_release_discretecontrolxcbr();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerDiscreteControlXCBR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::DiscreteControlXCBR* discretecontrolxcbr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerDiscreteControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerDiscreteControl) */ {
 public:
  inline BreakerDiscreteControl() : BreakerDiscreteControl(nullptr) {}
  ~BreakerDiscreteControl() override;
  explicit PROTOBUF_CONSTEXPR BreakerDiscreteControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerDiscreteControl(const BreakerDiscreteControl& from);
  BreakerDiscreteControl(BreakerDiscreteControl&& from) noexcept
    : BreakerDiscreteControl() {
    *this = ::std::move(from);
  }

  inline BreakerDiscreteControl& operator=(const BreakerDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerDiscreteControl& operator=(BreakerDiscreteControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerDiscreteControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerDiscreteControl* internal_default_instance() {
    return reinterpret_cast<const BreakerDiscreteControl*>(
               &_BreakerDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BreakerDiscreteControl& a, BreakerDiscreteControl& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerDiscreteControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerDiscreteControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerDiscreteControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerDiscreteControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerDiscreteControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerDiscreteControl& from) {
    BreakerDiscreteControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerDiscreteControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerDiscreteControl";
  }
  protected:
  explicit BreakerDiscreteControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kBreakerDiscreteControlXCBRFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .breakermodule.BreakerDiscreteControlXCBR breakerDiscreteControlXCBR = 3;
  bool has_breakerdiscretecontrolxcbr() const;
  private:
  bool _internal_has_breakerdiscretecontrolxcbr() const;

  public:
  void clear_breakerdiscretecontrolxcbr() ;
  const ::breakermodule::BreakerDiscreteControlXCBR& breakerdiscretecontrolxcbr() const;
  PROTOBUF_NODISCARD ::breakermodule::BreakerDiscreteControlXCBR* release_breakerdiscretecontrolxcbr();
  ::breakermodule::BreakerDiscreteControlXCBR* mutable_breakerdiscretecontrolxcbr();
  void set_allocated_breakerdiscretecontrolxcbr(::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr);
  private:
  const ::breakermodule::BreakerDiscreteControlXCBR& _internal_breakerdiscretecontrolxcbr() const;
  ::breakermodule::BreakerDiscreteControlXCBR* _internal_mutable_breakerdiscretecontrolxcbr();
  public:
  void unsafe_arena_set_allocated_breakerdiscretecontrolxcbr(
      ::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr);
  ::breakermodule::BreakerDiscreteControlXCBR* unsafe_arena_release_breakerdiscretecontrolxcbr();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerDiscreteControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class Breaker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.Breaker) */ {
 public:
  inline Breaker() : Breaker(nullptr) {}
  ~Breaker() override;
  explicit PROTOBUF_CONSTEXPR Breaker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Breaker(const Breaker& from);
  Breaker(Breaker&& from) noexcept
    : Breaker() {
    *this = ::std::move(from);
  }

  inline Breaker& operator=(const Breaker& from) {
    CopyFrom(from);
    return *this;
  }
  inline Breaker& operator=(Breaker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Breaker& default_instance() {
    return *internal_default_instance();
  }
  static inline const Breaker* internal_default_instance() {
    return reinterpret_cast<const Breaker*>(
               &_Breaker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Breaker& a, Breaker& b) {
    a.Swap(&b);
  }
  inline void Swap(Breaker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Breaker* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Breaker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Breaker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Breaker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Breaker& from) {
    Breaker::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Breaker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.Breaker";
  }
  protected:
  explicit Breaker(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  private:
  bool _internal_has_conductingequipment() const;

  public:
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);
  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_conductingequipment();
  public:
  void unsafe_arena_set_allocated_conductingequipment(
      ::commonmodule::ConductingEquipment* conductingequipment);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_conductingequipment();
  // @@protoc_insertion_point(class_scope:breakermodule.Breaker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipment* conductingequipment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerDiscreteControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerDiscreteControlProfile) */ {
 public:
  inline BreakerDiscreteControlProfile() : BreakerDiscreteControlProfile(nullptr) {}
  ~BreakerDiscreteControlProfile() override;
  explicit PROTOBUF_CONSTEXPR BreakerDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerDiscreteControlProfile(const BreakerDiscreteControlProfile& from);
  BreakerDiscreteControlProfile(BreakerDiscreteControlProfile&& from) noexcept
    : BreakerDiscreteControlProfile() {
    *this = ::std::move(from);
  }

  inline BreakerDiscreteControlProfile& operator=(const BreakerDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerDiscreteControlProfile& operator=(BreakerDiscreteControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerDiscreteControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerDiscreteControlProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerDiscreteControlProfile*>(
               &_BreakerDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BreakerDiscreteControlProfile& a, BreakerDiscreteControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerDiscreteControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerDiscreteControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerDiscreteControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerDiscreteControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerDiscreteControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerDiscreteControlProfile& from) {
    BreakerDiscreteControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerDiscreteControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerDiscreteControlProfile";
  }
  protected:
  explicit BreakerDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kBreakerFieldNumber = 2,
    kBreakerDiscreteControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  private:
  bool _internal_has_breaker() const;

  public:
  void clear_breaker() ;
  const ::breakermodule::Breaker& breaker() const;
  PROTOBUF_NODISCARD ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);
  private:
  const ::breakermodule::Breaker& _internal_breaker() const;
  ::breakermodule::Breaker* _internal_mutable_breaker();
  public:
  void unsafe_arena_set_allocated_breaker(
      ::breakermodule::Breaker* breaker);
  ::breakermodule::Breaker* unsafe_arena_release_breaker();
  // .breakermodule.BreakerDiscreteControl breakerDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breakerdiscretecontrol() const;
  private:
  bool _internal_has_breakerdiscretecontrol() const;

  public:
  void clear_breakerdiscretecontrol() ;
  const ::breakermodule::BreakerDiscreteControl& breakerdiscretecontrol() const;
  PROTOBUF_NODISCARD ::breakermodule::BreakerDiscreteControl* release_breakerdiscretecontrol();
  ::breakermodule::BreakerDiscreteControl* mutable_breakerdiscretecontrol();
  void set_allocated_breakerdiscretecontrol(::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol);
  private:
  const ::breakermodule::BreakerDiscreteControl& _internal_breakerdiscretecontrol() const;
  ::breakermodule::BreakerDiscreteControl* _internal_mutable_breakerdiscretecontrol();
  public:
  void unsafe_arena_set_allocated_breakerdiscretecontrol(
      ::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol);
  ::breakermodule::BreakerDiscreteControl* unsafe_arena_release_breakerdiscretecontrol();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerDiscreteControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::breakermodule::Breaker* breaker_;
    ::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerEvent) */ {
 public:
  inline BreakerEvent() : BreakerEvent(nullptr) {}
  ~BreakerEvent() override;
  explicit PROTOBUF_CONSTEXPR BreakerEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerEvent(const BreakerEvent& from);
  BreakerEvent(BreakerEvent&& from) noexcept
    : BreakerEvent() {
    *this = ::std::move(from);
  }

  inline BreakerEvent& operator=(const BreakerEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerEvent& operator=(BreakerEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerEvent* internal_default_instance() {
    return reinterpret_cast<const BreakerEvent*>(
               &_BreakerEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BreakerEvent& a, BreakerEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerEvent& from) {
    BreakerEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerEvent";
  }
  protected:
  explicit BreakerEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventValueFieldNumber = 1,
    kStatusAndEventXCBRFieldNumber = 2,
  };
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  private:
  bool _internal_has_eventvalue() const;

  public:
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);
  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* _internal_mutable_eventvalue();
  public:
  void unsafe_arena_set_allocated_eventvalue(
      ::commonmodule::EventValue* eventvalue);
  ::commonmodule::EventValue* unsafe_arena_release_eventvalue();
  // .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2;
  bool has_statusandeventxcbr() const;
  private:
  bool _internal_has_statusandeventxcbr() const;

  public:
  void clear_statusandeventxcbr() ;
  const ::commonmodule::StatusAndEventXCBR& statusandeventxcbr() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusAndEventXCBR* release_statusandeventxcbr();
  ::commonmodule::StatusAndEventXCBR* mutable_statusandeventxcbr();
  void set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr);
  private:
  const ::commonmodule::StatusAndEventXCBR& _internal_statusandeventxcbr() const;
  ::commonmodule::StatusAndEventXCBR* _internal_mutable_statusandeventxcbr();
  public:
  void unsafe_arena_set_allocated_statusandeventxcbr(
      ::commonmodule::StatusAndEventXCBR* statusandeventxcbr);
  ::commonmodule::StatusAndEventXCBR* unsafe_arena_release_statusandeventxcbr();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventValue* eventvalue_;
    ::commonmodule::StatusAndEventXCBR* statusandeventxcbr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerEventProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerEventProfile) */ {
 public:
  inline BreakerEventProfile() : BreakerEventProfile(nullptr) {}
  ~BreakerEventProfile() override;
  explicit PROTOBUF_CONSTEXPR BreakerEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerEventProfile(const BreakerEventProfile& from);
  BreakerEventProfile(BreakerEventProfile&& from) noexcept
    : BreakerEventProfile() {
    *this = ::std::move(from);
  }

  inline BreakerEventProfile& operator=(const BreakerEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerEventProfile& operator=(BreakerEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerEventProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerEventProfile*>(
               &_BreakerEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BreakerEventProfile& a, BreakerEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerEventProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerEventProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerEventProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerEventProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerEventProfile& from) {
    BreakerEventProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerEventProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerEventProfile";
  }
  protected:
  explicit BreakerEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kBreakerFieldNumber = 2,
    kBreakerEventFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;

  public:
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();
  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  private:
  bool _internal_has_breaker() const;

  public:
  void clear_breaker() ;
  const ::breakermodule::Breaker& breaker() const;
  PROTOBUF_NODISCARD ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);
  private:
  const ::breakermodule::Breaker& _internal_breaker() const;
  ::breakermodule::Breaker* _internal_mutable_breaker();
  public:
  void unsafe_arena_set_allocated_breaker(
      ::breakermodule::Breaker* breaker);
  ::breakermodule::Breaker* unsafe_arena_release_breaker();
  // .breakermodule.BreakerEvent breakerEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breakerevent() const;
  private:
  bool _internal_has_breakerevent() const;

  public:
  void clear_breakerevent() ;
  const ::breakermodule::BreakerEvent& breakerevent() const;
  PROTOBUF_NODISCARD ::breakermodule::BreakerEvent* release_breakerevent();
  ::breakermodule::BreakerEvent* mutable_breakerevent();
  void set_allocated_breakerevent(::breakermodule::BreakerEvent* breakerevent);
  private:
  const ::breakermodule::BreakerEvent& _internal_breakerevent() const;
  ::breakermodule::BreakerEvent* _internal_mutable_breakerevent();
  public:
  void unsafe_arena_set_allocated_breakerevent(
      ::breakermodule::BreakerEvent* breakerevent);
  ::breakermodule::BreakerEvent* unsafe_arena_release_breakerevent();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventMessageInfo* eventmessageinfo_;
    ::breakermodule::Breaker* breaker_;
    ::breakermodule::BreakerEvent* breakerevent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerReading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerReading) */ {
 public:
  inline BreakerReading() : BreakerReading(nullptr) {}
  ~BreakerReading() override;
  explicit PROTOBUF_CONSTEXPR BreakerReading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerReading(const BreakerReading& from);
  BreakerReading(BreakerReading&& from) noexcept
    : BreakerReading() {
    *this = ::std::move(from);
  }

  inline BreakerReading& operator=(const BreakerReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerReading& operator=(BreakerReading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerReading& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerReading* internal_default_instance() {
    return reinterpret_cast<const BreakerReading*>(
               &_BreakerReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BreakerReading& a, BreakerReading& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerReading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerReading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerReading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerReading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerReading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerReading& from) {
    BreakerReading::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerReading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerReading";
  }
  protected:
  explicit BreakerReading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kDiffReadingMMXUFieldNumber = 2,
    kPhaseMMTNFieldNumber = 3,
    kReadingMMTRFieldNumber = 4,
    kReadingMMXUFieldNumber = 5,
  };
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  private:
  bool _internal_has_conductingequipmentterminalreading() const;

  public:
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* _internal_mutable_conductingequipmentterminalreading();
  public:
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(
      ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  ::commonmodule::ConductingEquipmentTerminalReading* unsafe_arena_release_conductingequipmentterminalreading();
  // .commonmodule.ReadingMMXU diffReadingMMXU = 2;
  bool has_diffreadingmmxu() const;
  private:
  bool _internal_has_diffreadingmmxu() const;

  public:
  void clear_diffreadingmmxu() ;
  const ::commonmodule::ReadingMMXU& diffreadingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_diffreadingmmxu();
  ::commonmodule::ReadingMMXU* mutable_diffreadingmmxu();
  void set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_diffreadingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_diffreadingmmxu();
  public:
  void unsafe_arena_set_allocated_diffreadingmmxu(
      ::commonmodule::ReadingMMXU* diffreadingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_diffreadingmmxu();
  // .commonmodule.PhaseMMTN phaseMMTN = 3;
  bool has_phasemmtn() const;
  private:
  bool _internal_has_phasemmtn() const;

  public:
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);
  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* _internal_mutable_phasemmtn();
  public:
  void unsafe_arena_set_allocated_phasemmtn(
      ::commonmodule::PhaseMMTN* phasemmtn);
  ::commonmodule::PhaseMMTN* unsafe_arena_release_phasemmtn();
  // .commonmodule.ReadingMMTR readingMMTR = 4;
  bool has_readingmmtr() const;
  private:
  bool _internal_has_readingmmtr() const;

  public:
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);
  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* _internal_mutable_readingmmtr();
  public:
  void unsafe_arena_set_allocated_readingmmtr(
      ::commonmodule::ReadingMMTR* readingmmtr);
  ::commonmodule::ReadingMMTR* unsafe_arena_release_readingmmtr();
  // .commonmodule.ReadingMMXU readingMMXU = 5;
  bool has_readingmmxu() const;
  private:
  bool _internal_has_readingmmxu() const;

  public:
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_readingmmxu();
  public:
  void unsafe_arena_set_allocated_readingmmxu(
      ::commonmodule::ReadingMMXU* readingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_readingmmxu();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerReading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
    ::commonmodule::ReadingMMXU* diffreadingmmxu_;
    ::commonmodule::PhaseMMTN* phasemmtn_;
    ::commonmodule::ReadingMMTR* readingmmtr_;
    ::commonmodule::ReadingMMXU* readingmmxu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerReadingProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerReadingProfile) */ {
 public:
  inline BreakerReadingProfile() : BreakerReadingProfile(nullptr) {}
  ~BreakerReadingProfile() override;
  explicit PROTOBUF_CONSTEXPR BreakerReadingProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerReadingProfile(const BreakerReadingProfile& from);
  BreakerReadingProfile(BreakerReadingProfile&& from) noexcept
    : BreakerReadingProfile() {
    *this = ::std::move(from);
  }

  inline BreakerReadingProfile& operator=(const BreakerReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerReadingProfile& operator=(BreakerReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerReadingProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerReadingProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerReadingProfile*>(
               &_BreakerReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BreakerReadingProfile& a, BreakerReadingProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerReadingProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerReadingProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerReadingProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerReadingProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerReadingProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerReadingProfile& from) {
    BreakerReadingProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerReadingProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerReadingProfile";
  }
  protected:
  explicit BreakerReadingProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreakerReadingFieldNumber = 3,
    kReadingMessageInfoFieldNumber = 1,
    kBreakerFieldNumber = 2,
  };
  // repeated .breakermodule.BreakerReading breakerReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
  int breakerreading_size() const;
  private:
  int _internal_breakerreading_size() const;

  public:
  void clear_breakerreading() ;
  ::breakermodule::BreakerReading* mutable_breakerreading(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::breakermodule::BreakerReading >*
      mutable_breakerreading();
  private:
  const ::breakermodule::BreakerReading& _internal_breakerreading(int index) const;
  ::breakermodule::BreakerReading* _internal_add_breakerreading();
  public:
  const ::breakermodule::BreakerReading& breakerreading(int index) const;
  ::breakermodule::BreakerReading* add_breakerreading();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::breakermodule::BreakerReading >&
      breakerreading() const;
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  private:
  bool _internal_has_readingmessageinfo() const;

  public:
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);
  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* _internal_mutable_readingmessageinfo();
  public:
  void unsafe_arena_set_allocated_readingmessageinfo(
      ::commonmodule::ReadingMessageInfo* readingmessageinfo);
  ::commonmodule::ReadingMessageInfo* unsafe_arena_release_readingmessageinfo();
  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  private:
  bool _internal_has_breaker() const;

  public:
  void clear_breaker() ;
  const ::breakermodule::Breaker& breaker() const;
  PROTOBUF_NODISCARD ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);
  private:
  const ::breakermodule::Breaker& _internal_breaker() const;
  ::breakermodule::Breaker* _internal_mutable_breaker();
  public:
  void unsafe_arena_set_allocated_breaker(
      ::breakermodule::Breaker* breaker);
  ::breakermodule::Breaker* unsafe_arena_release_breaker();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerReadingProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::breakermodule::BreakerReading > breakerreading_;
    ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
    ::breakermodule::Breaker* breaker_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerStatus) */ {
 public:
  inline BreakerStatus() : BreakerStatus(nullptr) {}
  ~BreakerStatus() override;
  explicit PROTOBUF_CONSTEXPR BreakerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerStatus(const BreakerStatus& from);
  BreakerStatus(BreakerStatus&& from) noexcept
    : BreakerStatus() {
    *this = ::std::move(from);
  }

  inline BreakerStatus& operator=(const BreakerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerStatus& operator=(BreakerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerStatus* internal_default_instance() {
    return reinterpret_cast<const BreakerStatus*>(
               &_BreakerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BreakerStatus& a, BreakerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerStatus& from) {
    BreakerStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerStatus";
  }
  protected:
  explicit BreakerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusValueFieldNumber = 1,
    kStatusAndEventXCBRFieldNumber = 2,
  };
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  private:
  bool _internal_has_statusvalue() const;

  public:
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);
  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* _internal_mutable_statusvalue();
  public:
  void unsafe_arena_set_allocated_statusvalue(
      ::commonmodule::StatusValue* statusvalue);
  ::commonmodule::StatusValue* unsafe_arena_release_statusvalue();
  // .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2;
  bool has_statusandeventxcbr() const;
  private:
  bool _internal_has_statusandeventxcbr() const;

  public:
  void clear_statusandeventxcbr() ;
  const ::commonmodule::StatusAndEventXCBR& statusandeventxcbr() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusAndEventXCBR* release_statusandeventxcbr();
  ::commonmodule::StatusAndEventXCBR* mutable_statusandeventxcbr();
  void set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr);
  private:
  const ::commonmodule::StatusAndEventXCBR& _internal_statusandeventxcbr() const;
  ::commonmodule::StatusAndEventXCBR* _internal_mutable_statusandeventxcbr();
  public:
  void unsafe_arena_set_allocated_statusandeventxcbr(
      ::commonmodule::StatusAndEventXCBR* statusandeventxcbr);
  ::commonmodule::StatusAndEventXCBR* unsafe_arena_release_statusandeventxcbr();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusValue* statusvalue_;
    ::commonmodule::StatusAndEventXCBR* statusandeventxcbr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};// -------------------------------------------------------------------

class BreakerStatusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:breakermodule.BreakerStatusProfile) */ {
 public:
  inline BreakerStatusProfile() : BreakerStatusProfile(nullptr) {}
  ~BreakerStatusProfile() override;
  explicit PROTOBUF_CONSTEXPR BreakerStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakerStatusProfile(const BreakerStatusProfile& from);
  BreakerStatusProfile(BreakerStatusProfile&& from) noexcept
    : BreakerStatusProfile() {
    *this = ::std::move(from);
  }

  inline BreakerStatusProfile& operator=(const BreakerStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakerStatusProfile& operator=(BreakerStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakerStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakerStatusProfile* internal_default_instance() {
    return reinterpret_cast<const BreakerStatusProfile*>(
               &_BreakerStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BreakerStatusProfile& a, BreakerStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakerStatusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakerStatusProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakerStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakerStatusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakerStatusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakerStatusProfile& from) {
    BreakerStatusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakerStatusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "breakermodule.BreakerStatusProfile";
  }
  protected:
  explicit BreakerStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kBreakerFieldNumber = 2,
    kBreakerStatusFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  private:
  bool _internal_has_statusmessageinfo() const;

  public:
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);
  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* _internal_mutable_statusmessageinfo();
  public:
  void unsafe_arena_set_allocated_statusmessageinfo(
      ::commonmodule::StatusMessageInfo* statusmessageinfo);
  ::commonmodule::StatusMessageInfo* unsafe_arena_release_statusmessageinfo();
  // .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breaker() const;
  private:
  bool _internal_has_breaker() const;

  public:
  void clear_breaker() ;
  const ::breakermodule::Breaker& breaker() const;
  PROTOBUF_NODISCARD ::breakermodule::Breaker* release_breaker();
  ::breakermodule::Breaker* mutable_breaker();
  void set_allocated_breaker(::breakermodule::Breaker* breaker);
  private:
  const ::breakermodule::Breaker& _internal_breaker() const;
  ::breakermodule::Breaker* _internal_mutable_breaker();
  public:
  void unsafe_arena_set_allocated_breaker(
      ::breakermodule::Breaker* breaker);
  ::breakermodule::Breaker* unsafe_arena_release_breaker();
  // .breakermodule.BreakerStatus breakerStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_breakerstatus() const;
  private:
  bool _internal_has_breakerstatus() const;

  public:
  void clear_breakerstatus() ;
  const ::breakermodule::BreakerStatus& breakerstatus() const;
  PROTOBUF_NODISCARD ::breakermodule::BreakerStatus* release_breakerstatus();
  ::breakermodule::BreakerStatus* mutable_breakerstatus();
  void set_allocated_breakerstatus(::breakermodule::BreakerStatus* breakerstatus);
  private:
  const ::breakermodule::BreakerStatus& _internal_breakerstatus() const;
  ::breakermodule::BreakerStatus* _internal_mutable_breakerstatus();
  public:
  void unsafe_arena_set_allocated_breakerstatus(
      ::breakermodule::BreakerStatus* breakerstatus);
  ::breakermodule::BreakerStatus* unsafe_arena_release_breakerstatus();
  // @@protoc_insertion_point(class_scope:breakermodule.BreakerStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusMessageInfo* statusmessageinfo_;
    ::breakermodule::Breaker* breaker_;
    ::breakermodule::BreakerStatus* breakerstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_breakermodule_2fbreakermodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// BreakerDiscreteControlXCBR

// .commonmodule.DiscreteControlXCBR discreteControlXCBR = 1 [(.uml.option_parent_message) = true];
inline bool BreakerDiscreteControlXCBR::_internal_has_discretecontrolxcbr() const {
  return this != internal_default_instance() && _impl_.discretecontrolxcbr_ != nullptr;
}
inline bool BreakerDiscreteControlXCBR::has_discretecontrolxcbr() const {
  return _internal_has_discretecontrolxcbr();
}
inline const ::commonmodule::DiscreteControlXCBR& BreakerDiscreteControlXCBR::_internal_discretecontrolxcbr() const {
  const ::commonmodule::DiscreteControlXCBR* p = _impl_.discretecontrolxcbr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::DiscreteControlXCBR&>(
      ::commonmodule::_DiscreteControlXCBR_default_instance_);
}
inline const ::commonmodule::DiscreteControlXCBR& BreakerDiscreteControlXCBR::discretecontrolxcbr() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlXCBR.discreteControlXCBR)
  return _internal_discretecontrolxcbr();
}
inline void BreakerDiscreteControlXCBR::unsafe_arena_set_allocated_discretecontrolxcbr(
    ::commonmodule::DiscreteControlXCBR* discretecontrolxcbr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.discretecontrolxcbr_);
  }
  _impl_.discretecontrolxcbr_ = discretecontrolxcbr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerDiscreteControlXCBR.discreteControlXCBR)
}
inline ::commonmodule::DiscreteControlXCBR* BreakerDiscreteControlXCBR::release_discretecontrolxcbr() {
  
  ::commonmodule::DiscreteControlXCBR* temp = _impl_.discretecontrolxcbr_;
  _impl_.discretecontrolxcbr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::DiscreteControlXCBR* BreakerDiscreteControlXCBR::unsafe_arena_release_discretecontrolxcbr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlXCBR.discreteControlXCBR)
  
  ::commonmodule::DiscreteControlXCBR* temp = _impl_.discretecontrolxcbr_;
  _impl_.discretecontrolxcbr_ = nullptr;
  return temp;
}
inline ::commonmodule::DiscreteControlXCBR* BreakerDiscreteControlXCBR::_internal_mutable_discretecontrolxcbr() {
  
  if (_impl_.discretecontrolxcbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::DiscreteControlXCBR>(GetArenaForAllocation());
    _impl_.discretecontrolxcbr_ = p;
  }
  return _impl_.discretecontrolxcbr_;
}
inline ::commonmodule::DiscreteControlXCBR* BreakerDiscreteControlXCBR::mutable_discretecontrolxcbr() {
  ::commonmodule::DiscreteControlXCBR* _msg = _internal_mutable_discretecontrolxcbr();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlXCBR.discreteControlXCBR)
  return _msg;
}
inline void BreakerDiscreteControlXCBR::set_allocated_discretecontrolxcbr(::commonmodule::DiscreteControlXCBR* discretecontrolxcbr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.discretecontrolxcbr_);
  }
  if (discretecontrolxcbr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(discretecontrolxcbr));
    if (message_arena != submessage_arena) {
      discretecontrolxcbr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, discretecontrolxcbr, submessage_arena);
    }

  } else {

  }
  _impl_.discretecontrolxcbr_ = discretecontrolxcbr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlXCBR.discreteControlXCBR)
}

// -------------------------------------------------------------------

// BreakerDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool BreakerDiscreteControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool BreakerDiscreteControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& BreakerDiscreteControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& BreakerDiscreteControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControl.controlValue)
  return _internal_controlvalue();
}
inline void BreakerDiscreteControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerDiscreteControl.controlValue)
}
inline ::commonmodule::ControlValue* BreakerDiscreteControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* BreakerDiscreteControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* BreakerDiscreteControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* BreakerDiscreteControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControl.controlValue)
  return _msg;
}
inline void BreakerDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool BreakerDiscreteControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool BreakerDiscreteControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& BreakerDiscreteControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& BreakerDiscreteControl::check() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControl.check)
  return _internal_check();
}
inline void BreakerDiscreteControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerDiscreteControl.check)
}
inline ::commonmodule::CheckConditions* BreakerDiscreteControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* BreakerDiscreteControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* BreakerDiscreteControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* BreakerDiscreteControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControl.check)
  return _msg;
}
inline void BreakerDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControl.check)
}

// .breakermodule.BreakerDiscreteControlXCBR breakerDiscreteControlXCBR = 3;
inline bool BreakerDiscreteControl::_internal_has_breakerdiscretecontrolxcbr() const {
  return this != internal_default_instance() && _impl_.breakerdiscretecontrolxcbr_ != nullptr;
}
inline bool BreakerDiscreteControl::has_breakerdiscretecontrolxcbr() const {
  return _internal_has_breakerdiscretecontrolxcbr();
}
inline void BreakerDiscreteControl::clear_breakerdiscretecontrolxcbr() {
  if (GetArenaForAllocation() == nullptr && _impl_.breakerdiscretecontrolxcbr_ != nullptr) {
    delete _impl_.breakerdiscretecontrolxcbr_;
  }
  _impl_.breakerdiscretecontrolxcbr_ = nullptr;
}
inline const ::breakermodule::BreakerDiscreteControlXCBR& BreakerDiscreteControl::_internal_breakerdiscretecontrolxcbr() const {
  const ::breakermodule::BreakerDiscreteControlXCBR* p = _impl_.breakerdiscretecontrolxcbr_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::BreakerDiscreteControlXCBR&>(
      ::breakermodule::_BreakerDiscreteControlXCBR_default_instance_);
}
inline const ::breakermodule::BreakerDiscreteControlXCBR& BreakerDiscreteControl::breakerdiscretecontrolxcbr() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
  return _internal_breakerdiscretecontrolxcbr();
}
inline void BreakerDiscreteControl::unsafe_arena_set_allocated_breakerdiscretecontrolxcbr(
    ::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breakerdiscretecontrolxcbr_);
  }
  _impl_.breakerdiscretecontrolxcbr_ = breakerdiscretecontrolxcbr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
}
inline ::breakermodule::BreakerDiscreteControlXCBR* BreakerDiscreteControl::release_breakerdiscretecontrolxcbr() {
  
  ::breakermodule::BreakerDiscreteControlXCBR* temp = _impl_.breakerdiscretecontrolxcbr_;
  _impl_.breakerdiscretecontrolxcbr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::BreakerDiscreteControlXCBR* BreakerDiscreteControl::unsafe_arena_release_breakerdiscretecontrolxcbr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
  
  ::breakermodule::BreakerDiscreteControlXCBR* temp = _impl_.breakerdiscretecontrolxcbr_;
  _impl_.breakerdiscretecontrolxcbr_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerDiscreteControlXCBR* BreakerDiscreteControl::_internal_mutable_breakerdiscretecontrolxcbr() {
  
  if (_impl_.breakerdiscretecontrolxcbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerDiscreteControlXCBR>(GetArenaForAllocation());
    _impl_.breakerdiscretecontrolxcbr_ = p;
  }
  return _impl_.breakerdiscretecontrolxcbr_;
}
inline ::breakermodule::BreakerDiscreteControlXCBR* BreakerDiscreteControl::mutable_breakerdiscretecontrolxcbr() {
  ::breakermodule::BreakerDiscreteControlXCBR* _msg = _internal_mutable_breakerdiscretecontrolxcbr();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
  return _msg;
}
inline void BreakerDiscreteControl::set_allocated_breakerdiscretecontrolxcbr(::breakermodule::BreakerDiscreteControlXCBR* breakerdiscretecontrolxcbr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breakerdiscretecontrolxcbr_;
  }
  if (breakerdiscretecontrolxcbr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breakerdiscretecontrolxcbr);
    if (message_arena != submessage_arena) {
      breakerdiscretecontrolxcbr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breakerdiscretecontrolxcbr, submessage_arena);
    }

  } else {

  }
  _impl_.breakerdiscretecontrolxcbr_ = breakerdiscretecontrolxcbr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControl.breakerDiscreteControlXCBR)
}

// -------------------------------------------------------------------

// Breaker

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool Breaker::_internal_has_conductingequipment() const {
  return this != internal_default_instance() && _impl_.conductingequipment_ != nullptr;
}
inline bool Breaker::has_conductingequipment() const {
  return _internal_has_conductingequipment();
}
inline const ::commonmodule::ConductingEquipment& Breaker::_internal_conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& Breaker::conductingequipment() const {
  // @@protoc_insertion_point(field_get:breakermodule.Breaker.conductingEquipment)
  return _internal_conductingequipment();
}
inline void Breaker::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* conductingequipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.Breaker.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* Breaker::release_conductingequipment() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* Breaker::unsafe_arena_release_conductingequipment() {
  // @@protoc_insertion_point(field_release:breakermodule.Breaker.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* Breaker::_internal_mutable_conductingequipment() {
  
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.conductingequipment_ = p;
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* Breaker::mutable_conductingequipment() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:breakermodule.Breaker.conductingEquipment)
  return _msg;
}
inline void Breaker::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  if (conductingequipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipment));
    if (message_arena != submessage_arena) {
      conductingequipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.Breaker.conductingEquipment)
}

// -------------------------------------------------------------------

// BreakerDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerDiscreteControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool BreakerDiscreteControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& BreakerDiscreteControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& BreakerDiscreteControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void BreakerDiscreteControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* BreakerDiscreteControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* BreakerDiscreteControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* BreakerDiscreteControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* BreakerDiscreteControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
  return _msg;
}
inline void BreakerDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlProfile.controlMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerDiscreteControlProfile::_internal_has_breaker() const {
  return this != internal_default_instance() && _impl_.breaker_ != nullptr;
}
inline bool BreakerDiscreteControlProfile::has_breaker() const {
  return _internal_has_breaker();
}
inline void BreakerDiscreteControlProfile::clear_breaker() {
  if (GetArenaForAllocation() == nullptr && _impl_.breaker_ != nullptr) {
    delete _impl_.breaker_;
  }
  _impl_.breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerDiscreteControlProfile::_internal_breaker() const {
  const ::breakermodule::Breaker* p = _impl_.breaker_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::Breaker&>(
      ::breakermodule::_Breaker_default_instance_);
}
inline const ::breakermodule::Breaker& BreakerDiscreteControlProfile::breaker() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlProfile.breaker)
  return _internal_breaker();
}
inline void BreakerDiscreteControlProfile::unsafe_arena_set_allocated_breaker(
    ::breakermodule::Breaker* breaker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breaker_);
  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerDiscreteControlProfile.breaker)
}
inline ::breakermodule::Breaker* BreakerDiscreteControlProfile::release_breaker() {
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::Breaker* BreakerDiscreteControlProfile::unsafe_arena_release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlProfile.breaker)
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerDiscreteControlProfile::_internal_mutable_breaker() {
  
  if (_impl_.breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaForAllocation());
    _impl_.breaker_ = p;
  }
  return _impl_.breaker_;
}
inline ::breakermodule::Breaker* BreakerDiscreteControlProfile::mutable_breaker() {
  ::breakermodule::Breaker* _msg = _internal_mutable_breaker();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlProfile.breaker)
  return _msg;
}
inline void BreakerDiscreteControlProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breaker_;
  }
  if (breaker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breaker);
    if (message_arena != submessage_arena) {
      breaker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }

  } else {

  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlProfile.breaker)
}

// .breakermodule.BreakerDiscreteControl breakerDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerDiscreteControlProfile::_internal_has_breakerdiscretecontrol() const {
  return this != internal_default_instance() && _impl_.breakerdiscretecontrol_ != nullptr;
}
inline bool BreakerDiscreteControlProfile::has_breakerdiscretecontrol() const {
  return _internal_has_breakerdiscretecontrol();
}
inline void BreakerDiscreteControlProfile::clear_breakerdiscretecontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.breakerdiscretecontrol_ != nullptr) {
    delete _impl_.breakerdiscretecontrol_;
  }
  _impl_.breakerdiscretecontrol_ = nullptr;
}
inline const ::breakermodule::BreakerDiscreteControl& BreakerDiscreteControlProfile::_internal_breakerdiscretecontrol() const {
  const ::breakermodule::BreakerDiscreteControl* p = _impl_.breakerdiscretecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::BreakerDiscreteControl&>(
      ::breakermodule::_BreakerDiscreteControl_default_instance_);
}
inline const ::breakermodule::BreakerDiscreteControl& BreakerDiscreteControlProfile::breakerdiscretecontrol() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
  return _internal_breakerdiscretecontrol();
}
inline void BreakerDiscreteControlProfile::unsafe_arena_set_allocated_breakerdiscretecontrol(
    ::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breakerdiscretecontrol_);
  }
  _impl_.breakerdiscretecontrol_ = breakerdiscretecontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
}
inline ::breakermodule::BreakerDiscreteControl* BreakerDiscreteControlProfile::release_breakerdiscretecontrol() {
  
  ::breakermodule::BreakerDiscreteControl* temp = _impl_.breakerdiscretecontrol_;
  _impl_.breakerdiscretecontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::BreakerDiscreteControl* BreakerDiscreteControlProfile::unsafe_arena_release_breakerdiscretecontrol() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
  
  ::breakermodule::BreakerDiscreteControl* temp = _impl_.breakerdiscretecontrol_;
  _impl_.breakerdiscretecontrol_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerDiscreteControl* BreakerDiscreteControlProfile::_internal_mutable_breakerdiscretecontrol() {
  
  if (_impl_.breakerdiscretecontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerDiscreteControl>(GetArenaForAllocation());
    _impl_.breakerdiscretecontrol_ = p;
  }
  return _impl_.breakerdiscretecontrol_;
}
inline ::breakermodule::BreakerDiscreteControl* BreakerDiscreteControlProfile::mutable_breakerdiscretecontrol() {
  ::breakermodule::BreakerDiscreteControl* _msg = _internal_mutable_breakerdiscretecontrol();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
  return _msg;
}
inline void BreakerDiscreteControlProfile::set_allocated_breakerdiscretecontrol(::breakermodule::BreakerDiscreteControl* breakerdiscretecontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breakerdiscretecontrol_;
  }
  if (breakerdiscretecontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breakerdiscretecontrol);
    if (message_arena != submessage_arena) {
      breakerdiscretecontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breakerdiscretecontrol, submessage_arena);
    }

  } else {

  }
  _impl_.breakerdiscretecontrol_ = breakerdiscretecontrol;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerDiscreteControlProfile.breakerDiscreteControl)
}

// -------------------------------------------------------------------

// BreakerEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool BreakerEvent::_internal_has_eventvalue() const {
  return this != internal_default_instance() && _impl_.eventvalue_ != nullptr;
}
inline bool BreakerEvent::has_eventvalue() const {
  return _internal_has_eventvalue();
}
inline const ::commonmodule::EventValue& BreakerEvent::_internal_eventvalue() const {
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(
      ::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& BreakerEvent::eventvalue() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEvent.eventValue)
  return _internal_eventvalue();
}
inline void BreakerEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* eventvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerEvent.eventValue)
}
inline ::commonmodule::EventValue* BreakerEvent::release_eventvalue() {
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventValue* BreakerEvent::unsafe_arena_release_eventvalue() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEvent.eventValue)
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* BreakerEvent::_internal_mutable_eventvalue() {
  
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaForAllocation());
    _impl_.eventvalue_ = p;
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* BreakerEvent::mutable_eventvalue() {
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEvent.eventValue)
  return _msg;
}
inline void BreakerEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  if (eventvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventvalue));
    if (message_arena != submessage_arena) {
      eventvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }

  } else {

  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEvent.eventValue)
}

// .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2;
inline bool BreakerEvent::_internal_has_statusandeventxcbr() const {
  return this != internal_default_instance() && _impl_.statusandeventxcbr_ != nullptr;
}
inline bool BreakerEvent::has_statusandeventxcbr() const {
  return _internal_has_statusandeventxcbr();
}
inline const ::commonmodule::StatusAndEventXCBR& BreakerEvent::_internal_statusandeventxcbr() const {
  const ::commonmodule::StatusAndEventXCBR* p = _impl_.statusandeventxcbr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusAndEventXCBR&>(
      ::commonmodule::_StatusAndEventXCBR_default_instance_);
}
inline const ::commonmodule::StatusAndEventXCBR& BreakerEvent::statusandeventxcbr() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEvent.statusAndEventXCBR)
  return _internal_statusandeventxcbr();
}
inline void BreakerEvent::unsafe_arena_set_allocated_statusandeventxcbr(
    ::commonmodule::StatusAndEventXCBR* statusandeventxcbr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusandeventxcbr_);
  }
  _impl_.statusandeventxcbr_ = statusandeventxcbr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerEvent.statusAndEventXCBR)
}
inline ::commonmodule::StatusAndEventXCBR* BreakerEvent::release_statusandeventxcbr() {
  
  ::commonmodule::StatusAndEventXCBR* temp = _impl_.statusandeventxcbr_;
  _impl_.statusandeventxcbr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerEvent::unsafe_arena_release_statusandeventxcbr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEvent.statusAndEventXCBR)
  
  ::commonmodule::StatusAndEventXCBR* temp = _impl_.statusandeventxcbr_;
  _impl_.statusandeventxcbr_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerEvent::_internal_mutable_statusandeventxcbr() {
  
  if (_impl_.statusandeventxcbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusAndEventXCBR>(GetArenaForAllocation());
    _impl_.statusandeventxcbr_ = p;
  }
  return _impl_.statusandeventxcbr_;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerEvent::mutable_statusandeventxcbr() {
  ::commonmodule::StatusAndEventXCBR* _msg = _internal_mutable_statusandeventxcbr();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEvent.statusAndEventXCBR)
  return _msg;
}
inline void BreakerEvent::set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusandeventxcbr_);
  }
  if (statusandeventxcbr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusandeventxcbr));
    if (message_arena != submessage_arena) {
      statusandeventxcbr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusandeventxcbr, submessage_arena);
    }

  } else {

  }
  _impl_.statusandeventxcbr_ = statusandeventxcbr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEvent.statusAndEventXCBR)
}

// -------------------------------------------------------------------

// BreakerEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && _impl_.eventmessageinfo_ != nullptr;
}
inline bool BreakerEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& BreakerEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& BreakerEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void BreakerEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* BreakerEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventMessageInfo* BreakerEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* BreakerEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaForAllocation());
    _impl_.eventmessageinfo_ = p;
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* BreakerEventProfile::mutable_eventmessageinfo() {
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEventProfile.eventMessageInfo)
  return _msg;
}
inline void BreakerEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo));
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEventProfile.eventMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerEventProfile::_internal_has_breaker() const {
  return this != internal_default_instance() && _impl_.breaker_ != nullptr;
}
inline bool BreakerEventProfile::has_breaker() const {
  return _internal_has_breaker();
}
inline void BreakerEventProfile::clear_breaker() {
  if (GetArenaForAllocation() == nullptr && _impl_.breaker_ != nullptr) {
    delete _impl_.breaker_;
  }
  _impl_.breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerEventProfile::_internal_breaker() const {
  const ::breakermodule::Breaker* p = _impl_.breaker_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::Breaker&>(
      ::breakermodule::_Breaker_default_instance_);
}
inline const ::breakermodule::Breaker& BreakerEventProfile::breaker() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEventProfile.breaker)
  return _internal_breaker();
}
inline void BreakerEventProfile::unsafe_arena_set_allocated_breaker(
    ::breakermodule::Breaker* breaker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breaker_);
  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerEventProfile.breaker)
}
inline ::breakermodule::Breaker* BreakerEventProfile::release_breaker() {
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::Breaker* BreakerEventProfile::unsafe_arena_release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEventProfile.breaker)
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerEventProfile::_internal_mutable_breaker() {
  
  if (_impl_.breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaForAllocation());
    _impl_.breaker_ = p;
  }
  return _impl_.breaker_;
}
inline ::breakermodule::Breaker* BreakerEventProfile::mutable_breaker() {
  ::breakermodule::Breaker* _msg = _internal_mutable_breaker();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEventProfile.breaker)
  return _msg;
}
inline void BreakerEventProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breaker_;
  }
  if (breaker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breaker);
    if (message_arena != submessage_arena) {
      breaker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }

  } else {

  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEventProfile.breaker)
}

// .breakermodule.BreakerEvent breakerEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerEventProfile::_internal_has_breakerevent() const {
  return this != internal_default_instance() && _impl_.breakerevent_ != nullptr;
}
inline bool BreakerEventProfile::has_breakerevent() const {
  return _internal_has_breakerevent();
}
inline void BreakerEventProfile::clear_breakerevent() {
  if (GetArenaForAllocation() == nullptr && _impl_.breakerevent_ != nullptr) {
    delete _impl_.breakerevent_;
  }
  _impl_.breakerevent_ = nullptr;
}
inline const ::breakermodule::BreakerEvent& BreakerEventProfile::_internal_breakerevent() const {
  const ::breakermodule::BreakerEvent* p = _impl_.breakerevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::BreakerEvent&>(
      ::breakermodule::_BreakerEvent_default_instance_);
}
inline const ::breakermodule::BreakerEvent& BreakerEventProfile::breakerevent() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerEventProfile.breakerEvent)
  return _internal_breakerevent();
}
inline void BreakerEventProfile::unsafe_arena_set_allocated_breakerevent(
    ::breakermodule::BreakerEvent* breakerevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breakerevent_);
  }
  _impl_.breakerevent_ = breakerevent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerEventProfile.breakerEvent)
}
inline ::breakermodule::BreakerEvent* BreakerEventProfile::release_breakerevent() {
  
  ::breakermodule::BreakerEvent* temp = _impl_.breakerevent_;
  _impl_.breakerevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::BreakerEvent* BreakerEventProfile::unsafe_arena_release_breakerevent() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerEventProfile.breakerEvent)
  
  ::breakermodule::BreakerEvent* temp = _impl_.breakerevent_;
  _impl_.breakerevent_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerEvent* BreakerEventProfile::_internal_mutable_breakerevent() {
  
  if (_impl_.breakerevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerEvent>(GetArenaForAllocation());
    _impl_.breakerevent_ = p;
  }
  return _impl_.breakerevent_;
}
inline ::breakermodule::BreakerEvent* BreakerEventProfile::mutable_breakerevent() {
  ::breakermodule::BreakerEvent* _msg = _internal_mutable_breakerevent();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerEventProfile.breakerEvent)
  return _msg;
}
inline void BreakerEventProfile::set_allocated_breakerevent(::breakermodule::BreakerEvent* breakerevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breakerevent_;
  }
  if (breakerevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breakerevent);
    if (message_arena != submessage_arena) {
      breakerevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breakerevent, submessage_arena);
    }

  } else {

  }
  _impl_.breakerevent_ = breakerevent;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerEventProfile.breakerEvent)
}

// -------------------------------------------------------------------

// BreakerReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool BreakerReading::_internal_has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && _impl_.conductingequipmentterminalreading_ != nullptr;
}
inline bool BreakerReading::has_conductingequipmentterminalreading() const {
  return _internal_has_conductingequipmentterminalreading();
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& BreakerReading::_internal_conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(
      ::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& BreakerReading::conductingequipmentterminalreading() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void BreakerReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* BreakerReading::release_conductingequipmentterminalreading() {
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* BreakerReading::unsafe_arena_release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* BreakerReading::_internal_mutable_conductingequipmentterminalreading() {
  
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaForAllocation());
    _impl_.conductingequipmentterminalreading_ = p;
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* BreakerReading::mutable_conductingequipmentterminalreading() {
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void BreakerReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipmentterminalreading));
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.conductingEquipmentTerminalReading)
}

// .commonmodule.ReadingMMXU diffReadingMMXU = 2;
inline bool BreakerReading::_internal_has_diffreadingmmxu() const {
  return this != internal_default_instance() && _impl_.diffreadingmmxu_ != nullptr;
}
inline bool BreakerReading::has_diffreadingmmxu() const {
  return _internal_has_diffreadingmmxu();
}
inline const ::commonmodule::ReadingMMXU& BreakerReading::_internal_diffreadingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.diffreadingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& BreakerReading::diffreadingmmxu() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.diffReadingMMXU)
  return _internal_diffreadingmmxu();
}
inline void BreakerReading::unsafe_arena_set_allocated_diffreadingmmxu(
    ::commonmodule::ReadingMMXU* diffreadingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diffreadingmmxu_);
  }
  _impl_.diffreadingmmxu_ = diffreadingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerReading.diffReadingMMXU)
}
inline ::commonmodule::ReadingMMXU* BreakerReading::release_diffreadingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.diffreadingmmxu_;
  _impl_.diffreadingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::unsafe_arena_release_diffreadingmmxu() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.diffReadingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.diffreadingmmxu_;
  _impl_.diffreadingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::_internal_mutable_diffreadingmmxu() {
  
  if (_impl_.diffreadingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.diffreadingmmxu_ = p;
  }
  return _impl_.diffreadingmmxu_;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::mutable_diffreadingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_diffreadingmmxu();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.diffReadingMMXU)
  return _msg;
}
inline void BreakerReading::set_allocated_diffreadingmmxu(::commonmodule::ReadingMMXU* diffreadingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diffreadingmmxu_);
  }
  if (diffreadingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diffreadingmmxu));
    if (message_arena != submessage_arena) {
      diffreadingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diffreadingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.diffreadingmmxu_ = diffreadingmmxu;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.diffReadingMMXU)
}

// .commonmodule.PhaseMMTN phaseMMTN = 3;
inline bool BreakerReading::_internal_has_phasemmtn() const {
  return this != internal_default_instance() && _impl_.phasemmtn_ != nullptr;
}
inline bool BreakerReading::has_phasemmtn() const {
  return _internal_has_phasemmtn();
}
inline const ::commonmodule::PhaseMMTN& BreakerReading::_internal_phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(
      ::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& BreakerReading::phasemmtn() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void BreakerReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* phasemmtn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* BreakerReading::release_phasemmtn() {
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseMMTN* BreakerReading::unsafe_arena_release_phasemmtn() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* BreakerReading::_internal_mutable_phasemmtn() {
  
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaForAllocation());
    _impl_.phasemmtn_ = p;
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* BreakerReading::mutable_phasemmtn() {
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.phaseMMTN)
  return _msg;
}
inline void BreakerReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  if (phasemmtn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phasemmtn));
    if (message_arena != submessage_arena) {
      phasemmtn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }

  } else {

  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 4;
inline bool BreakerReading::_internal_has_readingmmtr() const {
  return this != internal_default_instance() && _impl_.readingmmtr_ != nullptr;
}
inline bool BreakerReading::has_readingmmtr() const {
  return _internal_has_readingmmtr();
}
inline const ::commonmodule::ReadingMMTR& BreakerReading::_internal_readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(
      ::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& BreakerReading::readingmmtr() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void BreakerReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* readingmmtr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* BreakerReading::release_readingmmtr() {
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTR* BreakerReading::unsafe_arena_release_readingmmtr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* BreakerReading::_internal_mutable_readingmmtr() {
  
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaForAllocation());
    _impl_.readingmmtr_ = p;
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* BreakerReading::mutable_readingmmtr() {
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.readingMMTR)
  return _msg;
}
inline void BreakerReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  if (readingmmtr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmtr));
    if (message_arena != submessage_arena) {
      readingmmtr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 5;
inline bool BreakerReading::_internal_has_readingmmxu() const {
  return this != internal_default_instance() && _impl_.readingmmxu_ != nullptr;
}
inline bool BreakerReading::has_readingmmxu() const {
  return _internal_has_readingmmxu();
}
inline const ::commonmodule::ReadingMMXU& BreakerReading::_internal_readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& BreakerReading::readingmmxu() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void BreakerReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* readingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* BreakerReading::release_readingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::unsafe_arena_release_readingmmxu() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::_internal_mutable_readingmmxu() {
  
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.readingmmxu_ = p;
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* BreakerReading::mutable_readingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReading.readingMMXU)
  return _msg;
}
inline void BreakerReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  if (readingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmxu));
    if (message_arena != submessage_arena) {
      readingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReading.readingMMXU)
}

// -------------------------------------------------------------------

// BreakerReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerReadingProfile::_internal_has_readingmessageinfo() const {
  return this != internal_default_instance() && _impl_.readingmessageinfo_ != nullptr;
}
inline bool BreakerReadingProfile::has_readingmessageinfo() const {
  return _internal_has_readingmessageinfo();
}
inline const ::commonmodule::ReadingMessageInfo& BreakerReadingProfile::_internal_readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(
      ::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& BreakerReadingProfile::readingmessageinfo() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void BreakerReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* BreakerReadingProfile::release_readingmessageinfo() {
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* BreakerReadingProfile::unsafe_arena_release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* BreakerReadingProfile::_internal_mutable_readingmessageinfo() {
  
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaForAllocation());
    _impl_.readingmessageinfo_ = p;
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* BreakerReadingProfile::mutable_readingmessageinfo() {
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReadingProfile.readingMessageInfo)
  return _msg;
}
inline void BreakerReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmessageinfo));
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReadingProfile.readingMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerReadingProfile::_internal_has_breaker() const {
  return this != internal_default_instance() && _impl_.breaker_ != nullptr;
}
inline bool BreakerReadingProfile::has_breaker() const {
  return _internal_has_breaker();
}
inline void BreakerReadingProfile::clear_breaker() {
  if (GetArenaForAllocation() == nullptr && _impl_.breaker_ != nullptr) {
    delete _impl_.breaker_;
  }
  _impl_.breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerReadingProfile::_internal_breaker() const {
  const ::breakermodule::Breaker* p = _impl_.breaker_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::Breaker&>(
      ::breakermodule::_Breaker_default_instance_);
}
inline const ::breakermodule::Breaker& BreakerReadingProfile::breaker() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReadingProfile.breaker)
  return _internal_breaker();
}
inline void BreakerReadingProfile::unsafe_arena_set_allocated_breaker(
    ::breakermodule::Breaker* breaker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breaker_);
  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerReadingProfile.breaker)
}
inline ::breakermodule::Breaker* BreakerReadingProfile::release_breaker() {
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::Breaker* BreakerReadingProfile::unsafe_arena_release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerReadingProfile.breaker)
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerReadingProfile::_internal_mutable_breaker() {
  
  if (_impl_.breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaForAllocation());
    _impl_.breaker_ = p;
  }
  return _impl_.breaker_;
}
inline ::breakermodule::Breaker* BreakerReadingProfile::mutable_breaker() {
  ::breakermodule::Breaker* _msg = _internal_mutable_breaker();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReadingProfile.breaker)
  return _msg;
}
inline void BreakerReadingProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breaker_;
  }
  if (breaker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breaker);
    if (message_arena != submessage_arena) {
      breaker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }

  } else {

  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerReadingProfile.breaker)
}

// repeated .breakermodule.BreakerReading breakerReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
inline int BreakerReadingProfile::_internal_breakerreading_size() const {
  return _impl_.breakerreading_.size();
}
inline int BreakerReadingProfile::breakerreading_size() const {
  return _internal_breakerreading_size();
}
inline void BreakerReadingProfile::clear_breakerreading() {
  _impl_.breakerreading_.Clear();
}
inline ::breakermodule::BreakerReading* BreakerReadingProfile::mutable_breakerreading(int index) {
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerReadingProfile.breakerReading)
  return _impl_.breakerreading_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::breakermodule::BreakerReading >*
BreakerReadingProfile::mutable_breakerreading() {
  // @@protoc_insertion_point(field_mutable_list:breakermodule.BreakerReadingProfile.breakerReading)
  return &_impl_.breakerreading_;
}
inline const ::breakermodule::BreakerReading& BreakerReadingProfile::_internal_breakerreading(int index) const {
  return _impl_.breakerreading_.Get(index);
}
inline const ::breakermodule::BreakerReading& BreakerReadingProfile::breakerreading(int index) const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerReadingProfile.breakerReading)
  return _internal_breakerreading(index);
}
inline ::breakermodule::BreakerReading* BreakerReadingProfile::_internal_add_breakerreading() {
  return _impl_.breakerreading_.Add();
}
inline ::breakermodule::BreakerReading* BreakerReadingProfile::add_breakerreading() {
  ::breakermodule::BreakerReading* _add = _internal_add_breakerreading();
  // @@protoc_insertion_point(field_add:breakermodule.BreakerReadingProfile.breakerReading)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::breakermodule::BreakerReading >&
BreakerReadingProfile::breakerreading() const {
  // @@protoc_insertion_point(field_list:breakermodule.BreakerReadingProfile.breakerReading)
  return _impl_.breakerreading_;
}

// -------------------------------------------------------------------

// BreakerStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool BreakerStatus::_internal_has_statusvalue() const {
  return this != internal_default_instance() && _impl_.statusvalue_ != nullptr;
}
inline bool BreakerStatus::has_statusvalue() const {
  return _internal_has_statusvalue();
}
inline const ::commonmodule::StatusValue& BreakerStatus::_internal_statusvalue() const {
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(
      ::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& BreakerStatus::statusvalue() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatus.statusValue)
  return _internal_statusvalue();
}
inline void BreakerStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* statusvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerStatus.statusValue)
}
inline ::commonmodule::StatusValue* BreakerStatus::release_statusvalue() {
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusValue* BreakerStatus::unsafe_arena_release_statusvalue() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* BreakerStatus::_internal_mutable_statusvalue() {
  
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaForAllocation());
    _impl_.statusvalue_ = p;
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* BreakerStatus::mutable_statusvalue() {
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatus.statusValue)
  return _msg;
}
inline void BreakerStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  if (statusvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusvalue));
    if (message_arena != submessage_arena) {
      statusvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }

  } else {

  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatus.statusValue)
}

// .commonmodule.StatusAndEventXCBR statusAndEventXCBR = 2;
inline bool BreakerStatus::_internal_has_statusandeventxcbr() const {
  return this != internal_default_instance() && _impl_.statusandeventxcbr_ != nullptr;
}
inline bool BreakerStatus::has_statusandeventxcbr() const {
  return _internal_has_statusandeventxcbr();
}
inline const ::commonmodule::StatusAndEventXCBR& BreakerStatus::_internal_statusandeventxcbr() const {
  const ::commonmodule::StatusAndEventXCBR* p = _impl_.statusandeventxcbr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusAndEventXCBR&>(
      ::commonmodule::_StatusAndEventXCBR_default_instance_);
}
inline const ::commonmodule::StatusAndEventXCBR& BreakerStatus::statusandeventxcbr() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatus.statusAndEventXCBR)
  return _internal_statusandeventxcbr();
}
inline void BreakerStatus::unsafe_arena_set_allocated_statusandeventxcbr(
    ::commonmodule::StatusAndEventXCBR* statusandeventxcbr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusandeventxcbr_);
  }
  _impl_.statusandeventxcbr_ = statusandeventxcbr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerStatus.statusAndEventXCBR)
}
inline ::commonmodule::StatusAndEventXCBR* BreakerStatus::release_statusandeventxcbr() {
  
  ::commonmodule::StatusAndEventXCBR* temp = _impl_.statusandeventxcbr_;
  _impl_.statusandeventxcbr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerStatus::unsafe_arena_release_statusandeventxcbr() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatus.statusAndEventXCBR)
  
  ::commonmodule::StatusAndEventXCBR* temp = _impl_.statusandeventxcbr_;
  _impl_.statusandeventxcbr_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerStatus::_internal_mutable_statusandeventxcbr() {
  
  if (_impl_.statusandeventxcbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusAndEventXCBR>(GetArenaForAllocation());
    _impl_.statusandeventxcbr_ = p;
  }
  return _impl_.statusandeventxcbr_;
}
inline ::commonmodule::StatusAndEventXCBR* BreakerStatus::mutable_statusandeventxcbr() {
  ::commonmodule::StatusAndEventXCBR* _msg = _internal_mutable_statusandeventxcbr();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatus.statusAndEventXCBR)
  return _msg;
}
inline void BreakerStatus::set_allocated_statusandeventxcbr(::commonmodule::StatusAndEventXCBR* statusandeventxcbr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusandeventxcbr_);
  }
  if (statusandeventxcbr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusandeventxcbr));
    if (message_arena != submessage_arena) {
      statusandeventxcbr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusandeventxcbr, submessage_arena);
    }

  } else {

  }
  _impl_.statusandeventxcbr_ = statusandeventxcbr;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatus.statusAndEventXCBR)
}

// -------------------------------------------------------------------

// BreakerStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool BreakerStatusProfile::_internal_has_statusmessageinfo() const {
  return this != internal_default_instance() && _impl_.statusmessageinfo_ != nullptr;
}
inline bool BreakerStatusProfile::has_statusmessageinfo() const {
  return _internal_has_statusmessageinfo();
}
inline const ::commonmodule::StatusMessageInfo& BreakerStatusProfile::_internal_statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(
      ::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& BreakerStatusProfile::statusmessageinfo() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void BreakerStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* statusmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* BreakerStatusProfile::release_statusmessageinfo() {
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusMessageInfo* BreakerStatusProfile::unsafe_arena_release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* BreakerStatusProfile::_internal_mutable_statusmessageinfo() {
  
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaForAllocation());
    _impl_.statusmessageinfo_ = p;
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* BreakerStatusProfile::mutable_statusmessageinfo() {
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatusProfile.statusMessageInfo)
  return _msg;
}
inline void BreakerStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusmessageinfo));
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatusProfile.statusMessageInfo)
}

// .breakermodule.Breaker breaker = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerStatusProfile::_internal_has_breaker() const {
  return this != internal_default_instance() && _impl_.breaker_ != nullptr;
}
inline bool BreakerStatusProfile::has_breaker() const {
  return _internal_has_breaker();
}
inline void BreakerStatusProfile::clear_breaker() {
  if (GetArenaForAllocation() == nullptr && _impl_.breaker_ != nullptr) {
    delete _impl_.breaker_;
  }
  _impl_.breaker_ = nullptr;
}
inline const ::breakermodule::Breaker& BreakerStatusProfile::_internal_breaker() const {
  const ::breakermodule::Breaker* p = _impl_.breaker_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::Breaker&>(
      ::breakermodule::_Breaker_default_instance_);
}
inline const ::breakermodule::Breaker& BreakerStatusProfile::breaker() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatusProfile.breaker)
  return _internal_breaker();
}
inline void BreakerStatusProfile::unsafe_arena_set_allocated_breaker(
    ::breakermodule::Breaker* breaker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breaker_);
  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerStatusProfile.breaker)
}
inline ::breakermodule::Breaker* BreakerStatusProfile::release_breaker() {
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::Breaker* BreakerStatusProfile::unsafe_arena_release_breaker() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatusProfile.breaker)
  
  ::breakermodule::Breaker* temp = _impl_.breaker_;
  _impl_.breaker_ = nullptr;
  return temp;
}
inline ::breakermodule::Breaker* BreakerStatusProfile::_internal_mutable_breaker() {
  
  if (_impl_.breaker_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::Breaker>(GetArenaForAllocation());
    _impl_.breaker_ = p;
  }
  return _impl_.breaker_;
}
inline ::breakermodule::Breaker* BreakerStatusProfile::mutable_breaker() {
  ::breakermodule::Breaker* _msg = _internal_mutable_breaker();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatusProfile.breaker)
  return _msg;
}
inline void BreakerStatusProfile::set_allocated_breaker(::breakermodule::Breaker* breaker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breaker_;
  }
  if (breaker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breaker);
    if (message_arena != submessage_arena) {
      breaker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breaker, submessage_arena);
    }

  } else {

  }
  _impl_.breaker_ = breaker;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatusProfile.breaker)
}

// .breakermodule.BreakerStatus breakerStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BreakerStatusProfile::_internal_has_breakerstatus() const {
  return this != internal_default_instance() && _impl_.breakerstatus_ != nullptr;
}
inline bool BreakerStatusProfile::has_breakerstatus() const {
  return _internal_has_breakerstatus();
}
inline void BreakerStatusProfile::clear_breakerstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.breakerstatus_ != nullptr) {
    delete _impl_.breakerstatus_;
  }
  _impl_.breakerstatus_ = nullptr;
}
inline const ::breakermodule::BreakerStatus& BreakerStatusProfile::_internal_breakerstatus() const {
  const ::breakermodule::BreakerStatus* p = _impl_.breakerstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::breakermodule::BreakerStatus&>(
      ::breakermodule::_BreakerStatus_default_instance_);
}
inline const ::breakermodule::BreakerStatus& BreakerStatusProfile::breakerstatus() const {
  // @@protoc_insertion_point(field_get:breakermodule.BreakerStatusProfile.breakerStatus)
  return _internal_breakerstatus();
}
inline void BreakerStatusProfile::unsafe_arena_set_allocated_breakerstatus(
    ::breakermodule::BreakerStatus* breakerstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breakerstatus_);
  }
  _impl_.breakerstatus_ = breakerstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:breakermodule.BreakerStatusProfile.breakerStatus)
}
inline ::breakermodule::BreakerStatus* BreakerStatusProfile::release_breakerstatus() {
  
  ::breakermodule::BreakerStatus* temp = _impl_.breakerstatus_;
  _impl_.breakerstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::breakermodule::BreakerStatus* BreakerStatusProfile::unsafe_arena_release_breakerstatus() {
  // @@protoc_insertion_point(field_release:breakermodule.BreakerStatusProfile.breakerStatus)
  
  ::breakermodule::BreakerStatus* temp = _impl_.breakerstatus_;
  _impl_.breakerstatus_ = nullptr;
  return temp;
}
inline ::breakermodule::BreakerStatus* BreakerStatusProfile::_internal_mutable_breakerstatus() {
  
  if (_impl_.breakerstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::breakermodule::BreakerStatus>(GetArenaForAllocation());
    _impl_.breakerstatus_ = p;
  }
  return _impl_.breakerstatus_;
}
inline ::breakermodule::BreakerStatus* BreakerStatusProfile::mutable_breakerstatus() {
  ::breakermodule::BreakerStatus* _msg = _internal_mutable_breakerstatus();
  // @@protoc_insertion_point(field_mutable:breakermodule.BreakerStatusProfile.breakerStatus)
  return _msg;
}
inline void BreakerStatusProfile::set_allocated_breakerstatus(::breakermodule::BreakerStatus* breakerstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breakerstatus_;
  }
  if (breakerstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breakerstatus);
    if (message_arena != submessage_arena) {
      breakerstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breakerstatus, submessage_arena);
    }

  } else {

  }
  _impl_.breakerstatus_ = breakerstatus;
  // @@protoc_insertion_point(field_set_allocated:breakermodule.BreakerStatusProfile.breakerStatus)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace breakermodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_breakermodule_2fbreakermodule_2eproto_2epb_2eh
