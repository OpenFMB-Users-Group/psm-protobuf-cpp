// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: circuitsegmentservicemodule/circuitsegmentservicemodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "uml.pb.h"
#include <google/protobuf/wrappers.pb.h>
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(int index);
namespace circuitsegmentservicemodule {
class CircuitSegmentControl;
struct CircuitSegmentControlDefaultTypeInternal;
extern CircuitSegmentControlDefaultTypeInternal _CircuitSegmentControl_default_instance_;
class CircuitSegmentControlDCSC;
struct CircuitSegmentControlDCSCDefaultTypeInternal;
extern CircuitSegmentControlDCSCDefaultTypeInternal _CircuitSegmentControlDCSC_default_instance_;
class CircuitSegmentControlProfile;
struct CircuitSegmentControlProfileDefaultTypeInternal;
extern CircuitSegmentControlProfileDefaultTypeInternal _CircuitSegmentControlProfile_default_instance_;
class CircuitSegmentEvent;
struct CircuitSegmentEventDefaultTypeInternal;
extern CircuitSegmentEventDefaultTypeInternal _CircuitSegmentEvent_default_instance_;
class CircuitSegmentEventDCSC;
struct CircuitSegmentEventDCSCDefaultTypeInternal;
extern CircuitSegmentEventDCSCDefaultTypeInternal _CircuitSegmentEventDCSC_default_instance_;
class CircuitSegmentEventProfile;
struct CircuitSegmentEventProfileDefaultTypeInternal;
extern CircuitSegmentEventProfileDefaultTypeInternal _CircuitSegmentEventProfile_default_instance_;
class CircuitSegmentStatus;
struct CircuitSegmentStatusDefaultTypeInternal;
extern CircuitSegmentStatusDefaultTypeInternal _CircuitSegmentStatus_default_instance_;
class CircuitSegmentStatusDCSC;
struct CircuitSegmentStatusDCSCDefaultTypeInternal;
extern CircuitSegmentStatusDCSCDefaultTypeInternal _CircuitSegmentStatusDCSC_default_instance_;
class CircuitSegmentStatusProfile;
struct CircuitSegmentStatusProfileDefaultTypeInternal;
extern CircuitSegmentStatusProfileDefaultTypeInternal _CircuitSegmentStatusProfile_default_instance_;
class ENG_CircuitSegmentServiceModeKind;
struct ENG_CircuitSegmentServiceModeKindDefaultTypeInternal;
extern ENG_CircuitSegmentServiceModeKindDefaultTypeInternal _ENG_CircuitSegmentServiceModeKind_default_instance_;
class Optional_CircuitSegmentServiceModeKind;
struct Optional_CircuitSegmentServiceModeKindDefaultTypeInternal;
extern Optional_CircuitSegmentServiceModeKindDefaultTypeInternal _Optional_CircuitSegmentServiceModeKind_default_instance_;
}  // namespace circuitsegmentservicemodule
PROTOBUF_NAMESPACE_OPEN
template<> ::circuitsegmentservicemodule::CircuitSegmentControl* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControl>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControlDCSC>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentControlProfile* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControlProfile>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentEvent* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEvent>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEventDCSC>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentEventProfile* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEventProfile>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentStatus* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatus>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatusDCSC>(Arena*);
template<> ::circuitsegmentservicemodule::CircuitSegmentStatusProfile* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatusProfile>(Arena*);
template<> ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(Arena*);
template<> ::circuitsegmentservicemodule::Optional_CircuitSegmentServiceModeKind* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::Optional_CircuitSegmentServiceModeKind>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace circuitsegmentservicemodule {

enum CircuitSegmentServiceModeKind : int {
  CircuitSegmentServiceModeKind_UNDEFINED = 0,
  CircuitSegmentServiceModeKind_none = 1,
  CircuitSegmentServiceModeKind_auto = 2,
  CircuitSegmentServiceModeKind_manual = 3,
  CircuitSegmentServiceModeKind_netzero = 4,
  CircuitSegmentServiceModeKind_start = 5,
  CircuitSegmentServiceModeKind_stop = 6,
  CircuitSegmentServiceModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CircuitSegmentServiceModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CircuitSegmentServiceModeKind_IsValid(int value);
constexpr CircuitSegmentServiceModeKind CircuitSegmentServiceModeKind_MIN = CircuitSegmentServiceModeKind_UNDEFINED;
constexpr CircuitSegmentServiceModeKind CircuitSegmentServiceModeKind_MAX = CircuitSegmentServiceModeKind_stop;
constexpr int CircuitSegmentServiceModeKind_ARRAYSIZE = CircuitSegmentServiceModeKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CircuitSegmentServiceModeKind_descriptor();
template<typename T>
inline const std::string& CircuitSegmentServiceModeKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CircuitSegmentServiceModeKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CircuitSegmentServiceModeKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CircuitSegmentServiceModeKind_descriptor(), enum_t_value);
}
inline bool CircuitSegmentServiceModeKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CircuitSegmentServiceModeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CircuitSegmentServiceModeKind>(
    CircuitSegmentServiceModeKind_descriptor(), name, value);
}
// ===================================================================

class Optional_CircuitSegmentServiceModeKind PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind) */ {
 public:
  inline Optional_CircuitSegmentServiceModeKind() : Optional_CircuitSegmentServiceModeKind(nullptr) {}
  virtual ~Optional_CircuitSegmentServiceModeKind();
  explicit constexpr Optional_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_CircuitSegmentServiceModeKind(const Optional_CircuitSegmentServiceModeKind& from);
  Optional_CircuitSegmentServiceModeKind(Optional_CircuitSegmentServiceModeKind&& from) noexcept
    : Optional_CircuitSegmentServiceModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_CircuitSegmentServiceModeKind& operator=(const Optional_CircuitSegmentServiceModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_CircuitSegmentServiceModeKind& operator=(Optional_CircuitSegmentServiceModeKind&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Optional_CircuitSegmentServiceModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_CircuitSegmentServiceModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_CircuitSegmentServiceModeKind*>(
               &_Optional_CircuitSegmentServiceModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Optional_CircuitSegmentServiceModeKind& a, Optional_CircuitSegmentServiceModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Optional_CircuitSegmentServiceModeKind* New() const final {
    return CreateMaybeMessage<Optional_CircuitSegmentServiceModeKind>(nullptr);
  }

  Optional_CircuitSegmentServiceModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Optional_CircuitSegmentServiceModeKind>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Optional_CircuitSegmentServiceModeKind& from);
  void MergeFrom(const Optional_CircuitSegmentServiceModeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_CircuitSegmentServiceModeKind* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind";
  }
  protected:
  explicit Optional_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .circuitsegmentservicemodule.CircuitSegmentServiceModeKind value = 1;
  void clear_value();
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value() const;
  void set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);
  private:
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind _internal_value() const;
  void _internal_set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);
  public:

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class ENG_CircuitSegmentServiceModeKind PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind) */ {
 public:
  inline ENG_CircuitSegmentServiceModeKind() : ENG_CircuitSegmentServiceModeKind(nullptr) {}
  virtual ~ENG_CircuitSegmentServiceModeKind();
  explicit constexpr ENG_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENG_CircuitSegmentServiceModeKind(const ENG_CircuitSegmentServiceModeKind& from);
  ENG_CircuitSegmentServiceModeKind(ENG_CircuitSegmentServiceModeKind&& from) noexcept
    : ENG_CircuitSegmentServiceModeKind() {
    *this = ::std::move(from);
  }

  inline ENG_CircuitSegmentServiceModeKind& operator=(const ENG_CircuitSegmentServiceModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENG_CircuitSegmentServiceModeKind& operator=(ENG_CircuitSegmentServiceModeKind&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ENG_CircuitSegmentServiceModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENG_CircuitSegmentServiceModeKind* internal_default_instance() {
    return reinterpret_cast<const ENG_CircuitSegmentServiceModeKind*>(
               &_ENG_CircuitSegmentServiceModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ENG_CircuitSegmentServiceModeKind& a, ENG_CircuitSegmentServiceModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENG_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENG_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ENG_CircuitSegmentServiceModeKind* New() const final {
    return CreateMaybeMessage<ENG_CircuitSegmentServiceModeKind>(nullptr);
  }

  ENG_CircuitSegmentServiceModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ENG_CircuitSegmentServiceModeKind>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ENG_CircuitSegmentServiceModeKind& from);
  void MergeFrom(const ENG_CircuitSegmentServiceModeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_CircuitSegmentServiceModeKind* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind";
  }
  protected:
  explicit ENG_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetValExtensionFieldNumber = 2,
    kSetValFieldNumber = 1,
  };
  // .google.protobuf.StringValue setValExtension = 2;
  bool has_setvalextension() const;
  private:
  bool _internal_has_setvalextension() const;
  public:
  void clear_setvalextension();
  const PROTOBUF_NAMESPACE_ID::StringValue& setvalextension() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_setvalextension();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_setvalextension();
  void set_allocated_setvalextension(PROTOBUF_NAMESPACE_ID::StringValue* setvalextension);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_setvalextension() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_setvalextension();
  public:
  void unsafe_arena_set_allocated_setvalextension(
      PROTOBUF_NAMESPACE_ID::StringValue* setvalextension);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_setvalextension();

  // .circuitsegmentservicemodule.CircuitSegmentServiceModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval();
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind setval() const;
  void set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);
  private:
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind _internal_setval() const;
  void _internal_set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);
  public:

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::StringValue* setvalextension_;
  int setval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentControlDCSC PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentControlDCSC) */ {
 public:
  inline CircuitSegmentControlDCSC() : CircuitSegmentControlDCSC(nullptr) {}
  virtual ~CircuitSegmentControlDCSC();
  explicit constexpr CircuitSegmentControlDCSC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentControlDCSC(const CircuitSegmentControlDCSC& from);
  CircuitSegmentControlDCSC(CircuitSegmentControlDCSC&& from) noexcept
    : CircuitSegmentControlDCSC() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentControlDCSC& operator=(const CircuitSegmentControlDCSC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentControlDCSC& operator=(CircuitSegmentControlDCSC&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentControlDCSC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentControlDCSC* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentControlDCSC*>(
               &_CircuitSegmentControlDCSC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CircuitSegmentControlDCSC& a, CircuitSegmentControlDCSC& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentControlDCSC* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentControlDCSC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentControlDCSC* New() const final {
    return CreateMaybeMessage<CircuitSegmentControlDCSC>(nullptr);
  }

  CircuitSegmentControlDCSC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentControlDCSC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentControlDCSC& from);
  void MergeFrom(const CircuitSegmentControlDCSC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentControlDCSC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentControlDCSC";
  }
  protected:
  explicit CircuitSegmentControlDCSC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kCircuitSegmentServiceModeFieldNumber = 2,
    kIslandFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;
  public:
  void clear_logicalnodeforcontrol();
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();

  // .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
  bool has_circuitsegmentservicemode() const;
  private:
  bool _internal_has_circuitsegmentservicemode() const;
  public:
  void clear_circuitsegmentservicemode();
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* release_circuitsegmentservicemode();
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* mutable_circuitsegmentservicemode();
  void set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  private:
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& _internal_circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _internal_mutable_circuitsegmentservicemode();
  public:
  void unsafe_arena_set_allocated_circuitsegmentservicemode(
      ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* unsafe_arena_release_circuitsegmentservicemode();

  // .commonmodule.ControlDPC Island = 3;
  bool has_island() const;
  private:
  bool _internal_has_island() const;
  public:
  void clear_island();
  const ::commonmodule::ControlDPC& island() const;
  ::commonmodule::ControlDPC* release_island();
  ::commonmodule::ControlDPC* mutable_island();
  void set_allocated_island(::commonmodule::ControlDPC* island);
  private:
  const ::commonmodule::ControlDPC& _internal_island() const;
  ::commonmodule::ControlDPC* _internal_mutable_island();
  public:
  void unsafe_arena_set_allocated_island(
      ::commonmodule::ControlDPC* island);
  ::commonmodule::ControlDPC* unsafe_arena_release_island();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentControlDCSC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode_;
  ::commonmodule::ControlDPC* island_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentControl PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentControl) */ {
 public:
  inline CircuitSegmentControl() : CircuitSegmentControl(nullptr) {}
  virtual ~CircuitSegmentControl();
  explicit constexpr CircuitSegmentControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentControl(const CircuitSegmentControl& from);
  CircuitSegmentControl(CircuitSegmentControl&& from) noexcept
    : CircuitSegmentControl() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentControl& operator=(const CircuitSegmentControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentControl& operator=(CircuitSegmentControl&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentControl* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentControl*>(
               &_CircuitSegmentControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CircuitSegmentControl& a, CircuitSegmentControl& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentControl* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentControl* New() const final {
    return CreateMaybeMessage<CircuitSegmentControl>(nullptr);
  }

  CircuitSegmentControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentControl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentControl& from);
  void MergeFrom(const CircuitSegmentControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentControl";
  }
  protected:
  explicit CircuitSegmentControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kCheckFieldNumber = 2,
    kCircuitSegmentControlDCSCFieldNumber = 3,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;
  public:
  void clear_identifiedobject();
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();

  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;
  public:
  void clear_check();
  const ::commonmodule::CheckConditions& check() const;
  ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();

  // .circuitsegmentservicemodule.CircuitSegmentControlDCSC circuitSegmentControlDCSC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentcontroldcsc() const;
  private:
  bool _internal_has_circuitsegmentcontroldcsc() const;
  public:
  void clear_circuitsegmentcontroldcsc();
  const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& circuitsegmentcontroldcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* release_circuitsegmentcontroldcsc();
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* mutable_circuitsegmentcontroldcsc();
  void set_allocated_circuitsegmentcontroldcsc(::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& _internal_circuitsegmentcontroldcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* _internal_mutable_circuitsegmentcontroldcsc();
  public:
  void unsafe_arena_set_allocated_circuitsegmentcontroldcsc(
      ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc);
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* unsafe_arena_release_circuitsegmentcontroldcsc();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  ::commonmodule::CheckConditions* check_;
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentControlProfile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentControlProfile) */ {
 public:
  inline CircuitSegmentControlProfile() : CircuitSegmentControlProfile(nullptr) {}
  virtual ~CircuitSegmentControlProfile();
  explicit constexpr CircuitSegmentControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentControlProfile(const CircuitSegmentControlProfile& from);
  CircuitSegmentControlProfile(CircuitSegmentControlProfile&& from) noexcept
    : CircuitSegmentControlProfile() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentControlProfile& operator=(const CircuitSegmentControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentControlProfile& operator=(CircuitSegmentControlProfile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentControlProfile* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentControlProfile*>(
               &_CircuitSegmentControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CircuitSegmentControlProfile& a, CircuitSegmentControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentControlProfile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentControlProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentControlProfile* New() const final {
    return CreateMaybeMessage<CircuitSegmentControlProfile>(nullptr);
  }

  CircuitSegmentControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentControlProfile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentControlProfile& from);
  void MergeFrom(const CircuitSegmentControlProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentControlProfile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentControlProfile";
  }
  protected:
  explicit CircuitSegmentControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kApplicationSystemFieldNumber = 2,
    kCircuitSegmentControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;
  public:
  void clear_controlmessageinfo();
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();

  // .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_applicationsystem() const;
  private:
  bool _internal_has_applicationsystem() const;
  public:
  void clear_applicationsystem();
  const ::commonmodule::ApplicationSystem& applicationsystem() const;
  ::commonmodule::ApplicationSystem* release_applicationsystem();
  ::commonmodule::ApplicationSystem* mutable_applicationsystem();
  void set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem);
  private:
  const ::commonmodule::ApplicationSystem& _internal_applicationsystem() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_applicationsystem();
  public:
  void unsafe_arena_set_allocated_applicationsystem(
      ::commonmodule::ApplicationSystem* applicationsystem);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_applicationsystem();

  // .circuitsegmentservicemodule.CircuitSegmentControl circuitSegmentControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentcontrol() const;
  private:
  bool _internal_has_circuitsegmentcontrol() const;
  public:
  void clear_circuitsegmentcontrol();
  const ::circuitsegmentservicemodule::CircuitSegmentControl& circuitsegmentcontrol() const;
  ::circuitsegmentservicemodule::CircuitSegmentControl* release_circuitsegmentcontrol();
  ::circuitsegmentservicemodule::CircuitSegmentControl* mutable_circuitsegmentcontrol();
  void set_allocated_circuitsegmentcontrol(::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentControl& _internal_circuitsegmentcontrol() const;
  ::circuitsegmentservicemodule::CircuitSegmentControl* _internal_mutable_circuitsegmentcontrol();
  public:
  void unsafe_arena_set_allocated_circuitsegmentcontrol(
      ::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol);
  ::circuitsegmentservicemodule::CircuitSegmentControl* unsafe_arena_release_circuitsegmentcontrol();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::ControlMessageInfo* controlmessageinfo_;
  ::commonmodule::ApplicationSystem* applicationsystem_;
  ::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentEventDCSC PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentEventDCSC) */ {
 public:
  inline CircuitSegmentEventDCSC() : CircuitSegmentEventDCSC(nullptr) {}
  virtual ~CircuitSegmentEventDCSC();
  explicit constexpr CircuitSegmentEventDCSC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentEventDCSC(const CircuitSegmentEventDCSC& from);
  CircuitSegmentEventDCSC(CircuitSegmentEventDCSC&& from) noexcept
    : CircuitSegmentEventDCSC() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentEventDCSC& operator=(const CircuitSegmentEventDCSC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentEventDCSC& operator=(CircuitSegmentEventDCSC&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentEventDCSC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentEventDCSC* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentEventDCSC*>(
               &_CircuitSegmentEventDCSC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CircuitSegmentEventDCSC& a, CircuitSegmentEventDCSC& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentEventDCSC* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentEventDCSC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentEventDCSC* New() const final {
    return CreateMaybeMessage<CircuitSegmentEventDCSC>(nullptr);
  }

  CircuitSegmentEventDCSC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentEventDCSC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentEventDCSC& from);
  void MergeFrom(const CircuitSegmentEventDCSC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentEventDCSC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentEventDCSC";
  }
  protected:
  explicit CircuitSegmentEventDCSC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kCircuitSegmentServiceModeFieldNumber = 2,
    kIslandFieldNumber = 3,
    kPermissibleAutoFieldNumber = 4,
    kPermissibleManualFieldNumber = 5,
    kPermissibleNetzeroFieldNumber = 6,
    kPermissibleStartFieldNumber = 7,
    kPermissibleStopFieldNumber = 8,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;
  public:
  void clear_logicalnode();
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();

  // .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
  bool has_circuitsegmentservicemode() const;
  private:
  bool _internal_has_circuitsegmentservicemode() const;
  public:
  void clear_circuitsegmentservicemode();
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* release_circuitsegmentservicemode();
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* mutable_circuitsegmentservicemode();
  void set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  private:
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& _internal_circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _internal_mutable_circuitsegmentservicemode();
  public:
  void unsafe_arena_set_allocated_circuitsegmentservicemode(
      ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* unsafe_arena_release_circuitsegmentservicemode();

  // .commonmodule.StatusSPS Island = 3;
  bool has_island() const;
  private:
  bool _internal_has_island() const;
  public:
  void clear_island();
  const ::commonmodule::StatusSPS& island() const;
  ::commonmodule::StatusSPS* release_island();
  ::commonmodule::StatusSPS* mutable_island();
  void set_allocated_island(::commonmodule::StatusSPS* island);
  private:
  const ::commonmodule::StatusSPS& _internal_island() const;
  ::commonmodule::StatusSPS* _internal_mutable_island();
  public:
  void unsafe_arena_set_allocated_island(
      ::commonmodule::StatusSPS* island);
  ::commonmodule::StatusSPS* unsafe_arena_release_island();

  // .commonmodule.StatusSPS PermissibleAuto = 4;
  bool has_permissibleauto() const;
  private:
  bool _internal_has_permissibleauto() const;
  public:
  void clear_permissibleauto();
  const ::commonmodule::StatusSPS& permissibleauto() const;
  ::commonmodule::StatusSPS* release_permissibleauto();
  ::commonmodule::StatusSPS* mutable_permissibleauto();
  void set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto);
  private:
  const ::commonmodule::StatusSPS& _internal_permissibleauto() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissibleauto();
  public:
  void unsafe_arena_set_allocated_permissibleauto(
      ::commonmodule::StatusSPS* permissibleauto);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissibleauto();

  // .commonmodule.StatusSPS PermissibleManual = 5;
  bool has_permissiblemanual() const;
  private:
  bool _internal_has_permissiblemanual() const;
  public:
  void clear_permissiblemanual();
  const ::commonmodule::StatusSPS& permissiblemanual() const;
  ::commonmodule::StatusSPS* release_permissiblemanual();
  ::commonmodule::StatusSPS* mutable_permissiblemanual();
  void set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblemanual() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblemanual();
  public:
  void unsafe_arena_set_allocated_permissiblemanual(
      ::commonmodule::StatusSPS* permissiblemanual);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblemanual();

  // .commonmodule.StatusSPS PermissibleNetzero = 6;
  bool has_permissiblenetzero() const;
  private:
  bool _internal_has_permissiblenetzero() const;
  public:
  void clear_permissiblenetzero();
  const ::commonmodule::StatusSPS& permissiblenetzero() const;
  ::commonmodule::StatusSPS* release_permissiblenetzero();
  ::commonmodule::StatusSPS* mutable_permissiblenetzero();
  void set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblenetzero() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblenetzero();
  public:
  void unsafe_arena_set_allocated_permissiblenetzero(
      ::commonmodule::StatusSPS* permissiblenetzero);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblenetzero();

  // .commonmodule.StatusSPS PermissibleStart = 7;
  bool has_permissiblestart() const;
  private:
  bool _internal_has_permissiblestart() const;
  public:
  void clear_permissiblestart();
  const ::commonmodule::StatusSPS& permissiblestart() const;
  ::commonmodule::StatusSPS* release_permissiblestart();
  ::commonmodule::StatusSPS* mutable_permissiblestart();
  void set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestart() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestart();
  public:
  void unsafe_arena_set_allocated_permissiblestart(
      ::commonmodule::StatusSPS* permissiblestart);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestart();

  // .commonmodule.StatusSPS PermissibleStop = 8;
  bool has_permissiblestop() const;
  private:
  bool _internal_has_permissiblestop() const;
  public:
  void clear_permissiblestop();
  const ::commonmodule::StatusSPS& permissiblestop() const;
  ::commonmodule::StatusSPS* release_permissiblestop();
  ::commonmodule::StatusSPS* mutable_permissiblestop();
  void set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestop() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestop();
  public:
  void unsafe_arena_set_allocated_permissiblestop(
      ::commonmodule::StatusSPS* permissiblestop);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestop();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentEventDCSC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode_;
  ::commonmodule::StatusSPS* island_;
  ::commonmodule::StatusSPS* permissibleauto_;
  ::commonmodule::StatusSPS* permissiblemanual_;
  ::commonmodule::StatusSPS* permissiblenetzero_;
  ::commonmodule::StatusSPS* permissiblestart_;
  ::commonmodule::StatusSPS* permissiblestop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentEvent) */ {
 public:
  inline CircuitSegmentEvent() : CircuitSegmentEvent(nullptr) {}
  virtual ~CircuitSegmentEvent();
  explicit constexpr CircuitSegmentEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentEvent(const CircuitSegmentEvent& from);
  CircuitSegmentEvent(CircuitSegmentEvent&& from) noexcept
    : CircuitSegmentEvent() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentEvent& operator=(const CircuitSegmentEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentEvent& operator=(CircuitSegmentEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentEvent* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentEvent*>(
               &_CircuitSegmentEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CircuitSegmentEvent& a, CircuitSegmentEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentEvent* New() const final {
    return CreateMaybeMessage<CircuitSegmentEvent>(nullptr);
  }

  CircuitSegmentEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentEvent& from);
  void MergeFrom(const CircuitSegmentEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentEvent";
  }
  protected:
  explicit CircuitSegmentEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kCircuitSegmentEventDCSCFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;
  public:
  void clear_identifiedobject();
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();

  // .circuitsegmentservicemodule.CircuitSegmentEventDCSC circuitSegmentEventDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmenteventdcsc() const;
  private:
  bool _internal_has_circuitsegmenteventdcsc() const;
  public:
  void clear_circuitsegmenteventdcsc();
  const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& circuitsegmenteventdcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* release_circuitsegmenteventdcsc();
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* mutable_circuitsegmenteventdcsc();
  void set_allocated_circuitsegmenteventdcsc(::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& _internal_circuitsegmenteventdcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* _internal_mutable_circuitsegmenteventdcsc();
  public:
  void unsafe_arena_set_allocated_circuitsegmenteventdcsc(
      ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc);
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* unsafe_arena_release_circuitsegmenteventdcsc();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentEventProfile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentEventProfile) */ {
 public:
  inline CircuitSegmentEventProfile() : CircuitSegmentEventProfile(nullptr) {}
  virtual ~CircuitSegmentEventProfile();
  explicit constexpr CircuitSegmentEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentEventProfile(const CircuitSegmentEventProfile& from);
  CircuitSegmentEventProfile(CircuitSegmentEventProfile&& from) noexcept
    : CircuitSegmentEventProfile() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentEventProfile& operator=(const CircuitSegmentEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentEventProfile& operator=(CircuitSegmentEventProfile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentEventProfile* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentEventProfile*>(
               &_CircuitSegmentEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CircuitSegmentEventProfile& a, CircuitSegmentEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentEventProfile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentEventProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentEventProfile* New() const final {
    return CreateMaybeMessage<CircuitSegmentEventProfile>(nullptr);
  }

  CircuitSegmentEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentEventProfile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentEventProfile& from);
  void MergeFrom(const CircuitSegmentEventProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentEventProfile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentEventProfile";
  }
  protected:
  explicit CircuitSegmentEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kApplicationSystemFieldNumber = 2,
    kCircuitSegmentEventFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;
  public:
  void clear_eventmessageinfo();
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();

  // .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_applicationsystem() const;
  private:
  bool _internal_has_applicationsystem() const;
  public:
  void clear_applicationsystem();
  const ::commonmodule::ApplicationSystem& applicationsystem() const;
  ::commonmodule::ApplicationSystem* release_applicationsystem();
  ::commonmodule::ApplicationSystem* mutable_applicationsystem();
  void set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem);
  private:
  const ::commonmodule::ApplicationSystem& _internal_applicationsystem() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_applicationsystem();
  public:
  void unsafe_arena_set_allocated_applicationsystem(
      ::commonmodule::ApplicationSystem* applicationsystem);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_applicationsystem();

  // .circuitsegmentservicemodule.CircuitSegmentEvent circuitSegmentEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentevent() const;
  private:
  bool _internal_has_circuitsegmentevent() const;
  public:
  void clear_circuitsegmentevent();
  const ::circuitsegmentservicemodule::CircuitSegmentEvent& circuitsegmentevent() const;
  ::circuitsegmentservicemodule::CircuitSegmentEvent* release_circuitsegmentevent();
  ::circuitsegmentservicemodule::CircuitSegmentEvent* mutable_circuitsegmentevent();
  void set_allocated_circuitsegmentevent(::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentEvent& _internal_circuitsegmentevent() const;
  ::circuitsegmentservicemodule::CircuitSegmentEvent* _internal_mutable_circuitsegmentevent();
  public:
  void unsafe_arena_set_allocated_circuitsegmentevent(
      ::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent);
  ::circuitsegmentservicemodule::CircuitSegmentEvent* unsafe_arena_release_circuitsegmentevent();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::EventMessageInfo* eventmessageinfo_;
  ::commonmodule::ApplicationSystem* applicationsystem_;
  ::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentStatusDCSC PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentStatusDCSC) */ {
 public:
  inline CircuitSegmentStatusDCSC() : CircuitSegmentStatusDCSC(nullptr) {}
  virtual ~CircuitSegmentStatusDCSC();
  explicit constexpr CircuitSegmentStatusDCSC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentStatusDCSC(const CircuitSegmentStatusDCSC& from);
  CircuitSegmentStatusDCSC(CircuitSegmentStatusDCSC&& from) noexcept
    : CircuitSegmentStatusDCSC() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentStatusDCSC& operator=(const CircuitSegmentStatusDCSC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentStatusDCSC& operator=(CircuitSegmentStatusDCSC&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentStatusDCSC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentStatusDCSC* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentStatusDCSC*>(
               &_CircuitSegmentStatusDCSC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CircuitSegmentStatusDCSC& a, CircuitSegmentStatusDCSC& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentStatusDCSC* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentStatusDCSC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentStatusDCSC* New() const final {
    return CreateMaybeMessage<CircuitSegmentStatusDCSC>(nullptr);
  }

  CircuitSegmentStatusDCSC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentStatusDCSC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentStatusDCSC& from);
  void MergeFrom(const CircuitSegmentStatusDCSC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentStatusDCSC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentStatusDCSC";
  }
  protected:
  explicit CircuitSegmentStatusDCSC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kCircuitSegmentServiceModeFieldNumber = 2,
    kIslandFieldNumber = 3,
    kPermissibleAutoFieldNumber = 4,
    kPermissibleManualFieldNumber = 5,
    kPermissibleNetzeroFieldNumber = 6,
    kPermissibleStartFieldNumber = 7,
    kPermissibleStopFieldNumber = 8,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;
  public:
  void clear_logicalnode();
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();

  // .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
  bool has_circuitsegmentservicemode() const;
  private:
  bool _internal_has_circuitsegmentservicemode() const;
  public:
  void clear_circuitsegmentservicemode();
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* release_circuitsegmentservicemode();
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* mutable_circuitsegmentservicemode();
  void set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  private:
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& _internal_circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _internal_mutable_circuitsegmentservicemode();
  public:
  void unsafe_arena_set_allocated_circuitsegmentservicemode(
      ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* unsafe_arena_release_circuitsegmentservicemode();

  // .commonmodule.StatusDPS Island = 3;
  bool has_island() const;
  private:
  bool _internal_has_island() const;
  public:
  void clear_island();
  const ::commonmodule::StatusDPS& island() const;
  ::commonmodule::StatusDPS* release_island();
  ::commonmodule::StatusDPS* mutable_island();
  void set_allocated_island(::commonmodule::StatusDPS* island);
  private:
  const ::commonmodule::StatusDPS& _internal_island() const;
  ::commonmodule::StatusDPS* _internal_mutable_island();
  public:
  void unsafe_arena_set_allocated_island(
      ::commonmodule::StatusDPS* island);
  ::commonmodule::StatusDPS* unsafe_arena_release_island();

  // .commonmodule.StatusSPS PermissibleAuto = 4;
  bool has_permissibleauto() const;
  private:
  bool _internal_has_permissibleauto() const;
  public:
  void clear_permissibleauto();
  const ::commonmodule::StatusSPS& permissibleauto() const;
  ::commonmodule::StatusSPS* release_permissibleauto();
  ::commonmodule::StatusSPS* mutable_permissibleauto();
  void set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto);
  private:
  const ::commonmodule::StatusSPS& _internal_permissibleauto() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissibleauto();
  public:
  void unsafe_arena_set_allocated_permissibleauto(
      ::commonmodule::StatusSPS* permissibleauto);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissibleauto();

  // .commonmodule.StatusSPS PermissibleManual = 5;
  bool has_permissiblemanual() const;
  private:
  bool _internal_has_permissiblemanual() const;
  public:
  void clear_permissiblemanual();
  const ::commonmodule::StatusSPS& permissiblemanual() const;
  ::commonmodule::StatusSPS* release_permissiblemanual();
  ::commonmodule::StatusSPS* mutable_permissiblemanual();
  void set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblemanual() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblemanual();
  public:
  void unsafe_arena_set_allocated_permissiblemanual(
      ::commonmodule::StatusSPS* permissiblemanual);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblemanual();

  // .commonmodule.StatusSPS PermissibleNetzero = 6;
  bool has_permissiblenetzero() const;
  private:
  bool _internal_has_permissiblenetzero() const;
  public:
  void clear_permissiblenetzero();
  const ::commonmodule::StatusSPS& permissiblenetzero() const;
  ::commonmodule::StatusSPS* release_permissiblenetzero();
  ::commonmodule::StatusSPS* mutable_permissiblenetzero();
  void set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblenetzero() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblenetzero();
  public:
  void unsafe_arena_set_allocated_permissiblenetzero(
      ::commonmodule::StatusSPS* permissiblenetzero);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblenetzero();

  // .commonmodule.StatusSPS PermissibleStart = 7;
  bool has_permissiblestart() const;
  private:
  bool _internal_has_permissiblestart() const;
  public:
  void clear_permissiblestart();
  const ::commonmodule::StatusSPS& permissiblestart() const;
  ::commonmodule::StatusSPS* release_permissiblestart();
  ::commonmodule::StatusSPS* mutable_permissiblestart();
  void set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestart() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestart();
  public:
  void unsafe_arena_set_allocated_permissiblestart(
      ::commonmodule::StatusSPS* permissiblestart);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestart();

  // .commonmodule.StatusSPS PermissibleStop = 8;
  bool has_permissiblestop() const;
  private:
  bool _internal_has_permissiblestop() const;
  public:
  void clear_permissiblestop();
  const ::commonmodule::StatusSPS& permissiblestop() const;
  ::commonmodule::StatusSPS* release_permissiblestop();
  ::commonmodule::StatusSPS* mutable_permissiblestop();
  void set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestop() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestop();
  public:
  void unsafe_arena_set_allocated_permissiblestop(
      ::commonmodule::StatusSPS* permissiblestop);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestop();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentStatusDCSC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode_;
  ::commonmodule::StatusDPS* island_;
  ::commonmodule::StatusSPS* permissibleauto_;
  ::commonmodule::StatusSPS* permissiblemanual_;
  ::commonmodule::StatusSPS* permissiblenetzero_;
  ::commonmodule::StatusSPS* permissiblestart_;
  ::commonmodule::StatusSPS* permissiblestop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentStatus) */ {
 public:
  inline CircuitSegmentStatus() : CircuitSegmentStatus(nullptr) {}
  virtual ~CircuitSegmentStatus();
  explicit constexpr CircuitSegmentStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentStatus(const CircuitSegmentStatus& from);
  CircuitSegmentStatus(CircuitSegmentStatus&& from) noexcept
    : CircuitSegmentStatus() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentStatus& operator=(const CircuitSegmentStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentStatus& operator=(CircuitSegmentStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentStatus* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentStatus*>(
               &_CircuitSegmentStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CircuitSegmentStatus& a, CircuitSegmentStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentStatus* New() const final {
    return CreateMaybeMessage<CircuitSegmentStatus>(nullptr);
  }

  CircuitSegmentStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentStatus& from);
  void MergeFrom(const CircuitSegmentStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentStatus";
  }
  protected:
  explicit CircuitSegmentStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kCircuitSegmentStatusDCSCFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;
  public:
  void clear_identifiedobject();
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();

  // .circuitsegmentservicemodule.CircuitSegmentStatusDCSC circuitSegmentStatusDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentstatusdcsc() const;
  private:
  bool _internal_has_circuitsegmentstatusdcsc() const;
  public:
  void clear_circuitsegmentstatusdcsc();
  const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& circuitsegmentstatusdcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* release_circuitsegmentstatusdcsc();
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* mutable_circuitsegmentstatusdcsc();
  void set_allocated_circuitsegmentstatusdcsc(::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& _internal_circuitsegmentstatusdcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* _internal_mutable_circuitsegmentstatusdcsc();
  public:
  void unsafe_arena_set_allocated_circuitsegmentstatusdcsc(
      ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc);
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* unsafe_arena_release_circuitsegmentstatusdcsc();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// -------------------------------------------------------------------

class CircuitSegmentStatusProfile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentStatusProfile) */ {
 public:
  inline CircuitSegmentStatusProfile() : CircuitSegmentStatusProfile(nullptr) {}
  virtual ~CircuitSegmentStatusProfile();
  explicit constexpr CircuitSegmentStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentStatusProfile(const CircuitSegmentStatusProfile& from);
  CircuitSegmentStatusProfile(CircuitSegmentStatusProfile&& from) noexcept
    : CircuitSegmentStatusProfile() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentStatusProfile& operator=(const CircuitSegmentStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentStatusProfile& operator=(CircuitSegmentStatusProfile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitSegmentStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentStatusProfile* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentStatusProfile*>(
               &_CircuitSegmentStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CircuitSegmentStatusProfile& a, CircuitSegmentStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentStatusProfile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentStatusProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitSegmentStatusProfile* New() const final {
    return CreateMaybeMessage<CircuitSegmentStatusProfile>(nullptr);
  }

  CircuitSegmentStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitSegmentStatusProfile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitSegmentStatusProfile& from);
  void MergeFrom(const CircuitSegmentStatusProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentStatusProfile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentStatusProfile";
  }
  protected:
  explicit CircuitSegmentStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kApplicationSystemFieldNumber = 2,
    kCircuitSegmentStatusFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;
  public:
  void clear_eventmessageinfo();
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();

  // .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_applicationsystem() const;
  private:
  bool _internal_has_applicationsystem() const;
  public:
  void clear_applicationsystem();
  const ::commonmodule::ApplicationSystem& applicationsystem() const;
  ::commonmodule::ApplicationSystem* release_applicationsystem();
  ::commonmodule::ApplicationSystem* mutable_applicationsystem();
  void set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem);
  private:
  const ::commonmodule::ApplicationSystem& _internal_applicationsystem() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_applicationsystem();
  public:
  void unsafe_arena_set_allocated_applicationsystem(
      ::commonmodule::ApplicationSystem* applicationsystem);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_applicationsystem();

  // .circuitsegmentservicemodule.CircuitSegmentStatus circuitSegmentStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentstatus() const;
  private:
  bool _internal_has_circuitsegmentstatus() const;
  public:
  void clear_circuitsegmentstatus();
  const ::circuitsegmentservicemodule::CircuitSegmentStatus& circuitsegmentstatus() const;
  ::circuitsegmentservicemodule::CircuitSegmentStatus* release_circuitsegmentstatus();
  ::circuitsegmentservicemodule::CircuitSegmentStatus* mutable_circuitsegmentstatus();
  void set_allocated_circuitsegmentstatus(::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentStatus& _internal_circuitsegmentstatus() const;
  ::circuitsegmentservicemodule::CircuitSegmentStatus* _internal_mutable_circuitsegmentstatus();
  public:
  void unsafe_arena_set_allocated_circuitsegmentstatus(
      ::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus);
  ::circuitsegmentservicemodule::CircuitSegmentStatus* unsafe_arena_release_circuitsegmentstatus();

  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commonmodule::EventMessageInfo* eventmessageinfo_;
  ::commonmodule::ApplicationSystem* applicationsystem_;
  ::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Optional_CircuitSegmentServiceModeKind

// .circuitsegmentservicemodule.CircuitSegmentServiceModeKind value = 1;
inline void Optional_CircuitSegmentServiceModeKind::clear_value() {
  value_ = 0;
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind Optional_CircuitSegmentServiceModeKind::_internal_value() const {
  return static_cast< ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind >(value_);
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind Optional_CircuitSegmentServiceModeKind::value() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind.value)
  return _internal_value();
}
inline void Optional_CircuitSegmentServiceModeKind::_internal_set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
  
  value_ = value;
}
inline void Optional_CircuitSegmentServiceModeKind::set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind.value)
}

// -------------------------------------------------------------------

// ENG_CircuitSegmentServiceModeKind

// .circuitsegmentservicemodule.CircuitSegmentServiceModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_CircuitSegmentServiceModeKind::clear_setval() {
  setval_ = 0;
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind ENG_CircuitSegmentServiceModeKind::_internal_setval() const {
  return static_cast< ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind >(setval_);
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind ENG_CircuitSegmentServiceModeKind::setval() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setVal)
  return _internal_setval();
}
inline void ENG_CircuitSegmentServiceModeKind::_internal_set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
  
  setval_ = value;
}
inline void ENG_CircuitSegmentServiceModeKind::set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
  _internal_set_setval(value);
  // @@protoc_insertion_point(field_set:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setVal)
}

// .google.protobuf.StringValue setValExtension = 2;
inline bool ENG_CircuitSegmentServiceModeKind::_internal_has_setvalextension() const {
  return this != internal_default_instance() && setvalextension_ != nullptr;
}
inline bool ENG_CircuitSegmentServiceModeKind::has_setvalextension() const {
  return _internal_has_setvalextension();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& ENG_CircuitSegmentServiceModeKind::_internal_setvalextension() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = setvalextension_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& ENG_CircuitSegmentServiceModeKind::setvalextension() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
  return _internal_setvalextension();
}
inline void ENG_CircuitSegmentServiceModeKind::unsafe_arena_set_allocated_setvalextension(
    PROTOBUF_NAMESPACE_ID::StringValue* setvalextension) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setvalextension_);
  }
  setvalextension_ = setvalextension;
  if (setvalextension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::release_setvalextension() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = setvalextension_;
  setvalextension_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::unsafe_arena_release_setvalextension() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = setvalextension_;
  setvalextension_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::_internal_mutable_setvalextension() {
  
  if (setvalextension_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    setvalextension_ = p;
  }
  return setvalextension_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::mutable_setvalextension() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
  return _internal_mutable_setvalextension();
}
inline void ENG_CircuitSegmentServiceModeKind::set_allocated_setvalextension(PROTOBUF_NAMESPACE_ID::StringValue* setvalextension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(setvalextension_);
  }
  if (setvalextension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setvalextension)->GetArena();
    if (message_arena != submessage_arena) {
      setvalextension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setvalextension, submessage_arena);
    }
    
  } else {
    
  }
  setvalextension_ = setvalextension;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
}

// -------------------------------------------------------------------

// CircuitSegmentControlDCSC

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentControlDCSC::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && logicalnodeforcontrol_ != nullptr;
}
inline bool CircuitSegmentControlDCSC::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline const ::commonmodule::LogicalNodeForControl& CircuitSegmentControlDCSC::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& CircuitSegmentControlDCSC::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void CircuitSegmentControlDCSC::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol_);
  }
  logicalnodeforcontrol_ = logicalnodeforcontrol;
  if (logicalnodeforcontrol) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = logicalnodeforcontrol_;
  logicalnodeforcontrol_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = logicalnodeforcontrol_;
  logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::_internal_mutable_logicalnodeforcontrol() {
  
  if (logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArena());
    logicalnodeforcontrol_ = p;
  }
  return logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::mutable_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
  return _internal_mutable_logicalnodeforcontrol();
}
inline void CircuitSegmentControlDCSC::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol)->GetArena();
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
}

// .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
inline bool CircuitSegmentControlDCSC::_internal_has_circuitsegmentservicemode() const {
  return this != internal_default_instance() && circuitsegmentservicemode_ != nullptr;
}
inline bool CircuitSegmentControlDCSC::has_circuitsegmentservicemode() const {
  return _internal_has_circuitsegmentservicemode();
}
inline void CircuitSegmentControlDCSC::clear_circuitsegmentservicemode() {
  if (GetArena() == nullptr && circuitsegmentservicemode_ != nullptr) {
    delete circuitsegmentservicemode_;
  }
  circuitsegmentservicemode_ = nullptr;
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentControlDCSC::_internal_circuitsegmentservicemode() const {
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* p = circuitsegmentservicemode_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind&>(
      ::circuitsegmentservicemodule::_ENG_CircuitSegmentServiceModeKind_default_instance_);
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentControlDCSC::circuitsegmentservicemode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
  return _internal_circuitsegmentservicemode();
}
inline void CircuitSegmentControlDCSC::unsafe_arena_set_allocated_circuitsegmentservicemode(
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentservicemode_);
  }
  circuitsegmentservicemode_ = circuitsegmentservicemode;
  if (circuitsegmentservicemode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::release_circuitsegmentservicemode() {
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = circuitsegmentservicemode_;
  circuitsegmentservicemode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::unsafe_arena_release_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = circuitsegmentservicemode_;
  circuitsegmentservicemode_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::_internal_mutable_circuitsegmentservicemode() {
  
  if (circuitsegmentservicemode_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(GetArena());
    circuitsegmentservicemode_ = p;
  }
  return circuitsegmentservicemode_;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::mutable_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
  return _internal_mutable_circuitsegmentservicemode();
}
inline void CircuitSegmentControlDCSC::set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentservicemode_;
  }
  if (circuitsegmentservicemode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentservicemode);
    if (message_arena != submessage_arena) {
      circuitsegmentservicemode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentservicemode, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
}

// .commonmodule.ControlDPC Island = 3;
inline bool CircuitSegmentControlDCSC::_internal_has_island() const {
  return this != internal_default_instance() && island_ != nullptr;
}
inline bool CircuitSegmentControlDCSC::has_island() const {
  return _internal_has_island();
}
inline const ::commonmodule::ControlDPC& CircuitSegmentControlDCSC::_internal_island() const {
  const ::commonmodule::ControlDPC* p = island_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlDPC&>(
      ::commonmodule::_ControlDPC_default_instance_);
}
inline const ::commonmodule::ControlDPC& CircuitSegmentControlDCSC::island() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
  return _internal_island();
}
inline void CircuitSegmentControlDCSC::unsafe_arena_set_allocated_island(
    ::commonmodule::ControlDPC* island) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island_);
  }
  island_ = island;
  if (island) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::release_island() {
  
  ::commonmodule::ControlDPC* temp = island_;
  island_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::unsafe_arena_release_island() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
  
  ::commonmodule::ControlDPC* temp = island_;
  island_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::_internal_mutable_island() {
  
  if (island_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArena());
    island_ = p;
  }
  return island_;
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::mutable_island() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
  return _internal_mutable_island();
}
inline void CircuitSegmentControlDCSC::set_allocated_island(::commonmodule::ControlDPC* island) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(island_);
  }
  if (island) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island)->GetArena();
    if (message_arena != submessage_arena) {
      island = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, island, submessage_arena);
    }
    
  } else {
    
  }
  island_ = island;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
}

// -------------------------------------------------------------------

// CircuitSegmentControl

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentControl::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline bool CircuitSegmentControl::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentControl::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentControl::identifiedobject() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
  return _internal_identifiedobject();
}
inline void CircuitSegmentControl::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject_);
  }
  identifiedobject_ = identifiedobject;
  if (identifiedobject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::_internal_mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArena());
    identifiedobject_ = p;
  }
  return identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::mutable_identifiedobject() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
  return _internal_mutable_identifiedobject();
}
inline void CircuitSegmentControl::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject)->GetArena();
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
}

// .commonmodule.CheckConditions check = 2;
inline bool CircuitSegmentControl::_internal_has_check() const {
  return this != internal_default_instance() && check_ != nullptr;
}
inline bool CircuitSegmentControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& CircuitSegmentControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& CircuitSegmentControl::check() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControl.check)
  return _internal_check();
}
inline void CircuitSegmentControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check_);
  }
  check_ = check;
  if (check) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.check)
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControl.check)
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::_internal_mutable_check() {
  
  if (check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArena());
    check_ = p;
  }
  return check_;
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::mutable_check() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControl.check)
  return _internal_mutable_check();
}
inline void CircuitSegmentControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check)->GetArena();
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.check)
}

// .circuitsegmentservicemodule.CircuitSegmentControlDCSC circuitSegmentControlDCSC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentControl::_internal_has_circuitsegmentcontroldcsc() const {
  return this != internal_default_instance() && circuitsegmentcontroldcsc_ != nullptr;
}
inline bool CircuitSegmentControl::has_circuitsegmentcontroldcsc() const {
  return _internal_has_circuitsegmentcontroldcsc();
}
inline void CircuitSegmentControl::clear_circuitsegmentcontroldcsc() {
  if (GetArena() == nullptr && circuitsegmentcontroldcsc_ != nullptr) {
    delete circuitsegmentcontroldcsc_;
  }
  circuitsegmentcontroldcsc_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& CircuitSegmentControl::_internal_circuitsegmentcontroldcsc() const {
  const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* p = circuitsegmentcontroldcsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC&>(
      ::circuitsegmentservicemodule::_CircuitSegmentControlDCSC_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& CircuitSegmentControl::circuitsegmentcontroldcsc() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
  return _internal_circuitsegmentcontroldcsc();
}
inline void CircuitSegmentControl::unsafe_arena_set_allocated_circuitsegmentcontroldcsc(
    ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentcontroldcsc_);
  }
  circuitsegmentcontroldcsc_ = circuitsegmentcontroldcsc;
  if (circuitsegmentcontroldcsc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::release_circuitsegmentcontroldcsc() {
  
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* temp = circuitsegmentcontroldcsc_;
  circuitsegmentcontroldcsc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::unsafe_arena_release_circuitsegmentcontroldcsc() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
  
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* temp = circuitsegmentcontroldcsc_;
  circuitsegmentcontroldcsc_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::_internal_mutable_circuitsegmentcontroldcsc() {
  
  if (circuitsegmentcontroldcsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControlDCSC>(GetArena());
    circuitsegmentcontroldcsc_ = p;
  }
  return circuitsegmentcontroldcsc_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::mutable_circuitsegmentcontroldcsc() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
  return _internal_mutable_circuitsegmentcontroldcsc();
}
inline void CircuitSegmentControl::set_allocated_circuitsegmentcontroldcsc(::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentcontroldcsc_;
  }
  if (circuitsegmentcontroldcsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentcontroldcsc);
    if (message_arena != submessage_arena) {
      circuitsegmentcontroldcsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentcontroldcsc, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentcontroldcsc_ = circuitsegmentcontroldcsc;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
}

// -------------------------------------------------------------------

// CircuitSegmentControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && controlmessageinfo_ != nullptr;
}
inline bool CircuitSegmentControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& CircuitSegmentControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& CircuitSegmentControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void CircuitSegmentControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo_);
  }
  controlmessageinfo_ = controlmessageinfo;
  if (controlmessageinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArena());
    controlmessageinfo_ = p;
  }
  return controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::mutable_controlmessageinfo() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
  return _internal_mutable_controlmessageinfo();
}
inline void CircuitSegmentControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo)->GetArena();
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
}

// .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentControlProfile::_internal_has_applicationsystem() const {
  return this != internal_default_instance() && applicationsystem_ != nullptr;
}
inline bool CircuitSegmentControlProfile::has_applicationsystem() const {
  return _internal_has_applicationsystem();
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentControlProfile::_internal_applicationsystem() const {
  const ::commonmodule::ApplicationSystem* p = applicationsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentControlProfile::applicationsystem() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
  return _internal_applicationsystem();
}
inline void CircuitSegmentControlProfile::unsafe_arena_set_allocated_applicationsystem(
    ::commonmodule::ApplicationSystem* applicationsystem) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem_);
  }
  applicationsystem_ = applicationsystem;
  if (applicationsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::release_applicationsystem() {
  
  ::commonmodule::ApplicationSystem* temp = applicationsystem_;
  applicationsystem_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::unsafe_arena_release_applicationsystem() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
  
  ::commonmodule::ApplicationSystem* temp = applicationsystem_;
  applicationsystem_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::_internal_mutable_applicationsystem() {
  
  if (applicationsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArena());
    applicationsystem_ = p;
  }
  return applicationsystem_;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::mutable_applicationsystem() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
  return _internal_mutable_applicationsystem();
}
inline void CircuitSegmentControlProfile::set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem_);
  }
  if (applicationsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem)->GetArena();
    if (message_arena != submessage_arena) {
      applicationsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applicationsystem, submessage_arena);
    }
    
  } else {
    
  }
  applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
}

// .circuitsegmentservicemodule.CircuitSegmentControl circuitSegmentControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentControlProfile::_internal_has_circuitsegmentcontrol() const {
  return this != internal_default_instance() && circuitsegmentcontrol_ != nullptr;
}
inline bool CircuitSegmentControlProfile::has_circuitsegmentcontrol() const {
  return _internal_has_circuitsegmentcontrol();
}
inline void CircuitSegmentControlProfile::clear_circuitsegmentcontrol() {
  if (GetArena() == nullptr && circuitsegmentcontrol_ != nullptr) {
    delete circuitsegmentcontrol_;
  }
  circuitsegmentcontrol_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControl& CircuitSegmentControlProfile::_internal_circuitsegmentcontrol() const {
  const ::circuitsegmentservicemodule::CircuitSegmentControl* p = circuitsegmentcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentControl&>(
      ::circuitsegmentservicemodule::_CircuitSegmentControl_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControl& CircuitSegmentControlProfile::circuitsegmentcontrol() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
  return _internal_circuitsegmentcontrol();
}
inline void CircuitSegmentControlProfile::unsafe_arena_set_allocated_circuitsegmentcontrol(
    ::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentcontrol_);
  }
  circuitsegmentcontrol_ = circuitsegmentcontrol;
  if (circuitsegmentcontrol) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::release_circuitsegmentcontrol() {
  
  ::circuitsegmentservicemodule::CircuitSegmentControl* temp = circuitsegmentcontrol_;
  circuitsegmentcontrol_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::unsafe_arena_release_circuitsegmentcontrol() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
  
  ::circuitsegmentservicemodule::CircuitSegmentControl* temp = circuitsegmentcontrol_;
  circuitsegmentcontrol_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::_internal_mutable_circuitsegmentcontrol() {
  
  if (circuitsegmentcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControl>(GetArena());
    circuitsegmentcontrol_ = p;
  }
  return circuitsegmentcontrol_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::mutable_circuitsegmentcontrol() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
  return _internal_mutable_circuitsegmentcontrol();
}
inline void CircuitSegmentControlProfile::set_allocated_circuitsegmentcontrol(::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentcontrol_;
  }
  if (circuitsegmentcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentcontrol);
    if (message_arena != submessage_arena) {
      circuitsegmentcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentcontrol, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentcontrol_ = circuitsegmentcontrol;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
}

// -------------------------------------------------------------------

// CircuitSegmentEventDCSC

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentEventDCSC::_internal_has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline const ::commonmodule::LogicalNode& CircuitSegmentEventDCSC::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CircuitSegmentEventDCSC::logicalnode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
  return _internal_logicalnode();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode_);
  }
  logicalnode_ = logicalnode;
  if (logicalnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::_internal_mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArena());
    logicalnode_ = p;
  }
  return logicalnode_;
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::mutable_logicalnode() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
  return _internal_mutable_logicalnode();
}
inline void CircuitSegmentEventDCSC::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode_);
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode)->GetArena();
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
}

// .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
inline bool CircuitSegmentEventDCSC::_internal_has_circuitsegmentservicemode() const {
  return this != internal_default_instance() && circuitsegmentservicemode_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_circuitsegmentservicemode() const {
  return _internal_has_circuitsegmentservicemode();
}
inline void CircuitSegmentEventDCSC::clear_circuitsegmentservicemode() {
  if (GetArena() == nullptr && circuitsegmentservicemode_ != nullptr) {
    delete circuitsegmentservicemode_;
  }
  circuitsegmentservicemode_ = nullptr;
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentEventDCSC::_internal_circuitsegmentservicemode() const {
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* p = circuitsegmentservicemode_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind&>(
      ::circuitsegmentservicemodule::_ENG_CircuitSegmentServiceModeKind_default_instance_);
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentEventDCSC::circuitsegmentservicemode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
  return _internal_circuitsegmentservicemode();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_circuitsegmentservicemode(
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentservicemode_);
  }
  circuitsegmentservicemode_ = circuitsegmentservicemode;
  if (circuitsegmentservicemode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::release_circuitsegmentservicemode() {
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = circuitsegmentservicemode_;
  circuitsegmentservicemode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::unsafe_arena_release_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = circuitsegmentservicemode_;
  circuitsegmentservicemode_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::_internal_mutable_circuitsegmentservicemode() {
  
  if (circuitsegmentservicemode_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(GetArena());
    circuitsegmentservicemode_ = p;
  }
  return circuitsegmentservicemode_;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::mutable_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
  return _internal_mutable_circuitsegmentservicemode();
}
inline void CircuitSegmentEventDCSC::set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentservicemode_;
  }
  if (circuitsegmentservicemode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentservicemode);
    if (message_arena != submessage_arena) {
      circuitsegmentservicemode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentservicemode, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
}

// .commonmodule.StatusSPS Island = 3;
inline bool CircuitSegmentEventDCSC::_internal_has_island() const {
  return this != internal_default_instance() && island_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_island() const {
  return _internal_has_island();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_island() const {
  const ::commonmodule::StatusSPS* p = island_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::island() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
  return _internal_island();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_island(
    ::commonmodule::StatusSPS* island) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island_);
  }
  island_ = island;
  if (island) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_island() {
  
  ::commonmodule::StatusSPS* temp = island_;
  island_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_island() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
  
  ::commonmodule::StatusSPS* temp = island_;
  island_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_island() {
  
  if (island_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    island_ = p;
  }
  return island_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_island() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
  return _internal_mutable_island();
}
inline void CircuitSegmentEventDCSC::set_allocated_island(::commonmodule::StatusSPS* island) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(island_);
  }
  if (island) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island)->GetArena();
    if (message_arena != submessage_arena) {
      island = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, island, submessage_arena);
    }
    
  } else {
    
  }
  island_ = island;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
}

// .commonmodule.StatusSPS PermissibleAuto = 4;
inline bool CircuitSegmentEventDCSC::_internal_has_permissibleauto() const {
  return this != internal_default_instance() && permissibleauto_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissibleauto() const {
  return _internal_has_permissibleauto();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissibleauto() const {
  const ::commonmodule::StatusSPS* p = permissibleauto_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissibleauto() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
  return _internal_permissibleauto();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissibleauto(
    ::commonmodule::StatusSPS* permissibleauto) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto_);
  }
  permissibleauto_ = permissibleauto;
  if (permissibleauto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissibleauto() {
  
  ::commonmodule::StatusSPS* temp = permissibleauto_;
  permissibleauto_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissibleauto() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
  
  ::commonmodule::StatusSPS* temp = permissibleauto_;
  permissibleauto_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissibleauto() {
  
  if (permissibleauto_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissibleauto_ = p;
  }
  return permissibleauto_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissibleauto() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
  return _internal_mutable_permissibleauto();
}
inline void CircuitSegmentEventDCSC::set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto_);
  }
  if (permissibleauto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto)->GetArena();
    if (message_arena != submessage_arena) {
      permissibleauto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissibleauto, submessage_arena);
    }
    
  } else {
    
  }
  permissibleauto_ = permissibleauto;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
}

// .commonmodule.StatusSPS PermissibleManual = 5;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblemanual() const {
  return this != internal_default_instance() && permissiblemanual_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblemanual() const {
  return _internal_has_permissiblemanual();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblemanual() const {
  const ::commonmodule::StatusSPS* p = permissiblemanual_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblemanual() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
  return _internal_permissiblemanual();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblemanual(
    ::commonmodule::StatusSPS* permissiblemanual) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual_);
  }
  permissiblemanual_ = permissiblemanual;
  if (permissiblemanual) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblemanual() {
  
  ::commonmodule::StatusSPS* temp = permissiblemanual_;
  permissiblemanual_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblemanual() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
  
  ::commonmodule::StatusSPS* temp = permissiblemanual_;
  permissiblemanual_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblemanual() {
  
  if (permissiblemanual_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblemanual_ = p;
  }
  return permissiblemanual_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblemanual() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
  return _internal_mutable_permissiblemanual();
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual_);
  }
  if (permissiblemanual) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblemanual = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblemanual, submessage_arena);
    }
    
  } else {
    
  }
  permissiblemanual_ = permissiblemanual;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
}

// .commonmodule.StatusSPS PermissibleNetzero = 6;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblenetzero() const {
  return this != internal_default_instance() && permissiblenetzero_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblenetzero() const {
  return _internal_has_permissiblenetzero();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblenetzero() const {
  const ::commonmodule::StatusSPS* p = permissiblenetzero_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblenetzero() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
  return _internal_permissiblenetzero();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblenetzero(
    ::commonmodule::StatusSPS* permissiblenetzero) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero_);
  }
  permissiblenetzero_ = permissiblenetzero;
  if (permissiblenetzero) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblenetzero() {
  
  ::commonmodule::StatusSPS* temp = permissiblenetzero_;
  permissiblenetzero_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblenetzero() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
  
  ::commonmodule::StatusSPS* temp = permissiblenetzero_;
  permissiblenetzero_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblenetzero() {
  
  if (permissiblenetzero_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblenetzero_ = p;
  }
  return permissiblenetzero_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblenetzero() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
  return _internal_mutable_permissiblenetzero();
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero_);
  }
  if (permissiblenetzero) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblenetzero = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblenetzero, submessage_arena);
    }
    
  } else {
    
  }
  permissiblenetzero_ = permissiblenetzero;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
}

// .commonmodule.StatusSPS PermissibleStart = 7;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblestart() const {
  return this != internal_default_instance() && permissiblestart_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblestart() const {
  return _internal_has_permissiblestart();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblestart() const {
  const ::commonmodule::StatusSPS* p = permissiblestart_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblestart() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
  return _internal_permissiblestart();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblestart(
    ::commonmodule::StatusSPS* permissiblestart) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart_);
  }
  permissiblestart_ = permissiblestart;
  if (permissiblestart) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblestart() {
  
  ::commonmodule::StatusSPS* temp = permissiblestart_;
  permissiblestart_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblestart() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
  
  ::commonmodule::StatusSPS* temp = permissiblestart_;
  permissiblestart_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblestart() {
  
  if (permissiblestart_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblestart_ = p;
  }
  return permissiblestart_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblestart() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
  return _internal_mutable_permissiblestart();
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart_);
  }
  if (permissiblestart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblestart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestart, submessage_arena);
    }
    
  } else {
    
  }
  permissiblestart_ = permissiblestart;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
}

// .commonmodule.StatusSPS PermissibleStop = 8;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblestop() const {
  return this != internal_default_instance() && permissiblestop_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblestop() const {
  return _internal_has_permissiblestop();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblestop() const {
  const ::commonmodule::StatusSPS* p = permissiblestop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblestop() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
  return _internal_permissiblestop();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblestop(
    ::commonmodule::StatusSPS* permissiblestop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop_);
  }
  permissiblestop_ = permissiblestop;
  if (permissiblestop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblestop() {
  
  ::commonmodule::StatusSPS* temp = permissiblestop_;
  permissiblestop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblestop() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
  
  ::commonmodule::StatusSPS* temp = permissiblestop_;
  permissiblestop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblestop() {
  
  if (permissiblestop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblestop_ = p;
  }
  return permissiblestop_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblestop() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
  return _internal_mutable_permissiblestop();
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop_);
  }
  if (permissiblestop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblestop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestop, submessage_arena);
    }
    
  } else {
    
  }
  permissiblestop_ = permissiblestop;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
}

// -------------------------------------------------------------------

// CircuitSegmentEvent

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentEvent::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline bool CircuitSegmentEvent::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentEvent::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentEvent::identifiedobject() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
  return _internal_identifiedobject();
}
inline void CircuitSegmentEvent::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject_);
  }
  identifiedobject_ = identifiedobject;
  if (identifiedobject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::_internal_mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArena());
    identifiedobject_ = p;
  }
  return identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::mutable_identifiedobject() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
  return _internal_mutable_identifiedobject();
}
inline void CircuitSegmentEvent::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject)->GetArena();
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
}

// .circuitsegmentservicemodule.CircuitSegmentEventDCSC circuitSegmentEventDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentEvent::_internal_has_circuitsegmenteventdcsc() const {
  return this != internal_default_instance() && circuitsegmenteventdcsc_ != nullptr;
}
inline bool CircuitSegmentEvent::has_circuitsegmenteventdcsc() const {
  return _internal_has_circuitsegmenteventdcsc();
}
inline void CircuitSegmentEvent::clear_circuitsegmenteventdcsc() {
  if (GetArena() == nullptr && circuitsegmenteventdcsc_ != nullptr) {
    delete circuitsegmenteventdcsc_;
  }
  circuitsegmenteventdcsc_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& CircuitSegmentEvent::_internal_circuitsegmenteventdcsc() const {
  const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* p = circuitsegmenteventdcsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC&>(
      ::circuitsegmentservicemodule::_CircuitSegmentEventDCSC_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& CircuitSegmentEvent::circuitsegmenteventdcsc() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
  return _internal_circuitsegmenteventdcsc();
}
inline void CircuitSegmentEvent::unsafe_arena_set_allocated_circuitsegmenteventdcsc(
    ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmenteventdcsc_);
  }
  circuitsegmenteventdcsc_ = circuitsegmenteventdcsc;
  if (circuitsegmenteventdcsc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::release_circuitsegmenteventdcsc() {
  
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* temp = circuitsegmenteventdcsc_;
  circuitsegmenteventdcsc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::unsafe_arena_release_circuitsegmenteventdcsc() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
  
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* temp = circuitsegmenteventdcsc_;
  circuitsegmenteventdcsc_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::_internal_mutable_circuitsegmenteventdcsc() {
  
  if (circuitsegmenteventdcsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEventDCSC>(GetArena());
    circuitsegmenteventdcsc_ = p;
  }
  return circuitsegmenteventdcsc_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::mutable_circuitsegmenteventdcsc() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
  return _internal_mutable_circuitsegmenteventdcsc();
}
inline void CircuitSegmentEvent::set_allocated_circuitsegmenteventdcsc(::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmenteventdcsc_;
  }
  if (circuitsegmenteventdcsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmenteventdcsc);
    if (message_arena != submessage_arena) {
      circuitsegmenteventdcsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmenteventdcsc, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmenteventdcsc_ = circuitsegmenteventdcsc;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
}

// -------------------------------------------------------------------

// CircuitSegmentEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && eventmessageinfo_ != nullptr;
}
inline bool CircuitSegmentEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& CircuitSegmentEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& CircuitSegmentEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void CircuitSegmentEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo_);
  }
  eventmessageinfo_ = eventmessageinfo;
  if (eventmessageinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArena());
    eventmessageinfo_ = p;
  }
  return eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::mutable_eventmessageinfo() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
  return _internal_mutable_eventmessageinfo();
}
inline void CircuitSegmentEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo)->GetArena();
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
}

// .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentEventProfile::_internal_has_applicationsystem() const {
  return this != internal_default_instance() && applicationsystem_ != nullptr;
}
inline bool CircuitSegmentEventProfile::has_applicationsystem() const {
  return _internal_has_applicationsystem();
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentEventProfile::_internal_applicationsystem() const {
  const ::commonmodule::ApplicationSystem* p = applicationsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentEventProfile::applicationsystem() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
  return _internal_applicationsystem();
}
inline void CircuitSegmentEventProfile::unsafe_arena_set_allocated_applicationsystem(
    ::commonmodule::ApplicationSystem* applicationsystem) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem_);
  }
  applicationsystem_ = applicationsystem;
  if (applicationsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::release_applicationsystem() {
  
  ::commonmodule::ApplicationSystem* temp = applicationsystem_;
  applicationsystem_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::unsafe_arena_release_applicationsystem() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
  
  ::commonmodule::ApplicationSystem* temp = applicationsystem_;
  applicationsystem_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::_internal_mutable_applicationsystem() {
  
  if (applicationsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArena());
    applicationsystem_ = p;
  }
  return applicationsystem_;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::mutable_applicationsystem() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
  return _internal_mutable_applicationsystem();
}
inline void CircuitSegmentEventProfile::set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem_);
  }
  if (applicationsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem)->GetArena();
    if (message_arena != submessage_arena) {
      applicationsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applicationsystem, submessage_arena);
    }
    
  } else {
    
  }
  applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
}

// .circuitsegmentservicemodule.CircuitSegmentEvent circuitSegmentEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentEventProfile::_internal_has_circuitsegmentevent() const {
  return this != internal_default_instance() && circuitsegmentevent_ != nullptr;
}
inline bool CircuitSegmentEventProfile::has_circuitsegmentevent() const {
  return _internal_has_circuitsegmentevent();
}
inline void CircuitSegmentEventProfile::clear_circuitsegmentevent() {
  if (GetArena() == nullptr && circuitsegmentevent_ != nullptr) {
    delete circuitsegmentevent_;
  }
  circuitsegmentevent_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEvent& CircuitSegmentEventProfile::_internal_circuitsegmentevent() const {
  const ::circuitsegmentservicemodule::CircuitSegmentEvent* p = circuitsegmentevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentEvent&>(
      ::circuitsegmentservicemodule::_CircuitSegmentEvent_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEvent& CircuitSegmentEventProfile::circuitsegmentevent() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
  return _internal_circuitsegmentevent();
}
inline void CircuitSegmentEventProfile::unsafe_arena_set_allocated_circuitsegmentevent(
    ::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentevent_);
  }
  circuitsegmentevent_ = circuitsegmentevent;
  if (circuitsegmentevent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::release_circuitsegmentevent() {
  
  ::circuitsegmentservicemodule::CircuitSegmentEvent* temp = circuitsegmentevent_;
  circuitsegmentevent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::unsafe_arena_release_circuitsegmentevent() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
  
  ::circuitsegmentservicemodule::CircuitSegmentEvent* temp = circuitsegmentevent_;
  circuitsegmentevent_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::_internal_mutable_circuitsegmentevent() {
  
  if (circuitsegmentevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEvent>(GetArena());
    circuitsegmentevent_ = p;
  }
  return circuitsegmentevent_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::mutable_circuitsegmentevent() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
  return _internal_mutable_circuitsegmentevent();
}
inline void CircuitSegmentEventProfile::set_allocated_circuitsegmentevent(::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentevent_;
  }
  if (circuitsegmentevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentevent);
    if (message_arena != submessage_arena) {
      circuitsegmentevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentevent, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentevent_ = circuitsegmentevent;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
}

// -------------------------------------------------------------------

// CircuitSegmentStatusDCSC

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentStatusDCSC::_internal_has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline const ::commonmodule::LogicalNode& CircuitSegmentStatusDCSC::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CircuitSegmentStatusDCSC::logicalnode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
  return _internal_logicalnode();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode_);
  }
  logicalnode_ = logicalnode;
  if (logicalnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::_internal_mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArena());
    logicalnode_ = p;
  }
  return logicalnode_;
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::mutable_logicalnode() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
  return _internal_mutable_logicalnode();
}
inline void CircuitSegmentStatusDCSC::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode_);
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode)->GetArena();
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
}

// .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
inline bool CircuitSegmentStatusDCSC::_internal_has_circuitsegmentservicemode() const {
  return this != internal_default_instance() && circuitsegmentservicemode_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_circuitsegmentservicemode() const {
  return _internal_has_circuitsegmentservicemode();
}
inline void CircuitSegmentStatusDCSC::clear_circuitsegmentservicemode() {
  if (GetArena() == nullptr && circuitsegmentservicemode_ != nullptr) {
    delete circuitsegmentservicemode_;
  }
  circuitsegmentservicemode_ = nullptr;
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentStatusDCSC::_internal_circuitsegmentservicemode() const {
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* p = circuitsegmentservicemode_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind&>(
      ::circuitsegmentservicemodule::_ENG_CircuitSegmentServiceModeKind_default_instance_);
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentStatusDCSC::circuitsegmentservicemode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
  return _internal_circuitsegmentservicemode();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_circuitsegmentservicemode(
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentservicemode_);
  }
  circuitsegmentservicemode_ = circuitsegmentservicemode;
  if (circuitsegmentservicemode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::release_circuitsegmentservicemode() {
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = circuitsegmentservicemode_;
  circuitsegmentservicemode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::unsafe_arena_release_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = circuitsegmentservicemode_;
  circuitsegmentservicemode_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::_internal_mutable_circuitsegmentservicemode() {
  
  if (circuitsegmentservicemode_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(GetArena());
    circuitsegmentservicemode_ = p;
  }
  return circuitsegmentservicemode_;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::mutable_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
  return _internal_mutable_circuitsegmentservicemode();
}
inline void CircuitSegmentStatusDCSC::set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentservicemode_;
  }
  if (circuitsegmentservicemode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentservicemode);
    if (message_arena != submessage_arena) {
      circuitsegmentservicemode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentservicemode, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
}

// .commonmodule.StatusDPS Island = 3;
inline bool CircuitSegmentStatusDCSC::_internal_has_island() const {
  return this != internal_default_instance() && island_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_island() const {
  return _internal_has_island();
}
inline const ::commonmodule::StatusDPS& CircuitSegmentStatusDCSC::_internal_island() const {
  const ::commonmodule::StatusDPS* p = island_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusDPS&>(
      ::commonmodule::_StatusDPS_default_instance_);
}
inline const ::commonmodule::StatusDPS& CircuitSegmentStatusDCSC::island() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
  return _internal_island();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_island(
    ::commonmodule::StatusDPS* island) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island_);
  }
  island_ = island;
  if (island) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::release_island() {
  
  ::commonmodule::StatusDPS* temp = island_;
  island_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::unsafe_arena_release_island() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
  
  ::commonmodule::StatusDPS* temp = island_;
  island_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::_internal_mutable_island() {
  
  if (island_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArena());
    island_ = p;
  }
  return island_;
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::mutable_island() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
  return _internal_mutable_island();
}
inline void CircuitSegmentStatusDCSC::set_allocated_island(::commonmodule::StatusDPS* island) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(island_);
  }
  if (island) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island)->GetArena();
    if (message_arena != submessage_arena) {
      island = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, island, submessage_arena);
    }
    
  } else {
    
  }
  island_ = island;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
}

// .commonmodule.StatusSPS PermissibleAuto = 4;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissibleauto() const {
  return this != internal_default_instance() && permissibleauto_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissibleauto() const {
  return _internal_has_permissibleauto();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissibleauto() const {
  const ::commonmodule::StatusSPS* p = permissibleauto_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissibleauto() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
  return _internal_permissibleauto();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissibleauto(
    ::commonmodule::StatusSPS* permissibleauto) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto_);
  }
  permissibleauto_ = permissibleauto;
  if (permissibleauto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissibleauto() {
  
  ::commonmodule::StatusSPS* temp = permissibleauto_;
  permissibleauto_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissibleauto() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
  
  ::commonmodule::StatusSPS* temp = permissibleauto_;
  permissibleauto_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissibleauto() {
  
  if (permissibleauto_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissibleauto_ = p;
  }
  return permissibleauto_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissibleauto() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
  return _internal_mutable_permissibleauto();
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto_);
  }
  if (permissibleauto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto)->GetArena();
    if (message_arena != submessage_arena) {
      permissibleauto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissibleauto, submessage_arena);
    }
    
  } else {
    
  }
  permissibleauto_ = permissibleauto;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
}

// .commonmodule.StatusSPS PermissibleManual = 5;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblemanual() const {
  return this != internal_default_instance() && permissiblemanual_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblemanual() const {
  return _internal_has_permissiblemanual();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblemanual() const {
  const ::commonmodule::StatusSPS* p = permissiblemanual_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblemanual() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
  return _internal_permissiblemanual();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblemanual(
    ::commonmodule::StatusSPS* permissiblemanual) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual_);
  }
  permissiblemanual_ = permissiblemanual;
  if (permissiblemanual) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblemanual() {
  
  ::commonmodule::StatusSPS* temp = permissiblemanual_;
  permissiblemanual_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblemanual() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
  
  ::commonmodule::StatusSPS* temp = permissiblemanual_;
  permissiblemanual_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblemanual() {
  
  if (permissiblemanual_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblemanual_ = p;
  }
  return permissiblemanual_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblemanual() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
  return _internal_mutable_permissiblemanual();
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual_);
  }
  if (permissiblemanual) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblemanual = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblemanual, submessage_arena);
    }
    
  } else {
    
  }
  permissiblemanual_ = permissiblemanual;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
}

// .commonmodule.StatusSPS PermissibleNetzero = 6;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblenetzero() const {
  return this != internal_default_instance() && permissiblenetzero_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblenetzero() const {
  return _internal_has_permissiblenetzero();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblenetzero() const {
  const ::commonmodule::StatusSPS* p = permissiblenetzero_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblenetzero() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
  return _internal_permissiblenetzero();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblenetzero(
    ::commonmodule::StatusSPS* permissiblenetzero) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero_);
  }
  permissiblenetzero_ = permissiblenetzero;
  if (permissiblenetzero) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblenetzero() {
  
  ::commonmodule::StatusSPS* temp = permissiblenetzero_;
  permissiblenetzero_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblenetzero() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
  
  ::commonmodule::StatusSPS* temp = permissiblenetzero_;
  permissiblenetzero_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblenetzero() {
  
  if (permissiblenetzero_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblenetzero_ = p;
  }
  return permissiblenetzero_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblenetzero() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
  return _internal_mutable_permissiblenetzero();
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero_);
  }
  if (permissiblenetzero) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblenetzero = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblenetzero, submessage_arena);
    }
    
  } else {
    
  }
  permissiblenetzero_ = permissiblenetzero;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
}

// .commonmodule.StatusSPS PermissibleStart = 7;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblestart() const {
  return this != internal_default_instance() && permissiblestart_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblestart() const {
  return _internal_has_permissiblestart();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblestart() const {
  const ::commonmodule::StatusSPS* p = permissiblestart_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblestart() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
  return _internal_permissiblestart();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblestart(
    ::commonmodule::StatusSPS* permissiblestart) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart_);
  }
  permissiblestart_ = permissiblestart;
  if (permissiblestart) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblestart() {
  
  ::commonmodule::StatusSPS* temp = permissiblestart_;
  permissiblestart_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblestart() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
  
  ::commonmodule::StatusSPS* temp = permissiblestart_;
  permissiblestart_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblestart() {
  
  if (permissiblestart_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblestart_ = p;
  }
  return permissiblestart_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblestart() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
  return _internal_mutable_permissiblestart();
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart_);
  }
  if (permissiblestart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblestart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestart, submessage_arena);
    }
    
  } else {
    
  }
  permissiblestart_ = permissiblestart;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
}

// .commonmodule.StatusSPS PermissibleStop = 8;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblestop() const {
  return this != internal_default_instance() && permissiblestop_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblestop() const {
  return _internal_has_permissiblestop();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblestop() const {
  const ::commonmodule::StatusSPS* p = permissiblestop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblestop() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
  return _internal_permissiblestop();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblestop(
    ::commonmodule::StatusSPS* permissiblestop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop_);
  }
  permissiblestop_ = permissiblestop;
  if (permissiblestop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblestop() {
  
  ::commonmodule::StatusSPS* temp = permissiblestop_;
  permissiblestop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblestop() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
  
  ::commonmodule::StatusSPS* temp = permissiblestop_;
  permissiblestop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblestop() {
  
  if (permissiblestop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArena());
    permissiblestop_ = p;
  }
  return permissiblestop_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblestop() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
  return _internal_mutable_permissiblestop();
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop_);
  }
  if (permissiblestop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop)->GetArena();
    if (message_arena != submessage_arena) {
      permissiblestop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestop, submessage_arena);
    }
    
  } else {
    
  }
  permissiblestop_ = permissiblestop;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
}

// -------------------------------------------------------------------

// CircuitSegmentStatus

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentStatus::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline bool CircuitSegmentStatus::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentStatus::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentStatus::identifiedobject() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
  return _internal_identifiedobject();
}
inline void CircuitSegmentStatus::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject_);
  }
  identifiedobject_ = identifiedobject;
  if (identifiedobject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::_internal_mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArena());
    identifiedobject_ = p;
  }
  return identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::mutable_identifiedobject() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
  return _internal_mutable_identifiedobject();
}
inline void CircuitSegmentStatus::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject)->GetArena();
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
}

// .circuitsegmentservicemodule.CircuitSegmentStatusDCSC circuitSegmentStatusDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentStatus::_internal_has_circuitsegmentstatusdcsc() const {
  return this != internal_default_instance() && circuitsegmentstatusdcsc_ != nullptr;
}
inline bool CircuitSegmentStatus::has_circuitsegmentstatusdcsc() const {
  return _internal_has_circuitsegmentstatusdcsc();
}
inline void CircuitSegmentStatus::clear_circuitsegmentstatusdcsc() {
  if (GetArena() == nullptr && circuitsegmentstatusdcsc_ != nullptr) {
    delete circuitsegmentstatusdcsc_;
  }
  circuitsegmentstatusdcsc_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& CircuitSegmentStatus::_internal_circuitsegmentstatusdcsc() const {
  const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* p = circuitsegmentstatusdcsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC&>(
      ::circuitsegmentservicemodule::_CircuitSegmentStatusDCSC_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& CircuitSegmentStatus::circuitsegmentstatusdcsc() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
  return _internal_circuitsegmentstatusdcsc();
}
inline void CircuitSegmentStatus::unsafe_arena_set_allocated_circuitsegmentstatusdcsc(
    ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentstatusdcsc_);
  }
  circuitsegmentstatusdcsc_ = circuitsegmentstatusdcsc;
  if (circuitsegmentstatusdcsc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::release_circuitsegmentstatusdcsc() {
  
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* temp = circuitsegmentstatusdcsc_;
  circuitsegmentstatusdcsc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::unsafe_arena_release_circuitsegmentstatusdcsc() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
  
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* temp = circuitsegmentstatusdcsc_;
  circuitsegmentstatusdcsc_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::_internal_mutable_circuitsegmentstatusdcsc() {
  
  if (circuitsegmentstatusdcsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatusDCSC>(GetArena());
    circuitsegmentstatusdcsc_ = p;
  }
  return circuitsegmentstatusdcsc_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::mutable_circuitsegmentstatusdcsc() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
  return _internal_mutable_circuitsegmentstatusdcsc();
}
inline void CircuitSegmentStatus::set_allocated_circuitsegmentstatusdcsc(::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentstatusdcsc_;
  }
  if (circuitsegmentstatusdcsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentstatusdcsc);
    if (message_arena != submessage_arena) {
      circuitsegmentstatusdcsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentstatusdcsc, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentstatusdcsc_ = circuitsegmentstatusdcsc;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
}

// -------------------------------------------------------------------

// CircuitSegmentStatusProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentStatusProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && eventmessageinfo_ != nullptr;
}
inline bool CircuitSegmentStatusProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& CircuitSegmentStatusProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& CircuitSegmentStatusProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void CircuitSegmentStatusProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo_);
  }
  eventmessageinfo_ = eventmessageinfo;
  if (eventmessageinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentStatusProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentStatusProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentStatusProfile::_internal_mutable_eventmessageinfo() {
  
  if (eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArena());
    eventmessageinfo_ = p;
  }
  return eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentStatusProfile::mutable_eventmessageinfo() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusProfile.eventMessageInfo)
  return _internal_mutable_eventmessageinfo();
}
inline void CircuitSegmentStatusProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo)->GetArena();
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.eventMessageInfo)
}

// .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentStatusProfile::_internal_has_applicationsystem() const {
  return this != internal_default_instance() && applicationsystem_ != nullptr;
}
inline bool CircuitSegmentStatusProfile::has_applicationsystem() const {
  return _internal_has_applicationsystem();
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentStatusProfile::_internal_applicationsystem() const {
  const ::commonmodule::ApplicationSystem* p = applicationsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentStatusProfile::applicationsystem() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
  return _internal_applicationsystem();
}
inline void CircuitSegmentStatusProfile::unsafe_arena_set_allocated_applicationsystem(
    ::commonmodule::ApplicationSystem* applicationsystem) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem_);
  }
  applicationsystem_ = applicationsystem;
  if (applicationsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::release_applicationsystem() {
  
  ::commonmodule::ApplicationSystem* temp = applicationsystem_;
  applicationsystem_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::unsafe_arena_release_applicationsystem() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
  
  ::commonmodule::ApplicationSystem* temp = applicationsystem_;
  applicationsystem_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::_internal_mutable_applicationsystem() {
  
  if (applicationsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArena());
    applicationsystem_ = p;
  }
  return applicationsystem_;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::mutable_applicationsystem() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
  return _internal_mutable_applicationsystem();
}
inline void CircuitSegmentStatusProfile::set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem_);
  }
  if (applicationsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem)->GetArena();
    if (message_arena != submessage_arena) {
      applicationsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applicationsystem, submessage_arena);
    }
    
  } else {
    
  }
  applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
}

// .circuitsegmentservicemodule.CircuitSegmentStatus circuitSegmentStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentStatusProfile::_internal_has_circuitsegmentstatus() const {
  return this != internal_default_instance() && circuitsegmentstatus_ != nullptr;
}
inline bool CircuitSegmentStatusProfile::has_circuitsegmentstatus() const {
  return _internal_has_circuitsegmentstatus();
}
inline void CircuitSegmentStatusProfile::clear_circuitsegmentstatus() {
  if (GetArena() == nullptr && circuitsegmentstatus_ != nullptr) {
    delete circuitsegmentstatus_;
  }
  circuitsegmentstatus_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatus& CircuitSegmentStatusProfile::_internal_circuitsegmentstatus() const {
  const ::circuitsegmentservicemodule::CircuitSegmentStatus* p = circuitsegmentstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentStatus&>(
      ::circuitsegmentservicemodule::_CircuitSegmentStatus_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatus& CircuitSegmentStatusProfile::circuitsegmentstatus() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
  return _internal_circuitsegmentstatus();
}
inline void CircuitSegmentStatusProfile::unsafe_arena_set_allocated_circuitsegmentstatus(
    ::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitsegmentstatus_);
  }
  circuitsegmentstatus_ = circuitsegmentstatus;
  if (circuitsegmentstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::release_circuitsegmentstatus() {
  
  ::circuitsegmentservicemodule::CircuitSegmentStatus* temp = circuitsegmentstatus_;
  circuitsegmentstatus_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::unsafe_arena_release_circuitsegmentstatus() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
  
  ::circuitsegmentservicemodule::CircuitSegmentStatus* temp = circuitsegmentstatus_;
  circuitsegmentstatus_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::_internal_mutable_circuitsegmentstatus() {
  
  if (circuitsegmentstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatus>(GetArena());
    circuitsegmentstatus_ = p;
  }
  return circuitsegmentstatus_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::mutable_circuitsegmentstatus() {
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
  return _internal_mutable_circuitsegmentstatus();
}
inline void CircuitSegmentStatusProfile::set_allocated_circuitsegmentstatus(::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitsegmentstatus_;
  }
  if (circuitsegmentstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitsegmentstatus);
    if (message_arena != submessage_arena) {
      circuitsegmentstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentstatus, submessage_arena);
    }
    
  } else {
    
  }
  circuitsegmentstatus_ = circuitsegmentstatus;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace circuitsegmentservicemodule

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind>() {
  return ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto
