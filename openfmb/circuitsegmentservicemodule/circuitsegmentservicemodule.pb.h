// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: circuitsegmentservicemodule/circuitsegmentservicemodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
namespace circuitsegmentservicemodule {
class CircuitSegmentControl;
struct CircuitSegmentControlDefaultTypeInternal;
extern CircuitSegmentControlDefaultTypeInternal _CircuitSegmentControl_default_instance_;
class CircuitSegmentControlDCSC;
struct CircuitSegmentControlDCSCDefaultTypeInternal;
extern CircuitSegmentControlDCSCDefaultTypeInternal _CircuitSegmentControlDCSC_default_instance_;
class CircuitSegmentControlProfile;
struct CircuitSegmentControlProfileDefaultTypeInternal;
extern CircuitSegmentControlProfileDefaultTypeInternal _CircuitSegmentControlProfile_default_instance_;
class CircuitSegmentEvent;
struct CircuitSegmentEventDefaultTypeInternal;
extern CircuitSegmentEventDefaultTypeInternal _CircuitSegmentEvent_default_instance_;
class CircuitSegmentEventDCSC;
struct CircuitSegmentEventDCSCDefaultTypeInternal;
extern CircuitSegmentEventDCSCDefaultTypeInternal _CircuitSegmentEventDCSC_default_instance_;
class CircuitSegmentEventProfile;
struct CircuitSegmentEventProfileDefaultTypeInternal;
extern CircuitSegmentEventProfileDefaultTypeInternal _CircuitSegmentEventProfile_default_instance_;
class CircuitSegmentStatus;
struct CircuitSegmentStatusDefaultTypeInternal;
extern CircuitSegmentStatusDefaultTypeInternal _CircuitSegmentStatus_default_instance_;
class CircuitSegmentStatusDCSC;
struct CircuitSegmentStatusDCSCDefaultTypeInternal;
extern CircuitSegmentStatusDCSCDefaultTypeInternal _CircuitSegmentStatusDCSC_default_instance_;
class CircuitSegmentStatusProfile;
struct CircuitSegmentStatusProfileDefaultTypeInternal;
extern CircuitSegmentStatusProfileDefaultTypeInternal _CircuitSegmentStatusProfile_default_instance_;
class ENG_CircuitSegmentServiceModeKind;
struct ENG_CircuitSegmentServiceModeKindDefaultTypeInternal;
extern ENG_CircuitSegmentServiceModeKindDefaultTypeInternal _ENG_CircuitSegmentServiceModeKind_default_instance_;
class Optional_CircuitSegmentServiceModeKind;
struct Optional_CircuitSegmentServiceModeKindDefaultTypeInternal;
extern Optional_CircuitSegmentServiceModeKindDefaultTypeInternal _Optional_CircuitSegmentServiceModeKind_default_instance_;
}  // namespace circuitsegmentservicemodule
PROTOBUF_NAMESPACE_OPEN
template <>
::circuitsegmentservicemodule::CircuitSegmentControl* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControl>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentControlDCSC* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControlDCSC>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentControlProfile* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControlProfile>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentEvent* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEvent>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentEventDCSC* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEventDCSC>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentEventProfile* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEventProfile>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentStatus* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatus>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatusDCSC>(Arena*);
template <>
::circuitsegmentservicemodule::CircuitSegmentStatusProfile* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatusProfile>(Arena*);
template <>
::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(Arena*);
template <>
::circuitsegmentservicemodule::Optional_CircuitSegmentServiceModeKind* Arena::CreateMaybeMessage<::circuitsegmentservicemodule::Optional_CircuitSegmentServiceModeKind>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace circuitsegmentservicemodule {
enum CircuitSegmentServiceModeKind : int {
  CircuitSegmentServiceModeKind_UNDEFINED = 0,
  CircuitSegmentServiceModeKind_none = 1,
  CircuitSegmentServiceModeKind_auto = 2,
  CircuitSegmentServiceModeKind_manual = 3,
  CircuitSegmentServiceModeKind_netzero = 4,
  CircuitSegmentServiceModeKind_start = 5,
  CircuitSegmentServiceModeKind_stop = 6,
  CircuitSegmentServiceModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CircuitSegmentServiceModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CircuitSegmentServiceModeKind_IsValid(int value);
constexpr CircuitSegmentServiceModeKind CircuitSegmentServiceModeKind_MIN = static_cast<CircuitSegmentServiceModeKind>(0);
constexpr CircuitSegmentServiceModeKind CircuitSegmentServiceModeKind_MAX = static_cast<CircuitSegmentServiceModeKind>(6);
constexpr int CircuitSegmentServiceModeKind_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CircuitSegmentServiceModeKind_descriptor();
template <typename T>
const std::string& CircuitSegmentServiceModeKind_Name(T value) {
  static_assert(std::is_same<T, CircuitSegmentServiceModeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CircuitSegmentServiceModeKind_Name().");
  return CircuitSegmentServiceModeKind_Name(static_cast<CircuitSegmentServiceModeKind>(value));
}
template <>
inline const std::string& CircuitSegmentServiceModeKind_Name(CircuitSegmentServiceModeKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CircuitSegmentServiceModeKind_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool CircuitSegmentServiceModeKind_Parse(absl::string_view name, CircuitSegmentServiceModeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CircuitSegmentServiceModeKind>(
      CircuitSegmentServiceModeKind_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Optional_CircuitSegmentServiceModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind) */ {
 public:
  inline Optional_CircuitSegmentServiceModeKind() : Optional_CircuitSegmentServiceModeKind(nullptr) {}
  ~Optional_CircuitSegmentServiceModeKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_CircuitSegmentServiceModeKind(const Optional_CircuitSegmentServiceModeKind& from);
  Optional_CircuitSegmentServiceModeKind(Optional_CircuitSegmentServiceModeKind&& from) noexcept
    : Optional_CircuitSegmentServiceModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_CircuitSegmentServiceModeKind& operator=(const Optional_CircuitSegmentServiceModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_CircuitSegmentServiceModeKind& operator=(Optional_CircuitSegmentServiceModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_CircuitSegmentServiceModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_CircuitSegmentServiceModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_CircuitSegmentServiceModeKind*>(
               &_Optional_CircuitSegmentServiceModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Optional_CircuitSegmentServiceModeKind& a, Optional_CircuitSegmentServiceModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_CircuitSegmentServiceModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_CircuitSegmentServiceModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_CircuitSegmentServiceModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_CircuitSegmentServiceModeKind& from) {
    Optional_CircuitSegmentServiceModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_CircuitSegmentServiceModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind";
  }
  protected:
  explicit Optional_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .circuitsegmentservicemodule.CircuitSegmentServiceModeKind value = 1;
  void clear_value() ;
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value() const;
  void set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);

  private:
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind _internal_value() const;
  void _internal_set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class ENG_CircuitSegmentServiceModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind) */ {
 public:
  inline ENG_CircuitSegmentServiceModeKind() : ENG_CircuitSegmentServiceModeKind(nullptr) {}
  ~ENG_CircuitSegmentServiceModeKind() override;
  explicit PROTOBUF_CONSTEXPR ENG_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENG_CircuitSegmentServiceModeKind(const ENG_CircuitSegmentServiceModeKind& from);
  ENG_CircuitSegmentServiceModeKind(ENG_CircuitSegmentServiceModeKind&& from) noexcept
    : ENG_CircuitSegmentServiceModeKind() {
    *this = ::std::move(from);
  }

  inline ENG_CircuitSegmentServiceModeKind& operator=(const ENG_CircuitSegmentServiceModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENG_CircuitSegmentServiceModeKind& operator=(ENG_CircuitSegmentServiceModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENG_CircuitSegmentServiceModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENG_CircuitSegmentServiceModeKind* internal_default_instance() {
    return reinterpret_cast<const ENG_CircuitSegmentServiceModeKind*>(
               &_ENG_CircuitSegmentServiceModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ENG_CircuitSegmentServiceModeKind& a, ENG_CircuitSegmentServiceModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENG_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENG_CircuitSegmentServiceModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENG_CircuitSegmentServiceModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENG_CircuitSegmentServiceModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENG_CircuitSegmentServiceModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENG_CircuitSegmentServiceModeKind& from) {
    ENG_CircuitSegmentServiceModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_CircuitSegmentServiceModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind";
  }
  protected:
  explicit ENG_CircuitSegmentServiceModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetValExtensionFieldNumber = 2,
    kSetValFieldNumber = 1,
  };
  // .google.protobuf.StringValue setValExtension = 2;
  bool has_setvalextension() const;
  private:
  bool _internal_has_setvalextension() const;

  public:
  void clear_setvalextension() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& setvalextension() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_setvalextension();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_setvalextension();
  void set_allocated_setvalextension(::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_setvalextension() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_setvalextension();
  public:
  void unsafe_arena_set_allocated_setvalextension(
      ::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_setvalextension();
  // .circuitsegmentservicemodule.CircuitSegmentServiceModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval() ;
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind setval() const;
  void set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);

  private:
  ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind _internal_setval() const;
  void _internal_set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension_;
    int setval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentControlDCSC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentControlDCSC) */ {
 public:
  inline CircuitSegmentControlDCSC() : CircuitSegmentControlDCSC(nullptr) {}
  ~CircuitSegmentControlDCSC() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentControlDCSC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentControlDCSC(const CircuitSegmentControlDCSC& from);
  CircuitSegmentControlDCSC(CircuitSegmentControlDCSC&& from) noexcept
    : CircuitSegmentControlDCSC() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentControlDCSC& operator=(const CircuitSegmentControlDCSC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentControlDCSC& operator=(CircuitSegmentControlDCSC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentControlDCSC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentControlDCSC* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentControlDCSC*>(
               &_CircuitSegmentControlDCSC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CircuitSegmentControlDCSC& a, CircuitSegmentControlDCSC& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentControlDCSC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentControlDCSC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentControlDCSC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentControlDCSC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentControlDCSC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentControlDCSC& from) {
    CircuitSegmentControlDCSC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentControlDCSC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentControlDCSC";
  }
  protected:
  explicit CircuitSegmentControlDCSC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kCircuitSegmentServiceModeFieldNumber = 2,
    kIslandFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;

  public:
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();
  // .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
  bool has_circuitsegmentservicemode() const;
  private:
  bool _internal_has_circuitsegmentservicemode() const;

  public:
  void clear_circuitsegmentservicemode() ;
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& circuitsegmentservicemode() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* release_circuitsegmentservicemode();
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* mutable_circuitsegmentservicemode();
  void set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  private:
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& _internal_circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _internal_mutable_circuitsegmentservicemode();
  public:
  void unsafe_arena_set_allocated_circuitsegmentservicemode(
      ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* unsafe_arena_release_circuitsegmentservicemode();
  // .commonmodule.ControlDPC Island = 3;
  bool has_island() const;
  private:
  bool _internal_has_island() const;

  public:
  void clear_island() ;
  const ::commonmodule::ControlDPC& island() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlDPC* release_island();
  ::commonmodule::ControlDPC* mutable_island();
  void set_allocated_island(::commonmodule::ControlDPC* island);
  private:
  const ::commonmodule::ControlDPC& _internal_island() const;
  ::commonmodule::ControlDPC* _internal_mutable_island();
  public:
  void unsafe_arena_set_allocated_island(
      ::commonmodule::ControlDPC* island);
  ::commonmodule::ControlDPC* unsafe_arena_release_island();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentControlDCSC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode_;
    ::commonmodule::ControlDPC* island_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentControl) */ {
 public:
  inline CircuitSegmentControl() : CircuitSegmentControl(nullptr) {}
  ~CircuitSegmentControl() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentControl(const CircuitSegmentControl& from);
  CircuitSegmentControl(CircuitSegmentControl&& from) noexcept
    : CircuitSegmentControl() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentControl& operator=(const CircuitSegmentControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentControl& operator=(CircuitSegmentControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentControl* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentControl*>(
               &_CircuitSegmentControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CircuitSegmentControl& a, CircuitSegmentControl& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentControl& from) {
    CircuitSegmentControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentControl";
  }
  protected:
  explicit CircuitSegmentControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kCheckFieldNumber = 2,
    kCircuitSegmentControlDCSCFieldNumber = 3,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .circuitsegmentservicemodule.CircuitSegmentControlDCSC circuitSegmentControlDCSC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentcontroldcsc() const;
  private:
  bool _internal_has_circuitsegmentcontroldcsc() const;

  public:
  void clear_circuitsegmentcontroldcsc() ;
  const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& circuitsegmentcontroldcsc() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* release_circuitsegmentcontroldcsc();
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* mutable_circuitsegmentcontroldcsc();
  void set_allocated_circuitsegmentcontroldcsc(::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& _internal_circuitsegmentcontroldcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* _internal_mutable_circuitsegmentcontroldcsc();
  public:
  void unsafe_arena_set_allocated_circuitsegmentcontroldcsc(
      ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc);
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* unsafe_arena_release_circuitsegmentcontroldcsc();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::commonmodule::CheckConditions* check_;
    ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentControlProfile) */ {
 public:
  inline CircuitSegmentControlProfile() : CircuitSegmentControlProfile(nullptr) {}
  ~CircuitSegmentControlProfile() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentControlProfile(const CircuitSegmentControlProfile& from);
  CircuitSegmentControlProfile(CircuitSegmentControlProfile&& from) noexcept
    : CircuitSegmentControlProfile() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentControlProfile& operator=(const CircuitSegmentControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentControlProfile& operator=(CircuitSegmentControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentControlProfile* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentControlProfile*>(
               &_CircuitSegmentControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CircuitSegmentControlProfile& a, CircuitSegmentControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentControlProfile& from) {
    CircuitSegmentControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentControlProfile";
  }
  protected:
  explicit CircuitSegmentControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kApplicationSystemFieldNumber = 2,
    kCircuitSegmentControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_applicationsystem() const;
  private:
  bool _internal_has_applicationsystem() const;

  public:
  void clear_applicationsystem() ;
  const ::commonmodule::ApplicationSystem& applicationsystem() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_applicationsystem();
  ::commonmodule::ApplicationSystem* mutable_applicationsystem();
  void set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem);
  private:
  const ::commonmodule::ApplicationSystem& _internal_applicationsystem() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_applicationsystem();
  public:
  void unsafe_arena_set_allocated_applicationsystem(
      ::commonmodule::ApplicationSystem* applicationsystem);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_applicationsystem();
  // .circuitsegmentservicemodule.CircuitSegmentControl circuitSegmentControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentcontrol() const;
  private:
  bool _internal_has_circuitsegmentcontrol() const;

  public:
  void clear_circuitsegmentcontrol() ;
  const ::circuitsegmentservicemodule::CircuitSegmentControl& circuitsegmentcontrol() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::CircuitSegmentControl* release_circuitsegmentcontrol();
  ::circuitsegmentservicemodule::CircuitSegmentControl* mutable_circuitsegmentcontrol();
  void set_allocated_circuitsegmentcontrol(::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentControl& _internal_circuitsegmentcontrol() const;
  ::circuitsegmentservicemodule::CircuitSegmentControl* _internal_mutable_circuitsegmentcontrol();
  public:
  void unsafe_arena_set_allocated_circuitsegmentcontrol(
      ::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol);
  ::circuitsegmentservicemodule::CircuitSegmentControl* unsafe_arena_release_circuitsegmentcontrol();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::commonmodule::ApplicationSystem* applicationsystem_;
    ::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentEventDCSC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentEventDCSC) */ {
 public:
  inline CircuitSegmentEventDCSC() : CircuitSegmentEventDCSC(nullptr) {}
  ~CircuitSegmentEventDCSC() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentEventDCSC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentEventDCSC(const CircuitSegmentEventDCSC& from);
  CircuitSegmentEventDCSC(CircuitSegmentEventDCSC&& from) noexcept
    : CircuitSegmentEventDCSC() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentEventDCSC& operator=(const CircuitSegmentEventDCSC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentEventDCSC& operator=(CircuitSegmentEventDCSC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentEventDCSC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentEventDCSC* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentEventDCSC*>(
               &_CircuitSegmentEventDCSC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CircuitSegmentEventDCSC& a, CircuitSegmentEventDCSC& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentEventDCSC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentEventDCSC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentEventDCSC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentEventDCSC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentEventDCSC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentEventDCSC& from) {
    CircuitSegmentEventDCSC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentEventDCSC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentEventDCSC";
  }
  protected:
  explicit CircuitSegmentEventDCSC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kCircuitSegmentServiceModeFieldNumber = 2,
    kIslandFieldNumber = 3,
    kPermissibleAutoFieldNumber = 4,
    kPermissibleManualFieldNumber = 5,
    kPermissibleNetzeroFieldNumber = 6,
    kPermissibleStartFieldNumber = 7,
    kPermissibleStopFieldNumber = 8,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
  bool has_circuitsegmentservicemode() const;
  private:
  bool _internal_has_circuitsegmentservicemode() const;

  public:
  void clear_circuitsegmentservicemode() ;
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& circuitsegmentservicemode() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* release_circuitsegmentservicemode();
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* mutable_circuitsegmentservicemode();
  void set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  private:
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& _internal_circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _internal_mutable_circuitsegmentservicemode();
  public:
  void unsafe_arena_set_allocated_circuitsegmentservicemode(
      ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* unsafe_arena_release_circuitsegmentservicemode();
  // .commonmodule.StatusSPS Island = 3;
  bool has_island() const;
  private:
  bool _internal_has_island() const;

  public:
  void clear_island() ;
  const ::commonmodule::StatusSPS& island() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_island();
  ::commonmodule::StatusSPS* mutable_island();
  void set_allocated_island(::commonmodule::StatusSPS* island);
  private:
  const ::commonmodule::StatusSPS& _internal_island() const;
  ::commonmodule::StatusSPS* _internal_mutable_island();
  public:
  void unsafe_arena_set_allocated_island(
      ::commonmodule::StatusSPS* island);
  ::commonmodule::StatusSPS* unsafe_arena_release_island();
  // .commonmodule.StatusSPS PermissibleAuto = 4;
  bool has_permissibleauto() const;
  private:
  bool _internal_has_permissibleauto() const;

  public:
  void clear_permissibleauto() ;
  const ::commonmodule::StatusSPS& permissibleauto() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissibleauto();
  ::commonmodule::StatusSPS* mutable_permissibleauto();
  void set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto);
  private:
  const ::commonmodule::StatusSPS& _internal_permissibleauto() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissibleauto();
  public:
  void unsafe_arena_set_allocated_permissibleauto(
      ::commonmodule::StatusSPS* permissibleauto);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissibleauto();
  // .commonmodule.StatusSPS PermissibleManual = 5;
  bool has_permissiblemanual() const;
  private:
  bool _internal_has_permissiblemanual() const;

  public:
  void clear_permissiblemanual() ;
  const ::commonmodule::StatusSPS& permissiblemanual() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblemanual();
  ::commonmodule::StatusSPS* mutable_permissiblemanual();
  void set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblemanual() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblemanual();
  public:
  void unsafe_arena_set_allocated_permissiblemanual(
      ::commonmodule::StatusSPS* permissiblemanual);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblemanual();
  // .commonmodule.StatusSPS PermissibleNetzero = 6;
  bool has_permissiblenetzero() const;
  private:
  bool _internal_has_permissiblenetzero() const;

  public:
  void clear_permissiblenetzero() ;
  const ::commonmodule::StatusSPS& permissiblenetzero() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblenetzero();
  ::commonmodule::StatusSPS* mutable_permissiblenetzero();
  void set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblenetzero() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblenetzero();
  public:
  void unsafe_arena_set_allocated_permissiblenetzero(
      ::commonmodule::StatusSPS* permissiblenetzero);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblenetzero();
  // .commonmodule.StatusSPS PermissibleStart = 7;
  bool has_permissiblestart() const;
  private:
  bool _internal_has_permissiblestart() const;

  public:
  void clear_permissiblestart() ;
  const ::commonmodule::StatusSPS& permissiblestart() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblestart();
  ::commonmodule::StatusSPS* mutable_permissiblestart();
  void set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestart() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestart();
  public:
  void unsafe_arena_set_allocated_permissiblestart(
      ::commonmodule::StatusSPS* permissiblestart);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestart();
  // .commonmodule.StatusSPS PermissibleStop = 8;
  bool has_permissiblestop() const;
  private:
  bool _internal_has_permissiblestop() const;

  public:
  void clear_permissiblestop() ;
  const ::commonmodule::StatusSPS& permissiblestop() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblestop();
  ::commonmodule::StatusSPS* mutable_permissiblestop();
  void set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestop() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestop();
  public:
  void unsafe_arena_set_allocated_permissiblestop(
      ::commonmodule::StatusSPS* permissiblestop);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestop();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentEventDCSC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode_;
    ::commonmodule::StatusSPS* island_;
    ::commonmodule::StatusSPS* permissibleauto_;
    ::commonmodule::StatusSPS* permissiblemanual_;
    ::commonmodule::StatusSPS* permissiblenetzero_;
    ::commonmodule::StatusSPS* permissiblestart_;
    ::commonmodule::StatusSPS* permissiblestop_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentEvent) */ {
 public:
  inline CircuitSegmentEvent() : CircuitSegmentEvent(nullptr) {}
  ~CircuitSegmentEvent() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentEvent(const CircuitSegmentEvent& from);
  CircuitSegmentEvent(CircuitSegmentEvent&& from) noexcept
    : CircuitSegmentEvent() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentEvent& operator=(const CircuitSegmentEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentEvent& operator=(CircuitSegmentEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentEvent* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentEvent*>(
               &_CircuitSegmentEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CircuitSegmentEvent& a, CircuitSegmentEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentEvent& from) {
    CircuitSegmentEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentEvent";
  }
  protected:
  explicit CircuitSegmentEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kCircuitSegmentEventDCSCFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .circuitsegmentservicemodule.CircuitSegmentEventDCSC circuitSegmentEventDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmenteventdcsc() const;
  private:
  bool _internal_has_circuitsegmenteventdcsc() const;

  public:
  void clear_circuitsegmenteventdcsc() ;
  const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& circuitsegmenteventdcsc() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* release_circuitsegmenteventdcsc();
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* mutable_circuitsegmenteventdcsc();
  void set_allocated_circuitsegmenteventdcsc(::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& _internal_circuitsegmenteventdcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* _internal_mutable_circuitsegmenteventdcsc();
  public:
  void unsafe_arena_set_allocated_circuitsegmenteventdcsc(
      ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc);
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* unsafe_arena_release_circuitsegmenteventdcsc();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentEventProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentEventProfile) */ {
 public:
  inline CircuitSegmentEventProfile() : CircuitSegmentEventProfile(nullptr) {}
  ~CircuitSegmentEventProfile() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentEventProfile(const CircuitSegmentEventProfile& from);
  CircuitSegmentEventProfile(CircuitSegmentEventProfile&& from) noexcept
    : CircuitSegmentEventProfile() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentEventProfile& operator=(const CircuitSegmentEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentEventProfile& operator=(CircuitSegmentEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentEventProfile* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentEventProfile*>(
               &_CircuitSegmentEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CircuitSegmentEventProfile& a, CircuitSegmentEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentEventProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentEventProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentEventProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentEventProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentEventProfile& from) {
    CircuitSegmentEventProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentEventProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentEventProfile";
  }
  protected:
  explicit CircuitSegmentEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kApplicationSystemFieldNumber = 2,
    kCircuitSegmentEventFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;

  public:
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();
  // .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_applicationsystem() const;
  private:
  bool _internal_has_applicationsystem() const;

  public:
  void clear_applicationsystem() ;
  const ::commonmodule::ApplicationSystem& applicationsystem() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_applicationsystem();
  ::commonmodule::ApplicationSystem* mutable_applicationsystem();
  void set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem);
  private:
  const ::commonmodule::ApplicationSystem& _internal_applicationsystem() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_applicationsystem();
  public:
  void unsafe_arena_set_allocated_applicationsystem(
      ::commonmodule::ApplicationSystem* applicationsystem);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_applicationsystem();
  // .circuitsegmentservicemodule.CircuitSegmentEvent circuitSegmentEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentevent() const;
  private:
  bool _internal_has_circuitsegmentevent() const;

  public:
  void clear_circuitsegmentevent() ;
  const ::circuitsegmentservicemodule::CircuitSegmentEvent& circuitsegmentevent() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::CircuitSegmentEvent* release_circuitsegmentevent();
  ::circuitsegmentservicemodule::CircuitSegmentEvent* mutable_circuitsegmentevent();
  void set_allocated_circuitsegmentevent(::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentEvent& _internal_circuitsegmentevent() const;
  ::circuitsegmentservicemodule::CircuitSegmentEvent* _internal_mutable_circuitsegmentevent();
  public:
  void unsafe_arena_set_allocated_circuitsegmentevent(
      ::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent);
  ::circuitsegmentservicemodule::CircuitSegmentEvent* unsafe_arena_release_circuitsegmentevent();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventMessageInfo* eventmessageinfo_;
    ::commonmodule::ApplicationSystem* applicationsystem_;
    ::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentStatusDCSC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentStatusDCSC) */ {
 public:
  inline CircuitSegmentStatusDCSC() : CircuitSegmentStatusDCSC(nullptr) {}
  ~CircuitSegmentStatusDCSC() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentStatusDCSC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentStatusDCSC(const CircuitSegmentStatusDCSC& from);
  CircuitSegmentStatusDCSC(CircuitSegmentStatusDCSC&& from) noexcept
    : CircuitSegmentStatusDCSC() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentStatusDCSC& operator=(const CircuitSegmentStatusDCSC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentStatusDCSC& operator=(CircuitSegmentStatusDCSC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentStatusDCSC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentStatusDCSC* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentStatusDCSC*>(
               &_CircuitSegmentStatusDCSC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CircuitSegmentStatusDCSC& a, CircuitSegmentStatusDCSC& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentStatusDCSC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentStatusDCSC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentStatusDCSC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentStatusDCSC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentStatusDCSC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentStatusDCSC& from) {
    CircuitSegmentStatusDCSC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentStatusDCSC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentStatusDCSC";
  }
  protected:
  explicit CircuitSegmentStatusDCSC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kCircuitSegmentServiceModeFieldNumber = 2,
    kIslandFieldNumber = 3,
    kPermissibleAutoFieldNumber = 4,
    kPermissibleManualFieldNumber = 5,
    kPermissibleNetzeroFieldNumber = 6,
    kPermissibleStartFieldNumber = 7,
    kPermissibleStopFieldNumber = 8,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
  bool has_circuitsegmentservicemode() const;
  private:
  bool _internal_has_circuitsegmentservicemode() const;

  public:
  void clear_circuitsegmentservicemode() ;
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& circuitsegmentservicemode() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* release_circuitsegmentservicemode();
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* mutable_circuitsegmentservicemode();
  void set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  private:
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& _internal_circuitsegmentservicemode() const;
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _internal_mutable_circuitsegmentservicemode();
  public:
  void unsafe_arena_set_allocated_circuitsegmentservicemode(
      ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode);
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* unsafe_arena_release_circuitsegmentservicemode();
  // .commonmodule.StatusDPS Island = 3;
  bool has_island() const;
  private:
  bool _internal_has_island() const;

  public:
  void clear_island() ;
  const ::commonmodule::StatusDPS& island() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusDPS* release_island();
  ::commonmodule::StatusDPS* mutable_island();
  void set_allocated_island(::commonmodule::StatusDPS* island);
  private:
  const ::commonmodule::StatusDPS& _internal_island() const;
  ::commonmodule::StatusDPS* _internal_mutable_island();
  public:
  void unsafe_arena_set_allocated_island(
      ::commonmodule::StatusDPS* island);
  ::commonmodule::StatusDPS* unsafe_arena_release_island();
  // .commonmodule.StatusSPS PermissibleAuto = 4;
  bool has_permissibleauto() const;
  private:
  bool _internal_has_permissibleauto() const;

  public:
  void clear_permissibleauto() ;
  const ::commonmodule::StatusSPS& permissibleauto() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissibleauto();
  ::commonmodule::StatusSPS* mutable_permissibleauto();
  void set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto);
  private:
  const ::commonmodule::StatusSPS& _internal_permissibleauto() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissibleauto();
  public:
  void unsafe_arena_set_allocated_permissibleauto(
      ::commonmodule::StatusSPS* permissibleauto);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissibleauto();
  // .commonmodule.StatusSPS PermissibleManual = 5;
  bool has_permissiblemanual() const;
  private:
  bool _internal_has_permissiblemanual() const;

  public:
  void clear_permissiblemanual() ;
  const ::commonmodule::StatusSPS& permissiblemanual() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblemanual();
  ::commonmodule::StatusSPS* mutable_permissiblemanual();
  void set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblemanual() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblemanual();
  public:
  void unsafe_arena_set_allocated_permissiblemanual(
      ::commonmodule::StatusSPS* permissiblemanual);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblemanual();
  // .commonmodule.StatusSPS PermissibleNetzero = 6;
  bool has_permissiblenetzero() const;
  private:
  bool _internal_has_permissiblenetzero() const;

  public:
  void clear_permissiblenetzero() ;
  const ::commonmodule::StatusSPS& permissiblenetzero() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblenetzero();
  ::commonmodule::StatusSPS* mutable_permissiblenetzero();
  void set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblenetzero() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblenetzero();
  public:
  void unsafe_arena_set_allocated_permissiblenetzero(
      ::commonmodule::StatusSPS* permissiblenetzero);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblenetzero();
  // .commonmodule.StatusSPS PermissibleStart = 7;
  bool has_permissiblestart() const;
  private:
  bool _internal_has_permissiblestart() const;

  public:
  void clear_permissiblestart() ;
  const ::commonmodule::StatusSPS& permissiblestart() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblestart();
  ::commonmodule::StatusSPS* mutable_permissiblestart();
  void set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestart() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestart();
  public:
  void unsafe_arena_set_allocated_permissiblestart(
      ::commonmodule::StatusSPS* permissiblestart);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestart();
  // .commonmodule.StatusSPS PermissibleStop = 8;
  bool has_permissiblestop() const;
  private:
  bool _internal_has_permissiblestop() const;

  public:
  void clear_permissiblestop() ;
  const ::commonmodule::StatusSPS& permissiblestop() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_permissiblestop();
  ::commonmodule::StatusSPS* mutable_permissiblestop();
  void set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop);
  private:
  const ::commonmodule::StatusSPS& _internal_permissiblestop() const;
  ::commonmodule::StatusSPS* _internal_mutable_permissiblestop();
  public:
  void unsafe_arena_set_allocated_permissiblestop(
      ::commonmodule::StatusSPS* permissiblestop);
  ::commonmodule::StatusSPS* unsafe_arena_release_permissiblestop();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentStatusDCSC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode_;
    ::commonmodule::StatusDPS* island_;
    ::commonmodule::StatusSPS* permissibleauto_;
    ::commonmodule::StatusSPS* permissiblemanual_;
    ::commonmodule::StatusSPS* permissiblenetzero_;
    ::commonmodule::StatusSPS* permissiblestart_;
    ::commonmodule::StatusSPS* permissiblestop_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentStatus) */ {
 public:
  inline CircuitSegmentStatus() : CircuitSegmentStatus(nullptr) {}
  ~CircuitSegmentStatus() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentStatus(const CircuitSegmentStatus& from);
  CircuitSegmentStatus(CircuitSegmentStatus&& from) noexcept
    : CircuitSegmentStatus() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentStatus& operator=(const CircuitSegmentStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentStatus& operator=(CircuitSegmentStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentStatus* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentStatus*>(
               &_CircuitSegmentStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CircuitSegmentStatus& a, CircuitSegmentStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentStatus& from) {
    CircuitSegmentStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentStatus";
  }
  protected:
  explicit CircuitSegmentStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kCircuitSegmentStatusDCSCFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .circuitsegmentservicemodule.CircuitSegmentStatusDCSC circuitSegmentStatusDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentstatusdcsc() const;
  private:
  bool _internal_has_circuitsegmentstatusdcsc() const;

  public:
  void clear_circuitsegmentstatusdcsc() ;
  const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& circuitsegmentstatusdcsc() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* release_circuitsegmentstatusdcsc();
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* mutable_circuitsegmentstatusdcsc();
  void set_allocated_circuitsegmentstatusdcsc(::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& _internal_circuitsegmentstatusdcsc() const;
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* _internal_mutable_circuitsegmentstatusdcsc();
  public:
  void unsafe_arena_set_allocated_circuitsegmentstatusdcsc(
      ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc);
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* unsafe_arena_release_circuitsegmentstatusdcsc();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};// -------------------------------------------------------------------

class CircuitSegmentStatusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:circuitsegmentservicemodule.CircuitSegmentStatusProfile) */ {
 public:
  inline CircuitSegmentStatusProfile() : CircuitSegmentStatusProfile(nullptr) {}
  ~CircuitSegmentStatusProfile() override;
  explicit PROTOBUF_CONSTEXPR CircuitSegmentStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CircuitSegmentStatusProfile(const CircuitSegmentStatusProfile& from);
  CircuitSegmentStatusProfile(CircuitSegmentStatusProfile&& from) noexcept
    : CircuitSegmentStatusProfile() {
    *this = ::std::move(from);
  }

  inline CircuitSegmentStatusProfile& operator=(const CircuitSegmentStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitSegmentStatusProfile& operator=(CircuitSegmentStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitSegmentStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircuitSegmentStatusProfile* internal_default_instance() {
    return reinterpret_cast<const CircuitSegmentStatusProfile*>(
               &_CircuitSegmentStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CircuitSegmentStatusProfile& a, CircuitSegmentStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitSegmentStatusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitSegmentStatusProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitSegmentStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircuitSegmentStatusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CircuitSegmentStatusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CircuitSegmentStatusProfile& from) {
    CircuitSegmentStatusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitSegmentStatusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "circuitsegmentservicemodule.CircuitSegmentStatusProfile";
  }
  protected:
  explicit CircuitSegmentStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kApplicationSystemFieldNumber = 2,
    kCircuitSegmentStatusFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  private:
  bool _internal_has_statusmessageinfo() const;

  public:
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);
  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* _internal_mutable_statusmessageinfo();
  public:
  void unsafe_arena_set_allocated_statusmessageinfo(
      ::commonmodule::StatusMessageInfo* statusmessageinfo);
  ::commonmodule::StatusMessageInfo* unsafe_arena_release_statusmessageinfo();
  // .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_applicationsystem() const;
  private:
  bool _internal_has_applicationsystem() const;

  public:
  void clear_applicationsystem() ;
  const ::commonmodule::ApplicationSystem& applicationsystem() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_applicationsystem();
  ::commonmodule::ApplicationSystem* mutable_applicationsystem();
  void set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem);
  private:
  const ::commonmodule::ApplicationSystem& _internal_applicationsystem() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_applicationsystem();
  public:
  void unsafe_arena_set_allocated_applicationsystem(
      ::commonmodule::ApplicationSystem* applicationsystem);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_applicationsystem();
  // .circuitsegmentservicemodule.CircuitSegmentStatus circuitSegmentStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_circuitsegmentstatus() const;
  private:
  bool _internal_has_circuitsegmentstatus() const;

  public:
  void clear_circuitsegmentstatus() ;
  const ::circuitsegmentservicemodule::CircuitSegmentStatus& circuitsegmentstatus() const;
  PROTOBUF_NODISCARD ::circuitsegmentservicemodule::CircuitSegmentStatus* release_circuitsegmentstatus();
  ::circuitsegmentservicemodule::CircuitSegmentStatus* mutable_circuitsegmentstatus();
  void set_allocated_circuitsegmentstatus(::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus);
  private:
  const ::circuitsegmentservicemodule::CircuitSegmentStatus& _internal_circuitsegmentstatus() const;
  ::circuitsegmentservicemodule::CircuitSegmentStatus* _internal_mutable_circuitsegmentstatus();
  public:
  void unsafe_arena_set_allocated_circuitsegmentstatus(
      ::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus);
  ::circuitsegmentservicemodule::CircuitSegmentStatus* unsafe_arena_release_circuitsegmentstatus();
  // @@protoc_insertion_point(class_scope:circuitsegmentservicemodule.CircuitSegmentStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusMessageInfo* statusmessageinfo_;
    ::commonmodule::ApplicationSystem* applicationsystem_;
    ::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Optional_CircuitSegmentServiceModeKind

// .circuitsegmentservicemodule.CircuitSegmentServiceModeKind value = 1;
inline void Optional_CircuitSegmentServiceModeKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind Optional_CircuitSegmentServiceModeKind::value() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind.value)
  return _internal_value();
}
inline void Optional_CircuitSegmentServiceModeKind::set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:circuitsegmentservicemodule.Optional_CircuitSegmentServiceModeKind.value)
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind Optional_CircuitSegmentServiceModeKind::_internal_value() const {
  return static_cast<::circuitsegmentservicemodule::CircuitSegmentServiceModeKind>(_impl_.value_);
}
inline void Optional_CircuitSegmentServiceModeKind::_internal_set_value(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENG_CircuitSegmentServiceModeKind

// .circuitsegmentservicemodule.CircuitSegmentServiceModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_CircuitSegmentServiceModeKind::clear_setval() {
  _impl_.setval_ = 0;
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind ENG_CircuitSegmentServiceModeKind::setval() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setVal)
  return _internal_setval();
}
inline void ENG_CircuitSegmentServiceModeKind::set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
   _internal_set_setval(value);
  // @@protoc_insertion_point(field_set:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setVal)
}
inline ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind ENG_CircuitSegmentServiceModeKind::_internal_setval() const {
  return static_cast<::circuitsegmentservicemodule::CircuitSegmentServiceModeKind>(_impl_.setval_);
}
inline void ENG_CircuitSegmentServiceModeKind::_internal_set_setval(::circuitsegmentservicemodule::CircuitSegmentServiceModeKind value) {
  ;
  _impl_.setval_ = value;
}

// .google.protobuf.StringValue setValExtension = 2;
inline bool ENG_CircuitSegmentServiceModeKind::_internal_has_setvalextension() const {
  return this != internal_default_instance() && _impl_.setvalextension_ != nullptr;
}
inline bool ENG_CircuitSegmentServiceModeKind::has_setvalextension() const {
  return _internal_has_setvalextension();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& ENG_CircuitSegmentServiceModeKind::_internal_setvalextension() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.setvalextension_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& ENG_CircuitSegmentServiceModeKind::setvalextension() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
  return _internal_setvalextension();
}
inline void ENG_CircuitSegmentServiceModeKind::unsafe_arena_set_allocated_setvalextension(
    ::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setvalextension_);
  }
  _impl_.setvalextension_ = setvalextension;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::release_setvalextension() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.setvalextension_;
  _impl_.setvalextension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::unsafe_arena_release_setvalextension() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.setvalextension_;
  _impl_.setvalextension_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::_internal_mutable_setvalextension() {
  
  if (_impl_.setvalextension_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.setvalextension_ = p;
  }
  return _impl_.setvalextension_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_CircuitSegmentServiceModeKind::mutable_setvalextension() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_setvalextension();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
  return _msg;
}
inline void ENG_CircuitSegmentServiceModeKind::set_allocated_setvalextension(::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setvalextension_);
  }
  if (setvalextension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setvalextension));
    if (message_arena != submessage_arena) {
      setvalextension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setvalextension, submessage_arena);
    }

  } else {

  }
  _impl_.setvalextension_ = setvalextension;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind.setValExtension)
}

// -------------------------------------------------------------------

// CircuitSegmentControlDCSC

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentControlDCSC::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && _impl_.logicalnodeforcontrol_ != nullptr;
}
inline bool CircuitSegmentControlDCSC::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline const ::commonmodule::LogicalNodeForControl& CircuitSegmentControlDCSC::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& CircuitSegmentControlDCSC::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void CircuitSegmentControlDCSC::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::_internal_mutable_logicalnodeforcontrol() {
  
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaForAllocation());
    _impl_.logicalnodeforcontrol_ = p;
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* CircuitSegmentControlDCSC::mutable_logicalnodeforcontrol() {
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
  return _msg;
}
inline void CircuitSegmentControlDCSC::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol));
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.logicalNodeForControl)
}

// .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
inline bool CircuitSegmentControlDCSC::_internal_has_circuitsegmentservicemode() const {
  return this != internal_default_instance() && _impl_.circuitsegmentservicemode_ != nullptr;
}
inline bool CircuitSegmentControlDCSC::has_circuitsegmentservicemode() const {
  return _internal_has_circuitsegmentservicemode();
}
inline void CircuitSegmentControlDCSC::clear_circuitsegmentservicemode() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentservicemode_ != nullptr) {
    delete _impl_.circuitsegmentservicemode_;
  }
  _impl_.circuitsegmentservicemode_ = nullptr;
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentControlDCSC::_internal_circuitsegmentservicemode() const {
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* p = _impl_.circuitsegmentservicemode_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind&>(
      ::circuitsegmentservicemodule::_ENG_CircuitSegmentServiceModeKind_default_instance_);
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentControlDCSC::circuitsegmentservicemode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
  return _internal_circuitsegmentservicemode();
}
inline void CircuitSegmentControlDCSC::unsafe_arena_set_allocated_circuitsegmentservicemode(
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentservicemode_);
  }
  _impl_.circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::release_circuitsegmentservicemode() {
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = _impl_.circuitsegmentservicemode_;
  _impl_.circuitsegmentservicemode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::unsafe_arena_release_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = _impl_.circuitsegmentservicemode_;
  _impl_.circuitsegmentservicemode_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::_internal_mutable_circuitsegmentservicemode() {
  
  if (_impl_.circuitsegmentservicemode_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(GetArenaForAllocation());
    _impl_.circuitsegmentservicemode_ = p;
  }
  return _impl_.circuitsegmentservicemode_;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentControlDCSC::mutable_circuitsegmentservicemode() {
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _msg = _internal_mutable_circuitsegmentservicemode();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
  return _msg;
}
inline void CircuitSegmentControlDCSC::set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentservicemode_;
  }
  if (circuitsegmentservicemode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentservicemode);
    if (message_arena != submessage_arena) {
      circuitsegmentservicemode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentservicemode, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.CircuitSegmentServiceMode)
}

// .commonmodule.ControlDPC Island = 3;
inline bool CircuitSegmentControlDCSC::_internal_has_island() const {
  return this != internal_default_instance() && _impl_.island_ != nullptr;
}
inline bool CircuitSegmentControlDCSC::has_island() const {
  return _internal_has_island();
}
inline const ::commonmodule::ControlDPC& CircuitSegmentControlDCSC::_internal_island() const {
  const ::commonmodule::ControlDPC* p = _impl_.island_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlDPC&>(
      ::commonmodule::_ControlDPC_default_instance_);
}
inline const ::commonmodule::ControlDPC& CircuitSegmentControlDCSC::island() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
  return _internal_island();
}
inline void CircuitSegmentControlDCSC::unsafe_arena_set_allocated_island(
    ::commonmodule::ControlDPC* island) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::release_island() {
  
  ::commonmodule::ControlDPC* temp = _impl_.island_;
  _impl_.island_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::unsafe_arena_release_island() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
  
  ::commonmodule::ControlDPC* temp = _impl_.island_;
  _impl_.island_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::_internal_mutable_island() {
  
  if (_impl_.island_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaForAllocation());
    _impl_.island_ = p;
  }
  return _impl_.island_;
}
inline ::commonmodule::ControlDPC* CircuitSegmentControlDCSC::mutable_island() {
  ::commonmodule::ControlDPC* _msg = _internal_mutable_island();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
  return _msg;
}
inline void CircuitSegmentControlDCSC::set_allocated_island(::commonmodule::ControlDPC* island) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  if (island) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island));
    if (message_arena != submessage_arena) {
      island = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, island, submessage_arena);
    }

  } else {

  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlDCSC.Island)
}

// -------------------------------------------------------------------

// CircuitSegmentControl

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentControl::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool CircuitSegmentControl::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentControl::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentControl::identifiedobject() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
  return _internal_identifiedobject();
}
inline void CircuitSegmentControl::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentControl::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
  return _msg;
}
inline void CircuitSegmentControl::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject));
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.identifiedObject)
}

// .commonmodule.CheckConditions check = 2;
inline bool CircuitSegmentControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool CircuitSegmentControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& CircuitSegmentControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& CircuitSegmentControl::check() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControl.check)
  return _internal_check();
}
inline void CircuitSegmentControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.check)
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* CircuitSegmentControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControl.check)
  return _msg;
}
inline void CircuitSegmentControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.check)
}

// .circuitsegmentservicemodule.CircuitSegmentControlDCSC circuitSegmentControlDCSC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentControl::_internal_has_circuitsegmentcontroldcsc() const {
  return this != internal_default_instance() && _impl_.circuitsegmentcontroldcsc_ != nullptr;
}
inline bool CircuitSegmentControl::has_circuitsegmentcontroldcsc() const {
  return _internal_has_circuitsegmentcontroldcsc();
}
inline void CircuitSegmentControl::clear_circuitsegmentcontroldcsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentcontroldcsc_ != nullptr) {
    delete _impl_.circuitsegmentcontroldcsc_;
  }
  _impl_.circuitsegmentcontroldcsc_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& CircuitSegmentControl::_internal_circuitsegmentcontroldcsc() const {
  const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* p = _impl_.circuitsegmentcontroldcsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC&>(
      ::circuitsegmentservicemodule::_CircuitSegmentControlDCSC_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControlDCSC& CircuitSegmentControl::circuitsegmentcontroldcsc() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
  return _internal_circuitsegmentcontroldcsc();
}
inline void CircuitSegmentControl::unsafe_arena_set_allocated_circuitsegmentcontroldcsc(
    ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentcontroldcsc_);
  }
  _impl_.circuitsegmentcontroldcsc_ = circuitsegmentcontroldcsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::release_circuitsegmentcontroldcsc() {
  
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* temp = _impl_.circuitsegmentcontroldcsc_;
  _impl_.circuitsegmentcontroldcsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::unsafe_arena_release_circuitsegmentcontroldcsc() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
  
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* temp = _impl_.circuitsegmentcontroldcsc_;
  _impl_.circuitsegmentcontroldcsc_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::_internal_mutable_circuitsegmentcontroldcsc() {
  
  if (_impl_.circuitsegmentcontroldcsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControlDCSC>(GetArenaForAllocation());
    _impl_.circuitsegmentcontroldcsc_ = p;
  }
  return _impl_.circuitsegmentcontroldcsc_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* CircuitSegmentControl::mutable_circuitsegmentcontroldcsc() {
  ::circuitsegmentservicemodule::CircuitSegmentControlDCSC* _msg = _internal_mutable_circuitsegmentcontroldcsc();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
  return _msg;
}
inline void CircuitSegmentControl::set_allocated_circuitsegmentcontroldcsc(::circuitsegmentservicemodule::CircuitSegmentControlDCSC* circuitsegmentcontroldcsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentcontroldcsc_;
  }
  if (circuitsegmentcontroldcsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentcontroldcsc);
    if (message_arena != submessage_arena) {
      circuitsegmentcontroldcsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentcontroldcsc, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentcontroldcsc_ = circuitsegmentcontroldcsc;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControl.circuitSegmentControlDCSC)
}

// -------------------------------------------------------------------

// CircuitSegmentControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool CircuitSegmentControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& CircuitSegmentControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& CircuitSegmentControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void CircuitSegmentControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* CircuitSegmentControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
  return _msg;
}
inline void CircuitSegmentControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.controlMessageInfo)
}

// .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentControlProfile::_internal_has_applicationsystem() const {
  return this != internal_default_instance() && _impl_.applicationsystem_ != nullptr;
}
inline bool CircuitSegmentControlProfile::has_applicationsystem() const {
  return _internal_has_applicationsystem();
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentControlProfile::_internal_applicationsystem() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.applicationsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentControlProfile::applicationsystem() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
  return _internal_applicationsystem();
}
inline void CircuitSegmentControlProfile::unsafe_arena_set_allocated_applicationsystem(
    ::commonmodule::ApplicationSystem* applicationsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applicationsystem_);
  }
  _impl_.applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::release_applicationsystem() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.applicationsystem_;
  _impl_.applicationsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::unsafe_arena_release_applicationsystem() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.applicationsystem_;
  _impl_.applicationsystem_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::_internal_mutable_applicationsystem() {
  
  if (_impl_.applicationsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.applicationsystem_ = p;
  }
  return _impl_.applicationsystem_;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentControlProfile::mutable_applicationsystem() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_applicationsystem();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
  return _msg;
}
inline void CircuitSegmentControlProfile::set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applicationsystem_);
  }
  if (applicationsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem));
    if (message_arena != submessage_arena) {
      applicationsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applicationsystem, submessage_arena);
    }

  } else {

  }
  _impl_.applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.applicationSystem)
}

// .circuitsegmentservicemodule.CircuitSegmentControl circuitSegmentControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentControlProfile::_internal_has_circuitsegmentcontrol() const {
  return this != internal_default_instance() && _impl_.circuitsegmentcontrol_ != nullptr;
}
inline bool CircuitSegmentControlProfile::has_circuitsegmentcontrol() const {
  return _internal_has_circuitsegmentcontrol();
}
inline void CircuitSegmentControlProfile::clear_circuitsegmentcontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentcontrol_ != nullptr) {
    delete _impl_.circuitsegmentcontrol_;
  }
  _impl_.circuitsegmentcontrol_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControl& CircuitSegmentControlProfile::_internal_circuitsegmentcontrol() const {
  const ::circuitsegmentservicemodule::CircuitSegmentControl* p = _impl_.circuitsegmentcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentControl&>(
      ::circuitsegmentservicemodule::_CircuitSegmentControl_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentControl& CircuitSegmentControlProfile::circuitsegmentcontrol() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
  return _internal_circuitsegmentcontrol();
}
inline void CircuitSegmentControlProfile::unsafe_arena_set_allocated_circuitsegmentcontrol(
    ::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentcontrol_);
  }
  _impl_.circuitsegmentcontrol_ = circuitsegmentcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::release_circuitsegmentcontrol() {
  
  ::circuitsegmentservicemodule::CircuitSegmentControl* temp = _impl_.circuitsegmentcontrol_;
  _impl_.circuitsegmentcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::unsafe_arena_release_circuitsegmentcontrol() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
  
  ::circuitsegmentservicemodule::CircuitSegmentControl* temp = _impl_.circuitsegmentcontrol_;
  _impl_.circuitsegmentcontrol_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::_internal_mutable_circuitsegmentcontrol() {
  
  if (_impl_.circuitsegmentcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentControl>(GetArenaForAllocation());
    _impl_.circuitsegmentcontrol_ = p;
  }
  return _impl_.circuitsegmentcontrol_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentControl* CircuitSegmentControlProfile::mutable_circuitsegmentcontrol() {
  ::circuitsegmentservicemodule::CircuitSegmentControl* _msg = _internal_mutable_circuitsegmentcontrol();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
  return _msg;
}
inline void CircuitSegmentControlProfile::set_allocated_circuitsegmentcontrol(::circuitsegmentservicemodule::CircuitSegmentControl* circuitsegmentcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentcontrol_;
  }
  if (circuitsegmentcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentcontrol);
    if (message_arena != submessage_arena) {
      circuitsegmentcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentcontrol_ = circuitsegmentcontrol;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentControlProfile.circuitSegmentControl)
}

// -------------------------------------------------------------------

// CircuitSegmentEventDCSC

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentEventDCSC::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline const ::commonmodule::LogicalNode& CircuitSegmentEventDCSC::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CircuitSegmentEventDCSC::logicalnode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
  return _internal_logicalnode();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* CircuitSegmentEventDCSC::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode));
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.logicalNode)
}

// .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
inline bool CircuitSegmentEventDCSC::_internal_has_circuitsegmentservicemode() const {
  return this != internal_default_instance() && _impl_.circuitsegmentservicemode_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_circuitsegmentservicemode() const {
  return _internal_has_circuitsegmentservicemode();
}
inline void CircuitSegmentEventDCSC::clear_circuitsegmentservicemode() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentservicemode_ != nullptr) {
    delete _impl_.circuitsegmentservicemode_;
  }
  _impl_.circuitsegmentservicemode_ = nullptr;
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentEventDCSC::_internal_circuitsegmentservicemode() const {
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* p = _impl_.circuitsegmentservicemode_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind&>(
      ::circuitsegmentservicemodule::_ENG_CircuitSegmentServiceModeKind_default_instance_);
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentEventDCSC::circuitsegmentservicemode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
  return _internal_circuitsegmentservicemode();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_circuitsegmentservicemode(
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentservicemode_);
  }
  _impl_.circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::release_circuitsegmentservicemode() {
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = _impl_.circuitsegmentservicemode_;
  _impl_.circuitsegmentservicemode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::unsafe_arena_release_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = _impl_.circuitsegmentservicemode_;
  _impl_.circuitsegmentservicemode_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::_internal_mutable_circuitsegmentservicemode() {
  
  if (_impl_.circuitsegmentservicemode_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(GetArenaForAllocation());
    _impl_.circuitsegmentservicemode_ = p;
  }
  return _impl_.circuitsegmentservicemode_;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentEventDCSC::mutable_circuitsegmentservicemode() {
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _msg = _internal_mutable_circuitsegmentservicemode();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentservicemode_;
  }
  if (circuitsegmentservicemode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentservicemode);
    if (message_arena != submessage_arena) {
      circuitsegmentservicemode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentservicemode, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.CircuitSegmentServiceMode)
}

// .commonmodule.StatusSPS Island = 3;
inline bool CircuitSegmentEventDCSC::_internal_has_island() const {
  return this != internal_default_instance() && _impl_.island_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_island() const {
  return _internal_has_island();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_island() const {
  const ::commonmodule::StatusSPS* p = _impl_.island_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::island() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
  return _internal_island();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_island(
    ::commonmodule::StatusSPS* island) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_island() {
  
  ::commonmodule::StatusSPS* temp = _impl_.island_;
  _impl_.island_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_island() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
  
  ::commonmodule::StatusSPS* temp = _impl_.island_;
  _impl_.island_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_island() {
  
  if (_impl_.island_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.island_ = p;
  }
  return _impl_.island_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_island() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_island();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_island(::commonmodule::StatusSPS* island) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  if (island) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island));
    if (message_arena != submessage_arena) {
      island = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, island, submessage_arena);
    }

  } else {

  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.Island)
}

// .commonmodule.StatusSPS PermissibleAuto = 4;
inline bool CircuitSegmentEventDCSC::_internal_has_permissibleauto() const {
  return this != internal_default_instance() && _impl_.permissibleauto_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissibleauto() const {
  return _internal_has_permissibleauto();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissibleauto() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissibleauto_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissibleauto() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
  return _internal_permissibleauto();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissibleauto(
    ::commonmodule::StatusSPS* permissibleauto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissibleauto_);
  }
  _impl_.permissibleauto_ = permissibleauto;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissibleauto() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissibleauto_;
  _impl_.permissibleauto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissibleauto() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissibleauto_;
  _impl_.permissibleauto_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissibleauto() {
  
  if (_impl_.permissibleauto_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissibleauto_ = p;
  }
  return _impl_.permissibleauto_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissibleauto() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissibleauto();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissibleauto_);
  }
  if (permissibleauto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto));
    if (message_arena != submessage_arena) {
      permissibleauto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissibleauto, submessage_arena);
    }

  } else {

  }
  _impl_.permissibleauto_ = permissibleauto;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleAuto)
}

// .commonmodule.StatusSPS PermissibleManual = 5;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblemanual() const {
  return this != internal_default_instance() && _impl_.permissiblemanual_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblemanual() const {
  return _internal_has_permissiblemanual();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblemanual() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblemanual_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblemanual() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
  return _internal_permissiblemanual();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblemanual(
    ::commonmodule::StatusSPS* permissiblemanual) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblemanual_);
  }
  _impl_.permissiblemanual_ = permissiblemanual;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblemanual() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblemanual_;
  _impl_.permissiblemanual_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblemanual() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblemanual_;
  _impl_.permissiblemanual_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblemanual() {
  
  if (_impl_.permissiblemanual_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblemanual_ = p;
  }
  return _impl_.permissiblemanual_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblemanual() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblemanual();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblemanual_);
  }
  if (permissiblemanual) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual));
    if (message_arena != submessage_arena) {
      permissiblemanual = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblemanual, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblemanual_ = permissiblemanual;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleManual)
}

// .commonmodule.StatusSPS PermissibleNetzero = 6;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblenetzero() const {
  return this != internal_default_instance() && _impl_.permissiblenetzero_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblenetzero() const {
  return _internal_has_permissiblenetzero();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblenetzero() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblenetzero_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblenetzero() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
  return _internal_permissiblenetzero();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblenetzero(
    ::commonmodule::StatusSPS* permissiblenetzero) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblenetzero_);
  }
  _impl_.permissiblenetzero_ = permissiblenetzero;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblenetzero() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblenetzero_;
  _impl_.permissiblenetzero_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblenetzero() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblenetzero_;
  _impl_.permissiblenetzero_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblenetzero() {
  
  if (_impl_.permissiblenetzero_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblenetzero_ = p;
  }
  return _impl_.permissiblenetzero_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblenetzero() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblenetzero();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblenetzero_);
  }
  if (permissiblenetzero) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero));
    if (message_arena != submessage_arena) {
      permissiblenetzero = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblenetzero, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblenetzero_ = permissiblenetzero;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleNetzero)
}

// .commonmodule.StatusSPS PermissibleStart = 7;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblestart() const {
  return this != internal_default_instance() && _impl_.permissiblestart_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblestart() const {
  return _internal_has_permissiblestart();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblestart() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblestart_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblestart() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
  return _internal_permissiblestart();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblestart(
    ::commonmodule::StatusSPS* permissiblestart) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestart_);
  }
  _impl_.permissiblestart_ = permissiblestart;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblestart() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestart_;
  _impl_.permissiblestart_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblestart() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestart_;
  _impl_.permissiblestart_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblestart() {
  
  if (_impl_.permissiblestart_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblestart_ = p;
  }
  return _impl_.permissiblestart_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblestart() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblestart();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestart_);
  }
  if (permissiblestart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart));
    if (message_arena != submessage_arena) {
      permissiblestart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestart, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblestart_ = permissiblestart;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStart)
}

// .commonmodule.StatusSPS PermissibleStop = 8;
inline bool CircuitSegmentEventDCSC::_internal_has_permissiblestop() const {
  return this != internal_default_instance() && _impl_.permissiblestop_ != nullptr;
}
inline bool CircuitSegmentEventDCSC::has_permissiblestop() const {
  return _internal_has_permissiblestop();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::_internal_permissiblestop() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblestop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentEventDCSC::permissiblestop() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
  return _internal_permissiblestop();
}
inline void CircuitSegmentEventDCSC::unsafe_arena_set_allocated_permissiblestop(
    ::commonmodule::StatusSPS* permissiblestop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestop_);
  }
  _impl_.permissiblestop_ = permissiblestop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::release_permissiblestop() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestop_;
  _impl_.permissiblestop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::unsafe_arena_release_permissiblestop() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestop_;
  _impl_.permissiblestop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::_internal_mutable_permissiblestop() {
  
  if (_impl_.permissiblestop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblestop_ = p;
  }
  return _impl_.permissiblestop_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentEventDCSC::mutable_permissiblestop() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblestop();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
  return _msg;
}
inline void CircuitSegmentEventDCSC::set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestop_);
  }
  if (permissiblestop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop));
    if (message_arena != submessage_arena) {
      permissiblestop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestop, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblestop_ = permissiblestop;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventDCSC.PermissibleStop)
}

// -------------------------------------------------------------------

// CircuitSegmentEvent

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentEvent::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool CircuitSegmentEvent::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentEvent::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentEvent::identifiedobject() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
  return _internal_identifiedobject();
}
inline void CircuitSegmentEvent::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentEvent::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
  return _msg;
}
inline void CircuitSegmentEvent::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject));
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.identifiedObject)
}

// .circuitsegmentservicemodule.CircuitSegmentEventDCSC circuitSegmentEventDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentEvent::_internal_has_circuitsegmenteventdcsc() const {
  return this != internal_default_instance() && _impl_.circuitsegmenteventdcsc_ != nullptr;
}
inline bool CircuitSegmentEvent::has_circuitsegmenteventdcsc() const {
  return _internal_has_circuitsegmenteventdcsc();
}
inline void CircuitSegmentEvent::clear_circuitsegmenteventdcsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmenteventdcsc_ != nullptr) {
    delete _impl_.circuitsegmenteventdcsc_;
  }
  _impl_.circuitsegmenteventdcsc_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& CircuitSegmentEvent::_internal_circuitsegmenteventdcsc() const {
  const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* p = _impl_.circuitsegmenteventdcsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC&>(
      ::circuitsegmentservicemodule::_CircuitSegmentEventDCSC_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEventDCSC& CircuitSegmentEvent::circuitsegmenteventdcsc() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
  return _internal_circuitsegmenteventdcsc();
}
inline void CircuitSegmentEvent::unsafe_arena_set_allocated_circuitsegmenteventdcsc(
    ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmenteventdcsc_);
  }
  _impl_.circuitsegmenteventdcsc_ = circuitsegmenteventdcsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::release_circuitsegmenteventdcsc() {
  
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* temp = _impl_.circuitsegmenteventdcsc_;
  _impl_.circuitsegmenteventdcsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::unsafe_arena_release_circuitsegmenteventdcsc() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
  
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* temp = _impl_.circuitsegmenteventdcsc_;
  _impl_.circuitsegmenteventdcsc_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::_internal_mutable_circuitsegmenteventdcsc() {
  
  if (_impl_.circuitsegmenteventdcsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEventDCSC>(GetArenaForAllocation());
    _impl_.circuitsegmenteventdcsc_ = p;
  }
  return _impl_.circuitsegmenteventdcsc_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* CircuitSegmentEvent::mutable_circuitsegmenteventdcsc() {
  ::circuitsegmentservicemodule::CircuitSegmentEventDCSC* _msg = _internal_mutable_circuitsegmenteventdcsc();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
  return _msg;
}
inline void CircuitSegmentEvent::set_allocated_circuitsegmenteventdcsc(::circuitsegmentservicemodule::CircuitSegmentEventDCSC* circuitsegmenteventdcsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmenteventdcsc_;
  }
  if (circuitsegmenteventdcsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmenteventdcsc);
    if (message_arena != submessage_arena) {
      circuitsegmenteventdcsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmenteventdcsc, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmenteventdcsc_ = circuitsegmenteventdcsc;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEvent.circuitSegmentEventDCSC)
}

// -------------------------------------------------------------------

// CircuitSegmentEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && _impl_.eventmessageinfo_ != nullptr;
}
inline bool CircuitSegmentEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& CircuitSegmentEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& CircuitSegmentEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void CircuitSegmentEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaForAllocation());
    _impl_.eventmessageinfo_ = p;
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* CircuitSegmentEventProfile::mutable_eventmessageinfo() {
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
  return _msg;
}
inline void CircuitSegmentEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo));
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.eventMessageInfo)
}

// .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentEventProfile::_internal_has_applicationsystem() const {
  return this != internal_default_instance() && _impl_.applicationsystem_ != nullptr;
}
inline bool CircuitSegmentEventProfile::has_applicationsystem() const {
  return _internal_has_applicationsystem();
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentEventProfile::_internal_applicationsystem() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.applicationsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentEventProfile::applicationsystem() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
  return _internal_applicationsystem();
}
inline void CircuitSegmentEventProfile::unsafe_arena_set_allocated_applicationsystem(
    ::commonmodule::ApplicationSystem* applicationsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applicationsystem_);
  }
  _impl_.applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::release_applicationsystem() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.applicationsystem_;
  _impl_.applicationsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::unsafe_arena_release_applicationsystem() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.applicationsystem_;
  _impl_.applicationsystem_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::_internal_mutable_applicationsystem() {
  
  if (_impl_.applicationsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.applicationsystem_ = p;
  }
  return _impl_.applicationsystem_;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentEventProfile::mutable_applicationsystem() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_applicationsystem();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
  return _msg;
}
inline void CircuitSegmentEventProfile::set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applicationsystem_);
  }
  if (applicationsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem));
    if (message_arena != submessage_arena) {
      applicationsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applicationsystem, submessage_arena);
    }

  } else {

  }
  _impl_.applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.applicationSystem)
}

// .circuitsegmentservicemodule.CircuitSegmentEvent circuitSegmentEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentEventProfile::_internal_has_circuitsegmentevent() const {
  return this != internal_default_instance() && _impl_.circuitsegmentevent_ != nullptr;
}
inline bool CircuitSegmentEventProfile::has_circuitsegmentevent() const {
  return _internal_has_circuitsegmentevent();
}
inline void CircuitSegmentEventProfile::clear_circuitsegmentevent() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentevent_ != nullptr) {
    delete _impl_.circuitsegmentevent_;
  }
  _impl_.circuitsegmentevent_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEvent& CircuitSegmentEventProfile::_internal_circuitsegmentevent() const {
  const ::circuitsegmentservicemodule::CircuitSegmentEvent* p = _impl_.circuitsegmentevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentEvent&>(
      ::circuitsegmentservicemodule::_CircuitSegmentEvent_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentEvent& CircuitSegmentEventProfile::circuitsegmentevent() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
  return _internal_circuitsegmentevent();
}
inline void CircuitSegmentEventProfile::unsafe_arena_set_allocated_circuitsegmentevent(
    ::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentevent_);
  }
  _impl_.circuitsegmentevent_ = circuitsegmentevent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::release_circuitsegmentevent() {
  
  ::circuitsegmentservicemodule::CircuitSegmentEvent* temp = _impl_.circuitsegmentevent_;
  _impl_.circuitsegmentevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::unsafe_arena_release_circuitsegmentevent() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
  
  ::circuitsegmentservicemodule::CircuitSegmentEvent* temp = _impl_.circuitsegmentevent_;
  _impl_.circuitsegmentevent_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::_internal_mutable_circuitsegmentevent() {
  
  if (_impl_.circuitsegmentevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentEvent>(GetArenaForAllocation());
    _impl_.circuitsegmentevent_ = p;
  }
  return _impl_.circuitsegmentevent_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentEvent* CircuitSegmentEventProfile::mutable_circuitsegmentevent() {
  ::circuitsegmentservicemodule::CircuitSegmentEvent* _msg = _internal_mutable_circuitsegmentevent();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
  return _msg;
}
inline void CircuitSegmentEventProfile::set_allocated_circuitsegmentevent(::circuitsegmentservicemodule::CircuitSegmentEvent* circuitsegmentevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentevent_;
  }
  if (circuitsegmentevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentevent);
    if (message_arena != submessage_arena) {
      circuitsegmentevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentevent, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentevent_ = circuitsegmentevent;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentEventProfile.circuitSegmentEvent)
}

// -------------------------------------------------------------------

// CircuitSegmentStatusDCSC

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentStatusDCSC::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline const ::commonmodule::LogicalNode& CircuitSegmentStatusDCSC::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CircuitSegmentStatusDCSC::logicalnode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
  return _internal_logicalnode();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* CircuitSegmentStatusDCSC::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnode));
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.logicalNode)
}

// .circuitsegmentservicemodule.ENG_CircuitSegmentServiceModeKind CircuitSegmentServiceMode = 2;
inline bool CircuitSegmentStatusDCSC::_internal_has_circuitsegmentservicemode() const {
  return this != internal_default_instance() && _impl_.circuitsegmentservicemode_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_circuitsegmentservicemode() const {
  return _internal_has_circuitsegmentservicemode();
}
inline void CircuitSegmentStatusDCSC::clear_circuitsegmentservicemode() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentservicemode_ != nullptr) {
    delete _impl_.circuitsegmentservicemode_;
  }
  _impl_.circuitsegmentservicemode_ = nullptr;
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentStatusDCSC::_internal_circuitsegmentservicemode() const {
  const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* p = _impl_.circuitsegmentservicemode_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind&>(
      ::circuitsegmentservicemodule::_ENG_CircuitSegmentServiceModeKind_default_instance_);
}
inline const ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind& CircuitSegmentStatusDCSC::circuitsegmentservicemode() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
  return _internal_circuitsegmentservicemode();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_circuitsegmentservicemode(
    ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentservicemode_);
  }
  _impl_.circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::release_circuitsegmentservicemode() {
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = _impl_.circuitsegmentservicemode_;
  _impl_.circuitsegmentservicemode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::unsafe_arena_release_circuitsegmentservicemode() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
  
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* temp = _impl_.circuitsegmentservicemode_;
  _impl_.circuitsegmentservicemode_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::_internal_mutable_circuitsegmentservicemode() {
  
  if (_impl_.circuitsegmentservicemode_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind>(GetArenaForAllocation());
    _impl_.circuitsegmentservicemode_ = p;
  }
  return _impl_.circuitsegmentservicemode_;
}
inline ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* CircuitSegmentStatusDCSC::mutable_circuitsegmentservicemode() {
  ::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* _msg = _internal_mutable_circuitsegmentservicemode();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_circuitsegmentservicemode(::circuitsegmentservicemodule::ENG_CircuitSegmentServiceModeKind* circuitsegmentservicemode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentservicemode_;
  }
  if (circuitsegmentservicemode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentservicemode);
    if (message_arena != submessage_arena) {
      circuitsegmentservicemode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentservicemode, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentservicemode_ = circuitsegmentservicemode;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.CircuitSegmentServiceMode)
}

// .commonmodule.StatusDPS Island = 3;
inline bool CircuitSegmentStatusDCSC::_internal_has_island() const {
  return this != internal_default_instance() && _impl_.island_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_island() const {
  return _internal_has_island();
}
inline const ::commonmodule::StatusDPS& CircuitSegmentStatusDCSC::_internal_island() const {
  const ::commonmodule::StatusDPS* p = _impl_.island_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusDPS&>(
      ::commonmodule::_StatusDPS_default_instance_);
}
inline const ::commonmodule::StatusDPS& CircuitSegmentStatusDCSC::island() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
  return _internal_island();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_island(
    ::commonmodule::StatusDPS* island) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::release_island() {
  
  ::commonmodule::StatusDPS* temp = _impl_.island_;
  _impl_.island_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::unsafe_arena_release_island() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
  
  ::commonmodule::StatusDPS* temp = _impl_.island_;
  _impl_.island_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::_internal_mutable_island() {
  
  if (_impl_.island_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaForAllocation());
    _impl_.island_ = p;
  }
  return _impl_.island_;
}
inline ::commonmodule::StatusDPS* CircuitSegmentStatusDCSC::mutable_island() {
  ::commonmodule::StatusDPS* _msg = _internal_mutable_island();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_island(::commonmodule::StatusDPS* island) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  if (island) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island));
    if (message_arena != submessage_arena) {
      island = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, island, submessage_arena);
    }

  } else {

  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.Island)
}

// .commonmodule.StatusSPS PermissibleAuto = 4;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissibleauto() const {
  return this != internal_default_instance() && _impl_.permissibleauto_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissibleauto() const {
  return _internal_has_permissibleauto();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissibleauto() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissibleauto_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissibleauto() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
  return _internal_permissibleauto();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissibleauto(
    ::commonmodule::StatusSPS* permissibleauto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissibleauto_);
  }
  _impl_.permissibleauto_ = permissibleauto;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissibleauto() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissibleauto_;
  _impl_.permissibleauto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissibleauto() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissibleauto_;
  _impl_.permissibleauto_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissibleauto() {
  
  if (_impl_.permissibleauto_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissibleauto_ = p;
  }
  return _impl_.permissibleauto_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissibleauto() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissibleauto();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissibleauto(::commonmodule::StatusSPS* permissibleauto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissibleauto_);
  }
  if (permissibleauto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissibleauto));
    if (message_arena != submessage_arena) {
      permissibleauto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissibleauto, submessage_arena);
    }

  } else {

  }
  _impl_.permissibleauto_ = permissibleauto;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleAuto)
}

// .commonmodule.StatusSPS PermissibleManual = 5;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblemanual() const {
  return this != internal_default_instance() && _impl_.permissiblemanual_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblemanual() const {
  return _internal_has_permissiblemanual();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblemanual() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblemanual_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblemanual() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
  return _internal_permissiblemanual();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblemanual(
    ::commonmodule::StatusSPS* permissiblemanual) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblemanual_);
  }
  _impl_.permissiblemanual_ = permissiblemanual;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblemanual() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblemanual_;
  _impl_.permissiblemanual_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblemanual() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblemanual_;
  _impl_.permissiblemanual_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblemanual() {
  
  if (_impl_.permissiblemanual_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblemanual_ = p;
  }
  return _impl_.permissiblemanual_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblemanual() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblemanual();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblemanual(::commonmodule::StatusSPS* permissiblemanual) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblemanual_);
  }
  if (permissiblemanual) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblemanual));
    if (message_arena != submessage_arena) {
      permissiblemanual = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblemanual, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblemanual_ = permissiblemanual;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleManual)
}

// .commonmodule.StatusSPS PermissibleNetzero = 6;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblenetzero() const {
  return this != internal_default_instance() && _impl_.permissiblenetzero_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblenetzero() const {
  return _internal_has_permissiblenetzero();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblenetzero() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblenetzero_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblenetzero() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
  return _internal_permissiblenetzero();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblenetzero(
    ::commonmodule::StatusSPS* permissiblenetzero) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblenetzero_);
  }
  _impl_.permissiblenetzero_ = permissiblenetzero;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblenetzero() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblenetzero_;
  _impl_.permissiblenetzero_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblenetzero() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblenetzero_;
  _impl_.permissiblenetzero_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblenetzero() {
  
  if (_impl_.permissiblenetzero_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblenetzero_ = p;
  }
  return _impl_.permissiblenetzero_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblenetzero() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblenetzero();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblenetzero(::commonmodule::StatusSPS* permissiblenetzero) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblenetzero_);
  }
  if (permissiblenetzero) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblenetzero));
    if (message_arena != submessage_arena) {
      permissiblenetzero = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblenetzero, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblenetzero_ = permissiblenetzero;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleNetzero)
}

// .commonmodule.StatusSPS PermissibleStart = 7;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblestart() const {
  return this != internal_default_instance() && _impl_.permissiblestart_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblestart() const {
  return _internal_has_permissiblestart();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblestart() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblestart_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblestart() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
  return _internal_permissiblestart();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblestart(
    ::commonmodule::StatusSPS* permissiblestart) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestart_);
  }
  _impl_.permissiblestart_ = permissiblestart;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblestart() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestart_;
  _impl_.permissiblestart_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblestart() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestart_;
  _impl_.permissiblestart_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblestart() {
  
  if (_impl_.permissiblestart_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblestart_ = p;
  }
  return _impl_.permissiblestart_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblestart() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblestart();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblestart(::commonmodule::StatusSPS* permissiblestart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestart_);
  }
  if (permissiblestart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestart));
    if (message_arena != submessage_arena) {
      permissiblestart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestart, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblestart_ = permissiblestart;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStart)
}

// .commonmodule.StatusSPS PermissibleStop = 8;
inline bool CircuitSegmentStatusDCSC::_internal_has_permissiblestop() const {
  return this != internal_default_instance() && _impl_.permissiblestop_ != nullptr;
}
inline bool CircuitSegmentStatusDCSC::has_permissiblestop() const {
  return _internal_has_permissiblestop();
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::_internal_permissiblestop() const {
  const ::commonmodule::StatusSPS* p = _impl_.permissiblestop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& CircuitSegmentStatusDCSC::permissiblestop() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
  return _internal_permissiblestop();
}
inline void CircuitSegmentStatusDCSC::unsafe_arena_set_allocated_permissiblestop(
    ::commonmodule::StatusSPS* permissiblestop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestop_);
  }
  _impl_.permissiblestop_ = permissiblestop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::release_permissiblestop() {
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestop_;
  _impl_.permissiblestop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::unsafe_arena_release_permissiblestop() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
  
  ::commonmodule::StatusSPS* temp = _impl_.permissiblestop_;
  _impl_.permissiblestop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::_internal_mutable_permissiblestop() {
  
  if (_impl_.permissiblestop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.permissiblestop_ = p;
  }
  return _impl_.permissiblestop_;
}
inline ::commonmodule::StatusSPS* CircuitSegmentStatusDCSC::mutable_permissiblestop() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_permissiblestop();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
  return _msg;
}
inline void CircuitSegmentStatusDCSC::set_allocated_permissiblestop(::commonmodule::StatusSPS* permissiblestop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permissiblestop_);
  }
  if (permissiblestop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permissiblestop));
    if (message_arena != submessage_arena) {
      permissiblestop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permissiblestop, submessage_arena);
    }

  } else {

  }
  _impl_.permissiblestop_ = permissiblestop;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusDCSC.PermissibleStop)
}

// -------------------------------------------------------------------

// CircuitSegmentStatus

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentStatus::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool CircuitSegmentStatus::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentStatus::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& CircuitSegmentStatus::identifiedobject() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
  return _internal_identifiedobject();
}
inline void CircuitSegmentStatus::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* CircuitSegmentStatus::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
  return _msg;
}
inline void CircuitSegmentStatus::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject));
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.identifiedObject)
}

// .circuitsegmentservicemodule.CircuitSegmentStatusDCSC circuitSegmentStatusDCSC = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentStatus::_internal_has_circuitsegmentstatusdcsc() const {
  return this != internal_default_instance() && _impl_.circuitsegmentstatusdcsc_ != nullptr;
}
inline bool CircuitSegmentStatus::has_circuitsegmentstatusdcsc() const {
  return _internal_has_circuitsegmentstatusdcsc();
}
inline void CircuitSegmentStatus::clear_circuitsegmentstatusdcsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentstatusdcsc_ != nullptr) {
    delete _impl_.circuitsegmentstatusdcsc_;
  }
  _impl_.circuitsegmentstatusdcsc_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& CircuitSegmentStatus::_internal_circuitsegmentstatusdcsc() const {
  const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* p = _impl_.circuitsegmentstatusdcsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC&>(
      ::circuitsegmentservicemodule::_CircuitSegmentStatusDCSC_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC& CircuitSegmentStatus::circuitsegmentstatusdcsc() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
  return _internal_circuitsegmentstatusdcsc();
}
inline void CircuitSegmentStatus::unsafe_arena_set_allocated_circuitsegmentstatusdcsc(
    ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentstatusdcsc_);
  }
  _impl_.circuitsegmentstatusdcsc_ = circuitsegmentstatusdcsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::release_circuitsegmentstatusdcsc() {
  
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* temp = _impl_.circuitsegmentstatusdcsc_;
  _impl_.circuitsegmentstatusdcsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::unsafe_arena_release_circuitsegmentstatusdcsc() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
  
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* temp = _impl_.circuitsegmentstatusdcsc_;
  _impl_.circuitsegmentstatusdcsc_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::_internal_mutable_circuitsegmentstatusdcsc() {
  
  if (_impl_.circuitsegmentstatusdcsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatusDCSC>(GetArenaForAllocation());
    _impl_.circuitsegmentstatusdcsc_ = p;
  }
  return _impl_.circuitsegmentstatusdcsc_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* CircuitSegmentStatus::mutable_circuitsegmentstatusdcsc() {
  ::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* _msg = _internal_mutable_circuitsegmentstatusdcsc();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
  return _msg;
}
inline void CircuitSegmentStatus::set_allocated_circuitsegmentstatusdcsc(::circuitsegmentservicemodule::CircuitSegmentStatusDCSC* circuitsegmentstatusdcsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentstatusdcsc_;
  }
  if (circuitsegmentstatusdcsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentstatusdcsc);
    if (message_arena != submessage_arena) {
      circuitsegmentstatusdcsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentstatusdcsc, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentstatusdcsc_ = circuitsegmentstatusdcsc;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatus.circuitSegmentStatusDCSC)
}

// -------------------------------------------------------------------

// CircuitSegmentStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool CircuitSegmentStatusProfile::_internal_has_statusmessageinfo() const {
  return this != internal_default_instance() && _impl_.statusmessageinfo_ != nullptr;
}
inline bool CircuitSegmentStatusProfile::has_statusmessageinfo() const {
  return _internal_has_statusmessageinfo();
}
inline const ::commonmodule::StatusMessageInfo& CircuitSegmentStatusProfile::_internal_statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(
      ::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& CircuitSegmentStatusProfile::statusmessageinfo() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void CircuitSegmentStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* statusmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* CircuitSegmentStatusProfile::release_statusmessageinfo() {
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusMessageInfo* CircuitSegmentStatusProfile::unsafe_arena_release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* CircuitSegmentStatusProfile::_internal_mutable_statusmessageinfo() {
  
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaForAllocation());
    _impl_.statusmessageinfo_ = p;
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* CircuitSegmentStatusProfile::mutable_statusmessageinfo() {
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusProfile.statusMessageInfo)
  return _msg;
}
inline void CircuitSegmentStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusmessageinfo));
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.statusMessageInfo)
}

// .commonmodule.ApplicationSystem applicationSystem = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentStatusProfile::_internal_has_applicationsystem() const {
  return this != internal_default_instance() && _impl_.applicationsystem_ != nullptr;
}
inline bool CircuitSegmentStatusProfile::has_applicationsystem() const {
  return _internal_has_applicationsystem();
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentStatusProfile::_internal_applicationsystem() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.applicationsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& CircuitSegmentStatusProfile::applicationsystem() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
  return _internal_applicationsystem();
}
inline void CircuitSegmentStatusProfile::unsafe_arena_set_allocated_applicationsystem(
    ::commonmodule::ApplicationSystem* applicationsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applicationsystem_);
  }
  _impl_.applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::release_applicationsystem() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.applicationsystem_;
  _impl_.applicationsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::unsafe_arena_release_applicationsystem() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.applicationsystem_;
  _impl_.applicationsystem_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::_internal_mutable_applicationsystem() {
  
  if (_impl_.applicationsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.applicationsystem_ = p;
  }
  return _impl_.applicationsystem_;
}
inline ::commonmodule::ApplicationSystem* CircuitSegmentStatusProfile::mutable_applicationsystem() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_applicationsystem();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
  return _msg;
}
inline void CircuitSegmentStatusProfile::set_allocated_applicationsystem(::commonmodule::ApplicationSystem* applicationsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.applicationsystem_);
  }
  if (applicationsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(applicationsystem));
    if (message_arena != submessage_arena) {
      applicationsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, applicationsystem, submessage_arena);
    }

  } else {

  }
  _impl_.applicationsystem_ = applicationsystem;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.applicationSystem)
}

// .circuitsegmentservicemodule.CircuitSegmentStatus circuitSegmentStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CircuitSegmentStatusProfile::_internal_has_circuitsegmentstatus() const {
  return this != internal_default_instance() && _impl_.circuitsegmentstatus_ != nullptr;
}
inline bool CircuitSegmentStatusProfile::has_circuitsegmentstatus() const {
  return _internal_has_circuitsegmentstatus();
}
inline void CircuitSegmentStatusProfile::clear_circuitsegmentstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.circuitsegmentstatus_ != nullptr) {
    delete _impl_.circuitsegmentstatus_;
  }
  _impl_.circuitsegmentstatus_ = nullptr;
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatus& CircuitSegmentStatusProfile::_internal_circuitsegmentstatus() const {
  const ::circuitsegmentservicemodule::CircuitSegmentStatus* p = _impl_.circuitsegmentstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::circuitsegmentservicemodule::CircuitSegmentStatus&>(
      ::circuitsegmentservicemodule::_CircuitSegmentStatus_default_instance_);
}
inline const ::circuitsegmentservicemodule::CircuitSegmentStatus& CircuitSegmentStatusProfile::circuitsegmentstatus() const {
  // @@protoc_insertion_point(field_get:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
  return _internal_circuitsegmentstatus();
}
inline void CircuitSegmentStatusProfile::unsafe_arena_set_allocated_circuitsegmentstatus(
    ::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.circuitsegmentstatus_);
  }
  _impl_.circuitsegmentstatus_ = circuitsegmentstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::release_circuitsegmentstatus() {
  
  ::circuitsegmentservicemodule::CircuitSegmentStatus* temp = _impl_.circuitsegmentstatus_;
  _impl_.circuitsegmentstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::unsafe_arena_release_circuitsegmentstatus() {
  // @@protoc_insertion_point(field_release:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
  
  ::circuitsegmentservicemodule::CircuitSegmentStatus* temp = _impl_.circuitsegmentstatus_;
  _impl_.circuitsegmentstatus_ = nullptr;
  return temp;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::_internal_mutable_circuitsegmentstatus() {
  
  if (_impl_.circuitsegmentstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::circuitsegmentservicemodule::CircuitSegmentStatus>(GetArenaForAllocation());
    _impl_.circuitsegmentstatus_ = p;
  }
  return _impl_.circuitsegmentstatus_;
}
inline ::circuitsegmentservicemodule::CircuitSegmentStatus* CircuitSegmentStatusProfile::mutable_circuitsegmentstatus() {
  ::circuitsegmentservicemodule::CircuitSegmentStatus* _msg = _internal_mutable_circuitsegmentstatus();
  // @@protoc_insertion_point(field_mutable:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
  return _msg;
}
inline void CircuitSegmentStatusProfile::set_allocated_circuitsegmentstatus(::circuitsegmentservicemodule::CircuitSegmentStatus* circuitsegmentstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.circuitsegmentstatus_;
  }
  if (circuitsegmentstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuitsegmentstatus);
    if (message_arena != submessage_arena) {
      circuitsegmentstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitsegmentstatus, submessage_arena);
    }

  } else {

  }
  _impl_.circuitsegmentstatus_ = circuitsegmentstatus;
  // @@protoc_insertion_point(field_set_allocated:circuitsegmentservicemodule.CircuitSegmentStatusProfile.circuitSegmentStatus)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace circuitsegmentservicemodule


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::circuitsegmentservicemodule::CircuitSegmentServiceModeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::circuitsegmentservicemodule::CircuitSegmentServiceModeKind>() {
  return ::circuitsegmentservicemodule::CircuitSegmentServiceModeKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_circuitsegmentservicemodule_2fcircuitsegmentservicemodule_2eproto_2epb_2eh
