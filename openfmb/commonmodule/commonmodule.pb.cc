// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commonmodule/commonmodule.proto

#include "commonmodule/commonmodule.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace commonmodule {
PROTOBUF_CONSTEXPR Optional_FaultDirectionKind::Optional_FaultDirectionKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_FaultDirectionKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_FaultDirectionKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_FaultDirectionKindDefaultTypeInternal() {}
  union {
    Optional_FaultDirectionKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_FaultDirectionKindDefaultTypeInternal _Optional_FaultDirectionKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_PhaseFaultDirectionKind::Optional_PhaseFaultDirectionKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_PhaseFaultDirectionKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_PhaseFaultDirectionKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_PhaseFaultDirectionKindDefaultTypeInternal() {}
  union {
    Optional_PhaseFaultDirectionKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_PhaseFaultDirectionKindDefaultTypeInternal _Optional_PhaseFaultDirectionKind_default_instance_;
PROTOBUF_CONSTEXPR ACD::ACD(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dirneut_)*/nullptr
  , /*decltype(_impl_.dirphsa_)*/nullptr
  , /*decltype(_impl_.dirphsb_)*/nullptr
  , /*decltype(_impl_.dirphsc_)*/nullptr
  , /*decltype(_impl_.neut_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_.dirgeneral_)*/ 0

  , /*decltype(_impl_.general_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ACDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACDDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACDDefaultTypeInternal() {}
  union {
    ACD _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACDDefaultTypeInternal _ACD_default_instance_;
PROTOBUF_CONSTEXPR IdentifiedObject::IdentifiedObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.description_)*/nullptr
  , /*decltype(_impl_.mrid_)*/nullptr
  , /*decltype(_impl_.name_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IdentifiedObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IdentifiedObjectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IdentifiedObjectDefaultTypeInternal() {}
  union {
    IdentifiedObject _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IdentifiedObjectDefaultTypeInternal _IdentifiedObject_default_instance_;
PROTOBUF_CONSTEXPR ACDCTerminal::ACDCTerminal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_.connected_)*/nullptr
  , /*decltype(_impl_.sequencenumber_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ACDCTerminalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACDCTerminalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACDCTerminalDefaultTypeInternal() {}
  union {
    ACDCTerminal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACDCTerminalDefaultTypeInternal _ACDCTerminal_default_instance_;
PROTOBUF_CONSTEXPR Optional_UnitSymbolKind::Optional_UnitSymbolKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_UnitSymbolKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_UnitSymbolKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_UnitSymbolKindDefaultTypeInternal() {}
  union {
    Optional_UnitSymbolKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_UnitSymbolKindDefaultTypeInternal _Optional_UnitSymbolKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_UnitMultiplierKind::Optional_UnitMultiplierKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_UnitMultiplierKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_UnitMultiplierKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_UnitMultiplierKindDefaultTypeInternal() {}
  union {
    Optional_UnitMultiplierKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_UnitMultiplierKindDefaultTypeInternal _Optional_UnitMultiplierKind_default_instance_;
PROTOBUF_CONSTEXPR ActivePower::ActivePower(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.multiplier_)*/nullptr
  , /*decltype(_impl_.unit_)*/nullptr
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ActivePowerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActivePowerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActivePowerDefaultTypeInternal() {}
  union {
    ActivePower _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActivePowerDefaultTypeInternal _ActivePower_default_instance_;
PROTOBUF_CONSTEXPR Optional_PhaseCodeKind::Optional_PhaseCodeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_PhaseCodeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_PhaseCodeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_PhaseCodeKindDefaultTypeInternal() {}
  union {
    Optional_PhaseCodeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_PhaseCodeKindDefaultTypeInternal _Optional_PhaseCodeKind_default_instance_;
PROTOBUF_CONSTEXPR Unit::Unit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.multiplier_)*/nullptr
  , /*decltype(_impl_.siunit_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UnitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnitDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnitDefaultTypeInternal() {}
  union {
    Unit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnitDefaultTypeInternal _Unit_default_instance_;
PROTOBUF_CONSTEXPR Optional_ValidityKind::Optional_ValidityKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_ValidityKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_ValidityKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_ValidityKindDefaultTypeInternal() {}
  union {
    Optional_ValidityKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_ValidityKindDefaultTypeInternal _Optional_ValidityKind_default_instance_;
PROTOBUF_CONSTEXPR DetailQual::DetailQual(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.badreference_)*/ false

  , /*decltype(_impl_.failure_)*/ false

  , /*decltype(_impl_.inaccurate_)*/ false

  , /*decltype(_impl_.inconsistent_)*/ false

  , /*decltype(_impl_.olddata_)*/ false

  , /*decltype(_impl_.oscillatory_)*/ false

  , /*decltype(_impl_.outofrange_)*/ false

  , /*decltype(_impl_.overflow_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DetailQualDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetailQualDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetailQualDefaultTypeInternal() {}
  union {
    DetailQual _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetailQualDefaultTypeInternal _DetailQual_default_instance_;
PROTOBUF_CONSTEXPR Optional_SourceKind::Optional_SourceKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_SourceKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_SourceKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_SourceKindDefaultTypeInternal() {}
  union {
    Optional_SourceKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_SourceKindDefaultTypeInternal _Optional_SourceKind_default_instance_;
PROTOBUF_CONSTEXPR Quality::Quality(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.detailqual_)*/nullptr
  , /*decltype(_impl_.source_)*/ 0

  , /*decltype(_impl_.operatorblocked_)*/ false

  , /*decltype(_impl_.test_)*/ false

  , /*decltype(_impl_.validity_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QualityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QualityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QualityDefaultTypeInternal() {}
  union {
    Quality _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QualityDefaultTypeInternal _Quality_default_instance_;
PROTOBUF_CONSTEXPR Optional_TimeAccuracyKind::Optional_TimeAccuracyKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_TimeAccuracyKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_TimeAccuracyKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_TimeAccuracyKindDefaultTypeInternal() {}
  union {
    Optional_TimeAccuracyKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_TimeAccuracyKindDefaultTypeInternal _Optional_TimeAccuracyKind_default_instance_;
PROTOBUF_CONSTEXPR TimeQuality::TimeQuality(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clockfailure_)*/ false

  , /*decltype(_impl_.clocknotsynchronized_)*/ false

  , /*decltype(_impl_.leapsecondsknown_)*/ false

  , /*decltype(_impl_.timeaccuracy_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TimeQualityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeQualityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeQualityDefaultTypeInternal() {}
  union {
    TimeQuality _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeQualityDefaultTypeInternal _TimeQuality_default_instance_;
PROTOBUF_CONSTEXPR Timestamp::Timestamp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tq_)*/nullptr
  , /*decltype(_impl_.seconds_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nanoseconds_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampDefaultTypeInternal() {}
  union {
    Timestamp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampDefaultTypeInternal _Timestamp_default_instance_;
PROTOBUF_CONSTEXPR MV::MV(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.units_)*/nullptr
  , /*decltype(_impl_.mag_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MVDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MVDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MVDefaultTypeInternal() {}
  union {
    MV _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MVDefaultTypeInternal _MV_default_instance_;
PROTOBUF_CONSTEXPR LogicalNode::LogicalNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogicalNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalNodeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalNodeDefaultTypeInternal() {}
  union {
    LogicalNode _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalNodeDefaultTypeInternal _LogicalNode_default_instance_;
PROTOBUF_CONSTEXPR AnalogEventAndStatusGGIO::AnalogEventAndStatusGGIO(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.anin_)*/nullptr
  , /*decltype(_impl_.phase_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AnalogEventAndStatusGGIODefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnalogEventAndStatusGGIODefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnalogEventAndStatusGGIODefaultTypeInternal() {}
  union {
    AnalogEventAndStatusGGIO _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnalogEventAndStatusGGIODefaultTypeInternal _AnalogEventAndStatusGGIO_default_instance_;
PROTOBUF_CONSTEXPR NamedObject::NamedObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.description_)*/nullptr
  , /*decltype(_impl_.name_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamedObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedObjectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedObjectDefaultTypeInternal() {}
  union {
    NamedObject _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedObjectDefaultTypeInternal _NamedObject_default_instance_;
PROTOBUF_CONSTEXPR ApplicationSystem::ApplicationSystem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mrid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.namedobject_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ApplicationSystemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplicationSystemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplicationSystemDefaultTypeInternal() {}
  union {
    ApplicationSystem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplicationSystemDefaultTypeInternal _ApplicationSystem_default_instance_;
PROTOBUF_CONSTEXPR ASG::ASG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.setmag_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ASGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ASGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ASGDefaultTypeInternal() {}
  union {
    ASG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ASGDefaultTypeInternal _ASG_default_instance_;
PROTOBUF_CONSTEXPR BCR::BCR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.actval_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BCRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BCRDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BCRDefaultTypeInternal() {}
  union {
    BCR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BCRDefaultTypeInternal _BCR_default_instance_;
PROTOBUF_CONSTEXPR StatusSPS::StatusSPS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusSPSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusSPSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusSPSDefaultTypeInternal() {}
  union {
    StatusSPS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusSPSDefaultTypeInternal _StatusSPS_default_instance_;
PROTOBUF_CONSTEXPR BooleanEventAndStatusGGIO::BooleanEventAndStatusGGIO(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.ind_)*/nullptr
  , /*decltype(_impl_.phase_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BooleanEventAndStatusGGIODefaultTypeInternal {
  PROTOBUF_CONSTEXPR BooleanEventAndStatusGGIODefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BooleanEventAndStatusGGIODefaultTypeInternal() {}
  union {
    BooleanEventAndStatusGGIO _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BooleanEventAndStatusGGIODefaultTypeInternal _BooleanEventAndStatusGGIO_default_instance_;
PROTOBUF_CONSTEXPR MessageInfo::MessageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_.messagetimestamp_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MessageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageInfoDefaultTypeInternal() {}
  union {
    MessageInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageInfoDefaultTypeInternal _MessageInfo_default_instance_;
PROTOBUF_CONSTEXPR CapabilityMessageInfo::CapabilityMessageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messageinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CapabilityMessageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CapabilityMessageInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CapabilityMessageInfoDefaultTypeInternal() {}
  union {
    CapabilityMessageInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CapabilityMessageInfoDefaultTypeInternal _CapabilityMessageInfo_default_instance_;
PROTOBUF_CONSTEXPR CheckConditions::CheckConditions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.interlockcheck_)*/nullptr
  , /*decltype(_impl_.synchrocheck_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckConditionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckConditionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckConditionsDefaultTypeInternal() {}
  union {
    CheckConditions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckConditionsDefaultTypeInternal _CheckConditions_default_instance_;
PROTOBUF_CONSTEXPR ClearingTime::ClearingTime(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.seconds_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nanoseconds_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClearingTimeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearingTimeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearingTimeDefaultTypeInternal() {}
  union {
    ClearingTime _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearingTimeDefaultTypeInternal _ClearingTime_default_instance_;
PROTOBUF_CONSTEXPR Vector::Vector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ang_)*/nullptr
  , /*decltype(_impl_.mag_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorDefaultTypeInternal() {}
  union {
    Vector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorDefaultTypeInternal _Vector_default_instance_;
PROTOBUF_CONSTEXPR CMV::CMV(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cval_)*/nullptr
  , /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMVDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMVDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMVDefaultTypeInternal() {}
  union {
    CMV _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMVDefaultTypeInternal _CMV_default_instance_;
PROTOBUF_CONSTEXPR ConductingEquipment::ConductingEquipment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mrid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.namedobject_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConductingEquipmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConductingEquipmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConductingEquipmentDefaultTypeInternal() {}
  union {
    ConductingEquipment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConductingEquipmentDefaultTypeInternal _ConductingEquipment_default_instance_;
PROTOBUF_CONSTEXPR Terminal::Terminal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.acdcterminal_)*/nullptr
  , /*decltype(_impl_.phases_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TerminalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TerminalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TerminalDefaultTypeInternal() {}
  union {
    Terminal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TerminalDefaultTypeInternal _Terminal_default_instance_;
PROTOBUF_CONSTEXPR ConductingEquipmentTerminalReading::ConductingEquipmentTerminalReading(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.terminal_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConductingEquipmentTerminalReadingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConductingEquipmentTerminalReadingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConductingEquipmentTerminalReadingDefaultTypeInternal() {}
  union {
    ConductingEquipmentTerminalReading _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConductingEquipmentTerminalReadingDefaultTypeInternal _ConductingEquipmentTerminalReading_default_instance_;
PROTOBUF_CONSTEXPR ControlAPC::ControlAPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctlval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlAPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlAPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlAPCDefaultTypeInternal() {}
  union {
    ControlAPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlAPCDefaultTypeInternal _ControlAPC_default_instance_;
PROTOBUF_CONSTEXPR ControlDPC::ControlDPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctlval_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlDPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlDPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlDPCDefaultTypeInternal() {}
  union {
    ControlDPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlDPCDefaultTypeInternal _ControlDPC_default_instance_;
PROTOBUF_CONSTEXPR ControlTimestamp::ControlTimestamp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.seconds_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nanoseconds_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlTimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlTimestampDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlTimestampDefaultTypeInternal() {}
  union {
    ControlTimestamp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlTimestampDefaultTypeInternal _ControlTimestamp_default_instance_;
PROTOBUF_CONSTEXPR Optional_ScheduleParameterKind::Optional_ScheduleParameterKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_ScheduleParameterKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_ScheduleParameterKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_ScheduleParameterKindDefaultTypeInternal() {}
  union {
    Optional_ScheduleParameterKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_ScheduleParameterKindDefaultTypeInternal _Optional_ScheduleParameterKind_default_instance_;
PROTOBUF_CONSTEXPR ENG_ScheduleParameter::ENG_ScheduleParameter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_.scheduleparametertype_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENG_ScheduleParameterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENG_ScheduleParameterDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENG_ScheduleParameterDefaultTypeInternal() {}
  union {
    ENG_ScheduleParameter _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENG_ScheduleParameterDefaultTypeInternal _ENG_ScheduleParameter_default_instance_;
PROTOBUF_CONSTEXPR SchedulePoint::SchedulePoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.scheduleparameter_)*/{}
  , /*decltype(_impl_.starttime_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SchedulePointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedulePointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedulePointDefaultTypeInternal() {}
  union {
    SchedulePoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedulePointDefaultTypeInternal _SchedulePoint_default_instance_;
PROTOBUF_CONSTEXPR ScheduleCSG::ScheduleCSG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.schpts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ScheduleCSGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScheduleCSGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScheduleCSGDefaultTypeInternal() {}
  union {
    ScheduleCSG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScheduleCSGDefaultTypeInternal _ScheduleCSG_default_instance_;
PROTOBUF_CONSTEXPR ControlScheduleFSCH::ControlScheduleFSCH(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.valacsg_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlScheduleFSCHDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlScheduleFSCHDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlScheduleFSCHDefaultTypeInternal() {}
  union {
    ControlScheduleFSCH _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlScheduleFSCHDefaultTypeInternal _ControlScheduleFSCH_default_instance_;
PROTOBUF_CONSTEXPR LogicalNodeForControl::LogicalNodeForControl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogicalNodeForControlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalNodeForControlDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalNodeForControlDefaultTypeInternal() {}
  union {
    LogicalNodeForControl _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalNodeForControlDefaultTypeInternal _LogicalNodeForControl_default_instance_;
PROTOBUF_CONSTEXPR ControlFSCC::ControlFSCC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnodeforcontrol_)*/nullptr
  , /*decltype(_impl_.controlschedulefsch_)*/nullptr
  , /*decltype(_impl_.islandcontrolschedulefsch_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlFSCCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlFSCCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlFSCCDefaultTypeInternal() {}
  union {
    ControlFSCC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlFSCCDefaultTypeInternal _ControlFSCC_default_instance_;
PROTOBUF_CONSTEXPR ControlINC::ControlINC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctlval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlINCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlINCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlINCDefaultTypeInternal() {}
  union {
    ControlINC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlINCDefaultTypeInternal _ControlINC_default_instance_;
PROTOBUF_CONSTEXPR ControlING::ControlING(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.units_)*/nullptr
  , /*decltype(_impl_.setval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlINGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlINGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlINGDefaultTypeInternal() {}
  union {
    ControlING _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlINGDefaultTypeInternal _ControlING_default_instance_;
PROTOBUF_CONSTEXPR ControlISC::ControlISC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctlval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlISCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlISCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlISCDefaultTypeInternal() {}
  union {
    ControlISC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlISCDefaultTypeInternal _ControlISC_default_instance_;
PROTOBUF_CONSTEXPR ControlMessageInfo::ControlMessageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messageinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlMessageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlMessageInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlMessageInfoDefaultTypeInternal() {}
  union {
    ControlMessageInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlMessageInfoDefaultTypeInternal _ControlMessageInfo_default_instance_;
PROTOBUF_CONSTEXPR ControlSPC::ControlSPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctlval_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlSPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlSPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlSPCDefaultTypeInternal() {}
  union {
    ControlSPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlSPCDefaultTypeInternal _ControlSPC_default_instance_;
PROTOBUF_CONSTEXPR ControlValue::ControlValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_.modblk_)*/nullptr
  , /*decltype(_impl_.reset_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlValueDefaultTypeInternal() {}
  union {
    ControlValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlValueDefaultTypeInternal _ControlValue_default_instance_;
PROTOBUF_CONSTEXPR CumulativeTime::CumulativeTime(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.seconds_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nanoseconds_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CumulativeTimeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CumulativeTimeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CumulativeTimeDefaultTypeInternal() {}
  union {
    CumulativeTime _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CumulativeTimeDefaultTypeInternal _CumulativeTime_default_instance_;
PROTOBUF_CONSTEXPR DateTimeInterval::DateTimeInterval(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DateTimeIntervalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateTimeIntervalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateTimeIntervalDefaultTypeInternal() {}
  union {
    DateTimeInterval _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateTimeIntervalDefaultTypeInternal _DateTimeInterval_default_instance_;
PROTOBUF_CONSTEXPR DEL::DEL(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phsab_)*/nullptr
  , /*decltype(_impl_.phsbc_)*/nullptr
  , /*decltype(_impl_.phsca_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DELDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DELDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DELDefaultTypeInternal() {}
  union {
    DEL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DELDefaultTypeInternal _DEL_default_instance_;
PROTOBUF_CONSTEXPR PhaseDPC::PhaseDPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseDPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseDPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseDPCDefaultTypeInternal() {}
  union {
    PhaseDPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseDPCDefaultTypeInternal _PhaseDPC_default_instance_;
PROTOBUF_CONSTEXPR DiscreteControlXCBR::DiscreteControlXCBR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnodeforcontrol_)*/nullptr
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.protectionmode_)*/nullptr
  , /*decltype(_impl_.recloseenabled_)*/nullptr
  , /*decltype(_impl_.resetprotectionpickup_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DiscreteControlXCBRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DiscreteControlXCBRDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DiscreteControlXCBRDefaultTypeInternal() {}
  union {
    DiscreteControlXCBR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DiscreteControlXCBRDefaultTypeInternal _DiscreteControlXCBR_default_instance_;
PROTOBUF_CONSTEXPR EnergyConsumer::EnergyConsumer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.conductingequipment_)*/nullptr
  , /*decltype(_impl_.operatinglimit_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnergyConsumerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnergyConsumerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnergyConsumerDefaultTypeInternal() {}
  union {
    EnergyConsumer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnergyConsumerDefaultTypeInternal _EnergyConsumer_default_instance_;
PROTOBUF_CONSTEXPR Optional_CalcMethodKind::Optional_CalcMethodKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_CalcMethodKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_CalcMethodKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_CalcMethodKindDefaultTypeInternal() {}
  union {
    Optional_CalcMethodKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_CalcMethodKindDefaultTypeInternal _Optional_CalcMethodKind_default_instance_;
PROTOBUF_CONSTEXPR ENG_CalcMethodKind::ENG_CalcMethodKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.setval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENG_CalcMethodKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENG_CalcMethodKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENG_CalcMethodKindDefaultTypeInternal() {}
  union {
    ENG_CalcMethodKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENG_CalcMethodKindDefaultTypeInternal _ENG_CalcMethodKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_GridConnectModeKind::Optional_GridConnectModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_GridConnectModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_GridConnectModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_GridConnectModeKindDefaultTypeInternal() {}
  union {
    Optional_GridConnectModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_GridConnectModeKindDefaultTypeInternal _Optional_GridConnectModeKind_default_instance_;
PROTOBUF_CONSTEXPR ENG_GridConnectModeKind::ENG_GridConnectModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.setvalextension_)*/nullptr
  , /*decltype(_impl_.setval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENG_GridConnectModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENG_GridConnectModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENG_GridConnectModeKindDefaultTypeInternal() {}
  union {
    ENG_GridConnectModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENG_GridConnectModeKindDefaultTypeInternal _ENG_GridConnectModeKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_PFSignKind::Optional_PFSignKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_PFSignKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_PFSignKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_PFSignKindDefaultTypeInternal() {}
  union {
    Optional_PFSignKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_PFSignKindDefaultTypeInternal _Optional_PFSignKind_default_instance_;
PROTOBUF_CONSTEXPR ENG_PFSignKind::ENG_PFSignKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.setval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENG_PFSignKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENG_PFSignKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENG_PFSignKindDefaultTypeInternal() {}
  union {
    ENG_PFSignKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENG_PFSignKindDefaultTypeInternal _ENG_PFSignKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_BehaviourModeKind::Optional_BehaviourModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_BehaviourModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_BehaviourModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_BehaviourModeKindDefaultTypeInternal() {}
  union {
    Optional_BehaviourModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_BehaviourModeKindDefaultTypeInternal _Optional_BehaviourModeKind_default_instance_;
PROTOBUF_CONSTEXPR ENS_BehaviourModeKind::ENS_BehaviourModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENS_BehaviourModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENS_BehaviourModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENS_BehaviourModeKindDefaultTypeInternal() {}
  union {
    ENS_BehaviourModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENS_BehaviourModeKindDefaultTypeInternal _ENS_BehaviourModeKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_DERGeneratorStateKind::Optional_DERGeneratorStateKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_DERGeneratorStateKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_DERGeneratorStateKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_DERGeneratorStateKindDefaultTypeInternal() {}
  union {
    Optional_DERGeneratorStateKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_DERGeneratorStateKindDefaultTypeInternal _Optional_DERGeneratorStateKind_default_instance_;
PROTOBUF_CONSTEXPR ENS_DERGeneratorStateKind::ENS_DERGeneratorStateKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENS_DERGeneratorStateKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENS_DERGeneratorStateKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENS_DERGeneratorStateKindDefaultTypeInternal() {}
  union {
    ENS_DERGeneratorStateKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENS_DERGeneratorStateKindDefaultTypeInternal _ENS_DERGeneratorStateKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_DynamicTestKind::Optional_DynamicTestKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_DynamicTestKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_DynamicTestKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_DynamicTestKindDefaultTypeInternal() {}
  union {
    Optional_DynamicTestKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_DynamicTestKindDefaultTypeInternal _Optional_DynamicTestKind_default_instance_;
PROTOBUF_CONSTEXPR ENS_DynamicTestKind::ENS_DynamicTestKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENS_DynamicTestKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENS_DynamicTestKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENS_DynamicTestKindDefaultTypeInternal() {}
  union {
    ENS_DynamicTestKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENS_DynamicTestKindDefaultTypeInternal _ENS_DynamicTestKind_default_instance_;
PROTOBUF_CONSTEXPR ENS_GridConnectModeKind::ENS_GridConnectModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stvalextension_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENS_GridConnectModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENS_GridConnectModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENS_GridConnectModeKindDefaultTypeInternal() {}
  union {
    ENS_GridConnectModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENS_GridConnectModeKindDefaultTypeInternal _ENS_GridConnectModeKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_HealthKind::Optional_HealthKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_HealthKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_HealthKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_HealthKindDefaultTypeInternal() {}
  union {
    Optional_HealthKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_HealthKindDefaultTypeInternal _Optional_HealthKind_default_instance_;
PROTOBUF_CONSTEXPR ENS_HealthKind::ENS_HealthKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.d_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENS_HealthKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENS_HealthKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENS_HealthKindDefaultTypeInternal() {}
  union {
    ENS_HealthKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENS_HealthKindDefaultTypeInternal _ENS_HealthKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_SwitchingCapabilityKind::Optional_SwitchingCapabilityKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_SwitchingCapabilityKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_SwitchingCapabilityKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_SwitchingCapabilityKindDefaultTypeInternal() {}
  union {
    Optional_SwitchingCapabilityKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_SwitchingCapabilityKindDefaultTypeInternal _Optional_SwitchingCapabilityKind_default_instance_;
PROTOBUF_CONSTEXPR ENS_SwitchingCapabilityKind::ENS_SwitchingCapabilityKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.blkena_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ENS_SwitchingCapabilityKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ENS_SwitchingCapabilityKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ENS_SwitchingCapabilityKindDefaultTypeInternal() {}
  union {
    ENS_SwitchingCapabilityKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ENS_SwitchingCapabilityKindDefaultTypeInternal _ENS_SwitchingCapabilityKind_default_instance_;
PROTOBUF_CONSTEXPR OperationDCTE::OperationDCTE(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rnddltmms_)*/nullptr
  , /*decltype(_impl_.rtndltmms_)*/nullptr
  , /*decltype(_impl_.rtnrmptmms_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDCTEDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDCTEDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDCTEDefaultTypeInternal() {}
  union {
    OperationDCTE _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDCTEDefaultTypeInternal _OperationDCTE_default_instance_;
PROTOBUF_CONSTEXPR EnterServiceAPC::EnterServiceAPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.enterserviceparameter_)*/nullptr
  , /*decltype(_impl_.hzhilim_)*/ 0

  , /*decltype(_impl_.hzlolim_)*/ 0

  , /*decltype(_impl_.rtnsrvauto_)*/ false

  , /*decltype(_impl_.vhilim_)*/ 0

  , /*decltype(_impl_.vlolim_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnterServiceAPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnterServiceAPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnterServiceAPCDefaultTypeInternal() {}
  union {
    EnterServiceAPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnterServiceAPCDefaultTypeInternal _EnterServiceAPC_default_instance_;
PROTOBUF_CONSTEXPR ESS::ESS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.conductingequipment_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ESSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ESSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ESSDefaultTypeInternal() {}
  union {
    ESS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ESSDefaultTypeInternal _ESS_default_instance_;
PROTOBUF_CONSTEXPR EventMessageInfo::EventMessageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messageinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventMessageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventMessageInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventMessageInfoDefaultTypeInternal() {}
  union {
    EventMessageInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventMessageInfoDefaultTypeInternal _EventMessageInfo_default_instance_;
PROTOBUF_CONSTEXPR EventValue::EventValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_.modblk_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventValueDefaultTypeInternal() {}
  union {
    EventValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventValueDefaultTypeInternal _EventValue_default_instance_;
PROTOBUF_CONSTEXPR ForecastValueSource::ForecastValueSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ForecastValueSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ForecastValueSourceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ForecastValueSourceDefaultTypeInternal() {}
  union {
    ForecastValueSource _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ForecastValueSourceDefaultTypeInternal _ForecastValueSource_default_instance_;
PROTOBUF_CONSTEXPR ForecastIED::ForecastIED(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sourceapplicationid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.forecastvaluesource_)*/nullptr
  , /*decltype(_impl_.sourcedatetime_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ForecastIEDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ForecastIEDDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ForecastIEDDefaultTypeInternal() {}
  union {
    ForecastIED _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ForecastIEDDefaultTypeInternal _ForecastIED_default_instance_;
PROTOBUF_CONSTEXPR ForecastValue::ForecastValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ForecastValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ForecastValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ForecastValueDefaultTypeInternal() {}
  union {
    ForecastValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ForecastValueDefaultTypeInternal _ForecastValue_default_instance_;
PROTOBUF_CONSTEXPR OperationDHFW::OperationDHFW(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.opltmmsmax_)*/nullptr
  , /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDHFWDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDHFWDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDHFWDefaultTypeInternal() {}
  union {
    OperationDHFW _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDHFWDefaultTypeInternal _OperationDHFW_default_instance_;
PROTOBUF_CONSTEXPR OperationDLFW::OperationDLFW(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.opltmmsmax_)*/nullptr
  , /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDLFWDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDLFWDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDLFWDefaultTypeInternal() {}
  union {
    OperationDLFW _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDLFWDefaultTypeInternal _OperationDLFW_default_instance_;
PROTOBUF_CONSTEXPR HzWPoint::HzWPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.deadbandhzval_)*/ 0

  , /*decltype(_impl_.slopeval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HzWPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HzWPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HzWPointDefaultTypeInternal() {}
  union {
    HzWPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HzWPointDefaultTypeInternal _HzWPoint_default_instance_;
PROTOBUF_CONSTEXPR HzWAPC::HzWAPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.overhzwpt_)*/nullptr
  , /*decltype(_impl_.overhzwparameter_)*/nullptr
  , /*decltype(_impl_.underhzwpt_)*/nullptr
  , /*decltype(_impl_.underhzwparameter_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HzWAPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HzWAPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HzWAPCDefaultTypeInternal() {}
  union {
    HzWAPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HzWAPCDefaultTypeInternal _HzWAPC_default_instance_;
PROTOBUF_CONSTEXPR StatusINS::StatusINS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusINSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusINSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusINSDefaultTypeInternal() {}
  union {
    StatusINS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusINSDefaultTypeInternal _StatusINS_default_instance_;
PROTOBUF_CONSTEXPR IntegerEventAndStatusGGIO::IntegerEventAndStatusGGIO(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.intin_)*/nullptr
  , /*decltype(_impl_.phase_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IntegerEventAndStatusGGIODefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntegerEventAndStatusGGIODefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntegerEventAndStatusGGIODefaultTypeInternal() {}
  union {
    IntegerEventAndStatusGGIO _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntegerEventAndStatusGGIODefaultTypeInternal _IntegerEventAndStatusGGIO_default_instance_;
PROTOBUF_CONSTEXPR OperationDWMX::OperationDWMX(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDWMXDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDWMXDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDWMXDefaultTypeInternal() {}
  union {
    OperationDWMX _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDWMXDefaultTypeInternal _OperationDWMX_default_instance_;
PROTOBUF_CONSTEXPR OperationDWMN::OperationDWMN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDWMNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDWMNDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDWMNDefaultTypeInternal() {}
  union {
    OperationDWMN _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDWMNDefaultTypeInternal _OperationDWMN_default_instance_;
PROTOBUF_CONSTEXPR LimitWAPC::LimitWAPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.maxlimparameter_)*/nullptr
  , /*decltype(_impl_.minlimparameter_)*/nullptr
  , /*decltype(_impl_.wmaxsptval_)*/ 0

  , /*decltype(_impl_.wminsptval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LimitWAPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitWAPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitWAPCDefaultTypeInternal() {}
  union {
    LimitWAPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitWAPCDefaultTypeInternal _LimitWAPC_default_instance_;
PROTOBUF_CONSTEXPR LogicalNodeForEventAndStatus::LogicalNodeForEventAndStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.beh_)*/nullptr
  , /*decltype(_impl_.eehealth_)*/nullptr
  , /*decltype(_impl_.hotlinetag_)*/nullptr
  , /*decltype(_impl_.remoteblk_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogicalNodeForEventAndStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalNodeForEventAndStatusDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalNodeForEventAndStatusDefaultTypeInternal() {}
  union {
    LogicalNodeForEventAndStatus _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalNodeForEventAndStatusDefaultTypeInternal _LogicalNodeForEventAndStatus_default_instance_;
PROTOBUF_CONSTEXPR MeasurementValue::MeasurementValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MeasurementValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MeasurementValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MeasurementValueDefaultTypeInternal() {}
  union {
    MeasurementValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MeasurementValueDefaultTypeInternal _MeasurementValue_default_instance_;
PROTOBUF_CONSTEXPR Meter::Meter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.conductingequipment_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MeterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MeterDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MeterDefaultTypeInternal() {}
  union {
    Meter _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MeterDefaultTypeInternal _Meter_default_instance_;
PROTOBUF_CONSTEXPR NameplateValue::NameplateValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_.model_)*/nullptr
  , /*decltype(_impl_.sernum_)*/nullptr
  , /*decltype(_impl_.swrev_)*/nullptr
  , /*decltype(_impl_.vendor_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NameplateValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NameplateValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NameplateValueDefaultTypeInternal() {}
  union {
    NameplateValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NameplateValueDefaultTypeInternal _NameplateValue_default_instance_;
PROTOBUF_CONSTEXPR OperationDFPF::OperationDFPF(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_.pfextset_)*/ false

  , /*decltype(_impl_.pfgntgtmxval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDFPFDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDFPFDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDFPFDefaultTypeInternal() {}
  union {
    OperationDFPF _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDFPFDefaultTypeInternal _OperationDFPF_default_instance_;
PROTOBUF_CONSTEXPR OperationDVAR::OperationDVAR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vartgtspt_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDVARDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDVARDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDVARDefaultTypeInternal() {}
  union {
    OperationDVAR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDVARDefaultTypeInternal _OperationDVAR_default_instance_;
PROTOBUF_CONSTEXPR OperationDVVR::OperationDVVR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.opltmmsmax_)*/nullptr
  , /*decltype(_impl_.vreftmms_)*/nullptr
  , /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_.vrefadjena_)*/ false

  , /*decltype(_impl_.vref_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDVVRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDVVRDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDVVRDefaultTypeInternal() {}
  union {
    OperationDVVR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDVVRDefaultTypeInternal _OperationDVVR_default_instance_;
PROTOBUF_CONSTEXPR OperationDVWC::OperationDVWC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.opltmmsmax_)*/nullptr
  , /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDVWCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDVWCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDVWCDefaultTypeInternal() {}
  union {
    OperationDVWC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDVWCDefaultTypeInternal _OperationDVWC_default_instance_;
PROTOBUF_CONSTEXPR OperationDWGC::OperationDWGC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wspt_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDWGCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDWGCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDWGCDefaultTypeInternal() {}
  union {
    OperationDWGC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDWGCDefaultTypeInternal _OperationDWGC_default_instance_;
PROTOBUF_CONSTEXPR OperationDWVR::OperationDWVR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDWVRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDWVRDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDWVRDefaultTypeInternal() {}
  union {
    OperationDWVR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDWVRDefaultTypeInternal _OperationDWVR_default_instance_;
PROTOBUF_CONSTEXPR OptimizationMessageInfo::OptimizationMessageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messageinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OptimizationMessageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptimizationMessageInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptimizationMessageInfoDefaultTypeInternal() {}
  union {
    OptimizationMessageInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptimizationMessageInfoDefaultTypeInternal _OptimizationMessageInfo_default_instance_;
PROTOBUF_CONSTEXPR PFSPC::PFSPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pfparameter_)*/nullptr
  , /*decltype(_impl_.ctlval_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PFSPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PFSPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PFSPCDefaultTypeInternal() {}
  union {
    PFSPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PFSPCDefaultTypeInternal _PFSPC_default_instance_;
PROTOBUF_CONSTEXPR PhaseAPC::PhaseAPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseAPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseAPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseAPCDefaultTypeInternal() {}
  union {
    PhaseAPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseAPCDefaultTypeInternal _PhaseAPC_default_instance_;
PROTOBUF_CONSTEXPR Optional_DbPosKind::Optional_DbPosKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_DbPosKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_DbPosKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_DbPosKindDefaultTypeInternal() {}
  union {
    Optional_DbPosKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_DbPosKindDefaultTypeInternal _Optional_DbPosKind_default_instance_;
PROTOBUF_CONSTEXPR StatusDPS::StatusDPS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusDPSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusDPSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusDPSDefaultTypeInternal() {}
  union {
    StatusDPS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusDPSDefaultTypeInternal _StatusDPS_default_instance_;
PROTOBUF_CONSTEXPR PhaseDPS::PhaseDPS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseDPSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseDPSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseDPSDefaultTypeInternal() {}
  union {
    PhaseDPS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseDPSDefaultTypeInternal _PhaseDPS_default_instance_;
PROTOBUF_CONSTEXPR PhaseINS::PhaseINS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseINSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseINSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseINSDefaultTypeInternal() {}
  union {
    PhaseINS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseINSDefaultTypeInternal _PhaseINS_default_instance_;
PROTOBUF_CONSTEXPR PhaseISC::PhaseISC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseISCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseISCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseISCDefaultTypeInternal() {}
  union {
    PhaseISC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseISCDefaultTypeInternal _PhaseISC_default_instance_;
PROTOBUF_CONSTEXPR ReadingMMTN::ReadingMMTN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.dmdvah_)*/nullptr
  , /*decltype(_impl_.dmdvarh_)*/nullptr
  , /*decltype(_impl_.dmdwh_)*/nullptr
  , /*decltype(_impl_.supvah_)*/nullptr
  , /*decltype(_impl_.supvarh_)*/nullptr
  , /*decltype(_impl_.supwh_)*/nullptr
  , /*decltype(_impl_.totvah_)*/nullptr
  , /*decltype(_impl_.totvarh_)*/nullptr
  , /*decltype(_impl_.totwh_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadingMMTNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadingMMTNDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadingMMTNDefaultTypeInternal() {}
  union {
    ReadingMMTN _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadingMMTNDefaultTypeInternal _ReadingMMTN_default_instance_;
PROTOBUF_CONSTEXPR PhaseMMTN::PhaseMMTN(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsab_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsbc_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_.phsca_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseMMTNDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseMMTNDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseMMTNDefaultTypeInternal() {}
  union {
    PhaseMMTN _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseMMTNDefaultTypeInternal _PhaseMMTN_default_instance_;
PROTOBUF_CONSTEXPR Optional_RecloseActionKind::Optional_RecloseActionKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_RecloseActionKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_RecloseActionKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_RecloseActionKindDefaultTypeInternal() {}
  union {
    Optional_RecloseActionKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_RecloseActionKindDefaultTypeInternal _Optional_RecloseActionKind_default_instance_;
PROTOBUF_CONSTEXPR PhaseRecloseAction::PhaseRecloseAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseRecloseActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseRecloseActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseRecloseActionDefaultTypeInternal() {}
  union {
    PhaseRecloseAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseRecloseActionDefaultTypeInternal _PhaseRecloseAction_default_instance_;
PROTOBUF_CONSTEXPR PhaseSPC::PhaseSPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseSPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseSPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseSPCDefaultTypeInternal() {}
  union {
    PhaseSPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseSPCDefaultTypeInternal _PhaseSPC_default_instance_;
PROTOBUF_CONSTEXPR PhaseSPS::PhaseSPS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.phs3_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PhaseSPSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhaseSPSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhaseSPSDefaultTypeInternal() {}
  union {
    PhaseSPS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhaseSPSDefaultTypeInternal _PhaseSPS_default_instance_;
PROTOBUF_CONSTEXPR PMG::PMG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.net_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PMGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PMGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PMGDefaultTypeInternal() {}
  union {
    PMG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PMGDefaultTypeInternal _PMG_default_instance_;
PROTOBUF_CONSTEXPR RampRate::RampRate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.negativereactivepowerkvarpermin_)*/nullptr
  , /*decltype(_impl_.negativerealpowerkwpermin_)*/nullptr
  , /*decltype(_impl_.positivereactivepowerkvarpermin_)*/nullptr
  , /*decltype(_impl_.positiverealpowerkwpermin_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RampRateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RampRateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RampRateDefaultTypeInternal() {}
  union {
    RampRate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RampRateDefaultTypeInternal _RampRate_default_instance_;
PROTOBUF_CONSTEXPR ReadingMessageInfo::ReadingMessageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messageinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadingMessageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadingMessageInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadingMessageInfoDefaultTypeInternal() {}
  union {
    ReadingMessageInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadingMessageInfoDefaultTypeInternal _ReadingMessageInfo_default_instance_;
PROTOBUF_CONSTEXPR ReadingMMTR::ReadingMMTR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.dmdvah_)*/nullptr
  , /*decltype(_impl_.dmdvarh_)*/nullptr
  , /*decltype(_impl_.dmdwh_)*/nullptr
  , /*decltype(_impl_.supvah_)*/nullptr
  , /*decltype(_impl_.supvarh_)*/nullptr
  , /*decltype(_impl_.supwh_)*/nullptr
  , /*decltype(_impl_.totvah_)*/nullptr
  , /*decltype(_impl_.totvarh_)*/nullptr
  , /*decltype(_impl_.totwh_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadingMMTRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadingMMTRDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadingMMTRDefaultTypeInternal() {}
  union {
    ReadingMMTR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadingMMTRDefaultTypeInternal _ReadingMMTR_default_instance_;
PROTOBUF_CONSTEXPR WYE::WYE(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.net_)*/nullptr
  , /*decltype(_impl_.neut_)*/nullptr
  , /*decltype(_impl_.phsa_)*/nullptr
  , /*decltype(_impl_.phsb_)*/nullptr
  , /*decltype(_impl_.phsc_)*/nullptr
  , /*decltype(_impl_.res_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WYEDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WYEDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WYEDefaultTypeInternal() {}
  union {
    WYE _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WYEDefaultTypeInternal _WYE_default_instance_;
PROTOBUF_CONSTEXPR ReadingMMXU::ReadingMMXU(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.a_)*/nullptr
  , /*decltype(_impl_.clcmth_)*/nullptr
  , /*decltype(_impl_.hz_)*/nullptr
  , /*decltype(_impl_.pf_)*/nullptr
  , /*decltype(_impl_.pfsign_)*/nullptr
  , /*decltype(_impl_.phv_)*/nullptr
  , /*decltype(_impl_.ppv_)*/nullptr
  , /*decltype(_impl_.va_)*/nullptr
  , /*decltype(_impl_.var_)*/nullptr
  , /*decltype(_impl_.w_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadingMMXUDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadingMMXUDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadingMMXUDefaultTypeInternal() {}
  union {
    ReadingMMXU _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadingMMXUDefaultTypeInternal _ReadingMMXU_default_instance_;
PROTOBUF_CONSTEXPR SourceCapabilityConfiguration::SourceCapabilityConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.amax_)*/nullptr
  , /*decltype(_impl_.vamax_)*/nullptr
  , /*decltype(_impl_.varmaxabs_)*/nullptr
  , /*decltype(_impl_.varmaxinj_)*/nullptr
  , /*decltype(_impl_.vmax_)*/nullptr
  , /*decltype(_impl_.vmin_)*/nullptr
  , /*decltype(_impl_.vnom_)*/nullptr
  , /*decltype(_impl_.wmax_)*/nullptr
  , /*decltype(_impl_.wovrext_)*/nullptr
  , /*decltype(_impl_.wovrextpf_)*/nullptr
  , /*decltype(_impl_.wundext_)*/nullptr
  , /*decltype(_impl_.wundextpf_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SourceCapabilityConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SourceCapabilityConfigurationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SourceCapabilityConfigurationDefaultTypeInternal() {}
  union {
    SourceCapabilityConfiguration _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SourceCapabilityConfigurationDefaultTypeInternal _SourceCapabilityConfiguration_default_instance_;
PROTOBUF_CONSTEXPR Optional_NorOpCatKind::Optional_NorOpCatKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_NorOpCatKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_NorOpCatKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_NorOpCatKindDefaultTypeInternal() {}
  union {
    Optional_NorOpCatKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_NorOpCatKindDefaultTypeInternal _Optional_NorOpCatKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_AbnOpCatKind::Optional_AbnOpCatKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_AbnOpCatKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_AbnOpCatKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_AbnOpCatKindDefaultTypeInternal() {}
  union {
    Optional_AbnOpCatKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_AbnOpCatKindDefaultTypeInternal _Optional_AbnOpCatKind_default_instance_;
PROTOBUF_CONSTEXPR SourceCapabilityRatings::SourceCapabilityRatings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.amaxrtg_)*/nullptr
  , /*decltype(_impl_.freqnomrtg_)*/nullptr
  , /*decltype(_impl_.reactsusceptrtg_)*/nullptr
  , /*decltype(_impl_.vamaxrtg_)*/nullptr
  , /*decltype(_impl_.varmaxabsrtg_)*/nullptr
  , /*decltype(_impl_.varmaxinjrtg_)*/nullptr
  , /*decltype(_impl_.vmaxrtg_)*/nullptr
  , /*decltype(_impl_.vminrtg_)*/nullptr
  , /*decltype(_impl_.vnomrtg_)*/nullptr
  , /*decltype(_impl_.wmaxrtg_)*/nullptr
  , /*decltype(_impl_.wovrextrtg_)*/nullptr
  , /*decltype(_impl_.wovrextrtgpf_)*/nullptr
  , /*decltype(_impl_.wundextrtg_)*/nullptr
  , /*decltype(_impl_.wundextrtgpf_)*/nullptr
  , /*decltype(_impl_.abnopcatrtg_)*/ 0

  , /*decltype(_impl_.noropcatrtg_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SourceCapabilityRatingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SourceCapabilityRatingsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SourceCapabilityRatingsDefaultTypeInternal() {}
  union {
    SourceCapabilityRatings _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SourceCapabilityRatingsDefaultTypeInternal _SourceCapabilityRatings_default_instance_;
PROTOBUF_CONSTEXPR StatusAndEventXCBR::StatusAndEventXCBR(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnodeforeventandstatus_)*/nullptr
  , /*decltype(_impl_.dynamictest_)*/nullptr
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.protectionpickup_)*/nullptr
  , /*decltype(_impl_.protectionmode_)*/nullptr
  , /*decltype(_impl_.recloseenabled_)*/nullptr
  , /*decltype(_impl_.reclosingaction_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusAndEventXCBRDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusAndEventXCBRDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusAndEventXCBRDefaultTypeInternal() {}
  union {
    StatusAndEventXCBR _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusAndEventXCBRDefaultTypeInternal _StatusAndEventXCBR_default_instance_;
PROTOBUF_CONSTEXPR StatusINC::StatusINC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusINCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusINCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusINCDefaultTypeInternal() {}
  union {
    StatusINC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusINCDefaultTypeInternal _StatusINC_default_instance_;
PROTOBUF_CONSTEXPR StatusISC::StatusISC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_.stval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusISCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusISCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusISCDefaultTypeInternal() {}
  union {
    StatusISC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusISCDefaultTypeInternal _StatusISC_default_instance_;
PROTOBUF_CONSTEXPR StatusMessageInfo::StatusMessageInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messageinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusMessageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusMessageInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusMessageInfoDefaultTypeInternal() {}
  union {
    StatusMessageInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusMessageInfoDefaultTypeInternal _StatusMessageInfo_default_instance_;
PROTOBUF_CONSTEXPR StatusValue::StatusValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.identifiedobject_)*/nullptr
  , /*decltype(_impl_.modblk_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusValueDefaultTypeInternal() {}
  union {
    StatusValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusValueDefaultTypeInternal _StatusValue_default_instance_;
PROTOBUF_CONSTEXPR VSS::VSS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stval_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.q_)*/nullptr
  , /*decltype(_impl_.t_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VSSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VSSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VSSDefaultTypeInternal() {}
  union {
    VSS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VSSDefaultTypeInternal _VSS_default_instance_;
PROTOBUF_CONSTEXPR StringEventAndStatusGGIO::StringEventAndStatusGGIO(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.logicalnode_)*/nullptr
  , /*decltype(_impl_.phase_)*/nullptr
  , /*decltype(_impl_.strin_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StringEventAndStatusGGIODefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringEventAndStatusGGIODefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringEventAndStatusGGIODefaultTypeInternal() {}
  union {
    StringEventAndStatusGGIO _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringEventAndStatusGGIODefaultTypeInternal _StringEventAndStatusGGIO_default_instance_;
PROTOBUF_CONSTEXPR SwitchPoint::SwitchPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.starttime_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SwitchPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SwitchPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SwitchPointDefaultTypeInternal() {}
  union {
    SwitchPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SwitchPointDefaultTypeInternal _SwitchPoint_default_instance_;
PROTOBUF_CONSTEXPR SwitchCSG::SwitchCSG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.crvpts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SwitchCSGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SwitchCSGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SwitchCSGDefaultTypeInternal() {}
  union {
    SwitchCSG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SwitchCSGDefaultTypeInternal _SwitchCSG_default_instance_;
PROTOBUF_CONSTEXPR TmHzPoint::TmHzPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tmval_)*/nullptr
  , /*decltype(_impl_.hzval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TmHzPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TmHzPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TmHzPointDefaultTypeInternal() {}
  union {
    TmHzPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TmHzPointDefaultTypeInternal _TmHzPoint_default_instance_;
PROTOBUF_CONSTEXPR TmHzCSG::TmHzCSG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.overcrvpts_)*/{}
  , /*decltype(_impl_.undercrvpts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TmHzCSGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TmHzCSGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TmHzCSGDefaultTypeInternal() {}
  union {
    TmHzCSG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TmHzCSGDefaultTypeInternal _TmHzCSG_default_instance_;
PROTOBUF_CONSTEXPR TmVoltPoint::TmVoltPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tmval_)*/nullptr
  , /*decltype(_impl_.voltval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TmVoltPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TmVoltPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TmVoltPointDefaultTypeInternal() {}
  union {
    TmVoltPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TmVoltPointDefaultTypeInternal _TmVoltPoint_default_instance_;
PROTOBUF_CONSTEXPR TmVoltCSG::TmVoltCSG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.overcrvpts_)*/{}
  , /*decltype(_impl_.undercrvpts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TmVoltCSGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TmVoltCSGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TmVoltCSGDefaultTypeInternal() {}
  union {
    TmVoltCSG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TmVoltCSGDefaultTypeInternal _TmVoltCSG_default_instance_;
PROTOBUF_CONSTEXPR VarSPC::VarSPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.varparameter_)*/nullptr
  , /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VarSPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VarSPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VarSPCDefaultTypeInternal() {}
  union {
    VarSPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VarSPCDefaultTypeInternal _VarSPC_default_instance_;
PROTOBUF_CONSTEXPR VoltVarPoint::VoltVarPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.varval_)*/ 0

  , /*decltype(_impl_.voltval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VoltVarPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoltVarPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoltVarPointDefaultTypeInternal() {}
  union {
    VoltVarPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoltVarPointDefaultTypeInternal _VoltVarPoint_default_instance_;
PROTOBUF_CONSTEXPR VoltVarCSG::VoltVarCSG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.crvpts_)*/{}
  , /*decltype(_impl_.vvarparameter_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VoltVarCSGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoltVarCSGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoltVarCSGDefaultTypeInternal() {}
  union {
    VoltVarCSG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoltVarCSGDefaultTypeInternal _VoltVarCSG_default_instance_;
PROTOBUF_CONSTEXPR VoltWPoint::VoltWPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.voltval_)*/ 0

  , /*decltype(_impl_.wval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VoltWPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoltWPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoltWPointDefaultTypeInternal() {}
  union {
    VoltWPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoltWPointDefaultTypeInternal _VoltWPoint_default_instance_;
PROTOBUF_CONSTEXPR VoltWCSG::VoltWCSG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.crvpts_)*/{}
  , /*decltype(_impl_.voltwparameter_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VoltWCSGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoltWCSGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoltWCSGDefaultTypeInternal() {}
  union {
    VoltWCSG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoltWCSGDefaultTypeInternal _VoltWCSG_default_instance_;
PROTOBUF_CONSTEXPR VSC::VSC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ctlval_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VSCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VSCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VSCDefaultTypeInternal() {}
  union {
    VSC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VSCDefaultTypeInternal _VSC_default_instance_;
PROTOBUF_CONSTEXPR WSPC::WSPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wparameter_)*/nullptr
  , /*decltype(_impl_.modena_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WSPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WSPCDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WSPCDefaultTypeInternal() {}
  union {
    WSPC _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WSPCDefaultTypeInternal _WSPC_default_instance_;
PROTOBUF_CONSTEXPR WVarPoint::WVarPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.varval_)*/ 0

  , /*decltype(_impl_.wval_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WVarPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WVarPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WVarPointDefaultTypeInternal() {}
  union {
    WVarPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WVarPointDefaultTypeInternal _WVarPoint_default_instance_;
PROTOBUF_CONSTEXPR WVarCSG::WVarCSG(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.crvpts_)*/{}
  , /*decltype(_impl_.wvarparameter_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WVarCSGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WVarCSGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WVarCSGDefaultTypeInternal() {}
  union {
    WVarCSG _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WVarCSGDefaultTypeInternal _WVarCSG_default_instance_;
PROTOBUF_CONSTEXPR Optional_AlrmKind::Optional_AlrmKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_AlrmKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_AlrmKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_AlrmKindDefaultTypeInternal() {}
  union {
    Optional_AlrmKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_AlrmKindDefaultTypeInternal _Optional_AlrmKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_ControlModeKind::Optional_ControlModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_ControlModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_ControlModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_ControlModeKindDefaultTypeInternal() {}
  union {
    Optional_ControlModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_ControlModeKindDefaultTypeInternal _Optional_ControlModeKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_DirectionModeKind::Optional_DirectionModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_DirectionModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_DirectionModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_DirectionModeKindDefaultTypeInternal() {}
  union {
    Optional_DirectionModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_DirectionModeKindDefaultTypeInternal _Optional_DirectionModeKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_GridConnectionStateKind::Optional_GridConnectionStateKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_GridConnectionStateKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_GridConnectionStateKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_GridConnectionStateKindDefaultTypeInternal() {}
  union {
    Optional_GridConnectionStateKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_GridConnectionStateKindDefaultTypeInternal _Optional_GridConnectionStateKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_OperatingStateKind::Optional_OperatingStateKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_OperatingStateKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_OperatingStateKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_OperatingStateKindDefaultTypeInternal() {}
  union {
    Optional_OperatingStateKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_OperatingStateKindDefaultTypeInternal _Optional_OperatingStateKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_ReactivePowerControlKind::Optional_ReactivePowerControlKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_ReactivePowerControlKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_ReactivePowerControlKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_ReactivePowerControlKindDefaultTypeInternal() {}
  union {
    Optional_ReactivePowerControlKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_ReactivePowerControlKindDefaultTypeInternal _Optional_ReactivePowerControlKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_RealPowerControlKind::Optional_RealPowerControlKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_RealPowerControlKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_RealPowerControlKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_RealPowerControlKindDefaultTypeInternal() {}
  union {
    Optional_RealPowerControlKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_RealPowerControlKindDefaultTypeInternal _Optional_RealPowerControlKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_StateKind::Optional_StateKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_StateKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_StateKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_StateKindDefaultTypeInternal() {}
  union {
    Optional_StateKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_StateKindDefaultTypeInternal _Optional_StateKind_default_instance_;
PROTOBUF_CONSTEXPR Optional_VoltLimitModeKind::Optional_VoltLimitModeKind(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Optional_VoltLimitModeKindDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Optional_VoltLimitModeKindDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Optional_VoltLimitModeKindDefaultTypeInternal() {}
  union {
    Optional_VoltLimitModeKind _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Optional_VoltLimitModeKindDefaultTypeInternal _Optional_VoltLimitModeKind_default_instance_;
}  // namespace commonmodule
static ::_pb::Metadata file_level_metadata_commonmodule_2fcommonmodule_2eproto[156];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[30];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_commonmodule_2fcommonmodule_2eproto = nullptr;
const ::uint32_t TableStruct_commonmodule_2fcommonmodule_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_FaultDirectionKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_FaultDirectionKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_PhaseFaultDirectionKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_PhaseFaultDirectionKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.dirgeneral_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.dirneut_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.dirphsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.dirphsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.dirphsc_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.general_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.neut_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACD, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::IdentifiedObject, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::IdentifiedObject, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::IdentifiedObject, _impl_.mrid_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::IdentifiedObject, _impl_.name_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACDCTerminal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACDCTerminal, _impl_.identifiedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACDCTerminal, _impl_.connected_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ACDCTerminal, _impl_.sequencenumber_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_UnitSymbolKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_UnitSymbolKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_UnitMultiplierKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_UnitMultiplierKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ActivePower, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ActivePower, _impl_.multiplier_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ActivePower, _impl_.unit_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ActivePower, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_PhaseCodeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_PhaseCodeKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Unit, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Unit, _impl_.multiplier_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Unit, _impl_.siunit_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ValidityKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ValidityKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.badreference_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.failure_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.inaccurate_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.inconsistent_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.olddata_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.oscillatory_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.outofrange_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DetailQual, _impl_.overflow_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_SourceKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_SourceKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Quality, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Quality, _impl_.detailqual_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Quality, _impl_.operatorblocked_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Quality, _impl_.source_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Quality, _impl_.test_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Quality, _impl_.validity_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_TimeAccuracyKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_TimeAccuracyKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::TimeQuality, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::TimeQuality, _impl_.clockfailure_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::TimeQuality, _impl_.clocknotsynchronized_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::TimeQuality, _impl_.leapsecondsknown_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::TimeQuality, _impl_.timeaccuracy_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Timestamp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Timestamp, _impl_.seconds_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Timestamp, _impl_.tq_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Timestamp, _impl_.nanoseconds_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::MV, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::MV, _impl_.mag_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::MV, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::MV, _impl_.t_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::MV, _impl_.units_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNode, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNode, _impl_.identifiedobject_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::AnalogEventAndStatusGGIO, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::AnalogEventAndStatusGGIO, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::AnalogEventAndStatusGGIO, _impl_.anin_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::AnalogEventAndStatusGGIO, _impl_.phase_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::NamedObject, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::NamedObject, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::NamedObject, _impl_.name_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ApplicationSystem, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ApplicationSystem, _impl_.namedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ApplicationSystem, _impl_.mrid_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ASG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ASG, _impl_.setmag_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::BCR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::BCR, _impl_.actval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::BCR, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::BCR, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusSPS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusSPS, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusSPS, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusSPS, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::BooleanEventAndStatusGGIO, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::BooleanEventAndStatusGGIO, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::BooleanEventAndStatusGGIO, _impl_.ind_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::BooleanEventAndStatusGGIO, _impl_.phase_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::MessageInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::MessageInfo, _impl_.identifiedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::MessageInfo, _impl_.messagetimestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::CapabilityMessageInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::CapabilityMessageInfo, _impl_.messageinfo_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::CheckConditions, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::CheckConditions, _impl_.interlockcheck_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::CheckConditions, _impl_.synchrocheck_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ClearingTime, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ClearingTime, _impl_.seconds_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ClearingTime, _impl_.nanoseconds_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Vector, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Vector, _impl_.ang_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Vector, _impl_.mag_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::CMV, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::CMV, _impl_.cval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::CMV, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::CMV, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ConductingEquipment, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ConductingEquipment, _impl_.namedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ConductingEquipment, _impl_.mrid_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Terminal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Terminal, _impl_.acdcterminal_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::Terminal, _impl_.phases_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ConductingEquipmentTerminalReading, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ConductingEquipmentTerminalReading, _impl_.terminal_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlAPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlAPC, _impl_.ctlval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlDPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlDPC, _impl_.ctlval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlTimestamp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlTimestamp, _impl_.seconds_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlTimestamp, _impl_.nanoseconds_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ScheduleParameterKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ScheduleParameterKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_ScheduleParameter, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_ScheduleParameter, _impl_.scheduleparametertype_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_ScheduleParameter, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::SchedulePoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::SchedulePoint, _impl_.scheduleparameter_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SchedulePoint, _impl_.starttime_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ScheduleCSG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ScheduleCSG, _impl_.schpts_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlScheduleFSCH, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlScheduleFSCH, _impl_.valacsg_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForControl, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForControl, _impl_.logicalnode_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlFSCC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlFSCC, _impl_.logicalnodeforcontrol_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlFSCC, _impl_.controlschedulefsch_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlFSCC, _impl_.islandcontrolschedulefsch_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlINC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlINC, _impl_.ctlval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlING, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlING, _impl_.setval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlING, _impl_.units_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlISC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlISC, _impl_.ctlval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlMessageInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlMessageInfo, _impl_.messageinfo_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlSPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlSPC, _impl_.ctlval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlValue, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlValue, _impl_.identifiedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlValue, _impl_.modblk_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ControlValue, _impl_.reset_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::CumulativeTime, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::CumulativeTime, _impl_.seconds_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::CumulativeTime, _impl_.nanoseconds_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::DateTimeInterval, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::DateTimeInterval, _impl_.end_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DateTimeInterval, _impl_.start_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::DEL, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::DEL, _impl_.phsab_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DEL, _impl_.phsbc_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DEL, _impl_.phsca_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPC, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPC, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPC, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPC, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::DiscreteControlXCBR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::DiscreteControlXCBR, _impl_.logicalnodeforcontrol_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DiscreteControlXCBR, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DiscreteControlXCBR, _impl_.protectionmode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DiscreteControlXCBR, _impl_.recloseenabled_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::DiscreteControlXCBR, _impl_.resetprotectionpickup_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnergyConsumer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnergyConsumer, _impl_.conductingequipment_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnergyConsumer, _impl_.operatinglimit_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_CalcMethodKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_CalcMethodKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_CalcMethodKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_CalcMethodKind, _impl_.setval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_GridConnectModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_GridConnectModeKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_GridConnectModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_GridConnectModeKind, _impl_.setval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_GridConnectModeKind, _impl_.setvalextension_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_PFSignKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_PFSignKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_PFSignKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENG_PFSignKind, _impl_.setval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_BehaviourModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_BehaviourModeKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_BehaviourModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_BehaviourModeKind, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_BehaviourModeKind, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_BehaviourModeKind, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DERGeneratorStateKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DERGeneratorStateKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DERGeneratorStateKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DERGeneratorStateKind, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DERGeneratorStateKind, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DERGeneratorStateKind, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DynamicTestKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DynamicTestKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DynamicTestKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DynamicTestKind, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DynamicTestKind, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_DynamicTestKind, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_GridConnectModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_GridConnectModeKind, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_GridConnectModeKind, _impl_.stvalextension_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_HealthKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_HealthKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_HealthKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_HealthKind, _impl_.d_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_HealthKind, _impl_.stval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_SwitchingCapabilityKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_SwitchingCapabilityKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_SwitchingCapabilityKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_SwitchingCapabilityKind, _impl_.blkena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ENS_SwitchingCapabilityKind, _impl_.stval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDCTE, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDCTE, _impl_.rnddltmms_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDCTE, _impl_.rtndltmms_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDCTE, _impl_.rtnrmptmms_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnterServiceAPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnterServiceAPC, _impl_.enterserviceparameter_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnterServiceAPC, _impl_.hzhilim_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnterServiceAPC, _impl_.hzlolim_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnterServiceAPC, _impl_.rtnsrvauto_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnterServiceAPC, _impl_.vhilim_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::EnterServiceAPC, _impl_.vlolim_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ESS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ESS, _impl_.conductingequipment_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::EventMessageInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::EventMessageInfo, _impl_.messageinfo_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::EventValue, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::EventValue, _impl_.identifiedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::EventValue, _impl_.modblk_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastValueSource, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastValueSource, _impl_.identifiedobject_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastIED, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastIED, _impl_.forecastvaluesource_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastIED, _impl_.sourceapplicationid_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastIED, _impl_.sourcedatetime_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastValue, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ForecastValue, _impl_.identifiedobject_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDHFW, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDHFW, _impl_.modena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDHFW, _impl_.opltmmsmax_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDLFW, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDLFW, _impl_.modena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDLFW, _impl_.opltmmsmax_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWPoint, _impl_.deadbandhzval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWPoint, _impl_.slopeval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWAPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWAPC, _impl_.overhzwpt_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWAPC, _impl_.overhzwparameter_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWAPC, _impl_.underhzwpt_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::HzWAPC, _impl_.underhzwparameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINS, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINS, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINS, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::IntegerEventAndStatusGGIO, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::IntegerEventAndStatusGGIO, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::IntegerEventAndStatusGGIO, _impl_.intin_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::IntegerEventAndStatusGGIO, _impl_.phase_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWMX, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWMX, _impl_.modena_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWMN, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWMN, _impl_.modena_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::LimitWAPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::LimitWAPC, _impl_.maxlimparameter_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::LimitWAPC, _impl_.minlimparameter_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::LimitWAPC, _impl_.wmaxsptval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::LimitWAPC, _impl_.wminsptval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForEventAndStatus, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForEventAndStatus, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForEventAndStatus, _impl_.beh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForEventAndStatus, _impl_.eehealth_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForEventAndStatus, _impl_.hotlinetag_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::LogicalNodeForEventAndStatus, _impl_.remoteblk_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::MeasurementValue, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::MeasurementValue, _impl_.identifiedobject_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Meter, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Meter, _impl_.conductingequipment_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::NameplateValue, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::NameplateValue, _impl_.identifiedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::NameplateValue, _impl_.model_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::NameplateValue, _impl_.sernum_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::NameplateValue, _impl_.swrev_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::NameplateValue, _impl_.vendor_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDFPF, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDFPF, _impl_.modena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDFPF, _impl_.pfextset_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDFPF, _impl_.pfgntgtmxval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVAR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVAR, _impl_.vartgtspt_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVVR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVVR, _impl_.modena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVVR, _impl_.opltmmsmax_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVVR, _impl_.vref_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVVR, _impl_.vrefadjena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVVR, _impl_.vreftmms_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVWC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVWC, _impl_.modena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDVWC, _impl_.opltmmsmax_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWGC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWGC, _impl_.wspt_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWVR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OperationDWVR, _impl_.modena_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::OptimizationMessageInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::OptimizationMessageInfo, _impl_.messageinfo_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PFSPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PFSPC, _impl_.ctlval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PFSPC, _impl_.pfparameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseAPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseAPC, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseAPC, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseAPC, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseAPC, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DbPosKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DbPosKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusDPS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusDPS, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusDPS, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusDPS, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPS, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPS, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPS, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseDPS, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseINS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseINS, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseINS, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseINS, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseINS, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseISC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseISC, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseISC, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseISC, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseISC, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.dmdvah_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.dmdvarh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.dmdwh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.supvah_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.supvarh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.supwh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.totvah_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.totvarh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTN, _impl_.totwh_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseMMTN, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseMMTN, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseMMTN, _impl_.phsab_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseMMTN, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseMMTN, _impl_.phsbc_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseMMTN, _impl_.phsc_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseMMTN, _impl_.phsca_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_RecloseActionKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_RecloseActionKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseRecloseAction, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseRecloseAction, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseRecloseAction, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseRecloseAction, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseRecloseAction, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPC, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPC, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPC, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPC, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPS, _impl_.phs3_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPS, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPS, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PhaseSPS, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::PMG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::PMG, _impl_.net_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PMG, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PMG, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::PMG, _impl_.phsc_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::RampRate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::RampRate, _impl_.negativereactivepowerkvarpermin_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::RampRate, _impl_.negativerealpowerkwpermin_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::RampRate, _impl_.positivereactivepowerkvarpermin_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::RampRate, _impl_.positiverealpowerkwpermin_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMessageInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMessageInfo, _impl_.messageinfo_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.dmdvah_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.dmdvarh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.dmdwh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.supvah_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.supvarh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.supwh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.totvah_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.totvarh_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMTR, _impl_.totwh_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::WYE, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::WYE, _impl_.net_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WYE, _impl_.neut_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WYE, _impl_.phsa_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WYE, _impl_.phsb_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WYE, _impl_.phsc_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WYE, _impl_.res_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.a_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.clcmth_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.hz_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.pf_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.pfsign_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.phv_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.ppv_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.va_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.var_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::ReadingMMXU, _impl_.w_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.amax_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.vamax_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.varmaxabs_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.varmaxinj_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.vmax_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.vmin_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.vnom_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.wmax_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.wovrext_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.wovrextpf_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.wundext_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityConfiguration, _impl_.wundextpf_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_NorOpCatKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_NorOpCatKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_AbnOpCatKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_AbnOpCatKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.abnopcatrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.amaxrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.freqnomrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.noropcatrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.reactsusceptrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.vamaxrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.varmaxabsrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.varmaxinjrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.vmaxrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.vminrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.vnomrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.wmaxrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.wovrextrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.wovrextrtgpf_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.wundextrtg_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SourceCapabilityRatings, _impl_.wundextrtgpf_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _impl_.logicalnodeforeventandstatus_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _impl_.dynamictest_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _impl_.protectionpickup_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _impl_.protectionmode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _impl_.recloseenabled_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusAndEventXCBR, _impl_.reclosingaction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINC, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINC, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusINC, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusISC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusISC, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusISC, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusISC, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusMessageInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusMessageInfo, _impl_.messageinfo_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusValue, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusValue, _impl_.identifiedobject_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StatusValue, _impl_.modblk_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::VSS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::VSS, _impl_.q_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::VSS, _impl_.stval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::VSS, _impl_.t_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::StringEventAndStatusGGIO, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::StringEventAndStatusGGIO, _impl_.logicalnode_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StringEventAndStatusGGIO, _impl_.phase_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::StringEventAndStatusGGIO, _impl_.strin_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::SwitchPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::SwitchPoint, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::SwitchPoint, _impl_.starttime_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::SwitchCSG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::SwitchCSG, _impl_.crvpts_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmHzPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmHzPoint, _impl_.hzval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmHzPoint, _impl_.tmval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmHzCSG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmHzCSG, _impl_.overcrvpts_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmHzCSG, _impl_.undercrvpts_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmVoltPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmVoltPoint, _impl_.tmval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmVoltPoint, _impl_.voltval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmVoltCSG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmVoltCSG, _impl_.overcrvpts_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::TmVoltCSG, _impl_.undercrvpts_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::VarSPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::VarSPC, _impl_.modena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::VarSPC, _impl_.varparameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltVarPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltVarPoint, _impl_.varval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltVarPoint, _impl_.voltval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltVarCSG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltVarCSG, _impl_.crvpts_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltVarCSG, _impl_.vvarparameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltWPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltWPoint, _impl_.voltval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltWPoint, _impl_.wval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltWCSG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltWCSG, _impl_.crvpts_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::VoltWCSG, _impl_.voltwparameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::VSC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::VSC, _impl_.ctlval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::WSPC, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::WSPC, _impl_.modena_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WSPC, _impl_.wparameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::WVarPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::WVarPoint, _impl_.varval_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WVarPoint, _impl_.wval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::WVarCSG, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::WVarCSG, _impl_.crvpts_),
    PROTOBUF_FIELD_OFFSET(::commonmodule::WVarCSG, _impl_.wvarparameter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_AlrmKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_AlrmKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ControlModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ControlModeKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DirectionModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_DirectionModeKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_GridConnectionStateKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_GridConnectionStateKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_OperatingStateKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_OperatingStateKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ReactivePowerControlKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_ReactivePowerControlKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_RealPowerControlKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_RealPowerControlKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_StateKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_StateKind, _impl_.value_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_VoltLimitModeKind, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::commonmodule::Optional_VoltLimitModeKind, _impl_.value_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::commonmodule::Optional_FaultDirectionKind)},
        { 9, -1, -1, sizeof(::commonmodule::Optional_PhaseFaultDirectionKind)},
        { 18, -1, -1, sizeof(::commonmodule::ACD)},
        { 36, -1, -1, sizeof(::commonmodule::IdentifiedObject)},
        { 47, -1, -1, sizeof(::commonmodule::ACDCTerminal)},
        { 58, -1, -1, sizeof(::commonmodule::Optional_UnitSymbolKind)},
        { 67, -1, -1, sizeof(::commonmodule::Optional_UnitMultiplierKind)},
        { 76, -1, -1, sizeof(::commonmodule::ActivePower)},
        { 87, -1, -1, sizeof(::commonmodule::Optional_PhaseCodeKind)},
        { 96, -1, -1, sizeof(::commonmodule::Unit)},
        { 106, -1, -1, sizeof(::commonmodule::Optional_ValidityKind)},
        { 115, -1, -1, sizeof(::commonmodule::DetailQual)},
        { 131, -1, -1, sizeof(::commonmodule::Optional_SourceKind)},
        { 140, -1, -1, sizeof(::commonmodule::Quality)},
        { 153, -1, -1, sizeof(::commonmodule::Optional_TimeAccuracyKind)},
        { 162, -1, -1, sizeof(::commonmodule::TimeQuality)},
        { 174, -1, -1, sizeof(::commonmodule::Timestamp)},
        { 185, -1, -1, sizeof(::commonmodule::MV)},
        { 197, -1, -1, sizeof(::commonmodule::LogicalNode)},
        { 206, -1, -1, sizeof(::commonmodule::AnalogEventAndStatusGGIO)},
        { 217, -1, -1, sizeof(::commonmodule::NamedObject)},
        { 227, -1, -1, sizeof(::commonmodule::ApplicationSystem)},
        { 237, -1, -1, sizeof(::commonmodule::ASG)},
        { 246, -1, -1, sizeof(::commonmodule::BCR)},
        { 257, -1, -1, sizeof(::commonmodule::StatusSPS)},
        { 268, -1, -1, sizeof(::commonmodule::BooleanEventAndStatusGGIO)},
        { 279, -1, -1, sizeof(::commonmodule::MessageInfo)},
        { 289, -1, -1, sizeof(::commonmodule::CapabilityMessageInfo)},
        { 298, -1, -1, sizeof(::commonmodule::CheckConditions)},
        { 308, -1, -1, sizeof(::commonmodule::ClearingTime)},
        { 318, -1, -1, sizeof(::commonmodule::Vector)},
        { 328, -1, -1, sizeof(::commonmodule::CMV)},
        { 339, -1, -1, sizeof(::commonmodule::ConductingEquipment)},
        { 349, -1, -1, sizeof(::commonmodule::Terminal)},
        { 359, -1, -1, sizeof(::commonmodule::ConductingEquipmentTerminalReading)},
        { 368, -1, -1, sizeof(::commonmodule::ControlAPC)},
        { 377, -1, -1, sizeof(::commonmodule::ControlDPC)},
        { 386, -1, -1, sizeof(::commonmodule::ControlTimestamp)},
        { 396, -1, -1, sizeof(::commonmodule::Optional_ScheduleParameterKind)},
        { 405, -1, -1, sizeof(::commonmodule::ENG_ScheduleParameter)},
        { 415, -1, -1, sizeof(::commonmodule::SchedulePoint)},
        { 425, -1, -1, sizeof(::commonmodule::ScheduleCSG)},
        { 434, -1, -1, sizeof(::commonmodule::ControlScheduleFSCH)},
        { 443, -1, -1, sizeof(::commonmodule::LogicalNodeForControl)},
        { 452, -1, -1, sizeof(::commonmodule::ControlFSCC)},
        { 463, -1, -1, sizeof(::commonmodule::ControlINC)},
        { 472, -1, -1, sizeof(::commonmodule::ControlING)},
        { 482, -1, -1, sizeof(::commonmodule::ControlISC)},
        { 491, -1, -1, sizeof(::commonmodule::ControlMessageInfo)},
        { 500, -1, -1, sizeof(::commonmodule::ControlSPC)},
        { 509, -1, -1, sizeof(::commonmodule::ControlValue)},
        { 520, -1, -1, sizeof(::commonmodule::CumulativeTime)},
        { 530, -1, -1, sizeof(::commonmodule::DateTimeInterval)},
        { 540, -1, -1, sizeof(::commonmodule::DEL)},
        { 551, -1, -1, sizeof(::commonmodule::PhaseDPC)},
        { 563, -1, -1, sizeof(::commonmodule::DiscreteControlXCBR)},
        { 576, -1, -1, sizeof(::commonmodule::EnergyConsumer)},
        { 586, -1, -1, sizeof(::commonmodule::Optional_CalcMethodKind)},
        { 595, -1, -1, sizeof(::commonmodule::ENG_CalcMethodKind)},
        { 604, -1, -1, sizeof(::commonmodule::Optional_GridConnectModeKind)},
        { 613, -1, -1, sizeof(::commonmodule::ENG_GridConnectModeKind)},
        { 623, -1, -1, sizeof(::commonmodule::Optional_PFSignKind)},
        { 632, -1, -1, sizeof(::commonmodule::ENG_PFSignKind)},
        { 641, -1, -1, sizeof(::commonmodule::Optional_BehaviourModeKind)},
        { 650, -1, -1, sizeof(::commonmodule::ENS_BehaviourModeKind)},
        { 661, -1, -1, sizeof(::commonmodule::Optional_DERGeneratorStateKind)},
        { 670, -1, -1, sizeof(::commonmodule::ENS_DERGeneratorStateKind)},
        { 681, -1, -1, sizeof(::commonmodule::Optional_DynamicTestKind)},
        { 690, -1, -1, sizeof(::commonmodule::ENS_DynamicTestKind)},
        { 701, -1, -1, sizeof(::commonmodule::ENS_GridConnectModeKind)},
        { 711, -1, -1, sizeof(::commonmodule::Optional_HealthKind)},
        { 720, -1, -1, sizeof(::commonmodule::ENS_HealthKind)},
        { 730, -1, -1, sizeof(::commonmodule::Optional_SwitchingCapabilityKind)},
        { 739, -1, -1, sizeof(::commonmodule::ENS_SwitchingCapabilityKind)},
        { 749, -1, -1, sizeof(::commonmodule::OperationDCTE)},
        { 760, -1, -1, sizeof(::commonmodule::EnterServiceAPC)},
        { 774, -1, -1, sizeof(::commonmodule::ESS)},
        { 783, -1, -1, sizeof(::commonmodule::EventMessageInfo)},
        { 792, -1, -1, sizeof(::commonmodule::EventValue)},
        { 802, -1, -1, sizeof(::commonmodule::ForecastValueSource)},
        { 811, -1, -1, sizeof(::commonmodule::ForecastIED)},
        { 822, -1, -1, sizeof(::commonmodule::ForecastValue)},
        { 831, -1, -1, sizeof(::commonmodule::OperationDHFW)},
        { 841, -1, -1, sizeof(::commonmodule::OperationDLFW)},
        { 851, -1, -1, sizeof(::commonmodule::HzWPoint)},
        { 861, -1, -1, sizeof(::commonmodule::HzWAPC)},
        { 873, -1, -1, sizeof(::commonmodule::StatusINS)},
        { 884, -1, -1, sizeof(::commonmodule::IntegerEventAndStatusGGIO)},
        { 895, -1, -1, sizeof(::commonmodule::OperationDWMX)},
        { 904, -1, -1, sizeof(::commonmodule::OperationDWMN)},
        { 913, -1, -1, sizeof(::commonmodule::LimitWAPC)},
        { 925, -1, -1, sizeof(::commonmodule::LogicalNodeForEventAndStatus)},
        { 938, -1, -1, sizeof(::commonmodule::MeasurementValue)},
        { 947, -1, -1, sizeof(::commonmodule::Meter)},
        { 956, -1, -1, sizeof(::commonmodule::NameplateValue)},
        { 969, -1, -1, sizeof(::commonmodule::OperationDFPF)},
        { 980, -1, -1, sizeof(::commonmodule::OperationDVAR)},
        { 989, -1, -1, sizeof(::commonmodule::OperationDVVR)},
        { 1002, -1, -1, sizeof(::commonmodule::OperationDVWC)},
        { 1012, -1, -1, sizeof(::commonmodule::OperationDWGC)},
        { 1021, -1, -1, sizeof(::commonmodule::OperationDWVR)},
        { 1030, -1, -1, sizeof(::commonmodule::OptimizationMessageInfo)},
        { 1039, -1, -1, sizeof(::commonmodule::PFSPC)},
        { 1049, -1, -1, sizeof(::commonmodule::PhaseAPC)},
        { 1061, -1, -1, sizeof(::commonmodule::Optional_DbPosKind)},
        { 1070, -1, -1, sizeof(::commonmodule::StatusDPS)},
        { 1081, -1, -1, sizeof(::commonmodule::PhaseDPS)},
        { 1093, -1, -1, sizeof(::commonmodule::PhaseINS)},
        { 1105, -1, -1, sizeof(::commonmodule::PhaseISC)},
        { 1117, -1, -1, sizeof(::commonmodule::ReadingMMTN)},
        { 1135, -1, -1, sizeof(::commonmodule::PhaseMMTN)},
        { 1149, -1, -1, sizeof(::commonmodule::Optional_RecloseActionKind)},
        { 1158, -1, -1, sizeof(::commonmodule::PhaseRecloseAction)},
        { 1170, -1, -1, sizeof(::commonmodule::PhaseSPC)},
        { 1182, -1, -1, sizeof(::commonmodule::PhaseSPS)},
        { 1194, -1, -1, sizeof(::commonmodule::PMG)},
        { 1206, -1, -1, sizeof(::commonmodule::RampRate)},
        { 1218, -1, -1, sizeof(::commonmodule::ReadingMessageInfo)},
        { 1227, -1, -1, sizeof(::commonmodule::ReadingMMTR)},
        { 1245, -1, -1, sizeof(::commonmodule::WYE)},
        { 1259, -1, -1, sizeof(::commonmodule::ReadingMMXU)},
        { 1278, -1, -1, sizeof(::commonmodule::SourceCapabilityConfiguration)},
        { 1299, -1, -1, sizeof(::commonmodule::Optional_NorOpCatKind)},
        { 1308, -1, -1, sizeof(::commonmodule::Optional_AbnOpCatKind)},
        { 1317, -1, -1, sizeof(::commonmodule::SourceCapabilityRatings)},
        { 1342, -1, -1, sizeof(::commonmodule::StatusAndEventXCBR)},
        { 1357, -1, -1, sizeof(::commonmodule::StatusINC)},
        { 1368, -1, -1, sizeof(::commonmodule::StatusISC)},
        { 1379, -1, -1, sizeof(::commonmodule::StatusMessageInfo)},
        { 1388, -1, -1, sizeof(::commonmodule::StatusValue)},
        { 1398, -1, -1, sizeof(::commonmodule::VSS)},
        { 1409, -1, -1, sizeof(::commonmodule::StringEventAndStatusGGIO)},
        { 1420, -1, -1, sizeof(::commonmodule::SwitchPoint)},
        { 1430, -1, -1, sizeof(::commonmodule::SwitchCSG)},
        { 1439, -1, -1, sizeof(::commonmodule::TmHzPoint)},
        { 1449, -1, -1, sizeof(::commonmodule::TmHzCSG)},
        { 1459, -1, -1, sizeof(::commonmodule::TmVoltPoint)},
        { 1469, -1, -1, sizeof(::commonmodule::TmVoltCSG)},
        { 1479, -1, -1, sizeof(::commonmodule::VarSPC)},
        { 1489, -1, -1, sizeof(::commonmodule::VoltVarPoint)},
        { 1499, -1, -1, sizeof(::commonmodule::VoltVarCSG)},
        { 1509, -1, -1, sizeof(::commonmodule::VoltWPoint)},
        { 1519, -1, -1, sizeof(::commonmodule::VoltWCSG)},
        { 1529, -1, -1, sizeof(::commonmodule::VSC)},
        { 1538, -1, -1, sizeof(::commonmodule::WSPC)},
        { 1548, -1, -1, sizeof(::commonmodule::WVarPoint)},
        { 1558, -1, -1, sizeof(::commonmodule::WVarCSG)},
        { 1568, -1, -1, sizeof(::commonmodule::Optional_AlrmKind)},
        { 1577, -1, -1, sizeof(::commonmodule::Optional_ControlModeKind)},
        { 1586, -1, -1, sizeof(::commonmodule::Optional_DirectionModeKind)},
        { 1595, -1, -1, sizeof(::commonmodule::Optional_GridConnectionStateKind)},
        { 1604, -1, -1, sizeof(::commonmodule::Optional_OperatingStateKind)},
        { 1613, -1, -1, sizeof(::commonmodule::Optional_ReactivePowerControlKind)},
        { 1622, -1, -1, sizeof(::commonmodule::Optional_RealPowerControlKind)},
        { 1631, -1, -1, sizeof(::commonmodule::Optional_StateKind)},
        { 1640, -1, -1, sizeof(::commonmodule::Optional_VoltLimitModeKind)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::commonmodule::_Optional_FaultDirectionKind_default_instance_._instance,
    &::commonmodule::_Optional_PhaseFaultDirectionKind_default_instance_._instance,
    &::commonmodule::_ACD_default_instance_._instance,
    &::commonmodule::_IdentifiedObject_default_instance_._instance,
    &::commonmodule::_ACDCTerminal_default_instance_._instance,
    &::commonmodule::_Optional_UnitSymbolKind_default_instance_._instance,
    &::commonmodule::_Optional_UnitMultiplierKind_default_instance_._instance,
    &::commonmodule::_ActivePower_default_instance_._instance,
    &::commonmodule::_Optional_PhaseCodeKind_default_instance_._instance,
    &::commonmodule::_Unit_default_instance_._instance,
    &::commonmodule::_Optional_ValidityKind_default_instance_._instance,
    &::commonmodule::_DetailQual_default_instance_._instance,
    &::commonmodule::_Optional_SourceKind_default_instance_._instance,
    &::commonmodule::_Quality_default_instance_._instance,
    &::commonmodule::_Optional_TimeAccuracyKind_default_instance_._instance,
    &::commonmodule::_TimeQuality_default_instance_._instance,
    &::commonmodule::_Timestamp_default_instance_._instance,
    &::commonmodule::_MV_default_instance_._instance,
    &::commonmodule::_LogicalNode_default_instance_._instance,
    &::commonmodule::_AnalogEventAndStatusGGIO_default_instance_._instance,
    &::commonmodule::_NamedObject_default_instance_._instance,
    &::commonmodule::_ApplicationSystem_default_instance_._instance,
    &::commonmodule::_ASG_default_instance_._instance,
    &::commonmodule::_BCR_default_instance_._instance,
    &::commonmodule::_StatusSPS_default_instance_._instance,
    &::commonmodule::_BooleanEventAndStatusGGIO_default_instance_._instance,
    &::commonmodule::_MessageInfo_default_instance_._instance,
    &::commonmodule::_CapabilityMessageInfo_default_instance_._instance,
    &::commonmodule::_CheckConditions_default_instance_._instance,
    &::commonmodule::_ClearingTime_default_instance_._instance,
    &::commonmodule::_Vector_default_instance_._instance,
    &::commonmodule::_CMV_default_instance_._instance,
    &::commonmodule::_ConductingEquipment_default_instance_._instance,
    &::commonmodule::_Terminal_default_instance_._instance,
    &::commonmodule::_ConductingEquipmentTerminalReading_default_instance_._instance,
    &::commonmodule::_ControlAPC_default_instance_._instance,
    &::commonmodule::_ControlDPC_default_instance_._instance,
    &::commonmodule::_ControlTimestamp_default_instance_._instance,
    &::commonmodule::_Optional_ScheduleParameterKind_default_instance_._instance,
    &::commonmodule::_ENG_ScheduleParameter_default_instance_._instance,
    &::commonmodule::_SchedulePoint_default_instance_._instance,
    &::commonmodule::_ScheduleCSG_default_instance_._instance,
    &::commonmodule::_ControlScheduleFSCH_default_instance_._instance,
    &::commonmodule::_LogicalNodeForControl_default_instance_._instance,
    &::commonmodule::_ControlFSCC_default_instance_._instance,
    &::commonmodule::_ControlINC_default_instance_._instance,
    &::commonmodule::_ControlING_default_instance_._instance,
    &::commonmodule::_ControlISC_default_instance_._instance,
    &::commonmodule::_ControlMessageInfo_default_instance_._instance,
    &::commonmodule::_ControlSPC_default_instance_._instance,
    &::commonmodule::_ControlValue_default_instance_._instance,
    &::commonmodule::_CumulativeTime_default_instance_._instance,
    &::commonmodule::_DateTimeInterval_default_instance_._instance,
    &::commonmodule::_DEL_default_instance_._instance,
    &::commonmodule::_PhaseDPC_default_instance_._instance,
    &::commonmodule::_DiscreteControlXCBR_default_instance_._instance,
    &::commonmodule::_EnergyConsumer_default_instance_._instance,
    &::commonmodule::_Optional_CalcMethodKind_default_instance_._instance,
    &::commonmodule::_ENG_CalcMethodKind_default_instance_._instance,
    &::commonmodule::_Optional_GridConnectModeKind_default_instance_._instance,
    &::commonmodule::_ENG_GridConnectModeKind_default_instance_._instance,
    &::commonmodule::_Optional_PFSignKind_default_instance_._instance,
    &::commonmodule::_ENG_PFSignKind_default_instance_._instance,
    &::commonmodule::_Optional_BehaviourModeKind_default_instance_._instance,
    &::commonmodule::_ENS_BehaviourModeKind_default_instance_._instance,
    &::commonmodule::_Optional_DERGeneratorStateKind_default_instance_._instance,
    &::commonmodule::_ENS_DERGeneratorStateKind_default_instance_._instance,
    &::commonmodule::_Optional_DynamicTestKind_default_instance_._instance,
    &::commonmodule::_ENS_DynamicTestKind_default_instance_._instance,
    &::commonmodule::_ENS_GridConnectModeKind_default_instance_._instance,
    &::commonmodule::_Optional_HealthKind_default_instance_._instance,
    &::commonmodule::_ENS_HealthKind_default_instance_._instance,
    &::commonmodule::_Optional_SwitchingCapabilityKind_default_instance_._instance,
    &::commonmodule::_ENS_SwitchingCapabilityKind_default_instance_._instance,
    &::commonmodule::_OperationDCTE_default_instance_._instance,
    &::commonmodule::_EnterServiceAPC_default_instance_._instance,
    &::commonmodule::_ESS_default_instance_._instance,
    &::commonmodule::_EventMessageInfo_default_instance_._instance,
    &::commonmodule::_EventValue_default_instance_._instance,
    &::commonmodule::_ForecastValueSource_default_instance_._instance,
    &::commonmodule::_ForecastIED_default_instance_._instance,
    &::commonmodule::_ForecastValue_default_instance_._instance,
    &::commonmodule::_OperationDHFW_default_instance_._instance,
    &::commonmodule::_OperationDLFW_default_instance_._instance,
    &::commonmodule::_HzWPoint_default_instance_._instance,
    &::commonmodule::_HzWAPC_default_instance_._instance,
    &::commonmodule::_StatusINS_default_instance_._instance,
    &::commonmodule::_IntegerEventAndStatusGGIO_default_instance_._instance,
    &::commonmodule::_OperationDWMX_default_instance_._instance,
    &::commonmodule::_OperationDWMN_default_instance_._instance,
    &::commonmodule::_LimitWAPC_default_instance_._instance,
    &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_._instance,
    &::commonmodule::_MeasurementValue_default_instance_._instance,
    &::commonmodule::_Meter_default_instance_._instance,
    &::commonmodule::_NameplateValue_default_instance_._instance,
    &::commonmodule::_OperationDFPF_default_instance_._instance,
    &::commonmodule::_OperationDVAR_default_instance_._instance,
    &::commonmodule::_OperationDVVR_default_instance_._instance,
    &::commonmodule::_OperationDVWC_default_instance_._instance,
    &::commonmodule::_OperationDWGC_default_instance_._instance,
    &::commonmodule::_OperationDWVR_default_instance_._instance,
    &::commonmodule::_OptimizationMessageInfo_default_instance_._instance,
    &::commonmodule::_PFSPC_default_instance_._instance,
    &::commonmodule::_PhaseAPC_default_instance_._instance,
    &::commonmodule::_Optional_DbPosKind_default_instance_._instance,
    &::commonmodule::_StatusDPS_default_instance_._instance,
    &::commonmodule::_PhaseDPS_default_instance_._instance,
    &::commonmodule::_PhaseINS_default_instance_._instance,
    &::commonmodule::_PhaseISC_default_instance_._instance,
    &::commonmodule::_ReadingMMTN_default_instance_._instance,
    &::commonmodule::_PhaseMMTN_default_instance_._instance,
    &::commonmodule::_Optional_RecloseActionKind_default_instance_._instance,
    &::commonmodule::_PhaseRecloseAction_default_instance_._instance,
    &::commonmodule::_PhaseSPC_default_instance_._instance,
    &::commonmodule::_PhaseSPS_default_instance_._instance,
    &::commonmodule::_PMG_default_instance_._instance,
    &::commonmodule::_RampRate_default_instance_._instance,
    &::commonmodule::_ReadingMessageInfo_default_instance_._instance,
    &::commonmodule::_ReadingMMTR_default_instance_._instance,
    &::commonmodule::_WYE_default_instance_._instance,
    &::commonmodule::_ReadingMMXU_default_instance_._instance,
    &::commonmodule::_SourceCapabilityConfiguration_default_instance_._instance,
    &::commonmodule::_Optional_NorOpCatKind_default_instance_._instance,
    &::commonmodule::_Optional_AbnOpCatKind_default_instance_._instance,
    &::commonmodule::_SourceCapabilityRatings_default_instance_._instance,
    &::commonmodule::_StatusAndEventXCBR_default_instance_._instance,
    &::commonmodule::_StatusINC_default_instance_._instance,
    &::commonmodule::_StatusISC_default_instance_._instance,
    &::commonmodule::_StatusMessageInfo_default_instance_._instance,
    &::commonmodule::_StatusValue_default_instance_._instance,
    &::commonmodule::_VSS_default_instance_._instance,
    &::commonmodule::_StringEventAndStatusGGIO_default_instance_._instance,
    &::commonmodule::_SwitchPoint_default_instance_._instance,
    &::commonmodule::_SwitchCSG_default_instance_._instance,
    &::commonmodule::_TmHzPoint_default_instance_._instance,
    &::commonmodule::_TmHzCSG_default_instance_._instance,
    &::commonmodule::_TmVoltPoint_default_instance_._instance,
    &::commonmodule::_TmVoltCSG_default_instance_._instance,
    &::commonmodule::_VarSPC_default_instance_._instance,
    &::commonmodule::_VoltVarPoint_default_instance_._instance,
    &::commonmodule::_VoltVarCSG_default_instance_._instance,
    &::commonmodule::_VoltWPoint_default_instance_._instance,
    &::commonmodule::_VoltWCSG_default_instance_._instance,
    &::commonmodule::_VSC_default_instance_._instance,
    &::commonmodule::_WSPC_default_instance_._instance,
    &::commonmodule::_WVarPoint_default_instance_._instance,
    &::commonmodule::_WVarCSG_default_instance_._instance,
    &::commonmodule::_Optional_AlrmKind_default_instance_._instance,
    &::commonmodule::_Optional_ControlModeKind_default_instance_._instance,
    &::commonmodule::_Optional_DirectionModeKind_default_instance_._instance,
    &::commonmodule::_Optional_GridConnectionStateKind_default_instance_._instance,
    &::commonmodule::_Optional_OperatingStateKind_default_instance_._instance,
    &::commonmodule::_Optional_ReactivePowerControlKind_default_instance_._instance,
    &::commonmodule::_Optional_RealPowerControlKind_default_instance_._instance,
    &::commonmodule::_Optional_StateKind_default_instance_._instance,
    &::commonmodule::_Optional_VoltLimitModeKind_default_instance_._instance,
};
const char descriptor_table_protodef_commonmodule_2fcommonmodule_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\037commonmodule/commonmodule.proto\022\014commo"
    "nmodule\032\tuml.proto\032\036google/protobuf/wrap"
    "pers.proto\"N\n\033Optional_FaultDirectionKin"
    "d\022/\n\005value\030\001 \001(\0162 .commonmodule.FaultDir"
    "ectionKind\"X\n Optional_PhaseFaultDirecti"
    "onKind\0224\n\005value\030\001 \001(\0162%.commonmodule.Pha"
    "seFaultDirectionKind\"\214\004\n\003ACD\022>\n\ndirGener"
    "al\030\001 \001(\0162 .commonmodule.FaultDirectionKi"
    "ndB\010\210\265\030\001\220\265\030\001\022\?\n\007dirNeut\030\002 \001(\0132..commonmo"
    "dule.Optional_PhaseFaultDirectionKind\022\?\n"
    "\007dirPhsA\030\003 \001(\0132..commonmodule.Optional_P"
    "haseFaultDirectionKind\022\?\n\007dirPhsB\030\004 \001(\0132"
    "..commonmodule.Optional_PhaseFaultDirect"
    "ionKind\022\?\n\007dirPhsC\030\005 \001(\0132..commonmodule."
    "Optional_PhaseFaultDirectionKind\022\031\n\007gene"
    "ral\030\006 \001(\010B\010\210\265\030\001\220\265\030\001\022(\n\004neut\030\007 \001(\0132\032.goog"
    "le.protobuf.BoolValue\022(\n\004phsA\030\010 \001(\0132\032.go"
    "ogle.protobuf.BoolValue\022(\n\004phsB\030\t \001(\0132\032."
    "google.protobuf.BoolValue\022(\n\004phsC\030\n \001(\0132"
    "\032.google.protobuf.BoolValue\"\243\001\n\020Identifi"
    "edObject\0221\n\013description\030\001 \001(\0132\034.google.p"
    "rotobuf.StringValue\0220\n\004mRID\030\002 \001(\0132\034.goog"
    "le.protobuf.StringValueB\004\240\265\030\001\022*\n\004name\030\003 "
    "\001(\0132\034.google.protobuf.StringValue\"\262\001\n\014AC"
    "DCTerminal\022>\n\020identifiedObject\030\001 \001(\0132\036.c"
    "ommonmodule.IdentifiedObjectB\004\200\265\030\001\022-\n\tco"
    "nnected\030\002 \001(\0132\032.google.protobuf.BoolValu"
    "e\0223\n\016sequenceNumber\030\003 \001(\0132\033.google.proto"
    "buf.Int32Value\"F\n\027Optional_UnitSymbolKin"
    "d\022+\n\005value\030\001 \001(\0162\034.commonmodule.UnitSymb"
    "olKind\"N\n\033Optional_UnitMultiplierKind\022/\n"
    "\005value\030\001 \001(\0162 .commonmodule.UnitMultipli"
    "erKind\"\255\001\n\013ActivePower\022=\n\nmultiplier\030\001 \001"
    "(\0132).commonmodule.Optional_UnitMultiplie"
    "rKind\0223\n\004unit\030\002 \001(\0132%.commonmodule.Optio"
    "nal_UnitSymbolKind\022*\n\005value\030\003 \001(\0132\033.goog"
    "le.protobuf.FloatValue\"D\n\026Optional_Phase"
    "CodeKind\022*\n\005value\030\001 \001(\0162\033.commonmodule.P"
    "haseCodeKind\"}\n\004Unit\022=\n\nmultiplier\030\001 \001(\013"
    "2).commonmodule.Optional_UnitMultiplierK"
    "ind\0226\n\006SIUnit\030\002 \001(\0162\034.commonmodule.UnitS"
    "ymbolKindB\010\210\265\030\001\220\265\030\001\"B\n\025Optional_Validity"
    "Kind\022)\n\005value\030\001 \001(\0162\032.commonmodule.Valid"
    "ityKind\"\371\001\n\nDetailQual\022\036\n\014badReference\030\001"
    " \001(\010B\010\210\265\030\001\220\265\030\001\022\031\n\007failure\030\002 \001(\010B\010\210\265\030\001\220\265\030"
    "\001\022\034\n\ninaccurate\030\003 \001(\010B\010\210\265\030\001\220\265\030\001\022\036\n\014incon"
    "sistent\030\004 \001(\010B\010\210\265\030\001\220\265\030\001\022\031\n\007oldData\030\005 \001(\010"
    "B\010\210\265\030\001\220\265\030\001\022\035\n\013oscillatory\030\006 \001(\010B\010\210\265\030\001\220\265\030"
    "\001\022\034\n\noutOfRange\030\007 \001(\010B\010\210\265\030\001\220\265\030\001\022\032\n\010overf"
    "low\030\010 \001(\010B\010\210\265\030\001\220\265\030\001\">\n\023Optional_SourceKi"
    "nd\022\'\n\005value\030\001 \001(\0162\030.commonmodule.SourceK"
    "ind\"\350\001\n\007Quality\0226\n\ndetailQual\030\001 \001(\0132\030.co"
    "mmonmodule.DetailQualB\010\210\265\030\001\220\265\030\001\022!\n\017opera"
    "torBlocked\030\002 \001(\010B\010\210\265\030\001\220\265\030\001\0222\n\006source\030\003 \001"
    "(\0162\030.commonmodule.SourceKindB\010\210\265\030\001\220\265\030\001\022\026"
    "\n\004test\030\004 \001(\010B\010\210\265\030\001\220\265\030\001\0226\n\010validity\030\005 \001(\016"
    "2\032.commonmodule.ValidityKindB\010\210\265\030\001\220\265\030\001\"J"
    "\n\031Optional_TimeAccuracyKind\022-\n\005value\030\001 \001"
    "(\0162\036.commonmodule.TimeAccuracyKind\"\271\001\n\013T"
    "imeQuality\022\036\n\014clockFailure\030\001 \001(\010B\010\210\265\030\001\220\265"
    "\030\001\022&\n\024clockNotSynchronized\030\002 \001(\010B\010\210\265\030\001\220\265"
    "\030\001\022\"\n\020leapSecondsKnown\030\003 \001(\010B\010\210\265\030\001\220\265\030\001\022>"
    "\n\014timeAccuracy\030\004 \001(\0162\036.commonmodule.Time"
    "AccuracyKindB\010\210\265\030\001\220\265\030\001\"r\n\tTimestamp\022\031\n\007s"
    "econds\030\002 \001(\004B\010\210\265\030\001\220\265\030\001\022%\n\002tq\030\003 \001(\0132\031.com"
    "monmodule.TimeQuality\022\035\n\013nanoseconds\030\004 \001"
    "(\rB\010\210\265\030\001\220\265\030\001J\004\010\001\020\002\"\204\001\n\002MV\022\025\n\003mag\030\001 \001(\001B\010"
    "\210\265\030\001\220\265\030\001\022 \n\001q\030\002 \001(\0132\025.commonmodule.Quali"
    "ty\022\"\n\001t\030\003 \001(\0132\027.commonmodule.Timestamp\022!"
    "\n\005units\030\004 \001(\0132\022.commonmodule.Unit\"M\n\013Log"
    "icalNode\022>\n\020identifiedObject\030\001 \001(\0132\036.com"
    "monmodule.IdentifiedObjectB\004\200\265\030\001\"\257\001\n\030Ana"
    "logEventAndStatusGGIO\0224\n\013logicalNode\030\001 \001"
    "(\0132\031.commonmodule.LogicalNodeB\004\200\265\030\001\022(\n\004A"
    "nIn\030\002 \001(\0132\020.commonmodule.MVB\010\210\265\030\001\220\265\030\001\0223\n"
    "\005Phase\030\003 \001(\0132$.commonmodule.Optional_Pha"
    "seCodeKind\"l\n\013NamedObject\0221\n\013description"
    "\030\001 \001(\0132\034.google.protobuf.StringValue\022*\n\004"
    "name\030\002 \001(\0132\034.google.protobuf.StringValue"
    "\"e\n\021ApplicationSystem\0224\n\013namedObject\030\001 \001"
    "(\0132\031.commonmodule.NamedObjectB\004\200\265\030\001\022\032\n\004m"
    "RID\030\002 \001(\tB\014\210\265\030\001\220\265\030\001\240\265\030\001\"\037\n\003ASG\022\030\n\006setMag"
    "\030\001 \001(\001B\010\210\265\030\001\220\265\030\001\"k\n\003BCR\022\030\n\006actVal\030\001 \001(\003B"
    "\010\210\265\030\001\220\265\030\001\022 \n\001q\030\002 \001(\0132\025.commonmodule.Qual"
    "ity\022\"\n\001t\030\003 \001(\0132\027.commonmodule.TimestampJ"
    "\004\010\004\020\005\"j\n\tStatusSPS\022 \n\001q\030\001 \001(\0132\025.commonmo"
    "dule.Quality\022\027\n\005stVal\030\002 \001(\010B\010\210\265\030\001\220\265\030\001\022\"\n"
    "\001t\030\003 \001(\0132\027.commonmodule.Timestamp\"\266\001\n\031Bo"
    "oleanEventAndStatusGGIO\0224\n\013logicalNode\030\001"
    " \001(\0132\031.commonmodule.LogicalNodeB\004\200\265\030\001\022.\n"
    "\003Ind\030\002 \001(\0132\027.commonmodule.StatusSPSB\010\210\265\030"
    "\001\220\265\030\001\0223\n\005Phase\030\003 \001(\0132$.commonmodule.Opti"
    "onal_PhaseCodeKind\"\212\001\n\013MessageInfo\022>\n\020id"
    "entifiedObject\030\001 \001(\0132\036.commonmodule.Iden"
    "tifiedObjectB\004\200\265\030\001\022;\n\020messageTimeStamp\030\002"
    " \001(\0132\027.commonmodule.TimestampB\010\210\265\030\001\220\265\030\001\""
    "M\n\025CapabilityMessageInfo\0224\n\013messageInfo\030"
    "\001 \001(\0132\031.commonmodule.MessageInfoB\004\200\265\030\001\"w"
    "\n\017CheckConditions\0222\n\016interlockCheck\030\001 \001("
    "\0132\032.google.protobuf.BoolValue\0220\n\014synchro"
    "Check\030\002 \001(\0132\032.google.protobuf.BoolValue\""
    "N\n\014ClearingTime\022\031\n\007seconds\030\002 \001(\004B\010\210\265\030\001\220\265"
    "\030\001\022\035\n\013nanoseconds\030\003 \001(\rB\010\210\265\030\001\220\265\030\001J\004\010\001\020\002\""
    "J\n\006Vector\022)\n\003ang\030\001 \001(\0132\034.google.protobuf"
    ".DoubleValue\022\025\n\003mag\030\002 \001(\001B\010\210\265\030\001\220\265\030\001\"\177\n\003C"
    "MV\022,\n\004cVal\030\001 \001(\0132\024.commonmodule.VectorB\010"
    "\210\265\030\001\220\265\030\001\022 \n\001q\030\002 \001(\0132\025.commonmodule.Quali"
    "ty\022\"\n\001t\030\003 \001(\0132\027.commonmodule.TimestampJ\004"
    "\010\004\020\005\"k\n\023ConductingEquipment\0224\n\013namedObje"
    "ct\030\001 \001(\0132\031.commonmodule.NamedObjectB\004\200\265\030"
    "\001\022\036\n\004mRID\030\002 \001(\tB\020\210\265\030\001\220\265\030\001\240\265\030\001\250\265\030\001\"x\n\010Ter"
    "minal\0226\n\014aCDCTerminal\030\001 \001(\0132\032.commonmodu"
    "le.ACDCTerminalB\004\200\265\030\001\0224\n\006phases\030\002 \001(\0132$."
    "commonmodule.Optional_PhaseCodeKind\"X\n\"C"
    "onductingEquipmentTerminalReading\0222\n\010ter"
    "minal\030\001 \001(\0132\026.commonmodule.TerminalB\010\210\265\030"
    "\001\220\265\030\001\"&\n\nControlAPC\022\030\n\006ctlVal\030\001 \001(\001B\010\210\265\030"
    "\001\220\265\030\001\"&\n\nControlDPC\022\030\n\006ctlVal\030\001 \001(\010B\010\210\265\030"
    "\001\220\265\030\001\"R\n\020ControlTimestamp\022\031\n\007seconds\030\002 \001"
    "(\004B\010\210\265\030\001\220\265\030\001\022\035\n\013nanoseconds\030\003 \001(\rB\010\210\265\030\001\220"
    "\265\030\001J\004\010\001\020\002\"T\n\036Optional_ScheduleParameterK"
    "ind\0222\n\005value\030\001 \001(\0162#.commonmodule.Schedu"
    "leParameterKind\"~\n\025ENG_ScheduleParameter"
    "\022L\n\025scheduleParameterType\030\001 \001(\0162#.common"
    "module.ScheduleParameterKindB\010\210\265\030\001\220\265\030\001\022\027"
    "\n\005value\030\002 \001(\001B\010\210\265\030\001\220\265\030\001\"\226\001\n\rSchedulePoin"
    "t\022H\n\021scheduleParameter\030\001 \003(\0132#.commonmod"
    "ule.ENG_ScheduleParameterB\010\210\265\030\001\220\265\030\001\022;\n\ts"
    "tartTime\030\002 \001(\0132\036.commonmodule.ControlTim"
    "estampB\010\210\265\030\001\220\265\030\001\"D\n\013ScheduleCSG\0225\n\006schPt"
    "s\030\001 \003(\0132\033.commonmodule.SchedulePointB\010\210\265"
    "\030\001\220\265\030\001\"K\n\023ControlScheduleFSCH\0224\n\007ValACSG"
    "\030\001 \001(\0132\031.commonmodule.ScheduleCSGB\010\210\265\030\001\220"
    "\265\030\001\"M\n\025LogicalNodeForControl\0224\n\013logicalN"
    "ode\030\001 \001(\0132\031.commonmodule.LogicalNodeB\004\200\265"
    "\030\001\"\335\001\n\013ControlFSCC\022H\n\025logicalNodeForCont"
    "rol\030\001 \001(\0132#.commonmodule.LogicalNodeForC"
    "ontrolB\004\200\265\030\001\022>\n\023controlScheduleFSCH\030\002 \001("
    "\0132!.commonmodule.ControlScheduleFSCH\022D\n\031"
    "islandControlScheduleFSCH\030\003 \001(\0132!.common"
    "module.ControlScheduleFSCH\"&\n\nControlINC"
    "\022\030\n\006ctlVal\030\001 \001(\005B\010\210\265\030\001\220\265\030\001\"I\n\nControlING"
    "\022\030\n\006setVal\030\001 \001(\005B\010\210\265\030\001\220\265\030\001\022!\n\005units\030\002 \001("
    "\0132\022.commonmodule.Unit\"&\n\nControlISC\022\030\n\006c"
    "tlVal\030\001 \001(\005B\010\210\265\030\001\220\265\030\001\"J\n\022ControlMessageI"
    "nfo\0224\n\013messageInfo\030\001 \001(\0132\031.commonmodule."
    "MessageInfoB\004\200\265\030\001\"&\n\nControlSPC\022\030\n\006ctlVa"
    "l\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\"\245\001\n\014ControlValue\022>\n\020id"
    "entifiedObject\030\001 \001(\0132\036.commonmodule.Iden"
    "tifiedObjectB\004\200\265\030\001\022*\n\006modBlk\030\003 \001(\0132\032.goo"
    "gle.protobuf.BoolValue\022)\n\005reset\030\004 \001(\0132\032."
    "google.protobuf.BoolValue\"P\n\016CumulativeT"
    "ime\022\031\n\007seconds\030\002 \001(\004B\010\210\265\030\001\220\265\030\001\022\035\n\013nanose"
    "conds\030\003 \001(\rB\010\210\265\030\001\220\265\030\001J\004\010\001\020\002\"h\n\020DateTimeI"
    "nterval\022(\n\003end\030\001 \001(\0132\033.google.protobuf.I"
    "nt64Value\022*\n\005start\030\002 \001(\0132\033.google.protob"
    "uf.Int64Value\"k\n\003DEL\022 \n\005phsAB\030\001 \001(\0132\021.co"
    "mmonmodule.CMV\022 \n\005phsBC\030\002 \001(\0132\021.commonmo"
    "dule.CMV\022 \n\005phsCA\030\003 \001(\0132\021.commonmodule.C"
    "MV\"\252\001\n\010PhaseDPC\022&\n\004phs3\030\001 \001(\0132\030.commonmo"
    "dule.ControlDPC\022&\n\004phsA\030\002 \001(\0132\030.commonmo"
    "dule.ControlDPC\022&\n\004phsB\030\003 \001(\0132\030.commonmo"
    "dule.ControlDPC\022&\n\004phsC\030\004 \001(\0132\030.commonmo"
    "dule.ControlDPC\"\241\002\n\023DiscreteControlXCBR\022"
    "H\n\025logicalNodeForControl\030\001 \001(\0132#.commonm"
    "odule.LogicalNodeForControlB\004\200\265\030\001\022#\n\003Pos"
    "\030\002 \001(\0132\026.commonmodule.PhaseDPC\0220\n\016Protec"
    "tionMode\030\003 \001(\0132\030.commonmodule.ControlINC"
    "\0220\n\016RecloseEnabled\030\004 \001(\0132\030.commonmodule."
    "ControlSPC\0227\n\025ResetProtectionPickup\030\005 \001("
    "\0132\030.commonmodule.ControlSPC\"\214\001\n\016EnergyCo"
    "nsumer\022D\n\023conductingEquipment\030\001 \001(\0132!.co"
    "mmonmodule.ConductingEquipmentB\004\200\265\030\001\0224\n\016"
    "operatingLimit\030\002 \001(\0132\034.google.protobuf.S"
    "tringValue\"F\n\027Optional_CalcMethodKind\022+\n"
    "\005value\030\001 \001(\0162\034.commonmodule.CalcMethodKi"
    "nd\"L\n\022ENG_CalcMethodKind\0226\n\006setVal\030\001 \001(\016"
    "2\034.commonmodule.CalcMethodKindB\010\210\265\030\001\220\265\030\001"
    "\"P\n\034Optional_GridConnectModeKind\0220\n\005valu"
    "e\030\001 \001(\0162!.commonmodule.GridConnectModeKi"
    "nd\"\215\001\n\027ENG_GridConnectModeKind\022;\n\006setVal"
    "\030\001 \001(\0162!.commonmodule.GridConnectModeKin"
    "dB\010\210\265\030\001\220\265\030\001\0225\n\017setValExtension\030\002 \001(\0132\034.g"
    "oogle.protobuf.StringValue\">\n\023Optional_P"
    "FSignKind\022\'\n\005value\030\001 \001(\0162\030.commonmodule."
    "PFSignKind\"D\n\016ENG_PFSignKind\0222\n\006setVal\030\001"
    " \001(\0162\030.commonmodule.PFSignKindB\010\210\265\030\001\220\265\030\001"
    "\"L\n\032Optional_BehaviourModeKind\022.\n\005value\030"
    "\001 \001(\0162\037.commonmodule.BehaviourModeKind\"\227"
    "\001\n\025ENS_BehaviourModeKind\022 \n\001q\030\001 \001(\0132\025.co"
    "mmonmodule.Quality\0228\n\005stVal\030\002 \001(\0162\037.comm"
    "onmodule.BehaviourModeKindB\010\210\265\030\001\220\265\030\001\022\"\n\001"
    "t\030\003 \001(\0132\027.commonmodule.Timestamp\"T\n\036Opti"
    "onal_DERGeneratorStateKind\0222\n\005value\030\001 \001("
    "\0162#.commonmodule.DERGeneratorStateKind\"\237"
    "\001\n\031ENS_DERGeneratorStateKind\022 \n\001q\030\001 \001(\0132"
    "\025.commonmodule.Quality\022<\n\005stVal\030\002 \001(\0162#."
    "commonmodule.DERGeneratorStateKindB\010\210\265\030\001"
    "\220\265\030\001\022\"\n\001t\030\003 \001(\0132\027.commonmodule.Timestamp"
    "\"H\n\030Optional_DynamicTestKind\022,\n\005value\030\001 "
    "\001(\0162\035.commonmodule.DynamicTestKind\"\223\001\n\023E"
    "NS_DynamicTestKind\022 \n\001q\030\001 \001(\0132\025.commonmo"
    "dule.Quality\0226\n\005stVal\030\002 \001(\0162\035.commonmodu"
    "le.DynamicTestKindB\010\210\265\030\001\220\265\030\001\022\"\n\001t\030\003 \001(\0132"
    "\027.commonmodule.Timestamp\"w\n\027ENS_GridConn"
    "ectModeKind\022:\n\005stVal\030\001 \001(\0162!.commonmodul"
    "e.GridConnectModeKindB\010\210\265\030\001\220\265\030\001\022 \n\016stVal"
    "Extension\030\002 \001(\tB\010\210\265\030\001\220\265\030\001\">\n\023Optional_He"
    "althKind\022\'\n\005value\030\001 \001(\0162\030.commonmodule.H"
    "ealthKind\"l\n\016ENS_HealthKind\022\'\n\001d\030\001 \001(\0132\034"
    ".google.protobuf.StringValue\0221\n\005stVal\030\002 "
    "\001(\0162\030.commonmodule.HealthKindB\010\210\265\030\001\220\265\030\001\""
    "X\n Optional_SwitchingCapabilityKind\0224\n\005v"
    "alue\030\001 \001(\0162%.commonmodule.SwitchingCapab"
    "ilityKind\"\211\001\n\033ENS_SwitchingCapabilityKin"
    "d\022*\n\006blkEna\030\001 \001(\0132\032.google.protobuf.Bool"
    "Value\022>\n\005stVal\030\002 \001(\0162%.commonmodule.Swit"
    "chingCapabilityKindB\010\210\265\030\001\220\265\030\001\"\265\001\n\rOperat"
    "ionDCTE\0225\n\trndDlTmms\030\001 \001(\0132\030.commonmodul"
    "e.ControlINGB\010\210\265\030\001\220\265\030\001\0225\n\trtnDlTmms\030\002 \001("
    "\0132\030.commonmodule.ControlINGB\010\210\265\030\001\220\265\030\001\0226\n"
    "\nrtnRmpTmms\030\003 \001(\0132\030.commonmodule.Control"
    "INGB\010\210\265\030\001\220\265\030\001\"\337\001\n\017EnterServiceAPC\022D\n\025ent"
    "erServiceParameter\030\001 \001(\0132\033.commonmodule."
    "OperationDCTEB\010\210\265\030\001\220\265\030\001\022\031\n\007hzHiLim\030\002 \001(\002"
    "B\010\210\265\030\001\220\265\030\001\022\031\n\007hzLoLim\030\003 \001(\002B\010\210\265\030\001\220\265\030\001\022\034\n"
    "\nrtnSrvAuto\030\004 \001(\010B\010\210\265\030\001\220\265\030\001\022\030\n\006vHiLim\030\005 "
    "\001(\002B\010\210\265\030\001\220\265\030\001\022\030\n\006vLoLim\030\006 \001(\002B\010\210\265\030\001\220\265\030\001\""
    "K\n\003ESS\022D\n\023conductingEquipment\030\001 \001(\0132!.co"
    "mmonmodule.ConductingEquipmentB\004\200\265\030\001\"H\n\020"
    "EventMessageInfo\0224\n\013messageInfo\030\001 \001(\0132\031."
    "commonmodule.MessageInfoB\004\200\265\030\001\"x\n\nEventV"
    "alue\022>\n\020identifiedObject\030\001 \001(\0132\036.commonm"
    "odule.IdentifiedObjectB\004\200\265\030\001\022*\n\006modBlk\030\002"
    " \001(\0132\032.google.protobuf.BoolValue\"U\n\023Fore"
    "castValueSource\022>\n\020identifiedObject\030\001 \001("
    "\0132\036.commonmodule.IdentifiedObjectB\004\200\265\030\001\""
    "\234\001\n\013ForecastIED\022D\n\023forecastValueSource\030\001"
    " \001(\0132!.commonmodule.ForecastValueSourceB"
    "\004\200\265\030\001\022%\n\023sourceApplicationID\030\002 \001(\tB\010\210\265\030\001"
    "\220\265\030\001\022 \n\016sourceDateTime\030\003 \001(\003B\010\210\265\030\001\220\265\030\001\"O"
    "\n\rForecastValue\022>\n\020identifiedObject\030\001 \001("
    "\0132\036.commonmodule.IdentifiedObjectB\004\200\265\030\001\""
    "c\n\rOperationDHFW\022\030\n\006modEna\030\001 \001(\010B\010\210\265\030\001\220\265"
    "\030\001\0228\n\nOplTmmsMax\030\002 \001(\0132\032.commonmodule.Cl"
    "earingTimeB\010\210\265\030\001\220\265\030\001\"c\n\rOperationDLFW\022\030\n"
    "\006modEna\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\0228\n\nOplTmmsMax\030\002 "
    "\001(\0132\032.commonmodule.ClearingTimeB\010\210\265\030\001\220\265\030"
    "\001\"G\n\010HzWPoint\022\037\n\rdeadbandHzVal\030\001 \001(\002B\010\210\265"
    "\030\001\220\265\030\001\022\032\n\010slopeVal\030\002 \001(\002B\010\210\265\030\001\220\265\030\001\"\366\001\n\006H"
    "zWAPC\0223\n\toverHzWPt\030\001 \001(\0132\026.commonmodule."
    "HzWPointB\010\210\265\030\001\220\265\030\001\022\?\n\020overHzWParameter\030\002"
    " \001(\0132\033.commonmodule.OperationDHFWB\010\210\265\030\001\220"
    "\265\030\001\0224\n\nunderHzWPt\030\003 \001(\0132\026.commonmodule.H"
    "zWPointB\010\210\265\030\001\220\265\030\001\022@\n\021underHzWParameter\030\004"
    " \001(\0132\033.commonmodule.OperationDLFWB\010\210\265\030\001\220"
    "\265\030\001\"j\n\tStatusINS\022 \n\001q\030\001 \001(\0132\025.commonmodu"
    "le.Quality\022\027\n\005stVal\030\002 \001(\005B\010\210\265\030\001\220\265\030\001\022\"\n\001t"
    "\030\003 \001(\0132\027.commonmodule.Timestamp\"\270\001\n\031Inte"
    "gerEventAndStatusGGIO\0224\n\013logicalNode\030\001 \001"
    "(\0132\031.commonmodule.LogicalNodeB\004\200\265\030\001\0220\n\005I"
    "ntIn\030\002 \001(\0132\027.commonmodule.StatusINSB\010\210\265\030"
    "\001\220\265\030\001\0223\n\005Phase\030\003 \001(\0132$.commonmodule.Opti"
    "onal_PhaseCodeKind\")\n\rOperationDWMX\022\030\n\006m"
    "odEna\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\")\n\rOperationDWMN\022\030"
    "\n\006modEna\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\"\307\001\n\tLimitWAPC\022>"
    "\n\017maxLimParameter\030\001 \001(\0132\033.commonmodule.O"
    "perationDWMXB\010\210\265\030\001\220\265\030\001\022>\n\017minLimParamete"
    "r\030\002 \001(\0132\033.commonmodule.OperationDWMNB\010\210\265"
    "\030\001\220\265\030\001\022\034\n\nwMaxSptVal\030\003 \001(\002B\010\210\265\030\001\220\265\030\001\022\034\n\n"
    "wMinSptVal\030\004 \001(\002B\010\210\265\030\001\220\265\030\001\"\217\002\n\034LogicalNo"
    "deForEventAndStatus\0224\n\013logicalNode\030\001 \001(\013"
    "2\031.commonmodule.LogicalNodeB\004\200\265\030\001\0220\n\003Beh"
    "\030\002 \001(\0132#.commonmodule.ENS_BehaviourModeK"
    "ind\022.\n\010EEHealth\030\003 \001(\0132\034.commonmodule.ENS"
    "_HealthKind\022+\n\nHotLineTag\030\004 \001(\0132\027.common"
    "module.StatusSPS\022*\n\tRemoteBlk\030\005 \001(\0132\027.co"
    "mmonmodule.StatusSPS\"R\n\020MeasurementValue"
    "\022>\n\020identifiedObject\030\001 \001(\0132\036.commonmodul"
    "e.IdentifiedObjectB\004\200\265\030\001\"M\n\005Meter\022D\n\023con"
    "ductingEquipment\030\001 \001(\0132!.commonmodule.Co"
    "nductingEquipmentB\004\200\265\030\001\"\206\002\n\016NameplateVal"
    "ue\022>\n\020identifiedObject\030\001 \001(\0132\036.commonmod"
    "ule.IdentifiedObjectB\004\200\265\030\001\022+\n\005model\030\002 \001("
    "\0132\034.google.protobuf.StringValue\022,\n\006sernu"
    "m\030\003 \001(\0132\034.google.protobuf.StringValue\022+\n"
    "\005swRev\030\004 \001(\0132\034.google.protobuf.StringVal"
    "ue\022,\n\006vendor\030\005 \001(\0132\034.google.protobuf.Str"
    "ingValue\"e\n\rOperationDFPF\022\030\n\006modEna\030\001 \001("
    "\010B\010\210\265\030\001\220\265\030\001\022\032\n\010pFExtSet\030\002 \001(\010B\010\210\265\030\001\220\265\030\001\022"
    "\036\n\014pFGnTgtMxVal\030\003 \001(\002B\010\210\265\030\001\220\265\030\001\",\n\rOpera"
    "tionDVAR\022\033\n\tvarTgtSpt\030\001 \001(\002B\010\210\265\030\001\220\265\030\001\"\317\001"
    "\n\rOperationDVVR\022\030\n\006modEna\030\001 \001(\010B\010\210\265\030\001\220\265\030"
    "\001\0228\n\nOplTmmsMax\030\002 \001(\0132\032.commonmodule.Cle"
    "aringTimeB\010\210\265\030\001\220\265\030\001\022\026\n\004VRef\030\003 \001(\002B\010\210\265\030\001\220"
    "\265\030\001\022\034\n\nVRefAdjEna\030\004 \001(\010B\010\210\265\030\001\220\265\030\001\0224\n\010VRe"
    "fTmms\030\005 \001(\0132\030.commonmodule.ControlINGB\010\210"
    "\265\030\001\220\265\030\001\"c\n\rOperationDVWC\022\030\n\006modEna\030\001 \001(\010"
    "B\010\210\265\030\001\220\265\030\001\0228\n\nOplTmmsMax\030\002 \001(\0132\032.commonm"
    "odule.ClearingTimeB\010\210\265\030\001\220\265\030\001\"\'\n\rOperatio"
    "nDWGC\022\026\n\004wSpt\030\001 \001(\002B\010\210\265\030\001\220\265\030\001\")\n\rOperati"
    "onDWVR\022\030\n\006modEna\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\"O\n\027Opti"
    "mizationMessageInfo\0224\n\013messageInfo\030\001 \001(\013"
    "2\031.commonmodule.MessageInfoB\004\200\265\030\001\"]\n\005PFS"
    "PC\022\030\n\006ctlVal\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\022:\n\013pFParame"
    "ter\030\002 \001(\0132\033.commonmodule.OperationDFPFB\010"
    "\210\265\030\001\220\265\030\001\"\252\001\n\010PhaseAPC\022&\n\004phs3\030\001 \001(\0132\030.co"
    "mmonmodule.ControlAPC\022&\n\004phsA\030\002 \001(\0132\030.co"
    "mmonmodule.ControlAPC\022&\n\004phsB\030\003 \001(\0132\030.co"
    "mmonmodule.ControlAPC\022&\n\004phsC\030\004 \001(\0132\030.co"
    "mmonmodule.ControlAPC\"<\n\022Optional_DbPosK"
    "ind\022&\n\005value\030\001 \001(\0162\027.commonmodule.DbPosK"
    "ind\"\203\001\n\tStatusDPS\022 \n\001q\030\001 \001(\0132\025.commonmod"
    "ule.Quality\0220\n\005stVal\030\002 \001(\0162\027.commonmodul"
    "e.DbPosKindB\010\210\265\030\001\220\265\030\001\022\"\n\001t\030\003 \001(\0132\027.commo"
    "nmodule.Timestamp\"\246\001\n\010PhaseDPS\022%\n\004phs3\030\001"
    " \001(\0132\027.commonmodule.StatusDPS\022%\n\004phsA\030\002 "
    "\001(\0132\027.commonmodule.StatusDPS\022%\n\004phsB\030\003 \001"
    "(\0132\027.commonmodule.StatusDPS\022%\n\004phsC\030\004 \001("
    "\0132\027.commonmodule.StatusDPS\"\246\001\n\010PhaseINS\022"
    "%\n\004phs3\030\001 \001(\0132\027.commonmodule.StatusINS\022%"
    "\n\004phsA\030\002 \001(\0132\027.commonmodule.StatusINS\022%\n"
    "\004phsB\030\003 \001(\0132\027.commonmodule.StatusINS\022%\n\004"
    "phsC\030\004 \001(\0132\027.commonmodule.StatusINS\"\252\001\n\010"
    "PhaseISC\022&\n\004phs3\030\001 \001(\0132\030.commonmodule.Co"
    "ntrolISC\022&\n\004phsA\030\002 \001(\0132\030.commonmodule.Co"
    "ntrolISC\022&\n\004phsB\030\003 \001(\0132\030.commonmodule.Co"
    "ntrolISC\022&\n\004phsC\030\004 \001(\0132\030.commonmodule.Co"
    "ntrolISC\"\376\002\n\013ReadingMMTN\0224\n\013logicalNode\030"
    "\001 \001(\0132\031.commonmodule.LogicalNodeB\004\200\265\030\001\022!"
    "\n\006DmdVAh\030\002 \001(\0132\021.commonmodule.BCR\022\"\n\007Dmd"
    "VArh\030\003 \001(\0132\021.commonmodule.BCR\022 \n\005DmdWh\030\004"
    " \001(\0132\021.commonmodule.BCR\022!\n\006SupVAh\030\005 \001(\0132"
    "\021.commonmodule.BCR\022\"\n\007SupVArh\030\006 \001(\0132\021.co"
    "mmonmodule.BCR\022 \n\005SupWh\030\007 \001(\0132\021.commonmo"
    "dule.BCR\022!\n\006TotVAh\030\010 \001(\0132\021.commonmodule."
    "BCR\022\"\n\007TotVArh\030\t \001(\0132\021.commonmodule.BCR\022"
    " \n\005TotWh\030\n \001(\0132\021.commonmodule.BCR\"\204\002\n\tPh"
    "aseMMTN\022\'\n\004phsA\030\001 \001(\0132\031.commonmodule.Rea"
    "dingMMTN\022(\n\005phsAB\030\002 \001(\0132\031.commonmodule.R"
    "eadingMMTN\022\'\n\004phsB\030\003 \001(\0132\031.commonmodule."
    "ReadingMMTN\022(\n\005phsBC\030\004 \001(\0132\031.commonmodul"
    "e.ReadingMMTN\022\'\n\004phsC\030\005 \001(\0132\031.commonmodu"
    "le.ReadingMMTN\022(\n\005phsCA\030\006 \001(\0132\031.commonmo"
    "dule.ReadingMMTN\"L\n\032Optional_RecloseActi"
    "onKind\022.\n\005value\030\001 \001(\0162\037.commonmodule.Rec"
    "loseActionKind\"\364\001\n\022PhaseRecloseAction\0226\n"
    "\004phs3\030\001 \001(\0132(.commonmodule.Optional_Recl"
    "oseActionKind\0226\n\004phsA\030\002 \001(\0132(.commonmodu"
    "le.Optional_RecloseActionKind\0226\n\004phsB\030\003 "
    "\001(\0132(.commonmodule.Optional_RecloseActio"
    "nKind\0226\n\004phsC\030\004 \001(\0132(.commonmodule.Optio"
    "nal_RecloseActionKind\"\252\001\n\010PhaseSPC\022&\n\004ph"
    "s3\030\001 \001(\0132\030.commonmodule.ControlSPC\022&\n\004ph"
    "sA\030\002 \001(\0132\030.commonmodule.ControlSPC\022&\n\004ph"
    "sB\030\003 \001(\0132\030.commonmodule.ControlSPC\022&\n\004ph"
    "sC\030\004 \001(\0132\030.commonmodule.ControlSPC\"\246\001\n\010P"
    "haseSPS\022%\n\004phs3\030\001 \001(\0132\027.commonmodule.Sta"
    "tusSPS\022%\n\004phsA\030\002 \001(\0132\027.commonmodule.Stat"
    "usSPS\022%\n\004phsB\030\003 \001(\0132\027.commonmodule.Statu"
    "sSPS\022%\n\004phsC\030\004 \001(\0132\027.commonmodule.Status"
    "SPS\"\204\001\n\003PMG\022\035\n\003net\030\001 \001(\0132\020.commonmodule."
    "MV\022\036\n\004phsA\030\002 \001(\0132\020.commonmodule.MV\022\036\n\004ph"
    "sB\030\003 \001(\0132\020.commonmodule.MV\022\036\n\004phsC\030\004 \001(\013"
    "2\020.commonmodule.MV\"\226\002\n\010RampRate\022D\n\037negat"
    "iveReactivePowerKVArPerMin\030\001 \001(\0132\033.googl"
    "e.protobuf.FloatValue\022>\n\031negativeRealPow"
    "erKWPerMin\030\002 \001(\0132\033.google.protobuf.Float"
    "Value\022D\n\037positiveReactivePowerKVArPerMin"
    "\030\003 \001(\0132\033.google.protobuf.FloatValue\022>\n\031p"
    "ositiveRealPowerKWPerMin\030\004 \001(\0132\033.google."
    "protobuf.FloatValue\"J\n\022ReadingMessageInf"
    "o\0224\n\013messageInfo\030\001 \001(\0132\031.commonmodule.Me"
    "ssageInfoB\004\200\265\030\001\"\376\002\n\013ReadingMMTR\0224\n\013logic"
    "alNode\030\001 \001(\0132\031.commonmodule.LogicalNodeB"
    "\004\200\265\030\001\022!\n\006DmdVAh\030\002 \001(\0132\021.commonmodule.BCR"
    "\022\"\n\007DmdVArh\030\003 \001(\0132\021.commonmodule.BCR\022 \n\005"
    "DmdWh\030\004 \001(\0132\021.commonmodule.BCR\022!\n\006SupVAh"
    "\030\005 \001(\0132\021.commonmodule.BCR\022\"\n\007SupVArh\030\006 \001"
    "(\0132\021.commonmodule.BCR\022 \n\005SupWh\030\007 \001(\0132\021.c"
    "ommonmodule.BCR\022!\n\006TotVAh\030\010 \001(\0132\021.common"
    "module.BCR\022\"\n\007TotVArh\030\t \001(\0132\021.commonmodu"
    "le.BCR\022 \n\005TotWh\030\n \001(\0132\021.commonmodule.BCR"
    "\"\311\001\n\003WYE\022\036\n\003net\030\001 \001(\0132\021.commonmodule.CMV"
    "\022\037\n\004neut\030\002 \001(\0132\021.commonmodule.CMV\022\037\n\004phs"
    "A\030\003 \001(\0132\021.commonmodule.CMV\022\037\n\004phsB\030\004 \001(\013"
    "2\021.commonmodule.CMV\022\037\n\004phsC\030\005 \001(\0132\021.comm"
    "onmodule.CMV\022\036\n\003res\030\006 \001(\0132\021.commonmodule"
    ".CMV\"\233\003\n\013ReadingMMXU\0224\n\013logicalNode\030\001 \001("
    "\0132\031.commonmodule.LogicalNodeB\004\200\265\030\001\022\034\n\001A\030"
    "\002 \001(\0132\021.commonmodule.WYE\0220\n\006ClcMth\030\003 \001(\013"
    "2 .commonmodule.ENG_CalcMethodKind\022\034\n\002Hz"
    "\030\004 \001(\0132\020.commonmodule.MV\022\035\n\002PF\030\005 \001(\0132\021.c"
    "ommonmodule.WYE\022,\n\006PFSign\030\006 \001(\0132\034.common"
    "module.ENG_PFSignKind\022\036\n\003PhV\030\007 \001(\0132\021.com"
    "monmodule.WYE\022\036\n\003PPV\030\010 \001(\0132\021.commonmodul"
    "e.DEL\022\035\n\002VA\030\t \001(\0132\021.commonmodule.WYE\022\036\n\003"
    "VAr\030\n \001(\0132\021.commonmodule.WYE\022\034\n\001W\030\013 \001(\0132"
    "\021.commonmodule.WYE\"\374\003\n\035SourceCapabilityC"
    "onfiguration\0224\n\013logicalNode\030\001 \001(\0132\031.comm"
    "onmodule.LogicalNodeB\004\200\265\030\001\022\037\n\004AMax\030\002 \001(\013"
    "2\021.commonmodule.ASG\022 \n\005VAMax\030\003 \001(\0132\021.com"
    "monmodule.ASG\022$\n\tVarMaxAbs\030\004 \001(\0132\021.commo"
    "nmodule.ASG\022$\n\tVarMaxInj\030\005 \001(\0132\021.commonm"
    "odule.ASG\022\037\n\004VMax\030\006 \001(\0132\021.commonmodule.A"
    "SG\022\037\n\004VMin\030\007 \001(\0132\021.commonmodule.ASG\022\037\n\004V"
    "Nom\030\010 \001(\0132\021.commonmodule.ASG\022\037\n\004WMax\030\t \001"
    "(\0132\021.commonmodule.ASG\022\"\n\007WOvrExt\030\n \001(\0132\021"
    ".commonmodule.ASG\022$\n\tWOvrExtPF\030\013 \001(\0132\021.c"
    "ommonmodule.ASG\022\"\n\007WUndExt\030\014 \001(\0132\021.commo"
    "nmodule.ASG\022$\n\tWUndExtPF\030\r \001(\0132\021.commonm"
    "odule.ASG\"B\n\025Optional_NorOpCatKind\022)\n\005va"
    "lue\030\001 \001(\0162\032.commonmodule.NorOpCatKind\"B\n"
    "\025Optional_AbnOpCatKind\022)\n\005value\030\001 \001(\0162\032."
    "commonmodule.AbnOpCatKind\"\345\006\n\027SourceCapa"
    "bilityRatings\0224\n\013logicalNode\030\001 \001(\0132\031.com"
    "monmodule.LogicalNodeB\004\200\265\030\001\0229\n\013AbnOpCatR"
    "tg\030\002 \001(\0162\032.commonmodule.AbnOpCatKindB\010\210\265"
    "\030\001\220\265\030\001\022\"\n\007AMaxRtg\030\003 \001(\0132\021.commonmodule.A"
    "SG\022/\n\nFreqNomRtg\030\004 \001(\0132\021.commonmodule.AS"
    "GB\010\210\265\030\001\220\265\030\001\0229\n\013NorOpCatRtg\030\005 \001(\0162\032.commo"
    "nmodule.NorOpCatKindB\010\210\265\030\001\220\265\030\001\0224\n\017ReactS"
    "usceptRtg\030\006 \001(\0132\021.commonmodule.ASGB\010\210\265\030\001"
    "\220\265\030\001\022-\n\010VAMaxRtg\030\007 \001(\0132\021.commonmodule.AS"
    "GB\010\210\265\030\001\220\265\030\001\0221\n\014VarMaxAbsRtg\030\010 \001(\0132\021.comm"
    "onmodule.ASGB\010\210\265\030\001\220\265\030\001\0221\n\014VarMaxInjRtg\030\t"
    " \001(\0132\021.commonmodule.ASGB\010\210\265\030\001\220\265\030\001\022,\n\007VMa"
    "xRtg\030\n \001(\0132\021.commonmodule.ASGB\010\210\265\030\001\220\265\030\001\022"
    ",\n\007VMinRtg\030\013 \001(\0132\021.commonmodule.ASGB\010\210\265\030"
    "\001\220\265\030\001\022,\n\007VNomRtg\030\014 \001(\0132\021.commonmodule.AS"
    "GB\010\210\265\030\001\220\265\030\001\022,\n\007WMaxRtg\030\r \001(\0132\021.commonmod"
    "ule.ASGB\010\210\265\030\001\220\265\030\001\022/\n\nWOvrExtRtg\030\016 \001(\0132\021."
    "commonmodule.ASGB\010\210\265\030\001\220\265\030\001\0221\n\014WOvrExtRtg"
    "PF\030\017 \001(\0132\021.commonmodule.ASGB\010\210\265\030\001\220\265\030\001\022/\n"
    "\nWUndExtRtg\030\020 \001(\0132\021.commonmodule.ASGB\010\210\265"
    "\030\001\220\265\030\001\0221\n\014WUndExtRtgPF\030\021 \001(\0132\021.commonmod"
    "ule.ASGB\010\210\265\030\001\220\265\030\001\"\222\003\n\022StatusAndEventXCBR"
    "\022V\n\034logicalNodeForEventAndStatus\030\001 \001(\0132*"
    ".commonmodule.LogicalNodeForEventAndStat"
    "usB\004\200\265\030\001\0226\n\013DynamicTest\030\002 \001(\0132!.commonmo"
    "dule.ENS_DynamicTestKind\022#\n\003Pos\030\003 \001(\0132\026."
    "commonmodule.PhaseDPS\022+\n\020ProtectionPicku"
    "p\030\004 \001(\0132\021.commonmodule.ACD\022/\n\016Protection"
    "Mode\030\005 \001(\0132\027.commonmodule.StatusINS\022.\n\016R"
    "ecloseEnabled\030\006 \001(\0132\026.commonmodule.Phase"
    "SPS\0229\n\017ReclosingAction\030\007 \001(\0132 .commonmod"
    "ule.PhaseRecloseAction\"j\n\tStatusINC\022 \n\001q"
    "\030\001 \001(\0132\025.commonmodule.Quality\022\027\n\005stVal\030\002"
    " \001(\005B\010\210\265\030\001\220\265\030\001\022\"\n\001t\030\003 \001(\0132\027.commonmodule"
    ".Timestamp\"j\n\tStatusISC\022 \n\001q\030\001 \001(\0132\025.com"
    "monmodule.Quality\022\027\n\005stVal\030\002 \001(\005B\010\210\265\030\001\220\265"
    "\030\001\022\"\n\001t\030\003 \001(\0132\027.commonmodule.Timestamp\"I"
    "\n\021StatusMessageInfo\0224\n\013messageInfo\030\001 \001(\013"
    "2\031.commonmodule.MessageInfoB\004\200\265\030\001\"y\n\013Sta"
    "tusValue\022>\n\020identifiedObject\030\001 \001(\0132\036.com"
    "monmodule.IdentifiedObjectB\004\200\265\030\001\022*\n\006modB"
    "lk\030\002 \001(\0132\032.google.protobuf.BoolValue\"d\n\003"
    "VSS\022 \n\001q\030\001 \001(\0132\025.commonmodule.Quality\022\027\n"
    "\005stVal\030\002 \001(\tB\010\210\265\030\001\220\265\030\001\022\"\n\001t\030\003 \001(\0132\027.comm"
    "onmodule.Timestamp\"\261\001\n\030StringEventAndSta"
    "tusGGIO\0224\n\013logicalNode\030\001 \001(\0132\031.commonmod"
    "ule.LogicalNodeB\004\200\265\030\001\0223\n\005Phase\030\002 \001(\0132$.c"
    "ommonmodule.Optional_PhaseCodeKind\022*\n\005St"
    "rIn\030\003 \001(\0132\021.commonmodule.VSSB\010\210\265\030\001\220\265\030\001\"{"
    "\n\013SwitchPoint\022/\n\003Pos\030\001 \001(\0132\030.commonmodul"
    "e.ControlDPCB\010\210\265\030\001\220\265\030\001\022;\n\tstartTime\030\002 \001("
    "\0132\036.commonmodule.ControlTimestampB\010\210\265\030\001\220"
    "\265\030\001\"@\n\tSwitchCSG\0223\n\006crvPts\030\001 \003(\0132\031.commo"
    "nmodule.SwitchPointB\010\210\265\030\001\220\265\030\001\"Y\n\tTmHzPoi"
    "nt\022\027\n\005hzVal\030\001 \001(\002B\010\210\265\030\001\220\265\030\001\0223\n\005tmVal\030\002 \001"
    "(\0132\032.commonmodule.ClearingTimeB\010\210\265\030\001\220\265\030\001"
    "\"x\n\007TmHzCSG\0225\n\noverCrvPts\030\001 \003(\0132\027.common"
    "module.TmHzPointB\010\210\265\030\001\220\265\030\001\0226\n\013underCrvPt"
    "s\030\002 \003(\0132\027.commonmodule.TmHzPointB\010\210\265\030\001\220\265"
    "\030\001\"]\n\013TmVoltPoint\0223\n\005tmVal\030\001 \001(\0132\032.commo"
    "nmodule.ClearingTimeB\010\210\265\030\001\220\265\030\001\022\031\n\007voltVa"
    "l\030\002 \001(\002B\010\210\265\030\001\220\265\030\001\"~\n\tTmVoltCSG\0227\n\noverCr"
    "vPts\030\001 \003(\0132\031.commonmodule.TmVoltPointB\010\210"
    "\265\030\001\220\265\030\001\0228\n\013underCrvPts\030\002 \003(\0132\031.commonmod"
    "ule.TmVoltPointB\010\210\265\030\001\220\265\030\001\"_\n\006VarSPC\022\030\n\006m"
    "odEna\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\022;\n\014varParameter\030\002 "
    "\001(\0132\033.commonmodule.OperationDVARB\010\210\265\030\001\220\265"
    "\030\001\"C\n\014VoltVarPoint\022\030\n\006varVal\030\001 \001(\002B\010\210\265\030\001"
    "\220\265\030\001\022\031\n\007voltVal\030\002 \001(\002B\010\210\265\030\001\220\265\030\001\"\200\001\n\nVolt"
    "VarCSG\0224\n\006crvPts\030\001 \003(\0132\032.commonmodule.Vo"
    "ltVarPointB\010\210\265\030\001\220\265\030\001\022<\n\rvVarParameter\030\002 "
    "\001(\0132\033.commonmodule.OperationDVVRB\010\210\265\030\001\220\265"
    "\030\001\"\?\n\nVoltWPoint\022\031\n\007voltVal\030\001 \001(\002B\010\210\265\030\001\220"
    "\265\030\001\022\026\n\004wVal\030\002 \001(\002B\010\210\265\030\001\220\265\030\001\"}\n\010VoltWCSG\022"
    "2\n\006crvPts\030\001 \003(\0132\030.commonmodule.VoltWPoin"
    "tB\010\210\265\030\001\220\265\030\001\022=\n\016voltWParameter\030\002 \001(\0132\033.co"
    "mmonmodule.OperationDVWCB\010\210\265\030\001\220\265\030\001\"\037\n\003VS"
    "C\022\030\n\006ctlVal\030\001 \001(\tB\010\210\265\030\001\220\265\030\001\"[\n\004WSPC\022\030\n\006m"
    "odEna\030\001 \001(\010B\010\210\265\030\001\220\265\030\001\0229\n\nwParameter\030\002 \001("
    "\0132\033.commonmodule.OperationDWGCB\010\210\265\030\001\220\265\030\001"
    "\"=\n\tWVarPoint\022\030\n\006varVal\030\001 \001(\002B\010\210\265\030\001\220\265\030\001\022"
    "\026\n\004wVal\030\002 \001(\002B\010\210\265\030\001\220\265\030\001\"z\n\007WVarCSG\0221\n\006cr"
    "vPts\030\001 \003(\0132\027.commonmodule.WVarPointB\010\210\265\030"
    "\001\220\265\030\001\022<\n\rwVarParameter\030\002 \001(\0132\033.commonmod"
    "ule.OperationDWVRB\010\210\265\030\001\220\265\030\001\":\n\021Optional_"
    "AlrmKind\022%\n\005value\030\001 \001(\0162\026.commonmodule.A"
    "lrmKind\"H\n\030Optional_ControlModeKind\022,\n\005v"
    "alue\030\001 \001(\0162\035.commonmodule.ControlModeKin"
    "d\"L\n\032Optional_DirectionModeKind\022.\n\005value"
    "\030\001 \001(\0162\037.commonmodule.DirectionModeKind\""
    "X\n Optional_GridConnectionStateKind\0224\n\005v"
    "alue\030\001 \001(\0162%.commonmodule.GridConnection"
    "StateKind\"N\n\033Optional_OperatingStateKind"
    "\022/\n\005value\030\001 \001(\0162 .commonmodule.Operating"
    "StateKind\"Z\n!Optional_ReactivePowerContr"
    "olKind\0225\n\005value\030\001 \001(\0162&.commonmodule.Rea"
    "ctivePowerControlKind\"R\n\035Optional_RealPo"
    "werControlKind\0221\n\005value\030\001 \001(\0162\".commonmo"
    "dule.RealPowerControlKind\"<\n\022Optional_St"
    "ateKind\022&\n\005value\030\001 \001(\0162\027.commonmodule.St"
    "ateKind\"L\n\032Optional_VoltLimitModeKind\022.\n"
    "\005value\030\001 \001(\0162\037.commonmodule.VoltLimitMod"
    "eKind*\264\001\n\022FaultDirectionKind\022 \n\034FaultDir"
    "ectionKind_UNDEFINED\020\000\022\036\n\032FaultDirection"
    "Kind_unknown\020\001\022\036\n\032FaultDirectionKind_for"
    "ward\020\002\022\037\n\033FaultDirectionKind_backward\020\003\022"
    "\033\n\027FaultDirectionKind_both\020\004*\260\001\n\027PhaseFa"
    "ultDirectionKind\022%\n!PhaseFaultDirectionK"
    "ind_UNDEFINED\020\000\022#\n\037PhaseFaultDirectionKi"
    "nd_unknown\020\001\022#\n\037PhaseFaultDirectionKind_"
    "forward\020\002\022$\n PhaseFaultDirectionKind_bac"
    "kward\020\003*\365\006\n\016UnitSymbolKind\022\027\n\023UnitSymbol"
    "Kind_none\020\000\022\030\n\024UnitSymbolKind_meter\020\002\022\027\n"
    "\023UnitSymbolKind_gram\020\003\022\026\n\022UnitSymbolKind"
    "_Amp\020\005\022\026\n\022UnitSymbolKind_deg\020\t\022\026\n\022UnitSy"
    "mbolKind_rad\020\n\022\027\n\023UnitSymbolKind_degC\020\027\022"
    "\030\n\024UnitSymbolKind_Farad\020\031\022\026\n\022UnitSymbolK"
    "ind_sec\020\033\022\030\n\024UnitSymbolKind_Henry\020\034\022\024\n\020U"
    "nitSymbolKind_V\020\035\022\026\n\022UnitSymbolKind_ohm\020"
    "\036\022\030\n\024UnitSymbolKind_Joule\020\037\022\031\n\025UnitSymbo"
    "lKind_Newton\020 \022\025\n\021UnitSymbolKind_Hz\020!\022\024\n"
    "\020UnitSymbolKind_W\020&\022\025\n\021UnitSymbolKind_Pa"
    "\020\'\022\025\n\021UnitSymbolKind_m2\020)\022\032\n\026UnitSymbolK"
    "ind_Siemens\0205\022\025\n\021UnitSymbolKind_VA\020=\022\026\n\022"
    "UnitSymbolKind_VAr\020\?\022\031\n\025UnitSymbolKind_w"
    "PerVA\020A\022\026\n\022UnitSymbolKind_VAh\020G\022\025\n\021UnitS"
    "ymbolKind_Wh\020H\022\027\n\023UnitSymbolKind_VArh\020I\022"
    "\031\n\025UnitSymbolKind_hzPerS\020K\022\030\n\024UnitSymbol"
    "Kind_wPerS\020Q\022\030\n\024UnitSymbolKind_other\020d\022\025"
    "\n\021UnitSymbolKind_Ah\020j\022\027\n\022UnitSymbolKind_"
    "min\020\237\001\022\030\n\023UnitSymbolKind_hour\020\240\001\022\026\n\021Unit"
    "SymbolKind_m3\020\246\001\022\032\n\025UnitSymbolKind_wPerM"
    "2\020\263\001\022\030\n\023UnitSymbolKind_degF\020\227\002\022\027\n\022UnitSy"
    "mbolKind_mph\020\364\003*\226\003\n\022UnitMultiplierKind\022 "
    "\n\034UnitMultiplierKind_UNDEFINED\020\000\022\033\n\027Unit"
    "MultiplierKind_none\020\001\022\034\n\030UnitMultiplierK"
    "ind_other\020\002\022\034\n\030UnitMultiplierKind_centi\020"
    "\003\022\033\n\027UnitMultiplierKind_deci\020\004\022\033\n\027UnitMu"
    "ltiplierKind_Giga\020\005\022\033\n\027UnitMultiplierKin"
    "d_kilo\020\006\022\033\n\027UnitMultiplierKind_Mega\020\007\022\034\n"
    "\030UnitMultiplierKind_micro\020\010\022\034\n\030UnitMulti"
    "plierKind_milli\020\t\022\033\n\027UnitMultiplierKind_"
    "nano\020\n\022\033\n\027UnitMultiplierKind_pico\020\013\022\033\n\027U"
    "nitMultiplierKind_Tera\020\014*\241\004\n\rPhaseCodeKi"
    "nd\022\026\n\022PhaseCodeKind_none\020\000\022\027\n\023PhaseCodeK"
    "ind_other\020\001\022\023\n\017PhaseCodeKind_N\020\020\022\023\n\017Phas"
    "eCodeKind_C\020 \022\024\n\020PhaseCodeKind_CN\020!\022\024\n\020P"
    "haseCodeKind_AC\020(\022\025\n\021PhaseCodeKind_ACN\020)"
    "\022\023\n\017PhaseCodeKind_B\020@\022\024\n\020PhaseCodeKind_B"
    "N\020A\022\024\n\020PhaseCodeKind_BC\020B\022\025\n\021PhaseCodeKi"
    "nd_BCN\020a\022\024\n\017PhaseCodeKind_A\020\200\001\022\025\n\020PhaseC"
    "odeKind_AN\020\201\001\022\025\n\020PhaseCodeKind_AB\020\204\001\022\026\n\021"
    "PhaseCodeKind_ABN\020\301\001\022\026\n\021PhaseCodeKind_AB"
    "C\020\340\001\022\027\n\022PhaseCodeKind_ABCN\020\341\001\022\025\n\020PhaseCo"
    "deKind_s2\020\200\002\022\026\n\021PhaseCodeKind_s2N\020\201\002\022\025\n\020"
    "PhaseCodeKind_s1\020\200\004\022\026\n\021PhaseCodeKind_s1N"
    "\020\201\004\022\026\n\021PhaseCodeKind_s12\020\200\006\022\027\n\022PhaseCode"
    "Kind_s12N\020\201\006*\225\001\n\014ValidityKind\022\032\n\026Validit"
    "yKind_UNDEFINED\020\000\022\025\n\021ValidityKind_good\020\001"
    "\022\030\n\024ValidityKind_invalid\020\002\022\031\n\025ValidityKi"
    "nd_reserved\020\003\022\035\n\031ValidityKind_questionab"
    "le\020\004*Z\n\nSourceKind\022\030\n\024SourceKind_UNDEFIN"
    "ED\020\000\022\026\n\022SourceKind_process\020\001\022\032\n\026SourceKi"
    "nd_substituted\020\002*\352\001\n\020TimeAccuracyKind\022\036\n"
    "\032TimeAccuracyKind_UNDEFINED\020\000\022\027\n\023TimeAcc"
    "uracyKind_T0\020\007\022\027\n\023TimeAccuracyKind_T1\020\n\022"
    "\027\n\023TimeAccuracyKind_T2\020\016\022\027\n\023TimeAccuracy"
    "Kind_T3\020\020\022\027\n\023TimeAccuracyKind_T4\020\022\022\027\n\023Ti"
    "meAccuracyKind_T5\020\024\022 \n\034TimeAccuracyKind_"
    "unspecified\020\037*\350\r\n\025ScheduleParameterKind\022"
    "#\n\037ScheduleParameterKind_UNDEFINED\020\000\022\036\n\032"
    "ScheduleParameterKind_none\020\001\022\037\n\033Schedule"
    "ParameterKind_other\020\002\022#\n\037ScheduleParamet"
    "erKind_A_net_mag\020\003\022$\n ScheduleParameterK"
    "ind_A_neut_mag\020\004\022$\n ScheduleParameterKin"
    "d_A_phsA_mag\020\005\022$\n ScheduleParameterKind_"
    "A_phsB_mag\020\006\022$\n ScheduleParameterKind_A_"
    "phsC_mag\020\007\022 \n\034ScheduleParameterKind_Hz_m"
    "ag\020\010\022$\n ScheduleParameterKind_PF_net_mag"
    "\020\t\022%\n!ScheduleParameterKind_PF_neut_mag\020"
    "\n\022%\n!ScheduleParameterKind_PF_phsA_mag\020\013"
    "\022%\n!ScheduleParameterKind_PF_phsB_mag\020\014\022"
    "%\n!ScheduleParameterKind_PF_phsC_mag\020\r\022%"
    "\n!ScheduleParameterKind_PhV_net_ang\020\016\022%\n"
    "!ScheduleParameterKind_PhV_net_mag\020\017\022&\n\""
    "ScheduleParameterKind_PhV_neut_ang\020\020\022&\n\""
    "ScheduleParameterKind_PhV_neut_mag\020\021\022&\n\""
    "ScheduleParameterKind_PhV_phsA_ang\020\022\022&\n\""
    "ScheduleParameterKind_PhV_phsA_mag\020\023\022&\n\""
    "ScheduleParameterKind_PhV_phsB_ang\020\024\022&\n\""
    "ScheduleParameterKind_PhV_phsB_mag\020\025\022&\n\""
    "ScheduleParameterKind_PhV_phsC_ang\020\026\022&\n\""
    "ScheduleParameterKind_PhV_phsC_mag\020\027\022\'\n#"
    "ScheduleParameterKind_PPV_phsAB_ang\020\030\022\'\n"
    "#ScheduleParameterKind_PPV_phsAB_mag\020\031\022\'"
    "\n#ScheduleParameterKind_PPV_phsBC_ang\020\032\022"
    "\'\n#ScheduleParameterKind_PPV_phsBC_mag\020\033"
    "\022\'\n#ScheduleParameterKind_PPV_phsCA_ang\020"
    "\034\022\'\n#ScheduleParameterKind_PPV_phsCA_mag"
    "\020\035\022$\n ScheduleParameterKind_VA_net_mag\020\036"
    "\022%\n!ScheduleParameterKind_VA_neut_mag\020\037\022"
    "%\n!ScheduleParameterKind_VA_phsA_mag\020 \022%"
    "\n!ScheduleParameterKind_VA_phsB_mag\020!\022%\n"
    "!ScheduleParameterKind_VA_phsC_mag\020\"\022%\n!"
    "ScheduleParameterKind_VAr_net_mag\020#\022&\n\"S"
    "cheduleParameterKind_VAr_neut_mag\020$\022&\n\"S"
    "cheduleParameterKind_VAr_phsA_mag\020%\022&\n\"S"
    "cheduleParameterKind_VAr_phsB_mag\020&\022&\n\"S"
    "cheduleParameterKind_VAr_phsC_mag\020\'\022#\n\037S"
    "cheduleParameterKind_W_net_mag\020(\022$\n Sche"
    "duleParameterKind_W_neut_mag\020)\022$\n Schedu"
    "leParameterKind_W_phsA_mag\020*\022$\n Schedule"
    "ParameterKind_W_phsB_mag\020+\022$\n SchedulePa"
    "rameterKind_W_phsC_mag\020,*\177\n\016CalcMethodKi"
    "nd\022\034\n\030CalcMethodKind_UNDEFINED\020\000\022\032\n\026Calc"
    "MethodKind_P_CLASS\020\013\022\032\n\026CalcMethodKind_M"
    "_CLASS\020\014\022\027\n\023CalcMethodKind_DIFF\020\r*\266\002\n\023Gr"
    "idConnectModeKind\022!\n\035GridConnectModeKind"
    "_UNDEFINED\020\000\022\033\n\027GridConnectModeKind_CSI\020"
    "\001\022\036\n\032GridConnectModeKind_VC_VSI\020\002\022\036\n\032Gri"
    "dConnectModeKind_CC_VSI\020\003\022\034\n\030GridConnect"
    "ModeKind_none\020b\022\035\n\031GridConnectModeKind_o"
    "ther\020c\022\037\n\032GridConnectModeKind_VSI_PQ\020\320\017\022"
    "\037\n\032GridConnectModeKind_VSI_VF\020\321\017\022 \n\033Grid"
    "ConnectModeKind_VSI_ISO\020\322\017*N\n\nPFSignKind"
    "\022\030\n\024PFSignKind_UNDEFINED\020\000\022\022\n\016PFSignKind"
    "_IEC\020\001\022\022\n\016PFSignKind_EEI\020\002*\310\001\n\021Behaviour"
    "ModeKind\022\037\n\033BehaviourModeKind_UNDEFINED\020"
    "\000\022\030\n\024BehaviourModeKind_on\020\001\022\035\n\031Behaviour"
    "ModeKind_blocked\020\002\022\032\n\026BehaviourModeKind_"
    "test\020\003\022\"\n\036BehaviourModeKind_test_blocked"
    "\020\004\022\031\n\025BehaviourModeKind_off\020\005*\340\003\n\025DERGen"
    "eratorStateKind\022#\n\037DERGeneratorStateKind"
    "_UNDEFINED\020\000\022\'\n#DERGeneratorStateKind_No"
    "t_operating\020\001\022#\n\037DERGeneratorStateKind_O"
    "perating\020\002\022%\n!DERGeneratorStateKind_Star"
    "ting_up\020\003\022\'\n#DERGeneratorStateKind_Shutt"
    "ing_down\020\004\022-\n)DERGeneratorStateKind_At_d"
    "isconnect_level\020\005\022*\n&DERGeneratorStateKi"
    "nd_Ramping_in_power\020\006\0223\n/DERGeneratorSta"
    "teKind_Ramping_in_reactive_power\020\007\022!\n\035DE"
    "RGeneratorStateKind_Standby\020\010\0220\n,DERGene"
    "ratorStateKind_Not_applicable_Unknown\020b\022"
    "\037\n\033DERGeneratorStateKind_Other\020c*\242\001\n\017Dyn"
    "amicTestKind\022\035\n\031DynamicTestKind_UNDEFINE"
    "D\020\000\022\030\n\024DynamicTestKind_none\020\001\022\033\n\027Dynamic"
    "TestKind_testing\020\002\022\035\n\031DynamicTestKind_op"
    "erating\020\003\022\032\n\026DynamicTestKind_failed\020\004*|\n"
    "\nHealthKind\022\030\n\024HealthKind_UNDEFINED\020\000\022\023\n"
    "\017HealthKind_none\020\001\022\021\n\rHealthKind_OK\020\002\022\026\n"
    "\022HealthKind_Warning\020\003\022\024\n\020HealthKind_Alar"
    "m\020\004*\323\001\n\027SwitchingCapabilityKind\022%\n!Switc"
    "hingCapabilityKind_UNDEFINED\020\000\022 \n\034Switch"
    "ingCapabilityKind_none\020\001\022 \n\034SwitchingCap"
    "abilityKind_open\020\002\022!\n\035SwitchingCapabilit"
    "yKind_close\020\003\022*\n&SwitchingCapabilityKind"
    "_open_and_close\020\004*~\n\tDbPosKind\022\027\n\023DbPosK"
    "ind_UNDEFINED\020\000\022\027\n\023DbPosKind_transient\020\001"
    "\022\024\n\020DbPosKind_closed\020\002\022\022\n\016DbPosKind_open"
    "\020\003\022\025\n\021DbPosKind_invalid\020\004*\216\001\n\021RecloseAct"
    "ionKind\022\037\n\033RecloseActionKind_UNDEFINED\020\000"
    "\022\032\n\026RecloseActionKind_idle\020\001\022\035\n\031RecloseA"
    "ctionKind_cycling\020\002\022\035\n\031RecloseActionKind"
    "_lockout\020\003*R\n\014NorOpCatKind\022\032\n\026NorOpCatKi"
    "nd_UNDEFINED\020\000\022\022\n\016NorOpCatKind_A\020\001\022\022\n\016No"
    "rOpCatKind_B\020\002*i\n\014AbnOpCatKind\022\032\n\026AbnOpC"
    "atKind_UNDEFINED\020\000\022\022\n\016AbnOpCatKind_I\020\001\022\023"
    "\n\017AbnOpCatKind_II\020\002\022\024\n\020AbnOpCatKind_III\020"
    "\003*\317\004\n\010AlrmKind\022\031\n\025AlrmKind_ground_fault\020"
    "\000\022\034\n\030AlrmKind_dc_over_voltage\020\001\022\037\n\033AlrmK"
    "ind_ac_disconnect_open\020\002\022\037\n\033AlrmKind_dc_"
    "disconnect_open\020\003\022\034\n\030AlrmKind_grid_disco"
    "nnect\020\004\022\031\n\025AlrmKind_cabinet_open\020\005\022\034\n\030Al"
    "rmKind_manual_shutdown\020\006\022\035\n\031AlrmKind_ove"
    "r_temperature\020\007\022\"\n\036AlrmKind_frequency_ab"
    "ove_limit\020\010\022\"\n\036AlrmKind_frequency_under_"
    "limit\020\t\022#\n\037AlrmKind_ac_voltage_above_lim"
    "it\020\n\022#\n\037AlrmKind_ac_voltage_under_limit\020"
    "\013\022\'\n#AlrmKind_blown_string_fuse_on_input"
    "\020\014\022\036\n\032AlrmKind_under_temperature\020\r\0222\n.Al"
    "rmKind_generic_memory_or_communication_e"
    "rror\020\016\022\"\n\036AlrmKind_hardware_test_failure"
    "\020\017\022\037\n\033AlrmKind_manufacturer_alarm\020\020*\240\001\n\017"
    "ControlModeKind\022\035\n\031ControlModeKind_UNDEF"
    "INED\020\000\022\030\n\024ControlModeKind_auto\020\001\022\032\n\026Cont"
    "rolModeKind_manual\020\002\022\034\n\030ControlModeKind_"
    "override\020\003\022\032\n\026ControlModeKind_remote\020\004*\276"
    "\003\n\021DirectionModeKind\022\037\n\033DirectionModeKin"
    "d_UNDEFINED\020\000\022$\n DirectionModeKind_locke"
    "d_forward\020\001\022$\n DirectionModeKind_locked_"
    "reverse\020\002\022\"\n\036DirectionModeKind_reverse_i"
    "dle\020\003\022#\n\037DirectionModeKind_bidirectional"
    "\020\004\022\"\n\036DirectionModeKind_neutral_idle\020\005\022\""
    "\n\036DirectionModeKind_cogeneration\020\006\022,\n(Di"
    "rectionModeKind_reactive_bidirectional\020\007"
    "\022(\n$DirectionModeKind_bias_bidirectional"
    "\020\010\022\'\n#DirectionModeKind_bias_cogeneratio"
    "n\020\t\022*\n&DirectionModeKind_reverse_cogener"
    "ation\020\n*j\n\027GridConnectionStateKind\022(\n$Gr"
    "idConnectionStateKind_disconnected\020\000\022%\n!"
    "GridConnectionStateKind_connected\020\001*\375\004\n\022"
    "OperatingStateKind\022 \n\034OperatingStateKind"
    "_UNDEFINED\020\000\022\032\n\026OperatingStateKind_off\020\001"
    "\022/\n+OperatingStateKind_disconnected_and_"
    "standby\020\002\0221\n-OperatingStateKind_disconne"
    "cted_and_available\020\003\0222\n.OperatingStateKi"
    "nd_disconnected_and_authorized\020\004\0221\n-Oper"
    "atingStateKind_starting_and_synchronizin"
    "g\020\005\022)\n%OperatingStateKind_connected_and_"
    "idle\020\006\022/\n+OperatingStateKind_connected_a"
    "nd_generating\020\007\022.\n*OperatingStateKind_co"
    "nnected_and_consuming\020\010\022\037\n\033OperatingStat"
    "eKind_stopping\020\t\022/\n+OperatingStateKind_d"
    "isconnected_and_blocked\020\n\0226\n2OperatingSt"
    "ateKind_disconnected_and_in_maintenance\020"
    "\013\022)\n%OperatingStateKind_ceased_to_energi"
    "ze\020\014\022\035\n\031OperatingStateKind_failed\020\r*\211\002\n\030"
    "ReactivePowerControlKind\022&\n\"ReactivePowe"
    "rControlKind_UNDEFINED\020\000\022%\n!ReactivePowe"
    "rControlKind_advanced\020\001\022\"\n\036ReactivePower"
    "ControlKind_droop\020\002\022$\n ReactivePowerCont"
    "rolKind_voltage\020\003\022*\n&ReactivePowerContro"
    "lKind_reactivePower\020\004\022(\n$ReactivePowerCo"
    "ntrolKind_powerFactor\020\005*\307\001\n\024RealPowerCon"
    "trolKind\022\"\n\036RealPowerControlKind_UNDEFIN"
    "ED\020\000\022!\n\035RealPowerControlKind_advanced\020\001\022"
    "\036\n\032RealPowerControlKind_droop\020\002\022$\n RealP"
    "owerControlKind_isochronous\020\003\022\"\n\036RealPow"
    "erControlKind_realPower\020\004*`\n\tStateKind\022\027"
    "\n\023StateKind_UNDEFINED\020\000\022\021\n\rStateKind_off"
    "\020\001\022\020\n\014StateKind_on\020\002\022\025\n\021StateKind_standb"
    "y\020\003*\306\002\n\021VoltLimitModeKind\022\037\n\033VoltLimitMo"
    "deKind_UNDEFINED\020\000\022\031\n\025VoltLimitModeKind_"
    "off\020\001\022%\n!VoltLimitModeKind_high_limit_on"
    "ly\020\002\022$\n VoltLimitModeKind_low_limit_only"
    "\020\003\022%\n!VoltLimitModeKind_high_low_limits\020"
    "\004\022*\n&VoltLimitModeKind_ivvc_high_limit_o"
    "nly\020\005\022)\n%VoltLimitModeKind_ivvc_low_limi"
    "t_only\020\006\022*\n&VoltLimitModeKind_ivvc_high_"
    "low_limits\020\007B\204\001\n\024openfmb.commonmoduleP\001Z"
    "Sgitlab.com/openfmb/psm/ops/protobuf/go-"
    "openfmb-ops-protobuf/v2/openfmb/commonmo"
    "dule\252\002\024openfmb.commonmoduleb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_commonmodule_2fcommonmodule_2eproto_deps[2] =
    {
        &::descriptor_table_google_2fprotobuf_2fwrappers_2eproto,
        &::descriptor_table_uml_2eproto,
};
static ::absl::once_flag descriptor_table_commonmodule_2fcommonmodule_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_commonmodule_2fcommonmodule_2eproto = {
    false,
    false,
    30315,
    descriptor_table_protodef_commonmodule_2fcommonmodule_2eproto,
    "commonmodule/commonmodule.proto",
    &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
    descriptor_table_commonmodule_2fcommonmodule_2eproto_deps,
    2,
    156,
    schemas,
    file_default_instances,
    TableStruct_commonmodule_2fcommonmodule_2eproto::offsets,
    file_level_metadata_commonmodule_2fcommonmodule_2eproto,
    file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto,
    file_level_service_descriptors_commonmodule_2fcommonmodule_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_commonmodule_2fcommonmodule_2eproto_getter() {
  return &descriptor_table_commonmodule_2fcommonmodule_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_commonmodule_2fcommonmodule_2eproto(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
namespace commonmodule {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FaultDirectionKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[0];
}
bool FaultDirectionKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhaseFaultDirectionKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[1];
}
bool PhaseFaultDirectionKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnitSymbolKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[2];
}
bool UnitSymbolKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 5:
    case 9:
    case 10:
    case 23:
    case 25:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 38:
    case 39:
    case 41:
    case 53:
    case 61:
    case 63:
    case 65:
    case 71:
    case 72:
    case 73:
    case 75:
    case 81:
    case 100:
    case 106:
    case 159:
    case 160:
    case 166:
    case 179:
    case 279:
    case 500:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnitMultiplierKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[3];
}
bool UnitMultiplierKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhaseCodeKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[4];
}
bool PhaseCodeKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 16:
    case 32:
    case 33:
    case 40:
    case 41:
    case 64:
    case 65:
    case 66:
    case 97:
    case 128:
    case 129:
    case 132:
    case 193:
    case 224:
    case 225:
    case 256:
    case 257:
    case 512:
    case 513:
    case 768:
    case 769:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidityKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[5];
}
bool ValidityKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SourceKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[6];
}
bool SourceKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeAccuracyKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[7];
}
bool TimeAccuracyKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 7:
    case 10:
    case 14:
    case 16:
    case 18:
    case 20:
    case 31:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScheduleParameterKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[8];
}
bool ScheduleParameterKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CalcMethodKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[9];
}
bool CalcMethodKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GridConnectModeKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[10];
}
bool GridConnectModeKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 98:
    case 99:
    case 2000:
    case 2001:
    case 2002:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PFSignKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[11];
}
bool PFSignKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BehaviourModeKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[12];
}
bool BehaviourModeKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DERGeneratorStateKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[13];
}
bool DERGeneratorStateKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 98:
    case 99:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DynamicTestKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[14];
}
bool DynamicTestKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HealthKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[15];
}
bool HealthKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SwitchingCapabilityKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[16];
}
bool SwitchingCapabilityKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DbPosKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[17];
}
bool DbPosKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecloseActionKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[18];
}
bool RecloseActionKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NorOpCatKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[19];
}
bool NorOpCatKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbnOpCatKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[20];
}
bool AbnOpCatKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlrmKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[21];
}
bool AlrmKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlModeKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[22];
}
bool ControlModeKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DirectionModeKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[23];
}
bool DirectionModeKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GridConnectionStateKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[24];
}
bool GridConnectionStateKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperatingStateKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[25];
}
bool OperatingStateKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReactivePowerControlKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[26];
}
bool ReactivePowerControlKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RealPowerControlKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[27];
}
bool RealPowerControlKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[28];
}
bool StateKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoltLimitModeKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_commonmodule_2fcommonmodule_2eproto);
  return file_level_enum_descriptors_commonmodule_2fcommonmodule_2eproto[29];
}
bool VoltLimitModeKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Optional_FaultDirectionKind::_Internal {
 public:
};

Optional_FaultDirectionKind::Optional_FaultDirectionKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_FaultDirectionKind)
}
Optional_FaultDirectionKind::Optional_FaultDirectionKind(const Optional_FaultDirectionKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_FaultDirectionKind)
}

inline void Optional_FaultDirectionKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_FaultDirectionKind::~Optional_FaultDirectionKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_FaultDirectionKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_FaultDirectionKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_FaultDirectionKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_FaultDirectionKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_FaultDirectionKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_FaultDirectionKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.FaultDirectionKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::FaultDirectionKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_FaultDirectionKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_FaultDirectionKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.FaultDirectionKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_FaultDirectionKind)
  return target;
}

::size_t Optional_FaultDirectionKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_FaultDirectionKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.FaultDirectionKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_FaultDirectionKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_FaultDirectionKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_FaultDirectionKind::GetClassData() const { return &_class_data_; }


void Optional_FaultDirectionKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_FaultDirectionKind*>(&to_msg);
  auto& from = static_cast<const Optional_FaultDirectionKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_FaultDirectionKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_FaultDirectionKind::CopyFrom(const Optional_FaultDirectionKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_FaultDirectionKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_FaultDirectionKind::IsInitialized() const {
  return true;
}

void Optional_FaultDirectionKind::InternalSwap(Optional_FaultDirectionKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_FaultDirectionKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[0]);
}
// ===================================================================

class Optional_PhaseFaultDirectionKind::_Internal {
 public:
};

Optional_PhaseFaultDirectionKind::Optional_PhaseFaultDirectionKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_PhaseFaultDirectionKind)
}
Optional_PhaseFaultDirectionKind::Optional_PhaseFaultDirectionKind(const Optional_PhaseFaultDirectionKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_PhaseFaultDirectionKind)
}

inline void Optional_PhaseFaultDirectionKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_PhaseFaultDirectionKind::~Optional_PhaseFaultDirectionKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_PhaseFaultDirectionKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_PhaseFaultDirectionKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_PhaseFaultDirectionKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_PhaseFaultDirectionKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_PhaseFaultDirectionKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_PhaseFaultDirectionKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.PhaseFaultDirectionKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::PhaseFaultDirectionKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_PhaseFaultDirectionKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_PhaseFaultDirectionKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.PhaseFaultDirectionKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_PhaseFaultDirectionKind)
  return target;
}

::size_t Optional_PhaseFaultDirectionKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_PhaseFaultDirectionKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.PhaseFaultDirectionKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_PhaseFaultDirectionKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_PhaseFaultDirectionKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_PhaseFaultDirectionKind::GetClassData() const { return &_class_data_; }


void Optional_PhaseFaultDirectionKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_PhaseFaultDirectionKind*>(&to_msg);
  auto& from = static_cast<const Optional_PhaseFaultDirectionKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_PhaseFaultDirectionKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_PhaseFaultDirectionKind::CopyFrom(const Optional_PhaseFaultDirectionKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_PhaseFaultDirectionKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_PhaseFaultDirectionKind::IsInitialized() const {
  return true;
}

void Optional_PhaseFaultDirectionKind::InternalSwap(Optional_PhaseFaultDirectionKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_PhaseFaultDirectionKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[1]);
}
// ===================================================================

class ACD::_Internal {
 public:
  static const ::commonmodule::Optional_PhaseFaultDirectionKind& dirneut(const ACD* msg);
  static const ::commonmodule::Optional_PhaseFaultDirectionKind& dirphsa(const ACD* msg);
  static const ::commonmodule::Optional_PhaseFaultDirectionKind& dirphsb(const ACD* msg);
  static const ::commonmodule::Optional_PhaseFaultDirectionKind& dirphsc(const ACD* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& neut(const ACD* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& phsa(const ACD* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& phsb(const ACD* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& phsc(const ACD* msg);
};

const ::commonmodule::Optional_PhaseFaultDirectionKind&
ACD::_Internal::dirneut(const ACD* msg) {
  return *msg->_impl_.dirneut_;
}
const ::commonmodule::Optional_PhaseFaultDirectionKind&
ACD::_Internal::dirphsa(const ACD* msg) {
  return *msg->_impl_.dirphsa_;
}
const ::commonmodule::Optional_PhaseFaultDirectionKind&
ACD::_Internal::dirphsb(const ACD* msg) {
  return *msg->_impl_.dirphsb_;
}
const ::commonmodule::Optional_PhaseFaultDirectionKind&
ACD::_Internal::dirphsc(const ACD* msg) {
  return *msg->_impl_.dirphsc_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ACD::_Internal::neut(const ACD* msg) {
  return *msg->_impl_.neut_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ACD::_Internal::phsa(const ACD* msg) {
  return *msg->_impl_.phsa_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ACD::_Internal::phsb(const ACD* msg) {
  return *msg->_impl_.phsb_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ACD::_Internal::phsc(const ACD* msg) {
  return *msg->_impl_.phsc_;
}
void ACD::clear_neut() {
  if (GetArenaForAllocation() == nullptr && _impl_.neut_ != nullptr) {
    delete _impl_.neut_;
  }
  _impl_.neut_ = nullptr;
}
void ACD::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
void ACD::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
void ACD::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
ACD::ACD(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ACD)
}
ACD::ACD(const ACD& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ACD* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dirneut_){nullptr}
    , decltype(_impl_.dirphsa_){nullptr}
    , decltype(_impl_.dirphsb_){nullptr}
    , decltype(_impl_.dirphsc_){nullptr}
    , decltype(_impl_.neut_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , decltype(_impl_.dirgeneral_) {}

    , decltype(_impl_.general_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dirneut()) {
    _this->_impl_.dirneut_ = new ::commonmodule::Optional_PhaseFaultDirectionKind(*from._impl_.dirneut_);
  }
  if (from._internal_has_dirphsa()) {
    _this->_impl_.dirphsa_ = new ::commonmodule::Optional_PhaseFaultDirectionKind(*from._impl_.dirphsa_);
  }
  if (from._internal_has_dirphsb()) {
    _this->_impl_.dirphsb_ = new ::commonmodule::Optional_PhaseFaultDirectionKind(*from._impl_.dirphsb_);
  }
  if (from._internal_has_dirphsc()) {
    _this->_impl_.dirphsc_ = new ::commonmodule::Optional_PhaseFaultDirectionKind(*from._impl_.dirphsc_);
  }
  if (from._internal_has_neut()) {
    _this->_impl_.neut_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.neut_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.phsc_);
  }
  ::memcpy(&_impl_.dirgeneral_, &from._impl_.dirgeneral_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.general_) -
    reinterpret_cast<char*>(&_impl_.dirgeneral_)) + sizeof(_impl_.general_));
  // @@protoc_insertion_point(copy_constructor:commonmodule.ACD)
}

inline void ACD::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.dirneut_){nullptr}
    , decltype(_impl_.dirphsa_){nullptr}
    , decltype(_impl_.dirphsb_){nullptr}
    , decltype(_impl_.dirphsc_){nullptr}
    , decltype(_impl_.neut_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , decltype(_impl_.dirgeneral_) { 0 }

    , decltype(_impl_.general_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ACD::~ACD() {
  // @@protoc_insertion_point(destructor:commonmodule.ACD)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ACD::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.dirneut_;
  if (this != internal_default_instance()) delete _impl_.dirphsa_;
  if (this != internal_default_instance()) delete _impl_.dirphsb_;
  if (this != internal_default_instance()) delete _impl_.dirphsc_;
  if (this != internal_default_instance()) delete _impl_.neut_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void ACD::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ACD::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ACD)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.dirneut_ != nullptr) {
    delete _impl_.dirneut_;
  }
  _impl_.dirneut_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dirphsa_ != nullptr) {
    delete _impl_.dirphsa_;
  }
  _impl_.dirphsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dirphsb_ != nullptr) {
    delete _impl_.dirphsb_;
  }
  _impl_.dirphsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dirphsc_ != nullptr) {
    delete _impl_.dirphsc_;
  }
  _impl_.dirphsc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.neut_ != nullptr) {
    delete _impl_.neut_;
  }
  _impl_.neut_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  ::memset(&_impl_.dirgeneral_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.general_) -
      reinterpret_cast<char*>(&_impl_.dirgeneral_)) + sizeof(_impl_.general_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ACD::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.FaultDirectionKind dirGeneral = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_dirgeneral(static_cast<::commonmodule::FaultDirectionKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseFaultDirectionKind dirNeut = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dirneut(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsA = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dirphsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsB = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_dirphsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsC = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_dirphsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool general = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.general_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue neut = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_neut(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue phsA = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue phsB = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue phsC = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ACD::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ACD)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.FaultDirectionKind dirGeneral = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_dirgeneral() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_dirgeneral(), target);
  }

  // .commonmodule.Optional_PhaseFaultDirectionKind dirNeut = 2;
  if (this->_internal_has_dirneut()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dirneut(this),
        _Internal::dirneut(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsA = 3;
  if (this->_internal_has_dirphsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dirphsa(this),
        _Internal::dirphsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsB = 4;
  if (this->_internal_has_dirphsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::dirphsb(this),
        _Internal::dirphsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsC = 5;
  if (this->_internal_has_dirphsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::dirphsc(this),
        _Internal::dirphsc(this).GetCachedSize(), target, stream);
  }

  // bool general = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_general() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_general(), target);
  }

  // .google.protobuf.BoolValue neut = 7;
  if (this->_internal_has_neut()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::neut(this),
        _Internal::neut(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue phsA = 8;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue phsB = 9;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue phsC = 10;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ACD)
  return target;
}

::size_t ACD::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ACD)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Optional_PhaseFaultDirectionKind dirNeut = 2;
  if (this->_internal_has_dirneut()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dirneut_);
  }

  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsA = 3;
  if (this->_internal_has_dirphsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dirphsa_);
  }

  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsB = 4;
  if (this->_internal_has_dirphsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dirphsb_);
  }

  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsC = 5;
  if (this->_internal_has_dirphsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dirphsc_);
  }

  // .google.protobuf.BoolValue neut = 7;
  if (this->_internal_has_neut()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.neut_);
  }

  // .google.protobuf.BoolValue phsA = 8;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .google.protobuf.BoolValue phsB = 9;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .google.protobuf.BoolValue phsC = 10;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  // .commonmodule.FaultDirectionKind dirGeneral = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_dirgeneral() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_dirgeneral());
  }

  // bool general = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_general() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ACD::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ACD::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ACD::GetClassData() const { return &_class_data_; }


void ACD::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ACD*>(&to_msg);
  auto& from = static_cast<const ACD&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ACD)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dirneut()) {
    _this->_internal_mutable_dirneut()->::commonmodule::Optional_PhaseFaultDirectionKind::MergeFrom(
        from._internal_dirneut());
  }
  if (from._internal_has_dirphsa()) {
    _this->_internal_mutable_dirphsa()->::commonmodule::Optional_PhaseFaultDirectionKind::MergeFrom(
        from._internal_dirphsa());
  }
  if (from._internal_has_dirphsb()) {
    _this->_internal_mutable_dirphsb()->::commonmodule::Optional_PhaseFaultDirectionKind::MergeFrom(
        from._internal_dirphsb());
  }
  if (from._internal_has_dirphsc()) {
    _this->_internal_mutable_dirphsc()->::commonmodule::Optional_PhaseFaultDirectionKind::MergeFrom(
        from._internal_dirphsc());
  }
  if (from._internal_has_neut()) {
    _this->_internal_mutable_neut()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_neut());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_phsc());
  }
  if (from._internal_dirgeneral() != 0) {
    _this->_internal_set_dirgeneral(from._internal_dirgeneral());
  }
  if (from._internal_general() != 0) {
    _this->_internal_set_general(from._internal_general());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ACD::CopyFrom(const ACD& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ACD)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACD::IsInitialized() const {
  return true;
}

void ACD::InternalSwap(ACD* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACD, _impl_.general_)
      + sizeof(ACD::_impl_.general_)
      - PROTOBUF_FIELD_OFFSET(ACD, _impl_.dirneut_)>(
          reinterpret_cast<char*>(&_impl_.dirneut_),
          reinterpret_cast<char*>(&other->_impl_.dirneut_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ACD::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[2]);
}
// ===================================================================

class IdentifiedObject::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& description(const IdentifiedObject* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& mrid(const IdentifiedObject* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& name(const IdentifiedObject* msg);
};

const ::PROTOBUF_NAMESPACE_ID::StringValue&
IdentifiedObject::_Internal::description(const IdentifiedObject* msg) {
  return *msg->_impl_.description_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
IdentifiedObject::_Internal::mrid(const IdentifiedObject* msg) {
  return *msg->_impl_.mrid_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
IdentifiedObject::_Internal::name(const IdentifiedObject* msg) {
  return *msg->_impl_.name_;
}
void IdentifiedObject::clear_description() {
  if (GetArenaForAllocation() == nullptr && _impl_.description_ != nullptr) {
    delete _impl_.description_;
  }
  _impl_.description_ = nullptr;
}
void IdentifiedObject::clear_mrid() {
  if (GetArenaForAllocation() == nullptr && _impl_.mrid_ != nullptr) {
    delete _impl_.mrid_;
  }
  _impl_.mrid_ = nullptr;
}
void IdentifiedObject::clear_name() {
  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
    delete _impl_.name_;
  }
  _impl_.name_ = nullptr;
}
IdentifiedObject::IdentifiedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.IdentifiedObject)
}
IdentifiedObject::IdentifiedObject(const IdentifiedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IdentifiedObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.description_){nullptr}
    , decltype(_impl_.mrid_){nullptr}
    , decltype(_impl_.name_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_description()) {
    _this->_impl_.description_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.description_);
  }
  if (from._internal_has_mrid()) {
    _this->_impl_.mrid_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.mrid_);
  }
  if (from._internal_has_name()) {
    _this->_impl_.name_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.name_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.IdentifiedObject)
}

inline void IdentifiedObject::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.description_){nullptr}
    , decltype(_impl_.mrid_){nullptr}
    , decltype(_impl_.name_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IdentifiedObject::~IdentifiedObject() {
  // @@protoc_insertion_point(destructor:commonmodule.IdentifiedObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IdentifiedObject::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.description_;
  if (this != internal_default_instance()) delete _impl_.mrid_;
  if (this != internal_default_instance()) delete _impl_.name_;
}

void IdentifiedObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IdentifiedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.IdentifiedObject)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.description_ != nullptr) {
    delete _impl_.description_;
  }
  _impl_.description_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.mrid_ != nullptr) {
    delete _impl_.mrid_;
  }
  _impl_.mrid_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
    delete _impl_.name_;
  }
  _impl_.name_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IdentifiedObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.StringValue description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_description(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue mRID = 2 [(.uml.option_uuid) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mrid(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IdentifiedObject::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.IdentifiedObject)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.StringValue description = 1;
  if (this->_internal_has_description()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::description(this),
        _Internal::description(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue mRID = 2 [(.uml.option_uuid) = true];
  if (this->_internal_has_mrid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::mrid(this),
        _Internal::mrid(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue name = 3;
  if (this->_internal_has_name()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::name(this),
        _Internal::name(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.IdentifiedObject)
  return target;
}

::size_t IdentifiedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.IdentifiedObject)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.StringValue description = 1;
  if (this->_internal_has_description()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.description_);
  }

  // .google.protobuf.StringValue mRID = 2 [(.uml.option_uuid) = true];
  if (this->_internal_has_mrid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mrid_);
  }

  // .google.protobuf.StringValue name = 3;
  if (this->_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.name_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IdentifiedObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IdentifiedObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IdentifiedObject::GetClassData() const { return &_class_data_; }


void IdentifiedObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IdentifiedObject*>(&to_msg);
  auto& from = static_cast<const IdentifiedObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.IdentifiedObject)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_description()) {
    _this->_internal_mutable_description()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_description());
  }
  if (from._internal_has_mrid()) {
    _this->_internal_mutable_mrid()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_mrid());
  }
  if (from._internal_has_name()) {
    _this->_internal_mutable_name()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IdentifiedObject::CopyFrom(const IdentifiedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.IdentifiedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IdentifiedObject::IsInitialized() const {
  return true;
}

void IdentifiedObject::InternalSwap(IdentifiedObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IdentifiedObject, _impl_.name_)
      + sizeof(IdentifiedObject::_impl_.name_)
      - PROTOBUF_FIELD_OFFSET(IdentifiedObject, _impl_.description_)>(
          reinterpret_cast<char*>(&_impl_.description_),
          reinterpret_cast<char*>(&other->_impl_.description_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IdentifiedObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[3]);
}
// ===================================================================

class ACDCTerminal::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const ACDCTerminal* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& connected(const ACDCTerminal* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Int32Value& sequencenumber(const ACDCTerminal* msg);
};

const ::commonmodule::IdentifiedObject&
ACDCTerminal::_Internal::identifiedobject(const ACDCTerminal* msg) {
  return *msg->_impl_.identifiedobject_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ACDCTerminal::_Internal::connected(const ACDCTerminal* msg) {
  return *msg->_impl_.connected_;
}
const ::PROTOBUF_NAMESPACE_ID::Int32Value&
ACDCTerminal::_Internal::sequencenumber(const ACDCTerminal* msg) {
  return *msg->_impl_.sequencenumber_;
}
void ACDCTerminal::clear_connected() {
  if (GetArenaForAllocation() == nullptr && _impl_.connected_ != nullptr) {
    delete _impl_.connected_;
  }
  _impl_.connected_ = nullptr;
}
void ACDCTerminal::clear_sequencenumber() {
  if (GetArenaForAllocation() == nullptr && _impl_.sequencenumber_ != nullptr) {
    delete _impl_.sequencenumber_;
  }
  _impl_.sequencenumber_ = nullptr;
}
ACDCTerminal::ACDCTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ACDCTerminal)
}
ACDCTerminal::ACDCTerminal(const ACDCTerminal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ACDCTerminal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.connected_){nullptr}
    , decltype(_impl_.sequencenumber_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  if (from._internal_has_connected()) {
    _this->_impl_.connected_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.connected_);
  }
  if (from._internal_has_sequencenumber()) {
    _this->_impl_.sequencenumber_ = new ::PROTOBUF_NAMESPACE_ID::Int32Value(*from._impl_.sequencenumber_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ACDCTerminal)
}

inline void ACDCTerminal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.connected_){nullptr}
    , decltype(_impl_.sequencenumber_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ACDCTerminal::~ACDCTerminal() {
  // @@protoc_insertion_point(destructor:commonmodule.ACDCTerminal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ACDCTerminal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
  if (this != internal_default_instance()) delete _impl_.connected_;
  if (this != internal_default_instance()) delete _impl_.sequencenumber_;
}

void ACDCTerminal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ACDCTerminal::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ACDCTerminal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.connected_ != nullptr) {
    delete _impl_.connected_;
  }
  _impl_.connected_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.sequencenumber_ != nullptr) {
    delete _impl_.sequencenumber_;
  }
  _impl_.sequencenumber_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ACDCTerminal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue connected = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Int32Value sequenceNumber = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sequencenumber(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ACDCTerminal::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ACDCTerminal)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue connected = 2;
  if (this->_internal_has_connected()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::connected(this),
        _Internal::connected(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int32Value sequenceNumber = 3;
  if (this->_internal_has_sequencenumber()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sequencenumber(this),
        _Internal::sequencenumber(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ACDCTerminal)
  return target;
}

::size_t ACDCTerminal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ACDCTerminal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  // .google.protobuf.BoolValue connected = 2;
  if (this->_internal_has_connected()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connected_);
  }

  // .google.protobuf.Int32Value sequenceNumber = 3;
  if (this->_internal_has_sequencenumber()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sequencenumber_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ACDCTerminal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ACDCTerminal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ACDCTerminal::GetClassData() const { return &_class_data_; }


void ACDCTerminal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ACDCTerminal*>(&to_msg);
  auto& from = static_cast<const ACDCTerminal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ACDCTerminal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  if (from._internal_has_connected()) {
    _this->_internal_mutable_connected()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_connected());
  }
  if (from._internal_has_sequencenumber()) {
    _this->_internal_mutable_sequencenumber()->::PROTOBUF_NAMESPACE_ID::Int32Value::MergeFrom(
        from._internal_sequencenumber());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ACDCTerminal::CopyFrom(const ACDCTerminal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ACDCTerminal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACDCTerminal::IsInitialized() const {
  return true;
}

void ACDCTerminal::InternalSwap(ACDCTerminal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACDCTerminal, _impl_.sequencenumber_)
      + sizeof(ACDCTerminal::_impl_.sequencenumber_)
      - PROTOBUF_FIELD_OFFSET(ACDCTerminal, _impl_.identifiedobject_)>(
          reinterpret_cast<char*>(&_impl_.identifiedobject_),
          reinterpret_cast<char*>(&other->_impl_.identifiedobject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ACDCTerminal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[4]);
}
// ===================================================================

class Optional_UnitSymbolKind::_Internal {
 public:
};

Optional_UnitSymbolKind::Optional_UnitSymbolKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_UnitSymbolKind)
}
Optional_UnitSymbolKind::Optional_UnitSymbolKind(const Optional_UnitSymbolKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_UnitSymbolKind)
}

inline void Optional_UnitSymbolKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_UnitSymbolKind::~Optional_UnitSymbolKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_UnitSymbolKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_UnitSymbolKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_UnitSymbolKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_UnitSymbolKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_UnitSymbolKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_UnitSymbolKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.UnitSymbolKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::UnitSymbolKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_UnitSymbolKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_UnitSymbolKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.UnitSymbolKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_UnitSymbolKind)
  return target;
}

::size_t Optional_UnitSymbolKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_UnitSymbolKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.UnitSymbolKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_UnitSymbolKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_UnitSymbolKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_UnitSymbolKind::GetClassData() const { return &_class_data_; }


void Optional_UnitSymbolKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_UnitSymbolKind*>(&to_msg);
  auto& from = static_cast<const Optional_UnitSymbolKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_UnitSymbolKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_UnitSymbolKind::CopyFrom(const Optional_UnitSymbolKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_UnitSymbolKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_UnitSymbolKind::IsInitialized() const {
  return true;
}

void Optional_UnitSymbolKind::InternalSwap(Optional_UnitSymbolKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_UnitSymbolKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[5]);
}
// ===================================================================

class Optional_UnitMultiplierKind::_Internal {
 public:
};

Optional_UnitMultiplierKind::Optional_UnitMultiplierKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_UnitMultiplierKind)
}
Optional_UnitMultiplierKind::Optional_UnitMultiplierKind(const Optional_UnitMultiplierKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_UnitMultiplierKind)
}

inline void Optional_UnitMultiplierKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_UnitMultiplierKind::~Optional_UnitMultiplierKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_UnitMultiplierKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_UnitMultiplierKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_UnitMultiplierKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_UnitMultiplierKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_UnitMultiplierKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_UnitMultiplierKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.UnitMultiplierKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::UnitMultiplierKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_UnitMultiplierKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_UnitMultiplierKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.UnitMultiplierKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_UnitMultiplierKind)
  return target;
}

::size_t Optional_UnitMultiplierKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_UnitMultiplierKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.UnitMultiplierKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_UnitMultiplierKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_UnitMultiplierKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_UnitMultiplierKind::GetClassData() const { return &_class_data_; }


void Optional_UnitMultiplierKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_UnitMultiplierKind*>(&to_msg);
  auto& from = static_cast<const Optional_UnitMultiplierKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_UnitMultiplierKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_UnitMultiplierKind::CopyFrom(const Optional_UnitMultiplierKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_UnitMultiplierKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_UnitMultiplierKind::IsInitialized() const {
  return true;
}

void Optional_UnitMultiplierKind::InternalSwap(Optional_UnitMultiplierKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_UnitMultiplierKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[6]);
}
// ===================================================================

class ActivePower::_Internal {
 public:
  static const ::commonmodule::Optional_UnitMultiplierKind& multiplier(const ActivePower* msg);
  static const ::commonmodule::Optional_UnitSymbolKind& unit(const ActivePower* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FloatValue& value(const ActivePower* msg);
};

const ::commonmodule::Optional_UnitMultiplierKind&
ActivePower::_Internal::multiplier(const ActivePower* msg) {
  return *msg->_impl_.multiplier_;
}
const ::commonmodule::Optional_UnitSymbolKind&
ActivePower::_Internal::unit(const ActivePower* msg) {
  return *msg->_impl_.unit_;
}
const ::PROTOBUF_NAMESPACE_ID::FloatValue&
ActivePower::_Internal::value(const ActivePower* msg) {
  return *msg->_impl_.value_;
}
void ActivePower::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
ActivePower::ActivePower(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ActivePower)
}
ActivePower::ActivePower(const ActivePower& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActivePower* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.multiplier_){nullptr}
    , decltype(_impl_.unit_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_multiplier()) {
    _this->_impl_.multiplier_ = new ::commonmodule::Optional_UnitMultiplierKind(*from._impl_.multiplier_);
  }
  if (from._internal_has_unit()) {
    _this->_impl_.unit_ = new ::commonmodule::Optional_UnitSymbolKind(*from._impl_.unit_);
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::PROTOBUF_NAMESPACE_ID::FloatValue(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ActivePower)
}

inline void ActivePower::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.multiplier_){nullptr}
    , decltype(_impl_.unit_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ActivePower::~ActivePower() {
  // @@protoc_insertion_point(destructor:commonmodule.ActivePower)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActivePower::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.multiplier_;
  if (this != internal_default_instance()) delete _impl_.unit_;
  if (this != internal_default_instance()) delete _impl_.value_;
}

void ActivePower::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActivePower::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ActivePower)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.multiplier_ != nullptr) {
    delete _impl_.multiplier_;
  }
  _impl_.multiplier_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.unit_ != nullptr) {
    delete _impl_.unit_;
  }
  _impl_.unit_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActivePower::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiplier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_UnitSymbolKind unit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_unit(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.FloatValue value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ActivePower::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ActivePower)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  if (this->_internal_has_multiplier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::multiplier(this),
        _Internal::multiplier(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_UnitSymbolKind unit = 2;
  if (this->_internal_has_unit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::unit(this),
        _Internal::unit(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FloatValue value = 3;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ActivePower)
  return target;
}

::size_t ActivePower::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ActivePower)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  if (this->_internal_has_multiplier()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.multiplier_);
  }

  // .commonmodule.Optional_UnitSymbolKind unit = 2;
  if (this->_internal_has_unit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.unit_);
  }

  // .google.protobuf.FloatValue value = 3;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActivePower::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActivePower::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActivePower::GetClassData() const { return &_class_data_; }


void ActivePower::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActivePower*>(&to_msg);
  auto& from = static_cast<const ActivePower&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ActivePower)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_multiplier()) {
    _this->_internal_mutable_multiplier()->::commonmodule::Optional_UnitMultiplierKind::MergeFrom(
        from._internal_multiplier());
  }
  if (from._internal_has_unit()) {
    _this->_internal_mutable_unit()->::commonmodule::Optional_UnitSymbolKind::MergeFrom(
        from._internal_unit());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::PROTOBUF_NAMESPACE_ID::FloatValue::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActivePower::CopyFrom(const ActivePower& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ActivePower)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivePower::IsInitialized() const {
  return true;
}

void ActivePower::InternalSwap(ActivePower* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActivePower, _impl_.value_)
      + sizeof(ActivePower::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(ActivePower, _impl_.multiplier_)>(
          reinterpret_cast<char*>(&_impl_.multiplier_),
          reinterpret_cast<char*>(&other->_impl_.multiplier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActivePower::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[7]);
}
// ===================================================================

class Optional_PhaseCodeKind::_Internal {
 public:
};

Optional_PhaseCodeKind::Optional_PhaseCodeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_PhaseCodeKind)
}
Optional_PhaseCodeKind::Optional_PhaseCodeKind(const Optional_PhaseCodeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_PhaseCodeKind)
}

inline void Optional_PhaseCodeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_PhaseCodeKind::~Optional_PhaseCodeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_PhaseCodeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_PhaseCodeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_PhaseCodeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_PhaseCodeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_PhaseCodeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_PhaseCodeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.PhaseCodeKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::PhaseCodeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_PhaseCodeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_PhaseCodeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.PhaseCodeKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_PhaseCodeKind)
  return target;
}

::size_t Optional_PhaseCodeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_PhaseCodeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.PhaseCodeKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_PhaseCodeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_PhaseCodeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_PhaseCodeKind::GetClassData() const { return &_class_data_; }


void Optional_PhaseCodeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_PhaseCodeKind*>(&to_msg);
  auto& from = static_cast<const Optional_PhaseCodeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_PhaseCodeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_PhaseCodeKind::CopyFrom(const Optional_PhaseCodeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_PhaseCodeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_PhaseCodeKind::IsInitialized() const {
  return true;
}

void Optional_PhaseCodeKind::InternalSwap(Optional_PhaseCodeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_PhaseCodeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[8]);
}
// ===================================================================

class Unit::_Internal {
 public:
  static const ::commonmodule::Optional_UnitMultiplierKind& multiplier(const Unit* msg);
};

const ::commonmodule::Optional_UnitMultiplierKind&
Unit::_Internal::multiplier(const Unit* msg) {
  return *msg->_impl_.multiplier_;
}
Unit::Unit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Unit)
}
Unit::Unit(const Unit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Unit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.multiplier_){nullptr}
    , decltype(_impl_.siunit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_multiplier()) {
    _this->_impl_.multiplier_ = new ::commonmodule::Optional_UnitMultiplierKind(*from._impl_.multiplier_);
  }
  _this->_impl_.siunit_ = from._impl_.siunit_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.Unit)
}

inline void Unit::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.multiplier_){nullptr}
    , decltype(_impl_.siunit_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Unit::~Unit() {
  // @@protoc_insertion_point(destructor:commonmodule.Unit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Unit::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.multiplier_;
}

void Unit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Unit::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Unit)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.multiplier_ != nullptr) {
    delete _impl_.multiplier_;
  }
  _impl_.multiplier_ = nullptr;
  _impl_.siunit_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Unit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiplier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.UnitSymbolKind SIUnit = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_siunit(static_cast<::commonmodule::UnitSymbolKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Unit::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Unit)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  if (this->_internal_has_multiplier()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::multiplier(this),
        _Internal::multiplier(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.UnitSymbolKind SIUnit = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_siunit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_siunit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Unit)
  return target;
}

::size_t Unit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Unit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  if (this->_internal_has_multiplier()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.multiplier_);
  }

  // .commonmodule.UnitSymbolKind SIUnit = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_siunit() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_siunit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Unit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Unit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Unit::GetClassData() const { return &_class_data_; }


void Unit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Unit*>(&to_msg);
  auto& from = static_cast<const Unit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Unit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_multiplier()) {
    _this->_internal_mutable_multiplier()->::commonmodule::Optional_UnitMultiplierKind::MergeFrom(
        from._internal_multiplier());
  }
  if (from._internal_siunit() != 0) {
    _this->_internal_set_siunit(from._internal_siunit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Unit::CopyFrom(const Unit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Unit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unit::IsInitialized() const {
  return true;
}

void Unit::InternalSwap(Unit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Unit, _impl_.siunit_)
      + sizeof(Unit::_impl_.siunit_)
      - PROTOBUF_FIELD_OFFSET(Unit, _impl_.multiplier_)>(
          reinterpret_cast<char*>(&_impl_.multiplier_),
          reinterpret_cast<char*>(&other->_impl_.multiplier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Unit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[9]);
}
// ===================================================================

class Optional_ValidityKind::_Internal {
 public:
};

Optional_ValidityKind::Optional_ValidityKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_ValidityKind)
}
Optional_ValidityKind::Optional_ValidityKind(const Optional_ValidityKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_ValidityKind)
}

inline void Optional_ValidityKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_ValidityKind::~Optional_ValidityKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_ValidityKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_ValidityKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_ValidityKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_ValidityKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_ValidityKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_ValidityKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ValidityKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::ValidityKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_ValidityKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_ValidityKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ValidityKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_ValidityKind)
  return target;
}

::size_t Optional_ValidityKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_ValidityKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ValidityKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_ValidityKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_ValidityKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_ValidityKind::GetClassData() const { return &_class_data_; }


void Optional_ValidityKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_ValidityKind*>(&to_msg);
  auto& from = static_cast<const Optional_ValidityKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_ValidityKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_ValidityKind::CopyFrom(const Optional_ValidityKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_ValidityKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_ValidityKind::IsInitialized() const {
  return true;
}

void Optional_ValidityKind::InternalSwap(Optional_ValidityKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_ValidityKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[10]);
}
// ===================================================================

class DetailQual::_Internal {
 public:
};

DetailQual::DetailQual(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.DetailQual)
}
DetailQual::DetailQual(const DetailQual& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.DetailQual)
}

inline void DetailQual::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.badreference_) { false }

    , decltype(_impl_.failure_) { false }

    , decltype(_impl_.inaccurate_) { false }

    , decltype(_impl_.inconsistent_) { false }

    , decltype(_impl_.olddata_) { false }

    , decltype(_impl_.oscillatory_) { false }

    , decltype(_impl_.outofrange_) { false }

    , decltype(_impl_.overflow_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DetailQual::~DetailQual() {
  // @@protoc_insertion_point(destructor:commonmodule.DetailQual)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DetailQual::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void DetailQual::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DetailQual::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.DetailQual)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.badreference_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.overflow_) -
      reinterpret_cast<char*>(&_impl_.badreference_)) + sizeof(_impl_.overflow_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DetailQual::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool badReference = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.badreference_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool failure = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.failure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool inaccurate = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.inaccurate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool inconsistent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.inconsistent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool oldData = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.olddata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool oscillatory = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.oscillatory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool outOfRange = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.outofrange_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool overflow = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.overflow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DetailQual::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.DetailQual)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool badReference = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_badreference() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_badreference(), target);
  }

  // bool failure = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_failure() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_failure(), target);
  }

  // bool inaccurate = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_inaccurate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_inaccurate(), target);
  }

  // bool inconsistent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_inconsistent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_inconsistent(), target);
  }

  // bool oldData = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_olddata() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_olddata(), target);
  }

  // bool oscillatory = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_oscillatory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_oscillatory(), target);
  }

  // bool outOfRange = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_outofrange() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_outofrange(), target);
  }

  // bool overflow = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_overflow() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_overflow(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.DetailQual)
  return target;
}

::size_t DetailQual::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.DetailQual)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool badReference = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_badreference() != 0) {
    total_size += 2;
  }

  // bool failure = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_failure() != 0) {
    total_size += 2;
  }

  // bool inaccurate = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_inaccurate() != 0) {
    total_size += 2;
  }

  // bool inconsistent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_inconsistent() != 0) {
    total_size += 2;
  }

  // bool oldData = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_olddata() != 0) {
    total_size += 2;
  }

  // bool oscillatory = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_oscillatory() != 0) {
    total_size += 2;
  }

  // bool outOfRange = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_outofrange() != 0) {
    total_size += 2;
  }

  // bool overflow = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_overflow() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DetailQual::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DetailQual::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DetailQual::GetClassData() const { return &_class_data_; }


void DetailQual::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DetailQual*>(&to_msg);
  auto& from = static_cast<const DetailQual&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.DetailQual)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_badreference() != 0) {
    _this->_internal_set_badreference(from._internal_badreference());
  }
  if (from._internal_failure() != 0) {
    _this->_internal_set_failure(from._internal_failure());
  }
  if (from._internal_inaccurate() != 0) {
    _this->_internal_set_inaccurate(from._internal_inaccurate());
  }
  if (from._internal_inconsistent() != 0) {
    _this->_internal_set_inconsistent(from._internal_inconsistent());
  }
  if (from._internal_olddata() != 0) {
    _this->_internal_set_olddata(from._internal_olddata());
  }
  if (from._internal_oscillatory() != 0) {
    _this->_internal_set_oscillatory(from._internal_oscillatory());
  }
  if (from._internal_outofrange() != 0) {
    _this->_internal_set_outofrange(from._internal_outofrange());
  }
  if (from._internal_overflow() != 0) {
    _this->_internal_set_overflow(from._internal_overflow());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DetailQual::CopyFrom(const DetailQual& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.DetailQual)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetailQual::IsInitialized() const {
  return true;
}

void DetailQual::InternalSwap(DetailQual* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DetailQual, _impl_.overflow_)
      + sizeof(DetailQual::_impl_.overflow_)
      - PROTOBUF_FIELD_OFFSET(DetailQual, _impl_.badreference_)>(
          reinterpret_cast<char*>(&_impl_.badreference_),
          reinterpret_cast<char*>(&other->_impl_.badreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DetailQual::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[11]);
}
// ===================================================================

class Optional_SourceKind::_Internal {
 public:
};

Optional_SourceKind::Optional_SourceKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_SourceKind)
}
Optional_SourceKind::Optional_SourceKind(const Optional_SourceKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_SourceKind)
}

inline void Optional_SourceKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_SourceKind::~Optional_SourceKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_SourceKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_SourceKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_SourceKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_SourceKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_SourceKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_SourceKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.SourceKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::SourceKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_SourceKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_SourceKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.SourceKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_SourceKind)
  return target;
}

::size_t Optional_SourceKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_SourceKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.SourceKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_SourceKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_SourceKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_SourceKind::GetClassData() const { return &_class_data_; }


void Optional_SourceKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_SourceKind*>(&to_msg);
  auto& from = static_cast<const Optional_SourceKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_SourceKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_SourceKind::CopyFrom(const Optional_SourceKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_SourceKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_SourceKind::IsInitialized() const {
  return true;
}

void Optional_SourceKind::InternalSwap(Optional_SourceKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_SourceKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[12]);
}
// ===================================================================

class Quality::_Internal {
 public:
  static const ::commonmodule::DetailQual& detailqual(const Quality* msg);
};

const ::commonmodule::DetailQual&
Quality::_Internal::detailqual(const Quality* msg) {
  return *msg->_impl_.detailqual_;
}
Quality::Quality(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Quality)
}
Quality::Quality(const Quality& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Quality* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.detailqual_){nullptr}
    , decltype(_impl_.source_) {}

    , decltype(_impl_.operatorblocked_) {}

    , decltype(_impl_.test_) {}

    , decltype(_impl_.validity_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_detailqual()) {
    _this->_impl_.detailqual_ = new ::commonmodule::DetailQual(*from._impl_.detailqual_);
  }
  ::memcpy(&_impl_.source_, &from._impl_.source_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.validity_) -
    reinterpret_cast<char*>(&_impl_.source_)) + sizeof(_impl_.validity_));
  // @@protoc_insertion_point(copy_constructor:commonmodule.Quality)
}

inline void Quality::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.detailqual_){nullptr}
    , decltype(_impl_.source_) { 0 }

    , decltype(_impl_.operatorblocked_) { false }

    , decltype(_impl_.test_) { false }

    , decltype(_impl_.validity_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Quality::~Quality() {
  // @@protoc_insertion_point(destructor:commonmodule.Quality)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Quality::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.detailqual_;
}

void Quality::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Quality::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Quality)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.detailqual_ != nullptr) {
    delete _impl_.detailqual_;
  }
  _impl_.detailqual_ = nullptr;
  ::memset(&_impl_.source_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.validity_) -
      reinterpret_cast<char*>(&_impl_.source_)) + sizeof(_impl_.validity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quality::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.DetailQual detailQual = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_detailqual(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool operatorBlocked = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.operatorblocked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.SourceKind source = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_source(static_cast<::commonmodule::SourceKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool test = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.test_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ValidityKind validity = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_validity(static_cast<::commonmodule::ValidityKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Quality::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Quality)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.DetailQual detailQual = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_detailqual()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::detailqual(this),
        _Internal::detailqual(this).GetCachedSize(), target, stream);
  }

  // bool operatorBlocked = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_operatorblocked() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_operatorblocked(), target);
  }

  // .commonmodule.SourceKind source = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_source(), target);
  }

  // bool test = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_test() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_test(), target);
  }

  // .commonmodule.ValidityKind validity = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_validity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_validity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Quality)
  return target;
}

::size_t Quality::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Quality)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.DetailQual detailQual = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_detailqual()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.detailqual_);
  }

  // .commonmodule.SourceKind source = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_source() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_source());
  }

  // bool operatorBlocked = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_operatorblocked() != 0) {
    total_size += 2;
  }

  // bool test = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_test() != 0) {
    total_size += 2;
  }

  // .commonmodule.ValidityKind validity = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_validity() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_validity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Quality::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Quality::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Quality::GetClassData() const { return &_class_data_; }


void Quality::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Quality*>(&to_msg);
  auto& from = static_cast<const Quality&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Quality)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_detailqual()) {
    _this->_internal_mutable_detailqual()->::commonmodule::DetailQual::MergeFrom(
        from._internal_detailqual());
  }
  if (from._internal_source() != 0) {
    _this->_internal_set_source(from._internal_source());
  }
  if (from._internal_operatorblocked() != 0) {
    _this->_internal_set_operatorblocked(from._internal_operatorblocked());
  }
  if (from._internal_test() != 0) {
    _this->_internal_set_test(from._internal_test());
  }
  if (from._internal_validity() != 0) {
    _this->_internal_set_validity(from._internal_validity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Quality::CopyFrom(const Quality& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Quality)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quality::IsInitialized() const {
  return true;
}

void Quality::InternalSwap(Quality* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quality, _impl_.validity_)
      + sizeof(Quality::_impl_.validity_)
      - PROTOBUF_FIELD_OFFSET(Quality, _impl_.detailqual_)>(
          reinterpret_cast<char*>(&_impl_.detailqual_),
          reinterpret_cast<char*>(&other->_impl_.detailqual_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quality::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[13]);
}
// ===================================================================

class Optional_TimeAccuracyKind::_Internal {
 public:
};

Optional_TimeAccuracyKind::Optional_TimeAccuracyKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_TimeAccuracyKind)
}
Optional_TimeAccuracyKind::Optional_TimeAccuracyKind(const Optional_TimeAccuracyKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_TimeAccuracyKind)
}

inline void Optional_TimeAccuracyKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_TimeAccuracyKind::~Optional_TimeAccuracyKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_TimeAccuracyKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_TimeAccuracyKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_TimeAccuracyKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_TimeAccuracyKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_TimeAccuracyKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_TimeAccuracyKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.TimeAccuracyKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::TimeAccuracyKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_TimeAccuracyKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_TimeAccuracyKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.TimeAccuracyKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_TimeAccuracyKind)
  return target;
}

::size_t Optional_TimeAccuracyKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_TimeAccuracyKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.TimeAccuracyKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_TimeAccuracyKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_TimeAccuracyKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_TimeAccuracyKind::GetClassData() const { return &_class_data_; }


void Optional_TimeAccuracyKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_TimeAccuracyKind*>(&to_msg);
  auto& from = static_cast<const Optional_TimeAccuracyKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_TimeAccuracyKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_TimeAccuracyKind::CopyFrom(const Optional_TimeAccuracyKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_TimeAccuracyKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_TimeAccuracyKind::IsInitialized() const {
  return true;
}

void Optional_TimeAccuracyKind::InternalSwap(Optional_TimeAccuracyKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_TimeAccuracyKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[14]);
}
// ===================================================================

class TimeQuality::_Internal {
 public:
};

TimeQuality::TimeQuality(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.TimeQuality)
}
TimeQuality::TimeQuality(const TimeQuality& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.TimeQuality)
}

inline void TimeQuality::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.clockfailure_) { false }

    , decltype(_impl_.clocknotsynchronized_) { false }

    , decltype(_impl_.leapsecondsknown_) { false }

    , decltype(_impl_.timeaccuracy_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TimeQuality::~TimeQuality() {
  // @@protoc_insertion_point(destructor:commonmodule.TimeQuality)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeQuality::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimeQuality::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimeQuality::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.TimeQuality)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.clockfailure_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.timeaccuracy_) -
      reinterpret_cast<char*>(&_impl_.clockfailure_)) + sizeof(_impl_.timeaccuracy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimeQuality::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.clockfailure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.clocknotsynchronized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.leapsecondsknown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_timeaccuracy(static_cast<::commonmodule::TimeAccuracyKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TimeQuality::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.TimeQuality)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_clockfailure() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_clockfailure(), target);
  }

  // bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_clocknotsynchronized() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_clocknotsynchronized(), target);
  }

  // bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_leapsecondsknown() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_leapsecondsknown(), target);
  }

  // .commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_timeaccuracy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_timeaccuracy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.TimeQuality)
  return target;
}

::size_t TimeQuality::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.TimeQuality)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_clockfailure() != 0) {
    total_size += 2;
  }

  // bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_clocknotsynchronized() != 0) {
    total_size += 2;
  }

  // bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_leapsecondsknown() != 0) {
    total_size += 2;
  }

  // .commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_timeaccuracy() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_timeaccuracy());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimeQuality::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimeQuality::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimeQuality::GetClassData() const { return &_class_data_; }


void TimeQuality::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimeQuality*>(&to_msg);
  auto& from = static_cast<const TimeQuality&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.TimeQuality)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_clockfailure() != 0) {
    _this->_internal_set_clockfailure(from._internal_clockfailure());
  }
  if (from._internal_clocknotsynchronized() != 0) {
    _this->_internal_set_clocknotsynchronized(from._internal_clocknotsynchronized());
  }
  if (from._internal_leapsecondsknown() != 0) {
    _this->_internal_set_leapsecondsknown(from._internal_leapsecondsknown());
  }
  if (from._internal_timeaccuracy() != 0) {
    _this->_internal_set_timeaccuracy(from._internal_timeaccuracy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimeQuality::CopyFrom(const TimeQuality& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.TimeQuality)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeQuality::IsInitialized() const {
  return true;
}

void TimeQuality::InternalSwap(TimeQuality* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeQuality, _impl_.timeaccuracy_)
      + sizeof(TimeQuality::_impl_.timeaccuracy_)
      - PROTOBUF_FIELD_OFFSET(TimeQuality, _impl_.clockfailure_)>(
          reinterpret_cast<char*>(&_impl_.clockfailure_),
          reinterpret_cast<char*>(&other->_impl_.clockfailure_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimeQuality::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[15]);
}
// ===================================================================

class Timestamp::_Internal {
 public:
  static const ::commonmodule::TimeQuality& tq(const Timestamp* msg);
};

const ::commonmodule::TimeQuality&
Timestamp::_Internal::tq(const Timestamp* msg) {
  return *msg->_impl_.tq_;
}
Timestamp::Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Timestamp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tq_){nullptr}
    , decltype(_impl_.seconds_) {}

    , decltype(_impl_.nanoseconds_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tq()) {
    _this->_impl_.tq_ = new ::commonmodule::TimeQuality(*from._impl_.tq_);
  }
  ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.nanoseconds_) -
    reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanoseconds_));
  // @@protoc_insertion_point(copy_constructor:commonmodule.Timestamp)
}

inline void Timestamp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.tq_){nullptr}
    , decltype(_impl_.seconds_) { ::uint64_t{0u} }

    , decltype(_impl_.nanoseconds_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Timestamp::~Timestamp() {
  // @@protoc_insertion_point(destructor:commonmodule.Timestamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Timestamp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tq_;
}

void Timestamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Timestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Timestamp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tq_ != nullptr) {
    delete _impl_.tq_;
  }
  _impl_.tq_ = nullptr;
  ::memset(&_impl_.seconds_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.nanoseconds_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanoseconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Timestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.TimeQuality tq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tq(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 nanoseconds = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.nanoseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Timestamp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Timestamp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_seconds(), target);
  }

  // .commonmodule.TimeQuality tq = 3;
  if (this->_internal_has_tq()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tq(this),
        _Internal::tq(this).GetCachedSize(), target, stream);
  }

  // uint32 nanoseconds = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_nanoseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Timestamp)
  return target;
}

::size_t Timestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Timestamp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.TimeQuality tq = 3;
  if (this->_internal_has_tq()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tq_);
  }

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_seconds());
  }

  // uint32 nanoseconds = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_nanoseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Timestamp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Timestamp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Timestamp::GetClassData() const { return &_class_data_; }


void Timestamp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Timestamp*>(&to_msg);
  auto& from = static_cast<const Timestamp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Timestamp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tq()) {
    _this->_internal_mutable_tq()->::commonmodule::TimeQuality::MergeFrom(
        from._internal_tq());
  }
  if (from._internal_seconds() != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  if (from._internal_nanoseconds() != 0) {
    _this->_internal_set_nanoseconds(from._internal_nanoseconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Timestamp::CopyFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamp::IsInitialized() const {
  return true;
}

void Timestamp::InternalSwap(Timestamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.nanoseconds_)
      + sizeof(Timestamp::_impl_.nanoseconds_)
      - PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.tq_)>(
          reinterpret_cast<char*>(&_impl_.tq_),
          reinterpret_cast<char*>(&other->_impl_.tq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Timestamp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[16]);
}
// ===================================================================

class MV::_Internal {
 public:
  static const ::commonmodule::Quality& q(const MV* msg);
  static const ::commonmodule::Timestamp& t(const MV* msg);
  static const ::commonmodule::Unit& units(const MV* msg);
};

const ::commonmodule::Quality&
MV::_Internal::q(const MV* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
MV::_Internal::t(const MV* msg) {
  return *msg->_impl_.t_;
}
const ::commonmodule::Unit&
MV::_Internal::units(const MV* msg) {
  return *msg->_impl_.units_;
}
MV::MV(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.MV)
}
MV::MV(const MV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MV* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.units_){nullptr}
    , decltype(_impl_.mag_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  if (from._internal_has_units()) {
    _this->_impl_.units_ = new ::commonmodule::Unit(*from._impl_.units_);
  }
  _this->_impl_.mag_ = from._impl_.mag_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.MV)
}

inline void MV::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.units_){nullptr}
    , decltype(_impl_.mag_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MV::~MV() {
  // @@protoc_insertion_point(destructor:commonmodule.MV)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MV::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
  if (this != internal_default_instance()) delete _impl_.units_;
}

void MV::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MV::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.MV)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.units_ != nullptr) {
    delete _impl_.units_;
  }
  _impl_.units_ = nullptr;
  _impl_.mag_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MV::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double mag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _impl_.mag_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Quality q = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Unit units = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_units(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MV::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.MV)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double mag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mag = this->_internal_mag();
  ::uint64_t raw_mag;
  memcpy(&raw_mag, &tmp_mag, sizeof(tmp_mag));
  if (raw_mag != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_mag(), target);
  }

  // .commonmodule.Quality q = 2;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Unit units = 4;
  if (this->_internal_has_units()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::units(this),
        _Internal::units(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.MV)
  return target;
}

::size_t MV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.MV)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 2;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // .commonmodule.Unit units = 4;
  if (this->_internal_has_units()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.units_);
  }

  // double mag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mag = this->_internal_mag();
  ::uint64_t raw_mag;
  memcpy(&raw_mag, &tmp_mag, sizeof(tmp_mag));
  if (raw_mag != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MV::GetClassData() const { return &_class_data_; }


void MV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MV*>(&to_msg);
  auto& from = static_cast<const MV&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.MV)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_has_units()) {
    _this->_internal_mutable_units()->::commonmodule::Unit::MergeFrom(
        from._internal_units());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mag = from._internal_mag();
  ::uint64_t raw_mag;
  memcpy(&raw_mag, &tmp_mag, sizeof(tmp_mag));
  if (raw_mag != 0) {
    _this->_internal_set_mag(from._internal_mag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MV::CopyFrom(const MV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.MV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MV::IsInitialized() const {
  return true;
}

void MV::InternalSwap(MV* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MV, _impl_.mag_)
      + sizeof(MV::_impl_.mag_)
      - PROTOBUF_FIELD_OFFSET(MV, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MV::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[17]);
}
// ===================================================================

class LogicalNode::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const LogicalNode* msg);
};

const ::commonmodule::IdentifiedObject&
LogicalNode::_Internal::identifiedobject(const LogicalNode* msg) {
  return *msg->_impl_.identifiedobject_;
}
LogicalNode::LogicalNode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.LogicalNode)
}
LogicalNode::LogicalNode(const LogicalNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogicalNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.LogicalNode)
}

inline void LogicalNode::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LogicalNode::~LogicalNode() {
  // @@protoc_insertion_point(destructor:commonmodule.LogicalNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogicalNode::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
}

void LogicalNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogicalNode::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.LogicalNode)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogicalNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LogicalNode::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.LogicalNode)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.LogicalNode)
  return target;
}

::size_t LogicalNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.LogicalNode)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogicalNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogicalNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogicalNode::GetClassData() const { return &_class_data_; }


void LogicalNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogicalNode*>(&to_msg);
  auto& from = static_cast<const LogicalNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.LogicalNode)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalNode::CopyFrom(const LogicalNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.LogicalNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalNode::IsInitialized() const {
  return true;
}

void LogicalNode::InternalSwap(LogicalNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.identifiedobject_, other->_impl_.identifiedobject_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicalNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[18]);
}
// ===================================================================

class AnalogEventAndStatusGGIO::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const AnalogEventAndStatusGGIO* msg);
  static const ::commonmodule::MV& anin(const AnalogEventAndStatusGGIO* msg);
  static const ::commonmodule::Optional_PhaseCodeKind& phase(const AnalogEventAndStatusGGIO* msg);
};

const ::commonmodule::LogicalNode&
AnalogEventAndStatusGGIO::_Internal::logicalnode(const AnalogEventAndStatusGGIO* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::MV&
AnalogEventAndStatusGGIO::_Internal::anin(const AnalogEventAndStatusGGIO* msg) {
  return *msg->_impl_.anin_;
}
const ::commonmodule::Optional_PhaseCodeKind&
AnalogEventAndStatusGGIO::_Internal::phase(const AnalogEventAndStatusGGIO* msg) {
  return *msg->_impl_.phase_;
}
AnalogEventAndStatusGGIO::AnalogEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.AnalogEventAndStatusGGIO)
}
AnalogEventAndStatusGGIO::AnalogEventAndStatusGGIO(const AnalogEventAndStatusGGIO& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnalogEventAndStatusGGIO* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.anin_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_anin()) {
    _this->_impl_.anin_ = new ::commonmodule::MV(*from._impl_.anin_);
  }
  if (from._internal_has_phase()) {
    _this->_impl_.phase_ = new ::commonmodule::Optional_PhaseCodeKind(*from._impl_.phase_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.AnalogEventAndStatusGGIO)
}

inline void AnalogEventAndStatusGGIO::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.anin_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AnalogEventAndStatusGGIO::~AnalogEventAndStatusGGIO() {
  // @@protoc_insertion_point(destructor:commonmodule.AnalogEventAndStatusGGIO)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnalogEventAndStatusGGIO::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.anin_;
  if (this != internal_default_instance()) delete _impl_.phase_;
}

void AnalogEventAndStatusGGIO::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnalogEventAndStatusGGIO::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.AnalogEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.anin_ != nullptr) {
    delete _impl_.anin_;
  }
  _impl_.anin_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnalogEventAndStatusGGIO::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.MV AnIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_anin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseCodeKind Phase = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phase(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AnalogEventAndStatusGGIO::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.AnalogEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.MV AnIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_anin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::anin(this),
        _Internal::anin(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  if (this->_internal_has_phase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phase(this),
        _Internal::phase(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.AnalogEventAndStatusGGIO)
  return target;
}

::size_t AnalogEventAndStatusGGIO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.AnalogEventAndStatusGGIO)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.MV AnIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_anin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.anin_);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  if (this->_internal_has_phase()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phase_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnalogEventAndStatusGGIO::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnalogEventAndStatusGGIO::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnalogEventAndStatusGGIO::GetClassData() const { return &_class_data_; }


void AnalogEventAndStatusGGIO::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnalogEventAndStatusGGIO*>(&to_msg);
  auto& from = static_cast<const AnalogEventAndStatusGGIO&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.AnalogEventAndStatusGGIO)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_anin()) {
    _this->_internal_mutable_anin()->::commonmodule::MV::MergeFrom(
        from._internal_anin());
  }
  if (from._internal_has_phase()) {
    _this->_internal_mutable_phase()->::commonmodule::Optional_PhaseCodeKind::MergeFrom(
        from._internal_phase());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnalogEventAndStatusGGIO::CopyFrom(const AnalogEventAndStatusGGIO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.AnalogEventAndStatusGGIO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnalogEventAndStatusGGIO::IsInitialized() const {
  return true;
}

void AnalogEventAndStatusGGIO::InternalSwap(AnalogEventAndStatusGGIO* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnalogEventAndStatusGGIO, _impl_.phase_)
      + sizeof(AnalogEventAndStatusGGIO::_impl_.phase_)
      - PROTOBUF_FIELD_OFFSET(AnalogEventAndStatusGGIO, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AnalogEventAndStatusGGIO::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[19]);
}
// ===================================================================

class NamedObject::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& description(const NamedObject* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& name(const NamedObject* msg);
};

const ::PROTOBUF_NAMESPACE_ID::StringValue&
NamedObject::_Internal::description(const NamedObject* msg) {
  return *msg->_impl_.description_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
NamedObject::_Internal::name(const NamedObject* msg) {
  return *msg->_impl_.name_;
}
void NamedObject::clear_description() {
  if (GetArenaForAllocation() == nullptr && _impl_.description_ != nullptr) {
    delete _impl_.description_;
  }
  _impl_.description_ = nullptr;
}
void NamedObject::clear_name() {
  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
    delete _impl_.name_;
  }
  _impl_.name_ = nullptr;
}
NamedObject::NamedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.NamedObject)
}
NamedObject::NamedObject(const NamedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamedObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.description_){nullptr}
    , decltype(_impl_.name_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_description()) {
    _this->_impl_.description_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.description_);
  }
  if (from._internal_has_name()) {
    _this->_impl_.name_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.name_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.NamedObject)
}

inline void NamedObject::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.description_){nullptr}
    , decltype(_impl_.name_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NamedObject::~NamedObject() {
  // @@protoc_insertion_point(destructor:commonmodule.NamedObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedObject::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.description_;
  if (this != internal_default_instance()) delete _impl_.name_;
}

void NamedObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.NamedObject)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.description_ != nullptr) {
    delete _impl_.description_;
  }
  _impl_.description_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.name_ != nullptr) {
    delete _impl_.name_;
  }
  _impl_.name_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamedObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.StringValue description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_description(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* NamedObject::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.NamedObject)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.StringValue description = 1;
  if (this->_internal_has_description()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::description(this),
        _Internal::description(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue name = 2;
  if (this->_internal_has_name()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::name(this),
        _Internal::name(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.NamedObject)
  return target;
}

::size_t NamedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.NamedObject)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.StringValue description = 1;
  if (this->_internal_has_description()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.description_);
  }

  // .google.protobuf.StringValue name = 2;
  if (this->_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.name_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamedObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamedObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamedObject::GetClassData() const { return &_class_data_; }


void NamedObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamedObject*>(&to_msg);
  auto& from = static_cast<const NamedObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.NamedObject)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_description()) {
    _this->_internal_mutable_description()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_description());
  }
  if (from._internal_has_name()) {
    _this->_internal_mutable_name()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamedObject::CopyFrom(const NamedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.NamedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedObject::IsInitialized() const {
  return true;
}

void NamedObject::InternalSwap(NamedObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NamedObject, _impl_.name_)
      + sizeof(NamedObject::_impl_.name_)
      - PROTOBUF_FIELD_OFFSET(NamedObject, _impl_.description_)>(
          reinterpret_cast<char*>(&_impl_.description_),
          reinterpret_cast<char*>(&other->_impl_.description_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NamedObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[20]);
}
// ===================================================================

class ApplicationSystem::_Internal {
 public:
  static const ::commonmodule::NamedObject& namedobject(const ApplicationSystem* msg);
};

const ::commonmodule::NamedObject&
ApplicationSystem::_Internal::namedobject(const ApplicationSystem* msg) {
  return *msg->_impl_.namedobject_;
}
ApplicationSystem::ApplicationSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ApplicationSystem)
}
ApplicationSystem::ApplicationSystem(const ApplicationSystem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplicationSystem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mrid_) {}

    , decltype(_impl_.namedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mrid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mrid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mrid().empty()) {
    _this->_impl_.mrid_.Set(from._internal_mrid(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_namedobject()) {
    _this->_impl_.namedobject_ = new ::commonmodule::NamedObject(*from._impl_.namedobject_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ApplicationSystem)
}

inline void ApplicationSystem::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.mrid_) {}

    , decltype(_impl_.namedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mrid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mrid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplicationSystem::~ApplicationSystem() {
  // @@protoc_insertion_point(destructor:commonmodule.ApplicationSystem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplicationSystem::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mrid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.namedobject_;
}

void ApplicationSystem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplicationSystem::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ApplicationSystem)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mrid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.namedobject_ != nullptr) {
    delete _impl_.namedobject_;
  }
  _impl_.namedobject_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplicationSystem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mrid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "commonmodule.ApplicationSystem.mRID"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ApplicationSystem::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ApplicationSystem)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_namedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::namedobject(this),
        _Internal::namedobject(this).GetCachedSize(), target, stream);
  }

  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true];
  if (!this->_internal_mrid().empty()) {
    const std::string& _s = this->_internal_mrid();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "commonmodule.ApplicationSystem.mRID");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ApplicationSystem)
  return target;
}

::size_t ApplicationSystem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ApplicationSystem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true];
  if (!this->_internal_mrid().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_mrid());
  }

  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_namedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.namedobject_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplicationSystem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplicationSystem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplicationSystem::GetClassData() const { return &_class_data_; }


void ApplicationSystem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplicationSystem*>(&to_msg);
  auto& from = static_cast<const ApplicationSystem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ApplicationSystem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mrid().empty()) {
    _this->_internal_set_mrid(from._internal_mrid());
  }
  if (from._internal_has_namedobject()) {
    _this->_internal_mutable_namedobject()->::commonmodule::NamedObject::MergeFrom(
        from._internal_namedobject());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplicationSystem::CopyFrom(const ApplicationSystem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ApplicationSystem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplicationSystem::IsInitialized() const {
  return true;
}

void ApplicationSystem::InternalSwap(ApplicationSystem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mrid_, lhs_arena,
                                       &other->_impl_.mrid_, rhs_arena);
  swap(_impl_.namedobject_, other->_impl_.namedobject_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplicationSystem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[21]);
}
// ===================================================================

class ASG::_Internal {
 public:
};

ASG::ASG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ASG)
}
ASG::ASG(const ASG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ASG)
}

inline void ASG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.setmag_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ASG::~ASG() {
  // @@protoc_insertion_point(destructor:commonmodule.ASG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ASG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ASG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ASG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ASG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.setmag_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ASG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double setMag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _impl_.setmag_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ASG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ASG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double setMag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_setmag = this->_internal_setmag();
  ::uint64_t raw_setmag;
  memcpy(&raw_setmag, &tmp_setmag, sizeof(tmp_setmag));
  if (raw_setmag != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_setmag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ASG)
  return target;
}

::size_t ASG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ASG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double setMag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_setmag = this->_internal_setmag();
  ::uint64_t raw_setmag;
  memcpy(&raw_setmag, &tmp_setmag, sizeof(tmp_setmag));
  if (raw_setmag != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ASG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ASG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ASG::GetClassData() const { return &_class_data_; }


void ASG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ASG*>(&to_msg);
  auto& from = static_cast<const ASG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ASG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_setmag = from._internal_setmag();
  ::uint64_t raw_setmag;
  memcpy(&raw_setmag, &tmp_setmag, sizeof(tmp_setmag));
  if (raw_setmag != 0) {
    _this->_internal_set_setmag(from._internal_setmag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ASG::CopyFrom(const ASG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ASG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ASG::IsInitialized() const {
  return true;
}

void ASG::InternalSwap(ASG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.setmag_, other->_impl_.setmag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ASG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[22]);
}
// ===================================================================

class BCR::_Internal {
 public:
  static const ::commonmodule::Quality& q(const BCR* msg);
  static const ::commonmodule::Timestamp& t(const BCR* msg);
};

const ::commonmodule::Quality&
BCR::_Internal::q(const BCR* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
BCR::_Internal::t(const BCR* msg) {
  return *msg->_impl_.t_;
}
BCR::BCR(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.BCR)
}
BCR::BCR(const BCR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BCR* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.actval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.actval_ = from._impl_.actval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.BCR)
}

inline void BCR::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.actval_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BCR::~BCR() {
  // @@protoc_insertion_point(destructor:commonmodule.BCR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BCR::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void BCR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BCR::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.BCR)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.actval_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BCR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 actVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.actval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Quality q = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BCR::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.BCR)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 actVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_actval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_actval(), target);
  }

  // .commonmodule.Quality q = 2;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.BCR)
  return target;
}

::size_t BCR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.BCR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 2;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // int64 actVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_actval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_actval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BCR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BCR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BCR::GetClassData() const { return &_class_data_; }


void BCR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BCR*>(&to_msg);
  auto& from = static_cast<const BCR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.BCR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_actval() != 0) {
    _this->_internal_set_actval(from._internal_actval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BCR::CopyFrom(const BCR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.BCR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BCR::IsInitialized() const {
  return true;
}

void BCR::InternalSwap(BCR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BCR, _impl_.actval_)
      + sizeof(BCR::_impl_.actval_)
      - PROTOBUF_FIELD_OFFSET(BCR, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BCR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[23]);
}
// ===================================================================

class StatusSPS::_Internal {
 public:
  static const ::commonmodule::Quality& q(const StatusSPS* msg);
  static const ::commonmodule::Timestamp& t(const StatusSPS* msg);
};

const ::commonmodule::Quality&
StatusSPS::_Internal::q(const StatusSPS* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
StatusSPS::_Internal::t(const StatusSPS* msg) {
  return *msg->_impl_.t_;
}
StatusSPS::StatusSPS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusSPS)
}
StatusSPS::StatusSPS(const StatusSPS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusSPS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusSPS)
}

inline void StatusSPS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusSPS::~StatusSPS() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusSPS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusSPS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void StatusSPS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusSPS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusSPS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusSPS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.stval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusSPS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusSPS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusSPS)
  return target;
}

::size_t StatusSPS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusSPS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusSPS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusSPS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusSPS::GetClassData() const { return &_class_data_; }


void StatusSPS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusSPS*>(&to_msg);
  auto& from = static_cast<const StatusSPS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusSPS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusSPS::CopyFrom(const StatusSPS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusSPS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusSPS::IsInitialized() const {
  return true;
}

void StatusSPS::InternalSwap(StatusSPS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusSPS, _impl_.stval_)
      + sizeof(StatusSPS::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(StatusSPS, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusSPS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[24]);
}
// ===================================================================

class BooleanEventAndStatusGGIO::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const BooleanEventAndStatusGGIO* msg);
  static const ::commonmodule::StatusSPS& ind(const BooleanEventAndStatusGGIO* msg);
  static const ::commonmodule::Optional_PhaseCodeKind& phase(const BooleanEventAndStatusGGIO* msg);
};

const ::commonmodule::LogicalNode&
BooleanEventAndStatusGGIO::_Internal::logicalnode(const BooleanEventAndStatusGGIO* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::StatusSPS&
BooleanEventAndStatusGGIO::_Internal::ind(const BooleanEventAndStatusGGIO* msg) {
  return *msg->_impl_.ind_;
}
const ::commonmodule::Optional_PhaseCodeKind&
BooleanEventAndStatusGGIO::_Internal::phase(const BooleanEventAndStatusGGIO* msg) {
  return *msg->_impl_.phase_;
}
BooleanEventAndStatusGGIO::BooleanEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.BooleanEventAndStatusGGIO)
}
BooleanEventAndStatusGGIO::BooleanEventAndStatusGGIO(const BooleanEventAndStatusGGIO& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BooleanEventAndStatusGGIO* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.ind_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_ind()) {
    _this->_impl_.ind_ = new ::commonmodule::StatusSPS(*from._impl_.ind_);
  }
  if (from._internal_has_phase()) {
    _this->_impl_.phase_ = new ::commonmodule::Optional_PhaseCodeKind(*from._impl_.phase_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.BooleanEventAndStatusGGIO)
}

inline void BooleanEventAndStatusGGIO::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.ind_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BooleanEventAndStatusGGIO::~BooleanEventAndStatusGGIO() {
  // @@protoc_insertion_point(destructor:commonmodule.BooleanEventAndStatusGGIO)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BooleanEventAndStatusGGIO::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.ind_;
  if (this != internal_default_instance()) delete _impl_.phase_;
}

void BooleanEventAndStatusGGIO::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BooleanEventAndStatusGGIO::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.BooleanEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.ind_ != nullptr) {
    delete _impl_.ind_;
  }
  _impl_.ind_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BooleanEventAndStatusGGIO::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusSPS Ind = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ind(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseCodeKind Phase = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phase(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BooleanEventAndStatusGGIO::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.BooleanEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusSPS Ind = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_ind()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ind(this),
        _Internal::ind(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  if (this->_internal_has_phase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phase(this),
        _Internal::phase(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.BooleanEventAndStatusGGIO)
  return target;
}

::size_t BooleanEventAndStatusGGIO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.BooleanEventAndStatusGGIO)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.StatusSPS Ind = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_ind()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ind_);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  if (this->_internal_has_phase()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phase_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BooleanEventAndStatusGGIO::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BooleanEventAndStatusGGIO::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BooleanEventAndStatusGGIO::GetClassData() const { return &_class_data_; }


void BooleanEventAndStatusGGIO::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BooleanEventAndStatusGGIO*>(&to_msg);
  auto& from = static_cast<const BooleanEventAndStatusGGIO&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.BooleanEventAndStatusGGIO)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_ind()) {
    _this->_internal_mutable_ind()->::commonmodule::StatusSPS::MergeFrom(
        from._internal_ind());
  }
  if (from._internal_has_phase()) {
    _this->_internal_mutable_phase()->::commonmodule::Optional_PhaseCodeKind::MergeFrom(
        from._internal_phase());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BooleanEventAndStatusGGIO::CopyFrom(const BooleanEventAndStatusGGIO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.BooleanEventAndStatusGGIO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BooleanEventAndStatusGGIO::IsInitialized() const {
  return true;
}

void BooleanEventAndStatusGGIO::InternalSwap(BooleanEventAndStatusGGIO* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BooleanEventAndStatusGGIO, _impl_.phase_)
      + sizeof(BooleanEventAndStatusGGIO::_impl_.phase_)
      - PROTOBUF_FIELD_OFFSET(BooleanEventAndStatusGGIO, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BooleanEventAndStatusGGIO::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[25]);
}
// ===================================================================

class MessageInfo::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const MessageInfo* msg);
  static const ::commonmodule::Timestamp& messagetimestamp(const MessageInfo* msg);
};

const ::commonmodule::IdentifiedObject&
MessageInfo::_Internal::identifiedobject(const MessageInfo* msg) {
  return *msg->_impl_.identifiedobject_;
}
const ::commonmodule::Timestamp&
MessageInfo::_Internal::messagetimestamp(const MessageInfo* msg) {
  return *msg->_impl_.messagetimestamp_;
}
MessageInfo::MessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.MessageInfo)
}
MessageInfo::MessageInfo(const MessageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MessageInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.messagetimestamp_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  if (from._internal_has_messagetimestamp()) {
    _this->_impl_.messagetimestamp_ = new ::commonmodule::Timestamp(*from._impl_.messagetimestamp_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.MessageInfo)
}

inline void MessageInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.messagetimestamp_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MessageInfo::~MessageInfo() {
  // @@protoc_insertion_point(destructor:commonmodule.MessageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MessageInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
  if (this != internal_default_instance()) delete _impl_.messagetimestamp_;
}

void MessageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MessageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.MessageInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.messagetimestamp_ != nullptr) {
    delete _impl_.messagetimestamp_;
  }
  _impl_.messagetimestamp_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp messageTimeStamp = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_messagetimestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MessageInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.MessageInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Timestamp messageTimeStamp = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_messagetimestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::messagetimestamp(this),
        _Internal::messagetimestamp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.MessageInfo)
  return target;
}

::size_t MessageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.MessageInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  // .commonmodule.Timestamp messageTimeStamp = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_messagetimestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.messagetimestamp_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MessageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageInfo::GetClassData() const { return &_class_data_; }


void MessageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MessageInfo*>(&to_msg);
  auto& from = static_cast<const MessageInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.MessageInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  if (from._internal_has_messagetimestamp()) {
    _this->_internal_mutable_messagetimestamp()->::commonmodule::Timestamp::MergeFrom(
        from._internal_messagetimestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageInfo::CopyFrom(const MessageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.MessageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageInfo::IsInitialized() const {
  return true;
}

void MessageInfo::InternalSwap(MessageInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageInfo, _impl_.messagetimestamp_)
      + sizeof(MessageInfo::_impl_.messagetimestamp_)
      - PROTOBUF_FIELD_OFFSET(MessageInfo, _impl_.identifiedobject_)>(
          reinterpret_cast<char*>(&_impl_.identifiedobject_),
          reinterpret_cast<char*>(&other->_impl_.identifiedobject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[26]);
}
// ===================================================================

class CapabilityMessageInfo::_Internal {
 public:
  static const ::commonmodule::MessageInfo& messageinfo(const CapabilityMessageInfo* msg);
};

const ::commonmodule::MessageInfo&
CapabilityMessageInfo::_Internal::messageinfo(const CapabilityMessageInfo* msg) {
  return *msg->_impl_.messageinfo_;
}
CapabilityMessageInfo::CapabilityMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.CapabilityMessageInfo)
}
CapabilityMessageInfo::CapabilityMessageInfo(const CapabilityMessageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CapabilityMessageInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_messageinfo()) {
    _this->_impl_.messageinfo_ = new ::commonmodule::MessageInfo(*from._impl_.messageinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.CapabilityMessageInfo)
}

inline void CapabilityMessageInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CapabilityMessageInfo::~CapabilityMessageInfo() {
  // @@protoc_insertion_point(destructor:commonmodule.CapabilityMessageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CapabilityMessageInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.messageinfo_;
}

void CapabilityMessageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CapabilityMessageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.CapabilityMessageInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CapabilityMessageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_messageinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CapabilityMessageInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.CapabilityMessageInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::messageinfo(this),
        _Internal::messageinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.CapabilityMessageInfo)
  return target;
}

::size_t CapabilityMessageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.CapabilityMessageInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.messageinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CapabilityMessageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CapabilityMessageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CapabilityMessageInfo::GetClassData() const { return &_class_data_; }


void CapabilityMessageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CapabilityMessageInfo*>(&to_msg);
  auto& from = static_cast<const CapabilityMessageInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.CapabilityMessageInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_messageinfo()) {
    _this->_internal_mutable_messageinfo()->::commonmodule::MessageInfo::MergeFrom(
        from._internal_messageinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CapabilityMessageInfo::CopyFrom(const CapabilityMessageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.CapabilityMessageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CapabilityMessageInfo::IsInitialized() const {
  return true;
}

void CapabilityMessageInfo::InternalSwap(CapabilityMessageInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.messageinfo_, other->_impl_.messageinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CapabilityMessageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[27]);
}
// ===================================================================

class CheckConditions::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& interlockcheck(const CheckConditions* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& synchrocheck(const CheckConditions* msg);
};

const ::PROTOBUF_NAMESPACE_ID::BoolValue&
CheckConditions::_Internal::interlockcheck(const CheckConditions* msg) {
  return *msg->_impl_.interlockcheck_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
CheckConditions::_Internal::synchrocheck(const CheckConditions* msg) {
  return *msg->_impl_.synchrocheck_;
}
void CheckConditions::clear_interlockcheck() {
  if (GetArenaForAllocation() == nullptr && _impl_.interlockcheck_ != nullptr) {
    delete _impl_.interlockcheck_;
  }
  _impl_.interlockcheck_ = nullptr;
}
void CheckConditions::clear_synchrocheck() {
  if (GetArenaForAllocation() == nullptr && _impl_.synchrocheck_ != nullptr) {
    delete _impl_.synchrocheck_;
  }
  _impl_.synchrocheck_ = nullptr;
}
CheckConditions::CheckConditions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.CheckConditions)
}
CheckConditions::CheckConditions(const CheckConditions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckConditions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.interlockcheck_){nullptr}
    , decltype(_impl_.synchrocheck_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_interlockcheck()) {
    _this->_impl_.interlockcheck_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.interlockcheck_);
  }
  if (from._internal_has_synchrocheck()) {
    _this->_impl_.synchrocheck_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.synchrocheck_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.CheckConditions)
}

inline void CheckConditions::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.interlockcheck_){nullptr}
    , decltype(_impl_.synchrocheck_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CheckConditions::~CheckConditions() {
  // @@protoc_insertion_point(destructor:commonmodule.CheckConditions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckConditions::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.interlockcheck_;
  if (this != internal_default_instance()) delete _impl_.synchrocheck_;
}

void CheckConditions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckConditions::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.CheckConditions)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.interlockcheck_ != nullptr) {
    delete _impl_.interlockcheck_;
  }
  _impl_.interlockcheck_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.synchrocheck_ != nullptr) {
    delete _impl_.synchrocheck_;
  }
  _impl_.synchrocheck_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckConditions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.BoolValue interlockCheck = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_interlockcheck(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue synchroCheck = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_synchrocheck(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CheckConditions::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.CheckConditions)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.BoolValue interlockCheck = 1;
  if (this->_internal_has_interlockcheck()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::interlockcheck(this),
        _Internal::interlockcheck(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue synchroCheck = 2;
  if (this->_internal_has_synchrocheck()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::synchrocheck(this),
        _Internal::synchrocheck(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.CheckConditions)
  return target;
}

::size_t CheckConditions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.CheckConditions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.BoolValue interlockCheck = 1;
  if (this->_internal_has_interlockcheck()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.interlockcheck_);
  }

  // .google.protobuf.BoolValue synchroCheck = 2;
  if (this->_internal_has_synchrocheck()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.synchrocheck_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckConditions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckConditions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckConditions::GetClassData() const { return &_class_data_; }


void CheckConditions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckConditions*>(&to_msg);
  auto& from = static_cast<const CheckConditions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.CheckConditions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_interlockcheck()) {
    _this->_internal_mutable_interlockcheck()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_interlockcheck());
  }
  if (from._internal_has_synchrocheck()) {
    _this->_internal_mutable_synchrocheck()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_synchrocheck());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckConditions::CopyFrom(const CheckConditions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.CheckConditions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckConditions::IsInitialized() const {
  return true;
}

void CheckConditions::InternalSwap(CheckConditions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckConditions, _impl_.synchrocheck_)
      + sizeof(CheckConditions::_impl_.synchrocheck_)
      - PROTOBUF_FIELD_OFFSET(CheckConditions, _impl_.interlockcheck_)>(
          reinterpret_cast<char*>(&_impl_.interlockcheck_),
          reinterpret_cast<char*>(&other->_impl_.interlockcheck_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckConditions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[28]);
}
// ===================================================================

class ClearingTime::_Internal {
 public:
};

ClearingTime::ClearingTime(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ClearingTime)
}
ClearingTime::ClearingTime(const ClearingTime& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ClearingTime)
}

inline void ClearingTime::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_) { ::uint64_t{0u} }

    , decltype(_impl_.nanoseconds_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ClearingTime::~ClearingTime() {
  // @@protoc_insertion_point(destructor:commonmodule.ClearingTime)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClearingTime::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClearingTime::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClearingTime::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ClearingTime)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.nanoseconds_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanoseconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClearingTime::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.nanoseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ClearingTime::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ClearingTime)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_seconds(), target);
  }

  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_nanoseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ClearingTime)
  return target;
}

::size_t ClearingTime::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ClearingTime)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_seconds());
  }

  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_nanoseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClearingTime::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClearingTime::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClearingTime::GetClassData() const { return &_class_data_; }


void ClearingTime::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClearingTime*>(&to_msg);
  auto& from = static_cast<const ClearingTime&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ClearingTime)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seconds() != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  if (from._internal_nanoseconds() != 0) {
    _this->_internal_set_nanoseconds(from._internal_nanoseconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClearingTime::CopyFrom(const ClearingTime& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ClearingTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearingTime::IsInitialized() const {
  return true;
}

void ClearingTime::InternalSwap(ClearingTime* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClearingTime, _impl_.nanoseconds_)
      + sizeof(ClearingTime::_impl_.nanoseconds_)
      - PROTOBUF_FIELD_OFFSET(ClearingTime, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClearingTime::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[29]);
}
// ===================================================================

class Vector::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ang(const Vector* msg);
};

const ::PROTOBUF_NAMESPACE_ID::DoubleValue&
Vector::_Internal::ang(const Vector* msg) {
  return *msg->_impl_.ang_;
}
void Vector::clear_ang() {
  if (GetArenaForAllocation() == nullptr && _impl_.ang_ != nullptr) {
    delete _impl_.ang_;
  }
  _impl_.ang_ = nullptr;
}
Vector::Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Vector)
}
Vector::Vector(const Vector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ang_){nullptr}
    , decltype(_impl_.mag_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ang()) {
    _this->_impl_.ang_ = new ::PROTOBUF_NAMESPACE_ID::DoubleValue(*from._impl_.ang_);
  }
  _this->_impl_.mag_ = from._impl_.mag_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.Vector)
}

inline void Vector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ang_){nullptr}
    , decltype(_impl_.mag_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector::~Vector() {
  // @@protoc_insertion_point(destructor:commonmodule.Vector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ang_;
}

void Vector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Vector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.ang_ != nullptr) {
    delete _impl_.ang_;
  }
  _impl_.ang_ = nullptr;
  _impl_.mag_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.DoubleValue ang = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ang(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double mag = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _impl_.mag_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Vector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Vector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.DoubleValue ang = 1;
  if (this->_internal_has_ang()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ang(this),
        _Internal::ang(this).GetCachedSize(), target, stream);
  }

  // double mag = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mag = this->_internal_mag();
  ::uint64_t raw_mag;
  memcpy(&raw_mag, &tmp_mag, sizeof(tmp_mag));
  if (raw_mag != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_mag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Vector)
  return target;
}

::size_t Vector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Vector)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.DoubleValue ang = 1;
  if (this->_internal_has_ang()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ang_);
  }

  // double mag = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mag = this->_internal_mag();
  ::uint64_t raw_mag;
  memcpy(&raw_mag, &tmp_mag, sizeof(tmp_mag));
  if (raw_mag != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector::GetClassData() const { return &_class_data_; }


void Vector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector*>(&to_msg);
  auto& from = static_cast<const Vector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Vector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ang()) {
    _this->_internal_mutable_ang()->::PROTOBUF_NAMESPACE_ID::DoubleValue::MergeFrom(
        from._internal_ang());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_mag = from._internal_mag();
  ::uint64_t raw_mag;
  memcpy(&raw_mag, &tmp_mag, sizeof(tmp_mag));
  if (raw_mag != 0) {
    _this->_internal_set_mag(from._internal_mag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector::CopyFrom(const Vector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Vector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector::IsInitialized() const {
  return true;
}

void Vector::InternalSwap(Vector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector, _impl_.mag_)
      + sizeof(Vector::_impl_.mag_)
      - PROTOBUF_FIELD_OFFSET(Vector, _impl_.ang_)>(
          reinterpret_cast<char*>(&_impl_.ang_),
          reinterpret_cast<char*>(&other->_impl_.ang_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[30]);
}
// ===================================================================

class CMV::_Internal {
 public:
  static const ::commonmodule::Vector& cval(const CMV* msg);
  static const ::commonmodule::Quality& q(const CMV* msg);
  static const ::commonmodule::Timestamp& t(const CMV* msg);
};

const ::commonmodule::Vector&
CMV::_Internal::cval(const CMV* msg) {
  return *msg->_impl_.cval_;
}
const ::commonmodule::Quality&
CMV::_Internal::q(const CMV* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
CMV::_Internal::t(const CMV* msg) {
  return *msg->_impl_.t_;
}
CMV::CMV(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.CMV)
}
CMV::CMV(const CMV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMV* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cval_){nullptr}
    , decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cval()) {
    _this->_impl_.cval_ = new ::commonmodule::Vector(*from._impl_.cval_);
  }
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.CMV)
}

inline void CMV::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.cval_){nullptr}
    , decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMV::~CMV() {
  // @@protoc_insertion_point(destructor:commonmodule.CMV)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMV::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cval_;
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void CMV::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMV::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.CMV)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.cval_ != nullptr) {
    delete _impl_.cval_;
  }
  _impl_.cval_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMV::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Vector cVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cval(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Quality q = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CMV::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.CMV)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Vector cVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_cval()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cval(this),
        _Internal::cval(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Quality q = 2;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.CMV)
  return target;
}

::size_t CMV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.CMV)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Vector cVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_cval()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cval_);
  }

  // .commonmodule.Quality q = 2;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMV::GetClassData() const { return &_class_data_; }


void CMV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMV*>(&to_msg);
  auto& from = static_cast<const CMV&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.CMV)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cval()) {
    _this->_internal_mutable_cval()->::commonmodule::Vector::MergeFrom(
        from._internal_cval());
  }
  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMV::CopyFrom(const CMV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.CMV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMV::IsInitialized() const {
  return true;
}

void CMV::InternalSwap(CMV* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMV, _impl_.t_)
      + sizeof(CMV::_impl_.t_)
      - PROTOBUF_FIELD_OFFSET(CMV, _impl_.cval_)>(
          reinterpret_cast<char*>(&_impl_.cval_),
          reinterpret_cast<char*>(&other->_impl_.cval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMV::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[31]);
}
// ===================================================================

class ConductingEquipment::_Internal {
 public:
  static const ::commonmodule::NamedObject& namedobject(const ConductingEquipment* msg);
};

const ::commonmodule::NamedObject&
ConductingEquipment::_Internal::namedobject(const ConductingEquipment* msg) {
  return *msg->_impl_.namedobject_;
}
ConductingEquipment::ConductingEquipment(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ConductingEquipment)
}
ConductingEquipment::ConductingEquipment(const ConductingEquipment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConductingEquipment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mrid_) {}

    , decltype(_impl_.namedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mrid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mrid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mrid().empty()) {
    _this->_impl_.mrid_.Set(from._internal_mrid(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_namedobject()) {
    _this->_impl_.namedobject_ = new ::commonmodule::NamedObject(*from._impl_.namedobject_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ConductingEquipment)
}

inline void ConductingEquipment::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.mrid_) {}

    , decltype(_impl_.namedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mrid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mrid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConductingEquipment::~ConductingEquipment() {
  // @@protoc_insertion_point(destructor:commonmodule.ConductingEquipment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConductingEquipment::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mrid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.namedobject_;
}

void ConductingEquipment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConductingEquipment::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ConductingEquipment)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mrid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.namedobject_ != nullptr) {
    delete _impl_.namedobject_;
  }
  _impl_.namedobject_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConductingEquipment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_namedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true, (.uml.option_key) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mrid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "commonmodule.ConductingEquipment.mRID"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConductingEquipment::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ConductingEquipment)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_namedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::namedobject(this),
        _Internal::namedobject(this).GetCachedSize(), target, stream);
  }

  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true, (.uml.option_key) = true];
  if (!this->_internal_mrid().empty()) {
    const std::string& _s = this->_internal_mrid();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "commonmodule.ConductingEquipment.mRID");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ConductingEquipment)
  return target;
}

::size_t ConductingEquipment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ConductingEquipment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true, (.uml.option_key) = true];
  if (!this->_internal_mrid().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_mrid());
  }

  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_namedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.namedobject_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConductingEquipment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConductingEquipment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConductingEquipment::GetClassData() const { return &_class_data_; }


void ConductingEquipment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConductingEquipment*>(&to_msg);
  auto& from = static_cast<const ConductingEquipment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ConductingEquipment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mrid().empty()) {
    _this->_internal_set_mrid(from._internal_mrid());
  }
  if (from._internal_has_namedobject()) {
    _this->_internal_mutable_namedobject()->::commonmodule::NamedObject::MergeFrom(
        from._internal_namedobject());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConductingEquipment::CopyFrom(const ConductingEquipment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ConductingEquipment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConductingEquipment::IsInitialized() const {
  return true;
}

void ConductingEquipment::InternalSwap(ConductingEquipment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mrid_, lhs_arena,
                                       &other->_impl_.mrid_, rhs_arena);
  swap(_impl_.namedobject_, other->_impl_.namedobject_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConductingEquipment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[32]);
}
// ===================================================================

class Terminal::_Internal {
 public:
  static const ::commonmodule::ACDCTerminal& acdcterminal(const Terminal* msg);
  static const ::commonmodule::Optional_PhaseCodeKind& phases(const Terminal* msg);
};

const ::commonmodule::ACDCTerminal&
Terminal::_Internal::acdcterminal(const Terminal* msg) {
  return *msg->_impl_.acdcterminal_;
}
const ::commonmodule::Optional_PhaseCodeKind&
Terminal::_Internal::phases(const Terminal* msg) {
  return *msg->_impl_.phases_;
}
Terminal::Terminal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Terminal)
}
Terminal::Terminal(const Terminal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Terminal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.acdcterminal_){nullptr}
    , decltype(_impl_.phases_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_acdcterminal()) {
    _this->_impl_.acdcterminal_ = new ::commonmodule::ACDCTerminal(*from._impl_.acdcterminal_);
  }
  if (from._internal_has_phases()) {
    _this->_impl_.phases_ = new ::commonmodule::Optional_PhaseCodeKind(*from._impl_.phases_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.Terminal)
}

inline void Terminal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.acdcterminal_){nullptr}
    , decltype(_impl_.phases_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Terminal::~Terminal() {
  // @@protoc_insertion_point(destructor:commonmodule.Terminal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Terminal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.acdcterminal_;
  if (this != internal_default_instance()) delete _impl_.phases_;
}

void Terminal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Terminal::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Terminal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.acdcterminal_ != nullptr) {
    delete _impl_.acdcterminal_;
  }
  _impl_.acdcterminal_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phases_ != nullptr) {
    delete _impl_.phases_;
  }
  _impl_.phases_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Terminal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ACDCTerminal aCDCTerminal = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_acdcterminal(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseCodeKind phases = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phases(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Terminal::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Terminal)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ACDCTerminal aCDCTerminal = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_acdcterminal()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::acdcterminal(this),
        _Internal::acdcterminal(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseCodeKind phases = 2;
  if (this->_internal_has_phases()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phases(this),
        _Internal::phases(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Terminal)
  return target;
}

::size_t Terminal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Terminal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ACDCTerminal aCDCTerminal = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_acdcterminal()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.acdcterminal_);
  }

  // .commonmodule.Optional_PhaseCodeKind phases = 2;
  if (this->_internal_has_phases()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phases_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Terminal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Terminal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Terminal::GetClassData() const { return &_class_data_; }


void Terminal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Terminal*>(&to_msg);
  auto& from = static_cast<const Terminal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Terminal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_acdcterminal()) {
    _this->_internal_mutable_acdcterminal()->::commonmodule::ACDCTerminal::MergeFrom(
        from._internal_acdcterminal());
  }
  if (from._internal_has_phases()) {
    _this->_internal_mutable_phases()->::commonmodule::Optional_PhaseCodeKind::MergeFrom(
        from._internal_phases());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Terminal::CopyFrom(const Terminal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Terminal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Terminal::IsInitialized() const {
  return true;
}

void Terminal::InternalSwap(Terminal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Terminal, _impl_.phases_)
      + sizeof(Terminal::_impl_.phases_)
      - PROTOBUF_FIELD_OFFSET(Terminal, _impl_.acdcterminal_)>(
          reinterpret_cast<char*>(&_impl_.acdcterminal_),
          reinterpret_cast<char*>(&other->_impl_.acdcterminal_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Terminal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[33]);
}
// ===================================================================

class ConductingEquipmentTerminalReading::_Internal {
 public:
  static const ::commonmodule::Terminal& terminal(const ConductingEquipmentTerminalReading* msg);
};

const ::commonmodule::Terminal&
ConductingEquipmentTerminalReading::_Internal::terminal(const ConductingEquipmentTerminalReading* msg) {
  return *msg->_impl_.terminal_;
}
ConductingEquipmentTerminalReading::ConductingEquipmentTerminalReading(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ConductingEquipmentTerminalReading)
}
ConductingEquipmentTerminalReading::ConductingEquipmentTerminalReading(const ConductingEquipmentTerminalReading& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConductingEquipmentTerminalReading* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.terminal_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_terminal()) {
    _this->_impl_.terminal_ = new ::commonmodule::Terminal(*from._impl_.terminal_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ConductingEquipmentTerminalReading)
}

inline void ConductingEquipmentTerminalReading::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.terminal_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConductingEquipmentTerminalReading::~ConductingEquipmentTerminalReading() {
  // @@protoc_insertion_point(destructor:commonmodule.ConductingEquipmentTerminalReading)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConductingEquipmentTerminalReading::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.terminal_;
}

void ConductingEquipmentTerminalReading::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConductingEquipmentTerminalReading::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ConductingEquipmentTerminalReading)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.terminal_ != nullptr) {
    delete _impl_.terminal_;
  }
  _impl_.terminal_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConductingEquipmentTerminalReading::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Terminal terminal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_terminal(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConductingEquipmentTerminalReading::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ConductingEquipmentTerminalReading)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Terminal terminal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_terminal()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::terminal(this),
        _Internal::terminal(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ConductingEquipmentTerminalReading)
  return target;
}

::size_t ConductingEquipmentTerminalReading::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ConductingEquipmentTerminalReading)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Terminal terminal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_terminal()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.terminal_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConductingEquipmentTerminalReading::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConductingEquipmentTerminalReading::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConductingEquipmentTerminalReading::GetClassData() const { return &_class_data_; }


void ConductingEquipmentTerminalReading::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConductingEquipmentTerminalReading*>(&to_msg);
  auto& from = static_cast<const ConductingEquipmentTerminalReading&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ConductingEquipmentTerminalReading)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_terminal()) {
    _this->_internal_mutable_terminal()->::commonmodule::Terminal::MergeFrom(
        from._internal_terminal());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConductingEquipmentTerminalReading::CopyFrom(const ConductingEquipmentTerminalReading& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ConductingEquipmentTerminalReading)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConductingEquipmentTerminalReading::IsInitialized() const {
  return true;
}

void ConductingEquipmentTerminalReading::InternalSwap(ConductingEquipmentTerminalReading* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.terminal_, other->_impl_.terminal_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConductingEquipmentTerminalReading::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[34]);
}
// ===================================================================

class ControlAPC::_Internal {
 public:
};

ControlAPC::ControlAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlAPC)
}
ControlAPC::ControlAPC(const ControlAPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlAPC)
}

inline void ControlAPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ctlval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlAPC::~ControlAPC() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlAPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlAPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ControlAPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlAPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlAPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctlval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlAPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _impl_.ctlval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlAPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlAPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_ctlval = this->_internal_ctlval();
  ::uint64_t raw_ctlval;
  memcpy(&raw_ctlval, &tmp_ctlval, sizeof(tmp_ctlval));
  if (raw_ctlval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_ctlval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlAPC)
  return target;
}

::size_t ControlAPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlAPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_ctlval = this->_internal_ctlval();
  ::uint64_t raw_ctlval;
  memcpy(&raw_ctlval, &tmp_ctlval, sizeof(tmp_ctlval));
  if (raw_ctlval != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlAPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlAPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlAPC::GetClassData() const { return &_class_data_; }


void ControlAPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlAPC*>(&to_msg);
  auto& from = static_cast<const ControlAPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlAPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_ctlval = from._internal_ctlval();
  ::uint64_t raw_ctlval;
  memcpy(&raw_ctlval, &tmp_ctlval, sizeof(tmp_ctlval));
  if (raw_ctlval != 0) {
    _this->_internal_set_ctlval(from._internal_ctlval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlAPC::CopyFrom(const ControlAPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlAPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlAPC::IsInitialized() const {
  return true;
}

void ControlAPC::InternalSwap(ControlAPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.ctlval_, other->_impl_.ctlval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlAPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[35]);
}
// ===================================================================

class ControlDPC::_Internal {
 public:
};

ControlDPC::ControlDPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlDPC)
}
ControlDPC::ControlDPC(const ControlDPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlDPC)
}

inline void ControlDPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ctlval_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlDPC::~ControlDPC() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlDPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlDPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ControlDPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlDPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlDPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctlval_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlDPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.ctlval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlDPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlDPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_ctlval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlDPC)
  return target;
}

::size_t ControlDPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlDPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlDPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlDPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlDPC::GetClassData() const { return &_class_data_; }


void ControlDPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlDPC*>(&to_msg);
  auto& from = static_cast<const ControlDPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlDPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ctlval() != 0) {
    _this->_internal_set_ctlval(from._internal_ctlval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlDPC::CopyFrom(const ControlDPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlDPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlDPC::IsInitialized() const {
  return true;
}

void ControlDPC::InternalSwap(ControlDPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.ctlval_, other->_impl_.ctlval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlDPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[36]);
}
// ===================================================================

class ControlTimestamp::_Internal {
 public:
};

ControlTimestamp::ControlTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlTimestamp)
}
ControlTimestamp::ControlTimestamp(const ControlTimestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlTimestamp)
}

inline void ControlTimestamp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_) { ::uint64_t{0u} }

    , decltype(_impl_.nanoseconds_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlTimestamp::~ControlTimestamp() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlTimestamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlTimestamp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ControlTimestamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlTimestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlTimestamp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.nanoseconds_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanoseconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlTimestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.nanoseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlTimestamp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlTimestamp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_seconds(), target);
  }

  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_nanoseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlTimestamp)
  return target;
}

::size_t ControlTimestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlTimestamp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_seconds());
  }

  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_nanoseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlTimestamp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlTimestamp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlTimestamp::GetClassData() const { return &_class_data_; }


void ControlTimestamp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlTimestamp*>(&to_msg);
  auto& from = static_cast<const ControlTimestamp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlTimestamp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seconds() != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  if (from._internal_nanoseconds() != 0) {
    _this->_internal_set_nanoseconds(from._internal_nanoseconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlTimestamp::CopyFrom(const ControlTimestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlTimestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlTimestamp::IsInitialized() const {
  return true;
}

void ControlTimestamp::InternalSwap(ControlTimestamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControlTimestamp, _impl_.nanoseconds_)
      + sizeof(ControlTimestamp::_impl_.nanoseconds_)
      - PROTOBUF_FIELD_OFFSET(ControlTimestamp, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlTimestamp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[37]);
}
// ===================================================================

class Optional_ScheduleParameterKind::_Internal {
 public:
};

Optional_ScheduleParameterKind::Optional_ScheduleParameterKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_ScheduleParameterKind)
}
Optional_ScheduleParameterKind::Optional_ScheduleParameterKind(const Optional_ScheduleParameterKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_ScheduleParameterKind)
}

inline void Optional_ScheduleParameterKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_ScheduleParameterKind::~Optional_ScheduleParameterKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_ScheduleParameterKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_ScheduleParameterKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_ScheduleParameterKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_ScheduleParameterKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_ScheduleParameterKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_ScheduleParameterKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ScheduleParameterKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::ScheduleParameterKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_ScheduleParameterKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_ScheduleParameterKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ScheduleParameterKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_ScheduleParameterKind)
  return target;
}

::size_t Optional_ScheduleParameterKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_ScheduleParameterKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ScheduleParameterKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_ScheduleParameterKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_ScheduleParameterKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_ScheduleParameterKind::GetClassData() const { return &_class_data_; }


void Optional_ScheduleParameterKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_ScheduleParameterKind*>(&to_msg);
  auto& from = static_cast<const Optional_ScheduleParameterKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_ScheduleParameterKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_ScheduleParameterKind::CopyFrom(const Optional_ScheduleParameterKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_ScheduleParameterKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_ScheduleParameterKind::IsInitialized() const {
  return true;
}

void Optional_ScheduleParameterKind::InternalSwap(Optional_ScheduleParameterKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_ScheduleParameterKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[38]);
}
// ===================================================================

class ENG_ScheduleParameter::_Internal {
 public:
};

ENG_ScheduleParameter::ENG_ScheduleParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENG_ScheduleParameter)
}
ENG_ScheduleParameter::ENG_ScheduleParameter(const ENG_ScheduleParameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENG_ScheduleParameter)
}

inline void ENG_ScheduleParameter::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , decltype(_impl_.scheduleparametertype_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENG_ScheduleParameter::~ENG_ScheduleParameter() {
  // @@protoc_insertion_point(destructor:commonmodule.ENG_ScheduleParameter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENG_ScheduleParameter::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ENG_ScheduleParameter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENG_ScheduleParameter::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENG_ScheduleParameter)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.value_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.scheduleparametertype_) -
      reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.scheduleparametertype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENG_ScheduleParameter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ScheduleParameterKind scheduleParameterType = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_scheduleparametertype(static_cast<::commonmodule::ScheduleParameterKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // double value = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENG_ScheduleParameter::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENG_ScheduleParameter)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ScheduleParameterKind scheduleParameterType = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_scheduleparametertype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_scheduleparametertype(), target);
  }

  // double value = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  ::uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENG_ScheduleParameter)
  return target;
}

::size_t ENG_ScheduleParameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENG_ScheduleParameter)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double value = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  ::uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 9;
  }

  // .commonmodule.ScheduleParameterKind scheduleParameterType = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_scheduleparametertype() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_scheduleparametertype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENG_ScheduleParameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENG_ScheduleParameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENG_ScheduleParameter::GetClassData() const { return &_class_data_; }


void ENG_ScheduleParameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENG_ScheduleParameter*>(&to_msg);
  auto& from = static_cast<const ENG_ScheduleParameter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENG_ScheduleParameter)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_value = from._internal_value();
  ::uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_scheduleparametertype() != 0) {
    _this->_internal_set_scheduleparametertype(from._internal_scheduleparametertype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENG_ScheduleParameter::CopyFrom(const ENG_ScheduleParameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENG_ScheduleParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENG_ScheduleParameter::IsInitialized() const {
  return true;
}

void ENG_ScheduleParameter::InternalSwap(ENG_ScheduleParameter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENG_ScheduleParameter, _impl_.scheduleparametertype_)
      + sizeof(ENG_ScheduleParameter::_impl_.scheduleparametertype_)
      - PROTOBUF_FIELD_OFFSET(ENG_ScheduleParameter, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ENG_ScheduleParameter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[39]);
}
// ===================================================================

class SchedulePoint::_Internal {
 public:
  static const ::commonmodule::ControlTimestamp& starttime(const SchedulePoint* msg);
};

const ::commonmodule::ControlTimestamp&
SchedulePoint::_Internal::starttime(const SchedulePoint* msg) {
  return *msg->_impl_.starttime_;
}
SchedulePoint::SchedulePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.SchedulePoint)
}
SchedulePoint::SchedulePoint(const SchedulePoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedulePoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.scheduleparameter_){from._impl_.scheduleparameter_}
    , decltype(_impl_.starttime_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_starttime()) {
    _this->_impl_.starttime_ = new ::commonmodule::ControlTimestamp(*from._impl_.starttime_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.SchedulePoint)
}

inline void SchedulePoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.scheduleparameter_){arena}
    , decltype(_impl_.starttime_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SchedulePoint::~SchedulePoint() {
  // @@protoc_insertion_point(destructor:commonmodule.SchedulePoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedulePoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.scheduleparameter_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.starttime_;
}

void SchedulePoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedulePoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.SchedulePoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.scheduleparameter_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.starttime_ != nullptr) {
    delete _impl_.starttime_;
  }
  _impl_.starttime_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedulePoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_scheduleparameter(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_starttime(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedulePoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.SchedulePoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_scheduleparameter_size()); i < n; i++) {
    const auto& repfield = this->_internal_scheduleparameter(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_starttime()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::starttime(this),
        _Internal::starttime(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.SchedulePoint)
  return target;
}

::size_t SchedulePoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.SchedulePoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_scheduleparameter_size();
  for (const auto& msg : this->_impl_.scheduleparameter_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_starttime()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.starttime_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedulePoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedulePoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedulePoint::GetClassData() const { return &_class_data_; }


void SchedulePoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedulePoint*>(&to_msg);
  auto& from = static_cast<const SchedulePoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.SchedulePoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.scheduleparameter_.MergeFrom(from._impl_.scheduleparameter_);
  if (from._internal_has_starttime()) {
    _this->_internal_mutable_starttime()->::commonmodule::ControlTimestamp::MergeFrom(
        from._internal_starttime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedulePoint::CopyFrom(const SchedulePoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.SchedulePoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedulePoint::IsInitialized() const {
  return true;
}

void SchedulePoint::InternalSwap(SchedulePoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.scheduleparameter_.InternalSwap(&other->_impl_.scheduleparameter_);
  swap(_impl_.starttime_, other->_impl_.starttime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedulePoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[40]);
}
// ===================================================================

class ScheduleCSG::_Internal {
 public:
};

ScheduleCSG::ScheduleCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ScheduleCSG)
}
ScheduleCSG::ScheduleCSG(const ScheduleCSG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScheduleCSG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.schpts_){from._impl_.schpts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ScheduleCSG)
}

inline void ScheduleCSG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.schpts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ScheduleCSG::~ScheduleCSG() {
  // @@protoc_insertion_point(destructor:commonmodule.ScheduleCSG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScheduleCSG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.schpts_.~RepeatedPtrField();
}

void ScheduleCSG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScheduleCSG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ScheduleCSG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.schpts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScheduleCSG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.SchedulePoint schPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_schpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ScheduleCSG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ScheduleCSG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.SchedulePoint schPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_schpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_schpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ScheduleCSG)
  return target;
}

::size_t ScheduleCSG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ScheduleCSG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.SchedulePoint schPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_schpts_size();
  for (const auto& msg : this->_impl_.schpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScheduleCSG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScheduleCSG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScheduleCSG::GetClassData() const { return &_class_data_; }


void ScheduleCSG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScheduleCSG*>(&to_msg);
  auto& from = static_cast<const ScheduleCSG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ScheduleCSG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.schpts_.MergeFrom(from._impl_.schpts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScheduleCSG::CopyFrom(const ScheduleCSG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ScheduleCSG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScheduleCSG::IsInitialized() const {
  return true;
}

void ScheduleCSG::InternalSwap(ScheduleCSG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.schpts_.InternalSwap(&other->_impl_.schpts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ScheduleCSG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[41]);
}
// ===================================================================

class ControlScheduleFSCH::_Internal {
 public:
  static const ::commonmodule::ScheduleCSG& valacsg(const ControlScheduleFSCH* msg);
};

const ::commonmodule::ScheduleCSG&
ControlScheduleFSCH::_Internal::valacsg(const ControlScheduleFSCH* msg) {
  return *msg->_impl_.valacsg_;
}
ControlScheduleFSCH::ControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlScheduleFSCH)
}
ControlScheduleFSCH::ControlScheduleFSCH(const ControlScheduleFSCH& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControlScheduleFSCH* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.valacsg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_valacsg()) {
    _this->_impl_.valacsg_ = new ::commonmodule::ScheduleCSG(*from._impl_.valacsg_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlScheduleFSCH)
}

inline void ControlScheduleFSCH::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.valacsg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlScheduleFSCH::~ControlScheduleFSCH() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlScheduleFSCH)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlScheduleFSCH::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.valacsg_;
}

void ControlScheduleFSCH::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlScheduleFSCH::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlScheduleFSCH)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.valacsg_ != nullptr) {
    delete _impl_.valacsg_;
  }
  _impl_.valacsg_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlScheduleFSCH::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_valacsg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlScheduleFSCH::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlScheduleFSCH)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_valacsg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::valacsg(this),
        _Internal::valacsg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlScheduleFSCH)
  return target;
}

::size_t ControlScheduleFSCH::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlScheduleFSCH)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_valacsg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.valacsg_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlScheduleFSCH::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlScheduleFSCH::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlScheduleFSCH::GetClassData() const { return &_class_data_; }


void ControlScheduleFSCH::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlScheduleFSCH*>(&to_msg);
  auto& from = static_cast<const ControlScheduleFSCH&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlScheduleFSCH)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_valacsg()) {
    _this->_internal_mutable_valacsg()->::commonmodule::ScheduleCSG::MergeFrom(
        from._internal_valacsg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlScheduleFSCH::CopyFrom(const ControlScheduleFSCH& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlScheduleFSCH)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlScheduleFSCH::IsInitialized() const {
  return true;
}

void ControlScheduleFSCH::InternalSwap(ControlScheduleFSCH* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.valacsg_, other->_impl_.valacsg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlScheduleFSCH::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[42]);
}
// ===================================================================

class LogicalNodeForControl::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const LogicalNodeForControl* msg);
};

const ::commonmodule::LogicalNode&
LogicalNodeForControl::_Internal::logicalnode(const LogicalNodeForControl* msg) {
  return *msg->_impl_.logicalnode_;
}
LogicalNodeForControl::LogicalNodeForControl(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.LogicalNodeForControl)
}
LogicalNodeForControl::LogicalNodeForControl(const LogicalNodeForControl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogicalNodeForControl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.LogicalNodeForControl)
}

inline void LogicalNodeForControl::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LogicalNodeForControl::~LogicalNodeForControl() {
  // @@protoc_insertion_point(destructor:commonmodule.LogicalNodeForControl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogicalNodeForControl::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
}

void LogicalNodeForControl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogicalNodeForControl::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.LogicalNodeForControl)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogicalNodeForControl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LogicalNodeForControl::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.LogicalNodeForControl)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.LogicalNodeForControl)
  return target;
}

::size_t LogicalNodeForControl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.LogicalNodeForControl)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogicalNodeForControl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogicalNodeForControl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogicalNodeForControl::GetClassData() const { return &_class_data_; }


void LogicalNodeForControl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogicalNodeForControl*>(&to_msg);
  auto& from = static_cast<const LogicalNodeForControl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.LogicalNodeForControl)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalNodeForControl::CopyFrom(const LogicalNodeForControl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.LogicalNodeForControl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalNodeForControl::IsInitialized() const {
  return true;
}

void LogicalNodeForControl::InternalSwap(LogicalNodeForControl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.logicalnode_, other->_impl_.logicalnode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicalNodeForControl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[43]);
}
// ===================================================================

class ControlFSCC::_Internal {
 public:
  static const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol(const ControlFSCC* msg);
  static const ::commonmodule::ControlScheduleFSCH& controlschedulefsch(const ControlFSCC* msg);
  static const ::commonmodule::ControlScheduleFSCH& islandcontrolschedulefsch(const ControlFSCC* msg);
};

const ::commonmodule::LogicalNodeForControl&
ControlFSCC::_Internal::logicalnodeforcontrol(const ControlFSCC* msg) {
  return *msg->_impl_.logicalnodeforcontrol_;
}
const ::commonmodule::ControlScheduleFSCH&
ControlFSCC::_Internal::controlschedulefsch(const ControlFSCC* msg) {
  return *msg->_impl_.controlschedulefsch_;
}
const ::commonmodule::ControlScheduleFSCH&
ControlFSCC::_Internal::islandcontrolschedulefsch(const ControlFSCC* msg) {
  return *msg->_impl_.islandcontrolschedulefsch_;
}
ControlFSCC::ControlFSCC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlFSCC)
}
ControlFSCC::ControlFSCC(const ControlFSCC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControlFSCC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnodeforcontrol_){nullptr}
    , decltype(_impl_.controlschedulefsch_){nullptr}
    , decltype(_impl_.islandcontrolschedulefsch_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnodeforcontrol()) {
    _this->_impl_.logicalnodeforcontrol_ = new ::commonmodule::LogicalNodeForControl(*from._impl_.logicalnodeforcontrol_);
  }
  if (from._internal_has_controlschedulefsch()) {
    _this->_impl_.controlschedulefsch_ = new ::commonmodule::ControlScheduleFSCH(*from._impl_.controlschedulefsch_);
  }
  if (from._internal_has_islandcontrolschedulefsch()) {
    _this->_impl_.islandcontrolschedulefsch_ = new ::commonmodule::ControlScheduleFSCH(*from._impl_.islandcontrolschedulefsch_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlFSCC)
}

inline void ControlFSCC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnodeforcontrol_){nullptr}
    , decltype(_impl_.controlschedulefsch_){nullptr}
    , decltype(_impl_.islandcontrolschedulefsch_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlFSCC::~ControlFSCC() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlFSCC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlFSCC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnodeforcontrol_;
  if (this != internal_default_instance()) delete _impl_.controlschedulefsch_;
  if (this != internal_default_instance()) delete _impl_.islandcontrolschedulefsch_;
}

void ControlFSCC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlFSCC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlFSCC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnodeforcontrol_ != nullptr) {
    delete _impl_.logicalnodeforcontrol_;
  }
  _impl_.logicalnodeforcontrol_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.controlschedulefsch_ != nullptr) {
    delete _impl_.controlschedulefsch_;
  }
  _impl_.controlschedulefsch_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.islandcontrolschedulefsch_ != nullptr) {
    delete _impl_.islandcontrolschedulefsch_;
  }
  _impl_.islandcontrolschedulefsch_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlFSCC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnodeforcontrol(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_controlschedulefsch(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_islandcontrolschedulefsch(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlFSCC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlFSCC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnodeforcontrol()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnodeforcontrol(this),
        _Internal::logicalnodeforcontrol(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;
  if (this->_internal_has_controlschedulefsch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::controlschedulefsch(this),
        _Internal::controlschedulefsch(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;
  if (this->_internal_has_islandcontrolschedulefsch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::islandcontrolschedulefsch(this),
        _Internal::islandcontrolschedulefsch(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlFSCC)
  return target;
}

::size_t ControlFSCC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlFSCC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnodeforcontrol()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnodeforcontrol_);
  }

  // .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;
  if (this->_internal_has_controlschedulefsch()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.controlschedulefsch_);
  }

  // .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;
  if (this->_internal_has_islandcontrolschedulefsch()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.islandcontrolschedulefsch_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlFSCC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlFSCC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlFSCC::GetClassData() const { return &_class_data_; }


void ControlFSCC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlFSCC*>(&to_msg);
  auto& from = static_cast<const ControlFSCC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlFSCC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnodeforcontrol()) {
    _this->_internal_mutable_logicalnodeforcontrol()->::commonmodule::LogicalNodeForControl::MergeFrom(
        from._internal_logicalnodeforcontrol());
  }
  if (from._internal_has_controlschedulefsch()) {
    _this->_internal_mutable_controlschedulefsch()->::commonmodule::ControlScheduleFSCH::MergeFrom(
        from._internal_controlschedulefsch());
  }
  if (from._internal_has_islandcontrolschedulefsch()) {
    _this->_internal_mutable_islandcontrolschedulefsch()->::commonmodule::ControlScheduleFSCH::MergeFrom(
        from._internal_islandcontrolschedulefsch());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlFSCC::CopyFrom(const ControlFSCC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlFSCC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlFSCC::IsInitialized() const {
  return true;
}

void ControlFSCC::InternalSwap(ControlFSCC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControlFSCC, _impl_.islandcontrolschedulefsch_)
      + sizeof(ControlFSCC::_impl_.islandcontrolschedulefsch_)
      - PROTOBUF_FIELD_OFFSET(ControlFSCC, _impl_.logicalnodeforcontrol_)>(
          reinterpret_cast<char*>(&_impl_.logicalnodeforcontrol_),
          reinterpret_cast<char*>(&other->_impl_.logicalnodeforcontrol_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlFSCC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[44]);
}
// ===================================================================

class ControlINC::_Internal {
 public:
};

ControlINC::ControlINC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlINC)
}
ControlINC::ControlINC(const ControlINC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlINC)
}

inline void ControlINC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ctlval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlINC::~ControlINC() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlINC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlINC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ControlINC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlINC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlINC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctlval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlINC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.ctlval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlINC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlINC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_ctlval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlINC)
  return target;
}

::size_t ControlINC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlINC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ctlval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlINC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlINC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlINC::GetClassData() const { return &_class_data_; }


void ControlINC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlINC*>(&to_msg);
  auto& from = static_cast<const ControlINC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlINC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ctlval() != 0) {
    _this->_internal_set_ctlval(from._internal_ctlval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlINC::CopyFrom(const ControlINC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlINC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlINC::IsInitialized() const {
  return true;
}

void ControlINC::InternalSwap(ControlINC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.ctlval_, other->_impl_.ctlval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlINC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[45]);
}
// ===================================================================

class ControlING::_Internal {
 public:
  static const ::commonmodule::Unit& units(const ControlING* msg);
};

const ::commonmodule::Unit&
ControlING::_Internal::units(const ControlING* msg) {
  return *msg->_impl_.units_;
}
ControlING::ControlING(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlING)
}
ControlING::ControlING(const ControlING& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControlING* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.units_){nullptr}
    , decltype(_impl_.setval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_units()) {
    _this->_impl_.units_ = new ::commonmodule::Unit(*from._impl_.units_);
  }
  _this->_impl_.setval_ = from._impl_.setval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlING)
}

inline void ControlING::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.units_){nullptr}
    , decltype(_impl_.setval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlING::~ControlING() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlING)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlING::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.units_;
}

void ControlING::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlING::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlING)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.units_ != nullptr) {
    delete _impl_.units_;
  }
  _impl_.units_ = nullptr;
  _impl_.setval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlING::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.setval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Unit units = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_units(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlING::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlING)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_setval(), target);
  }

  // .commonmodule.Unit units = 2;
  if (this->_internal_has_units()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::units(this),
        _Internal::units(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlING)
  return target;
}

::size_t ControlING::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlING)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Unit units = 2;
  if (this->_internal_has_units()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.units_);
  }

  // int32 setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_setval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlING::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlING::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlING::GetClassData() const { return &_class_data_; }


void ControlING::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlING*>(&to_msg);
  auto& from = static_cast<const ControlING&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlING)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_units()) {
    _this->_internal_mutable_units()->::commonmodule::Unit::MergeFrom(
        from._internal_units());
  }
  if (from._internal_setval() != 0) {
    _this->_internal_set_setval(from._internal_setval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlING::CopyFrom(const ControlING& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlING)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlING::IsInitialized() const {
  return true;
}

void ControlING::InternalSwap(ControlING* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControlING, _impl_.setval_)
      + sizeof(ControlING::_impl_.setval_)
      - PROTOBUF_FIELD_OFFSET(ControlING, _impl_.units_)>(
          reinterpret_cast<char*>(&_impl_.units_),
          reinterpret_cast<char*>(&other->_impl_.units_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlING::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[46]);
}
// ===================================================================

class ControlISC::_Internal {
 public:
};

ControlISC::ControlISC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlISC)
}
ControlISC::ControlISC(const ControlISC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlISC)
}

inline void ControlISC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ctlval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlISC::~ControlISC() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlISC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlISC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ControlISC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlISC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlISC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctlval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlISC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.ctlval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlISC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlISC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_ctlval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlISC)
  return target;
}

::size_t ControlISC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlISC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ctlval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlISC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlISC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlISC::GetClassData() const { return &_class_data_; }


void ControlISC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlISC*>(&to_msg);
  auto& from = static_cast<const ControlISC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlISC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ctlval() != 0) {
    _this->_internal_set_ctlval(from._internal_ctlval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlISC::CopyFrom(const ControlISC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlISC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlISC::IsInitialized() const {
  return true;
}

void ControlISC::InternalSwap(ControlISC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.ctlval_, other->_impl_.ctlval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlISC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[47]);
}
// ===================================================================

class ControlMessageInfo::_Internal {
 public:
  static const ::commonmodule::MessageInfo& messageinfo(const ControlMessageInfo* msg);
};

const ::commonmodule::MessageInfo&
ControlMessageInfo::_Internal::messageinfo(const ControlMessageInfo* msg) {
  return *msg->_impl_.messageinfo_;
}
ControlMessageInfo::ControlMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlMessageInfo)
}
ControlMessageInfo::ControlMessageInfo(const ControlMessageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControlMessageInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_messageinfo()) {
    _this->_impl_.messageinfo_ = new ::commonmodule::MessageInfo(*from._impl_.messageinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlMessageInfo)
}

inline void ControlMessageInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlMessageInfo::~ControlMessageInfo() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlMessageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlMessageInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.messageinfo_;
}

void ControlMessageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlMessageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlMessageInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlMessageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_messageinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlMessageInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlMessageInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::messageinfo(this),
        _Internal::messageinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlMessageInfo)
  return target;
}

::size_t ControlMessageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlMessageInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.messageinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlMessageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlMessageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlMessageInfo::GetClassData() const { return &_class_data_; }


void ControlMessageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlMessageInfo*>(&to_msg);
  auto& from = static_cast<const ControlMessageInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlMessageInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_messageinfo()) {
    _this->_internal_mutable_messageinfo()->::commonmodule::MessageInfo::MergeFrom(
        from._internal_messageinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlMessageInfo::CopyFrom(const ControlMessageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlMessageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlMessageInfo::IsInitialized() const {
  return true;
}

void ControlMessageInfo::InternalSwap(ControlMessageInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.messageinfo_, other->_impl_.messageinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlMessageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[48]);
}
// ===================================================================

class ControlSPC::_Internal {
 public:
};

ControlSPC::ControlSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlSPC)
}
ControlSPC::ControlSPC(const ControlSPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlSPC)
}

inline void ControlSPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ctlval_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlSPC::~ControlSPC() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlSPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlSPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ControlSPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlSPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlSPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctlval_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlSPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.ctlval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlSPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlSPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_ctlval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlSPC)
  return target;
}

::size_t ControlSPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlSPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlSPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlSPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlSPC::GetClassData() const { return &_class_data_; }


void ControlSPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlSPC*>(&to_msg);
  auto& from = static_cast<const ControlSPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlSPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ctlval() != 0) {
    _this->_internal_set_ctlval(from._internal_ctlval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlSPC::CopyFrom(const ControlSPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlSPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlSPC::IsInitialized() const {
  return true;
}

void ControlSPC::InternalSwap(ControlSPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.ctlval_, other->_impl_.ctlval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlSPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[49]);
}
// ===================================================================

class ControlValue::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const ControlValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& modblk(const ControlValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& reset(const ControlValue* msg);
};

const ::commonmodule::IdentifiedObject&
ControlValue::_Internal::identifiedobject(const ControlValue* msg) {
  return *msg->_impl_.identifiedobject_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ControlValue::_Internal::modblk(const ControlValue* msg) {
  return *msg->_impl_.modblk_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ControlValue::_Internal::reset(const ControlValue* msg) {
  return *msg->_impl_.reset_;
}
void ControlValue::clear_modblk() {
  if (GetArenaForAllocation() == nullptr && _impl_.modblk_ != nullptr) {
    delete _impl_.modblk_;
  }
  _impl_.modblk_ = nullptr;
}
void ControlValue::clear_reset() {
  if (GetArenaForAllocation() == nullptr && _impl_.reset_ != nullptr) {
    delete _impl_.reset_;
  }
  _impl_.reset_ = nullptr;
}
ControlValue::ControlValue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ControlValue)
}
ControlValue::ControlValue(const ControlValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControlValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.modblk_){nullptr}
    , decltype(_impl_.reset_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  if (from._internal_has_modblk()) {
    _this->_impl_.modblk_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.modblk_);
  }
  if (from._internal_has_reset()) {
    _this->_impl_.reset_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.reset_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ControlValue)
}

inline void ControlValue::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.modblk_){nullptr}
    , decltype(_impl_.reset_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControlValue::~ControlValue() {
  // @@protoc_insertion_point(destructor:commonmodule.ControlValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlValue::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
  if (this != internal_default_instance()) delete _impl_.modblk_;
  if (this != internal_default_instance()) delete _impl_.reset_;
}

void ControlValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlValue::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ControlValue)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.modblk_ != nullptr) {
    delete _impl_.modblk_;
  }
  _impl_.modblk_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.reset_ != nullptr) {
    delete _impl_.reset_;
  }
  _impl_.reset_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue modBlk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_modblk(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue reset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reset(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ControlValue::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ControlValue)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue modBlk = 3;
  if (this->_internal_has_modblk()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::modblk(this),
        _Internal::modblk(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue reset = 4;
  if (this->_internal_has_reset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::reset(this),
        _Internal::reset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ControlValue)
  return target;
}

::size_t ControlValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ControlValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  // .google.protobuf.BoolValue modBlk = 3;
  if (this->_internal_has_modblk()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.modblk_);
  }

  // .google.protobuf.BoolValue reset = 4;
  if (this->_internal_has_reset()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reset_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlValue::GetClassData() const { return &_class_data_; }


void ControlValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlValue*>(&to_msg);
  auto& from = static_cast<const ControlValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ControlValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  if (from._internal_has_modblk()) {
    _this->_internal_mutable_modblk()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_modblk());
  }
  if (from._internal_has_reset()) {
    _this->_internal_mutable_reset()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_reset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlValue::CopyFrom(const ControlValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ControlValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlValue::IsInitialized() const {
  return true;
}

void ControlValue::InternalSwap(ControlValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControlValue, _impl_.reset_)
      + sizeof(ControlValue::_impl_.reset_)
      - PROTOBUF_FIELD_OFFSET(ControlValue, _impl_.identifiedobject_)>(
          reinterpret_cast<char*>(&_impl_.identifiedobject_),
          reinterpret_cast<char*>(&other->_impl_.identifiedobject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[50]);
}
// ===================================================================

class CumulativeTime::_Internal {
 public:
};

CumulativeTime::CumulativeTime(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.CumulativeTime)
}
CumulativeTime::CumulativeTime(const CumulativeTime& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.CumulativeTime)
}

inline void CumulativeTime::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_) { ::uint64_t{0u} }

    , decltype(_impl_.nanoseconds_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CumulativeTime::~CumulativeTime() {
  // @@protoc_insertion_point(destructor:commonmodule.CumulativeTime)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CumulativeTime::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void CumulativeTime::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CumulativeTime::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.CumulativeTime)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.nanoseconds_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanoseconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CumulativeTime::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.nanoseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CumulativeTime::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.CumulativeTime)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_seconds(), target);
  }

  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_nanoseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.CumulativeTime)
  return target;
}

::size_t CumulativeTime::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.CumulativeTime)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_seconds());
  }

  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_nanoseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_nanoseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CumulativeTime::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CumulativeTime::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CumulativeTime::GetClassData() const { return &_class_data_; }


void CumulativeTime::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CumulativeTime*>(&to_msg);
  auto& from = static_cast<const CumulativeTime&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.CumulativeTime)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seconds() != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  if (from._internal_nanoseconds() != 0) {
    _this->_internal_set_nanoseconds(from._internal_nanoseconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CumulativeTime::CopyFrom(const CumulativeTime& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.CumulativeTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CumulativeTime::IsInitialized() const {
  return true;
}

void CumulativeTime::InternalSwap(CumulativeTime* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CumulativeTime, _impl_.nanoseconds_)
      + sizeof(CumulativeTime::_impl_.nanoseconds_)
      - PROTOBUF_FIELD_OFFSET(CumulativeTime, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CumulativeTime::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[51]);
}
// ===================================================================

class DateTimeInterval::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Int64Value& end(const DateTimeInterval* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Int64Value& start(const DateTimeInterval* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Int64Value&
DateTimeInterval::_Internal::end(const DateTimeInterval* msg) {
  return *msg->_impl_.end_;
}
const ::PROTOBUF_NAMESPACE_ID::Int64Value&
DateTimeInterval::_Internal::start(const DateTimeInterval* msg) {
  return *msg->_impl_.start_;
}
void DateTimeInterval::clear_end() {
  if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
    delete _impl_.end_;
  }
  _impl_.end_ = nullptr;
}
void DateTimeInterval::clear_start() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
}
DateTimeInterval::DateTimeInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.DateTimeInterval)
}
DateTimeInterval::DateTimeInterval(const DateTimeInterval& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DateTimeInterval* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.end_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::PROTOBUF_NAMESPACE_ID::Int64Value(*from._impl_.end_);
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::PROTOBUF_NAMESPACE_ID::Int64Value(*from._impl_.start_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.DateTimeInterval)
}

inline void DateTimeInterval::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.end_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DateTimeInterval::~DateTimeInterval() {
  // @@protoc_insertion_point(destructor:commonmodule.DateTimeInterval)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DateTimeInterval::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.end_;
  if (this != internal_default_instance()) delete _impl_.start_;
}

void DateTimeInterval::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DateTimeInterval::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.DateTimeInterval)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
    delete _impl_.end_;
  }
  _impl_.end_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DateTimeInterval::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Int64Value end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Int64Value start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DateTimeInterval::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.DateTimeInterval)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Int64Value end = 1;
  if (this->_internal_has_end()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value start = 2;
  if (this->_internal_has_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.DateTimeInterval)
  return target;
}

::size_t DateTimeInterval::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.DateTimeInterval)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.Int64Value end = 1;
  if (this->_internal_has_end()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.end_);
  }

  // .google.protobuf.Int64Value start = 2;
  if (this->_internal_has_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DateTimeInterval::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DateTimeInterval::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DateTimeInterval::GetClassData() const { return &_class_data_; }


void DateTimeInterval::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DateTimeInterval*>(&to_msg);
  auto& from = static_cast<const DateTimeInterval&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.DateTimeInterval)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_end()) {
    _this->_internal_mutable_end()->::PROTOBUF_NAMESPACE_ID::Int64Value::MergeFrom(
        from._internal_end());
  }
  if (from._internal_has_start()) {
    _this->_internal_mutable_start()->::PROTOBUF_NAMESPACE_ID::Int64Value::MergeFrom(
        from._internal_start());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DateTimeInterval::CopyFrom(const DateTimeInterval& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.DateTimeInterval)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DateTimeInterval::IsInitialized() const {
  return true;
}

void DateTimeInterval::InternalSwap(DateTimeInterval* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DateTimeInterval, _impl_.start_)
      + sizeof(DateTimeInterval::_impl_.start_)
      - PROTOBUF_FIELD_OFFSET(DateTimeInterval, _impl_.end_)>(
          reinterpret_cast<char*>(&_impl_.end_),
          reinterpret_cast<char*>(&other->_impl_.end_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DateTimeInterval::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[52]);
}
// ===================================================================

class DEL::_Internal {
 public:
  static const ::commonmodule::CMV& phsab(const DEL* msg);
  static const ::commonmodule::CMV& phsbc(const DEL* msg);
  static const ::commonmodule::CMV& phsca(const DEL* msg);
};

const ::commonmodule::CMV&
DEL::_Internal::phsab(const DEL* msg) {
  return *msg->_impl_.phsab_;
}
const ::commonmodule::CMV&
DEL::_Internal::phsbc(const DEL* msg) {
  return *msg->_impl_.phsbc_;
}
const ::commonmodule::CMV&
DEL::_Internal::phsca(const DEL* msg) {
  return *msg->_impl_.phsca_;
}
DEL::DEL(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.DEL)
}
DEL::DEL(const DEL& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DEL* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phsab_){nullptr}
    , decltype(_impl_.phsbc_){nullptr}
    , decltype(_impl_.phsca_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phsab()) {
    _this->_impl_.phsab_ = new ::commonmodule::CMV(*from._impl_.phsab_);
  }
  if (from._internal_has_phsbc()) {
    _this->_impl_.phsbc_ = new ::commonmodule::CMV(*from._impl_.phsbc_);
  }
  if (from._internal_has_phsca()) {
    _this->_impl_.phsca_ = new ::commonmodule::CMV(*from._impl_.phsca_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.DEL)
}

inline void DEL::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phsab_){nullptr}
    , decltype(_impl_.phsbc_){nullptr}
    , decltype(_impl_.phsca_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DEL::~DEL() {
  // @@protoc_insertion_point(destructor:commonmodule.DEL)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DEL::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phsab_;
  if (this != internal_default_instance()) delete _impl_.phsbc_;
  if (this != internal_default_instance()) delete _impl_.phsca_;
}

void DEL::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DEL::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.DEL)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phsab_ != nullptr) {
    delete _impl_.phsab_;
  }
  _impl_.phsab_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsbc_ != nullptr) {
    delete _impl_.phsbc_;
  }
  _impl_.phsbc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsca_ != nullptr) {
    delete _impl_.phsca_;
  }
  _impl_.phsca_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DEL::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.CMV phsAB = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsab(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.CMV phsBC = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsbc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.CMV phsCA = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsca(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DEL::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.DEL)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.CMV phsAB = 1;
  if (this->_internal_has_phsab()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phsab(this),
        _Internal::phsab(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.CMV phsBC = 2;
  if (this->_internal_has_phsbc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsbc(this),
        _Internal::phsbc(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.CMV phsCA = 3;
  if (this->_internal_has_phsca()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsca(this),
        _Internal::phsca(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.DEL)
  return target;
}

::size_t DEL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.DEL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.CMV phsAB = 1;
  if (this->_internal_has_phsab()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsab_);
  }

  // .commonmodule.CMV phsBC = 2;
  if (this->_internal_has_phsbc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsbc_);
  }

  // .commonmodule.CMV phsCA = 3;
  if (this->_internal_has_phsca()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsca_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DEL::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DEL::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DEL::GetClassData() const { return &_class_data_; }


void DEL::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DEL*>(&to_msg);
  auto& from = static_cast<const DEL&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.DEL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phsab()) {
    _this->_internal_mutable_phsab()->::commonmodule::CMV::MergeFrom(
        from._internal_phsab());
  }
  if (from._internal_has_phsbc()) {
    _this->_internal_mutable_phsbc()->::commonmodule::CMV::MergeFrom(
        from._internal_phsbc());
  }
  if (from._internal_has_phsca()) {
    _this->_internal_mutable_phsca()->::commonmodule::CMV::MergeFrom(
        from._internal_phsca());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DEL::CopyFrom(const DEL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.DEL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DEL::IsInitialized() const {
  return true;
}

void DEL::InternalSwap(DEL* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DEL, _impl_.phsca_)
      + sizeof(DEL::_impl_.phsca_)
      - PROTOBUF_FIELD_OFFSET(DEL, _impl_.phsab_)>(
          reinterpret_cast<char*>(&_impl_.phsab_),
          reinterpret_cast<char*>(&other->_impl_.phsab_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DEL::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[53]);
}
// ===================================================================

class PhaseDPC::_Internal {
 public:
  static const ::commonmodule::ControlDPC& phs3(const PhaseDPC* msg);
  static const ::commonmodule::ControlDPC& phsa(const PhaseDPC* msg);
  static const ::commonmodule::ControlDPC& phsb(const PhaseDPC* msg);
  static const ::commonmodule::ControlDPC& phsc(const PhaseDPC* msg);
};

const ::commonmodule::ControlDPC&
PhaseDPC::_Internal::phs3(const PhaseDPC* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::ControlDPC&
PhaseDPC::_Internal::phsa(const PhaseDPC* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::ControlDPC&
PhaseDPC::_Internal::phsb(const PhaseDPC* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::ControlDPC&
PhaseDPC::_Internal::phsc(const PhaseDPC* msg) {
  return *msg->_impl_.phsc_;
}
PhaseDPC::PhaseDPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseDPC)
}
PhaseDPC::PhaseDPC(const PhaseDPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseDPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::ControlDPC(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::ControlDPC(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::ControlDPC(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::ControlDPC(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseDPC)
}

inline void PhaseDPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseDPC::~PhaseDPC() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseDPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseDPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseDPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseDPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseDPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseDPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ControlDPC phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlDPC phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlDPC phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlDPC phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseDPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseDPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ControlDPC phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlDPC phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlDPC phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlDPC phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseDPC)
  return target;
}

::size_t PhaseDPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseDPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ControlDPC phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.ControlDPC phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.ControlDPC phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.ControlDPC phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseDPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseDPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseDPC::GetClassData() const { return &_class_data_; }


void PhaseDPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseDPC*>(&to_msg);
  auto& from = static_cast<const PhaseDPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseDPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::ControlDPC::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::ControlDPC::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::ControlDPC::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::ControlDPC::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseDPC::CopyFrom(const PhaseDPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseDPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseDPC::IsInitialized() const {
  return true;
}

void PhaseDPC::InternalSwap(PhaseDPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseDPC, _impl_.phsc_)
      + sizeof(PhaseDPC::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseDPC, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseDPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[54]);
}
// ===================================================================

class DiscreteControlXCBR::_Internal {
 public:
  static const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol(const DiscreteControlXCBR* msg);
  static const ::commonmodule::PhaseDPC& pos(const DiscreteControlXCBR* msg);
  static const ::commonmodule::ControlINC& protectionmode(const DiscreteControlXCBR* msg);
  static const ::commonmodule::ControlSPC& recloseenabled(const DiscreteControlXCBR* msg);
  static const ::commonmodule::ControlSPC& resetprotectionpickup(const DiscreteControlXCBR* msg);
};

const ::commonmodule::LogicalNodeForControl&
DiscreteControlXCBR::_Internal::logicalnodeforcontrol(const DiscreteControlXCBR* msg) {
  return *msg->_impl_.logicalnodeforcontrol_;
}
const ::commonmodule::PhaseDPC&
DiscreteControlXCBR::_Internal::pos(const DiscreteControlXCBR* msg) {
  return *msg->_impl_.pos_;
}
const ::commonmodule::ControlINC&
DiscreteControlXCBR::_Internal::protectionmode(const DiscreteControlXCBR* msg) {
  return *msg->_impl_.protectionmode_;
}
const ::commonmodule::ControlSPC&
DiscreteControlXCBR::_Internal::recloseenabled(const DiscreteControlXCBR* msg) {
  return *msg->_impl_.recloseenabled_;
}
const ::commonmodule::ControlSPC&
DiscreteControlXCBR::_Internal::resetprotectionpickup(const DiscreteControlXCBR* msg) {
  return *msg->_impl_.resetprotectionpickup_;
}
DiscreteControlXCBR::DiscreteControlXCBR(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.DiscreteControlXCBR)
}
DiscreteControlXCBR::DiscreteControlXCBR(const DiscreteControlXCBR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DiscreteControlXCBR* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnodeforcontrol_){nullptr}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.protectionmode_){nullptr}
    , decltype(_impl_.recloseenabled_){nullptr}
    , decltype(_impl_.resetprotectionpickup_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnodeforcontrol()) {
    _this->_impl_.logicalnodeforcontrol_ = new ::commonmodule::LogicalNodeForControl(*from._impl_.logicalnodeforcontrol_);
  }
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::commonmodule::PhaseDPC(*from._impl_.pos_);
  }
  if (from._internal_has_protectionmode()) {
    _this->_impl_.protectionmode_ = new ::commonmodule::ControlINC(*from._impl_.protectionmode_);
  }
  if (from._internal_has_recloseenabled()) {
    _this->_impl_.recloseenabled_ = new ::commonmodule::ControlSPC(*from._impl_.recloseenabled_);
  }
  if (from._internal_has_resetprotectionpickup()) {
    _this->_impl_.resetprotectionpickup_ = new ::commonmodule::ControlSPC(*from._impl_.resetprotectionpickup_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.DiscreteControlXCBR)
}

inline void DiscreteControlXCBR::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnodeforcontrol_){nullptr}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.protectionmode_){nullptr}
    , decltype(_impl_.recloseenabled_){nullptr}
    , decltype(_impl_.resetprotectionpickup_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DiscreteControlXCBR::~DiscreteControlXCBR() {
  // @@protoc_insertion_point(destructor:commonmodule.DiscreteControlXCBR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DiscreteControlXCBR::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnodeforcontrol_;
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.protectionmode_;
  if (this != internal_default_instance()) delete _impl_.recloseenabled_;
  if (this != internal_default_instance()) delete _impl_.resetprotectionpickup_;
}

void DiscreteControlXCBR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DiscreteControlXCBR::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.DiscreteControlXCBR)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnodeforcontrol_ != nullptr) {
    delete _impl_.logicalnodeforcontrol_;
  }
  _impl_.logicalnodeforcontrol_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.protectionmode_ != nullptr) {
    delete _impl_.protectionmode_;
  }
  _impl_.protectionmode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.recloseenabled_ != nullptr) {
    delete _impl_.recloseenabled_;
  }
  _impl_.recloseenabled_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.resetprotectionpickup_ != nullptr) {
    delete _impl_.resetprotectionpickup_;
  }
  _impl_.resetprotectionpickup_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DiscreteControlXCBR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnodeforcontrol(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.PhaseDPC Pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlINC ProtectionMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_protectionmode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlSPC RecloseEnabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_recloseenabled(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlSPC ResetProtectionPickup = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_resetprotectionpickup(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DiscreteControlXCBR::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.DiscreteControlXCBR)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnodeforcontrol()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnodeforcontrol(this),
        _Internal::logicalnodeforcontrol(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.PhaseDPC Pos = 2;
  if (this->_internal_has_pos()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlINC ProtectionMode = 3;
  if (this->_internal_has_protectionmode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::protectionmode(this),
        _Internal::protectionmode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlSPC RecloseEnabled = 4;
  if (this->_internal_has_recloseenabled()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::recloseenabled(this),
        _Internal::recloseenabled(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlSPC ResetProtectionPickup = 5;
  if (this->_internal_has_resetprotectionpickup()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::resetprotectionpickup(this),
        _Internal::resetprotectionpickup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.DiscreteControlXCBR)
  return target;
}

::size_t DiscreteControlXCBR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.DiscreteControlXCBR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnodeforcontrol()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnodeforcontrol_);
  }

  // .commonmodule.PhaseDPC Pos = 2;
  if (this->_internal_has_pos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pos_);
  }

  // .commonmodule.ControlINC ProtectionMode = 3;
  if (this->_internal_has_protectionmode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.protectionmode_);
  }

  // .commonmodule.ControlSPC RecloseEnabled = 4;
  if (this->_internal_has_recloseenabled()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.recloseenabled_);
  }

  // .commonmodule.ControlSPC ResetProtectionPickup = 5;
  if (this->_internal_has_resetprotectionpickup()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.resetprotectionpickup_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DiscreteControlXCBR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DiscreteControlXCBR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DiscreteControlXCBR::GetClassData() const { return &_class_data_; }


void DiscreteControlXCBR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DiscreteControlXCBR*>(&to_msg);
  auto& from = static_cast<const DiscreteControlXCBR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.DiscreteControlXCBR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnodeforcontrol()) {
    _this->_internal_mutable_logicalnodeforcontrol()->::commonmodule::LogicalNodeForControl::MergeFrom(
        from._internal_logicalnodeforcontrol());
  }
  if (from._internal_has_pos()) {
    _this->_internal_mutable_pos()->::commonmodule::PhaseDPC::MergeFrom(
        from._internal_pos());
  }
  if (from._internal_has_protectionmode()) {
    _this->_internal_mutable_protectionmode()->::commonmodule::ControlINC::MergeFrom(
        from._internal_protectionmode());
  }
  if (from._internal_has_recloseenabled()) {
    _this->_internal_mutable_recloseenabled()->::commonmodule::ControlSPC::MergeFrom(
        from._internal_recloseenabled());
  }
  if (from._internal_has_resetprotectionpickup()) {
    _this->_internal_mutable_resetprotectionpickup()->::commonmodule::ControlSPC::MergeFrom(
        from._internal_resetprotectionpickup());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DiscreteControlXCBR::CopyFrom(const DiscreteControlXCBR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.DiscreteControlXCBR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiscreteControlXCBR::IsInitialized() const {
  return true;
}

void DiscreteControlXCBR::InternalSwap(DiscreteControlXCBR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DiscreteControlXCBR, _impl_.resetprotectionpickup_)
      + sizeof(DiscreteControlXCBR::_impl_.resetprotectionpickup_)
      - PROTOBUF_FIELD_OFFSET(DiscreteControlXCBR, _impl_.logicalnodeforcontrol_)>(
          reinterpret_cast<char*>(&_impl_.logicalnodeforcontrol_),
          reinterpret_cast<char*>(&other->_impl_.logicalnodeforcontrol_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DiscreteControlXCBR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[55]);
}
// ===================================================================

class EnergyConsumer::_Internal {
 public:
  static const ::commonmodule::ConductingEquipment& conductingequipment(const EnergyConsumer* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& operatinglimit(const EnergyConsumer* msg);
};

const ::commonmodule::ConductingEquipment&
EnergyConsumer::_Internal::conductingequipment(const EnergyConsumer* msg) {
  return *msg->_impl_.conductingequipment_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
EnergyConsumer::_Internal::operatinglimit(const EnergyConsumer* msg) {
  return *msg->_impl_.operatinglimit_;
}
void EnergyConsumer::clear_operatinglimit() {
  if (GetArenaForAllocation() == nullptr && _impl_.operatinglimit_ != nullptr) {
    delete _impl_.operatinglimit_;
  }
  _impl_.operatinglimit_ = nullptr;
}
EnergyConsumer::EnergyConsumer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.EnergyConsumer)
}
EnergyConsumer::EnergyConsumer(const EnergyConsumer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnergyConsumer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.conductingequipment_){nullptr}
    , decltype(_impl_.operatinglimit_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_conductingequipment()) {
    _this->_impl_.conductingequipment_ = new ::commonmodule::ConductingEquipment(*from._impl_.conductingequipment_);
  }
  if (from._internal_has_operatinglimit()) {
    _this->_impl_.operatinglimit_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.operatinglimit_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.EnergyConsumer)
}

inline void EnergyConsumer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.conductingequipment_){nullptr}
    , decltype(_impl_.operatinglimit_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EnergyConsumer::~EnergyConsumer() {
  // @@protoc_insertion_point(destructor:commonmodule.EnergyConsumer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnergyConsumer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.conductingequipment_;
  if (this != internal_default_instance()) delete _impl_.operatinglimit_;
}

void EnergyConsumer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnergyConsumer::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.EnergyConsumer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.conductingequipment_ != nullptr) {
    delete _impl_.conductingequipment_;
  }
  _impl_.conductingequipment_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.operatinglimit_ != nullptr) {
    delete _impl_.operatinglimit_;
  }
  _impl_.operatinglimit_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnergyConsumer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_conductingequipment(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue operatingLimit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_operatinglimit(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EnergyConsumer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.EnergyConsumer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_conductingequipment()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::conductingequipment(this),
        _Internal::conductingequipment(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue operatingLimit = 2;
  if (this->_internal_has_operatinglimit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::operatinglimit(this),
        _Internal::operatinglimit(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.EnergyConsumer)
  return target;
}

::size_t EnergyConsumer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.EnergyConsumer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_conductingequipment()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.conductingequipment_);
  }

  // .google.protobuf.StringValue operatingLimit = 2;
  if (this->_internal_has_operatinglimit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.operatinglimit_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnergyConsumer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnergyConsumer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnergyConsumer::GetClassData() const { return &_class_data_; }


void EnergyConsumer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnergyConsumer*>(&to_msg);
  auto& from = static_cast<const EnergyConsumer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.EnergyConsumer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_conductingequipment()) {
    _this->_internal_mutable_conductingequipment()->::commonmodule::ConductingEquipment::MergeFrom(
        from._internal_conductingequipment());
  }
  if (from._internal_has_operatinglimit()) {
    _this->_internal_mutable_operatinglimit()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_operatinglimit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnergyConsumer::CopyFrom(const EnergyConsumer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.EnergyConsumer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnergyConsumer::IsInitialized() const {
  return true;
}

void EnergyConsumer::InternalSwap(EnergyConsumer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnergyConsumer, _impl_.operatinglimit_)
      + sizeof(EnergyConsumer::_impl_.operatinglimit_)
      - PROTOBUF_FIELD_OFFSET(EnergyConsumer, _impl_.conductingequipment_)>(
          reinterpret_cast<char*>(&_impl_.conductingequipment_),
          reinterpret_cast<char*>(&other->_impl_.conductingequipment_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnergyConsumer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[56]);
}
// ===================================================================

class Optional_CalcMethodKind::_Internal {
 public:
};

Optional_CalcMethodKind::Optional_CalcMethodKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_CalcMethodKind)
}
Optional_CalcMethodKind::Optional_CalcMethodKind(const Optional_CalcMethodKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_CalcMethodKind)
}

inline void Optional_CalcMethodKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_CalcMethodKind::~Optional_CalcMethodKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_CalcMethodKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_CalcMethodKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_CalcMethodKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_CalcMethodKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_CalcMethodKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_CalcMethodKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.CalcMethodKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::CalcMethodKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_CalcMethodKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_CalcMethodKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.CalcMethodKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_CalcMethodKind)
  return target;
}

::size_t Optional_CalcMethodKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_CalcMethodKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.CalcMethodKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_CalcMethodKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_CalcMethodKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_CalcMethodKind::GetClassData() const { return &_class_data_; }


void Optional_CalcMethodKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_CalcMethodKind*>(&to_msg);
  auto& from = static_cast<const Optional_CalcMethodKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_CalcMethodKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_CalcMethodKind::CopyFrom(const Optional_CalcMethodKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_CalcMethodKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_CalcMethodKind::IsInitialized() const {
  return true;
}

void Optional_CalcMethodKind::InternalSwap(Optional_CalcMethodKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_CalcMethodKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[57]);
}
// ===================================================================

class ENG_CalcMethodKind::_Internal {
 public:
};

ENG_CalcMethodKind::ENG_CalcMethodKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENG_CalcMethodKind)
}
ENG_CalcMethodKind::ENG_CalcMethodKind(const ENG_CalcMethodKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENG_CalcMethodKind)
}

inline void ENG_CalcMethodKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.setval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENG_CalcMethodKind::~ENG_CalcMethodKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENG_CalcMethodKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENG_CalcMethodKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ENG_CalcMethodKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENG_CalcMethodKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENG_CalcMethodKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.setval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENG_CalcMethodKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.CalcMethodKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_setval(static_cast<::commonmodule::CalcMethodKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENG_CalcMethodKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENG_CalcMethodKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.CalcMethodKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_setval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENG_CalcMethodKind)
  return target;
}

::size_t ENG_CalcMethodKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENG_CalcMethodKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.CalcMethodKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_setval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENG_CalcMethodKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENG_CalcMethodKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENG_CalcMethodKind::GetClassData() const { return &_class_data_; }


void ENG_CalcMethodKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENG_CalcMethodKind*>(&to_msg);
  auto& from = static_cast<const ENG_CalcMethodKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENG_CalcMethodKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_setval() != 0) {
    _this->_internal_set_setval(from._internal_setval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENG_CalcMethodKind::CopyFrom(const ENG_CalcMethodKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENG_CalcMethodKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENG_CalcMethodKind::IsInitialized() const {
  return true;
}

void ENG_CalcMethodKind::InternalSwap(ENG_CalcMethodKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.setval_, other->_impl_.setval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ENG_CalcMethodKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[58]);
}
// ===================================================================

class Optional_GridConnectModeKind::_Internal {
 public:
};

Optional_GridConnectModeKind::Optional_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_GridConnectModeKind)
}
Optional_GridConnectModeKind::Optional_GridConnectModeKind(const Optional_GridConnectModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_GridConnectModeKind)
}

inline void Optional_GridConnectModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_GridConnectModeKind::~Optional_GridConnectModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_GridConnectModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_GridConnectModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_GridConnectModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_GridConnectModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_GridConnectModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_GridConnectModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.GridConnectModeKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::GridConnectModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_GridConnectModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_GridConnectModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.GridConnectModeKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_GridConnectModeKind)
  return target;
}

::size_t Optional_GridConnectModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_GridConnectModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.GridConnectModeKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_GridConnectModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_GridConnectModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_GridConnectModeKind::GetClassData() const { return &_class_data_; }


void Optional_GridConnectModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_GridConnectModeKind*>(&to_msg);
  auto& from = static_cast<const Optional_GridConnectModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_GridConnectModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_GridConnectModeKind::CopyFrom(const Optional_GridConnectModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_GridConnectModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_GridConnectModeKind::IsInitialized() const {
  return true;
}

void Optional_GridConnectModeKind::InternalSwap(Optional_GridConnectModeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_GridConnectModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[59]);
}
// ===================================================================

class ENG_GridConnectModeKind::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& setvalextension(const ENG_GridConnectModeKind* msg);
};

const ::PROTOBUF_NAMESPACE_ID::StringValue&
ENG_GridConnectModeKind::_Internal::setvalextension(const ENG_GridConnectModeKind* msg) {
  return *msg->_impl_.setvalextension_;
}
void ENG_GridConnectModeKind::clear_setvalextension() {
  if (GetArenaForAllocation() == nullptr && _impl_.setvalextension_ != nullptr) {
    delete _impl_.setvalextension_;
  }
  _impl_.setvalextension_ = nullptr;
}
ENG_GridConnectModeKind::ENG_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENG_GridConnectModeKind)
}
ENG_GridConnectModeKind::ENG_GridConnectModeKind(const ENG_GridConnectModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ENG_GridConnectModeKind* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.setvalextension_){nullptr}
    , decltype(_impl_.setval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_setvalextension()) {
    _this->_impl_.setvalextension_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.setvalextension_);
  }
  _this->_impl_.setval_ = from._impl_.setval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENG_GridConnectModeKind)
}

inline void ENG_GridConnectModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.setvalextension_){nullptr}
    , decltype(_impl_.setval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENG_GridConnectModeKind::~ENG_GridConnectModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENG_GridConnectModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENG_GridConnectModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.setvalextension_;
}

void ENG_GridConnectModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENG_GridConnectModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENG_GridConnectModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.setvalextension_ != nullptr) {
    delete _impl_.setvalextension_;
  }
  _impl_.setvalextension_ = nullptr;
  _impl_.setval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENG_GridConnectModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.GridConnectModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_setval(static_cast<::commonmodule::GridConnectModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue setValExtension = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_setvalextension(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENG_GridConnectModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENG_GridConnectModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.GridConnectModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_setval(), target);
  }

  // .google.protobuf.StringValue setValExtension = 2;
  if (this->_internal_has_setvalextension()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::setvalextension(this),
        _Internal::setvalextension(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENG_GridConnectModeKind)
  return target;
}

::size_t ENG_GridConnectModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENG_GridConnectModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.StringValue setValExtension = 2;
  if (this->_internal_has_setvalextension()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.setvalextension_);
  }

  // .commonmodule.GridConnectModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_setval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENG_GridConnectModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENG_GridConnectModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENG_GridConnectModeKind::GetClassData() const { return &_class_data_; }


void ENG_GridConnectModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENG_GridConnectModeKind*>(&to_msg);
  auto& from = static_cast<const ENG_GridConnectModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENG_GridConnectModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_setvalextension()) {
    _this->_internal_mutable_setvalextension()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_setvalextension());
  }
  if (from._internal_setval() != 0) {
    _this->_internal_set_setval(from._internal_setval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENG_GridConnectModeKind::CopyFrom(const ENG_GridConnectModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENG_GridConnectModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENG_GridConnectModeKind::IsInitialized() const {
  return true;
}

void ENG_GridConnectModeKind::InternalSwap(ENG_GridConnectModeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENG_GridConnectModeKind, _impl_.setval_)
      + sizeof(ENG_GridConnectModeKind::_impl_.setval_)
      - PROTOBUF_FIELD_OFFSET(ENG_GridConnectModeKind, _impl_.setvalextension_)>(
          reinterpret_cast<char*>(&_impl_.setvalextension_),
          reinterpret_cast<char*>(&other->_impl_.setvalextension_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ENG_GridConnectModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[60]);
}
// ===================================================================

class Optional_PFSignKind::_Internal {
 public:
};

Optional_PFSignKind::Optional_PFSignKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_PFSignKind)
}
Optional_PFSignKind::Optional_PFSignKind(const Optional_PFSignKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_PFSignKind)
}

inline void Optional_PFSignKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_PFSignKind::~Optional_PFSignKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_PFSignKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_PFSignKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_PFSignKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_PFSignKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_PFSignKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_PFSignKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.PFSignKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::PFSignKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_PFSignKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_PFSignKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.PFSignKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_PFSignKind)
  return target;
}

::size_t Optional_PFSignKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_PFSignKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.PFSignKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_PFSignKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_PFSignKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_PFSignKind::GetClassData() const { return &_class_data_; }


void Optional_PFSignKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_PFSignKind*>(&to_msg);
  auto& from = static_cast<const Optional_PFSignKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_PFSignKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_PFSignKind::CopyFrom(const Optional_PFSignKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_PFSignKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_PFSignKind::IsInitialized() const {
  return true;
}

void Optional_PFSignKind::InternalSwap(Optional_PFSignKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_PFSignKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[61]);
}
// ===================================================================

class ENG_PFSignKind::_Internal {
 public:
};

ENG_PFSignKind::ENG_PFSignKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENG_PFSignKind)
}
ENG_PFSignKind::ENG_PFSignKind(const ENG_PFSignKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENG_PFSignKind)
}

inline void ENG_PFSignKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.setval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENG_PFSignKind::~ENG_PFSignKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENG_PFSignKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENG_PFSignKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ENG_PFSignKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENG_PFSignKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENG_PFSignKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.setval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENG_PFSignKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.PFSignKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_setval(static_cast<::commonmodule::PFSignKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENG_PFSignKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENG_PFSignKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.PFSignKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_setval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENG_PFSignKind)
  return target;
}

::size_t ENG_PFSignKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENG_PFSignKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.PFSignKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_setval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_setval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENG_PFSignKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENG_PFSignKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENG_PFSignKind::GetClassData() const { return &_class_data_; }


void ENG_PFSignKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENG_PFSignKind*>(&to_msg);
  auto& from = static_cast<const ENG_PFSignKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENG_PFSignKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_setval() != 0) {
    _this->_internal_set_setval(from._internal_setval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENG_PFSignKind::CopyFrom(const ENG_PFSignKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENG_PFSignKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENG_PFSignKind::IsInitialized() const {
  return true;
}

void ENG_PFSignKind::InternalSwap(ENG_PFSignKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.setval_, other->_impl_.setval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ENG_PFSignKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[62]);
}
// ===================================================================

class Optional_BehaviourModeKind::_Internal {
 public:
};

Optional_BehaviourModeKind::Optional_BehaviourModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_BehaviourModeKind)
}
Optional_BehaviourModeKind::Optional_BehaviourModeKind(const Optional_BehaviourModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_BehaviourModeKind)
}

inline void Optional_BehaviourModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_BehaviourModeKind::~Optional_BehaviourModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_BehaviourModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_BehaviourModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_BehaviourModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_BehaviourModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_BehaviourModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_BehaviourModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.BehaviourModeKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::BehaviourModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_BehaviourModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_BehaviourModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.BehaviourModeKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_BehaviourModeKind)
  return target;
}

::size_t Optional_BehaviourModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_BehaviourModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.BehaviourModeKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_BehaviourModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_BehaviourModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_BehaviourModeKind::GetClassData() const { return &_class_data_; }


void Optional_BehaviourModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_BehaviourModeKind*>(&to_msg);
  auto& from = static_cast<const Optional_BehaviourModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_BehaviourModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_BehaviourModeKind::CopyFrom(const Optional_BehaviourModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_BehaviourModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_BehaviourModeKind::IsInitialized() const {
  return true;
}

void Optional_BehaviourModeKind::InternalSwap(Optional_BehaviourModeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_BehaviourModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[63]);
}
// ===================================================================

class ENS_BehaviourModeKind::_Internal {
 public:
  static const ::commonmodule::Quality& q(const ENS_BehaviourModeKind* msg);
  static const ::commonmodule::Timestamp& t(const ENS_BehaviourModeKind* msg);
};

const ::commonmodule::Quality&
ENS_BehaviourModeKind::_Internal::q(const ENS_BehaviourModeKind* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
ENS_BehaviourModeKind::_Internal::t(const ENS_BehaviourModeKind* msg) {
  return *msg->_impl_.t_;
}
ENS_BehaviourModeKind::ENS_BehaviourModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENS_BehaviourModeKind)
}
ENS_BehaviourModeKind::ENS_BehaviourModeKind(const ENS_BehaviourModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ENS_BehaviourModeKind* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENS_BehaviourModeKind)
}

inline void ENS_BehaviourModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENS_BehaviourModeKind::~ENS_BehaviourModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENS_BehaviourModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENS_BehaviourModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void ENS_BehaviourModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENS_BehaviourModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENS_BehaviourModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENS_BehaviourModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BehaviourModeKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_stval(static_cast<::commonmodule::BehaviourModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENS_BehaviourModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENS_BehaviourModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BehaviourModeKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENS_BehaviourModeKind)
  return target;
}

::size_t ENS_BehaviourModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENS_BehaviourModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // .commonmodule.BehaviourModeKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENS_BehaviourModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENS_BehaviourModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENS_BehaviourModeKind::GetClassData() const { return &_class_data_; }


void ENS_BehaviourModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENS_BehaviourModeKind*>(&to_msg);
  auto& from = static_cast<const ENS_BehaviourModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENS_BehaviourModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENS_BehaviourModeKind::CopyFrom(const ENS_BehaviourModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENS_BehaviourModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENS_BehaviourModeKind::IsInitialized() const {
  return true;
}

void ENS_BehaviourModeKind::InternalSwap(ENS_BehaviourModeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENS_BehaviourModeKind, _impl_.stval_)
      + sizeof(ENS_BehaviourModeKind::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(ENS_BehaviourModeKind, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ENS_BehaviourModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[64]);
}
// ===================================================================

class Optional_DERGeneratorStateKind::_Internal {
 public:
};

Optional_DERGeneratorStateKind::Optional_DERGeneratorStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_DERGeneratorStateKind)
}
Optional_DERGeneratorStateKind::Optional_DERGeneratorStateKind(const Optional_DERGeneratorStateKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_DERGeneratorStateKind)
}

inline void Optional_DERGeneratorStateKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_DERGeneratorStateKind::~Optional_DERGeneratorStateKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_DERGeneratorStateKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_DERGeneratorStateKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_DERGeneratorStateKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_DERGeneratorStateKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_DERGeneratorStateKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_DERGeneratorStateKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.DERGeneratorStateKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::DERGeneratorStateKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_DERGeneratorStateKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_DERGeneratorStateKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.DERGeneratorStateKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_DERGeneratorStateKind)
  return target;
}

::size_t Optional_DERGeneratorStateKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_DERGeneratorStateKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.DERGeneratorStateKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_DERGeneratorStateKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_DERGeneratorStateKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_DERGeneratorStateKind::GetClassData() const { return &_class_data_; }


void Optional_DERGeneratorStateKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_DERGeneratorStateKind*>(&to_msg);
  auto& from = static_cast<const Optional_DERGeneratorStateKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_DERGeneratorStateKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_DERGeneratorStateKind::CopyFrom(const Optional_DERGeneratorStateKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_DERGeneratorStateKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_DERGeneratorStateKind::IsInitialized() const {
  return true;
}

void Optional_DERGeneratorStateKind::InternalSwap(Optional_DERGeneratorStateKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_DERGeneratorStateKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[65]);
}
// ===================================================================

class ENS_DERGeneratorStateKind::_Internal {
 public:
  static const ::commonmodule::Quality& q(const ENS_DERGeneratorStateKind* msg);
  static const ::commonmodule::Timestamp& t(const ENS_DERGeneratorStateKind* msg);
};

const ::commonmodule::Quality&
ENS_DERGeneratorStateKind::_Internal::q(const ENS_DERGeneratorStateKind* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
ENS_DERGeneratorStateKind::_Internal::t(const ENS_DERGeneratorStateKind* msg) {
  return *msg->_impl_.t_;
}
ENS_DERGeneratorStateKind::ENS_DERGeneratorStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENS_DERGeneratorStateKind)
}
ENS_DERGeneratorStateKind::ENS_DERGeneratorStateKind(const ENS_DERGeneratorStateKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ENS_DERGeneratorStateKind* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENS_DERGeneratorStateKind)
}

inline void ENS_DERGeneratorStateKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENS_DERGeneratorStateKind::~ENS_DERGeneratorStateKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENS_DERGeneratorStateKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENS_DERGeneratorStateKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void ENS_DERGeneratorStateKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENS_DERGeneratorStateKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENS_DERGeneratorStateKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENS_DERGeneratorStateKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.DERGeneratorStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_stval(static_cast<::commonmodule::DERGeneratorStateKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENS_DERGeneratorStateKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENS_DERGeneratorStateKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.DERGeneratorStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENS_DERGeneratorStateKind)
  return target;
}

::size_t ENS_DERGeneratorStateKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENS_DERGeneratorStateKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // .commonmodule.DERGeneratorStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENS_DERGeneratorStateKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENS_DERGeneratorStateKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENS_DERGeneratorStateKind::GetClassData() const { return &_class_data_; }


void ENS_DERGeneratorStateKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENS_DERGeneratorStateKind*>(&to_msg);
  auto& from = static_cast<const ENS_DERGeneratorStateKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENS_DERGeneratorStateKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENS_DERGeneratorStateKind::CopyFrom(const ENS_DERGeneratorStateKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENS_DERGeneratorStateKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENS_DERGeneratorStateKind::IsInitialized() const {
  return true;
}

void ENS_DERGeneratorStateKind::InternalSwap(ENS_DERGeneratorStateKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENS_DERGeneratorStateKind, _impl_.stval_)
      + sizeof(ENS_DERGeneratorStateKind::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(ENS_DERGeneratorStateKind, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ENS_DERGeneratorStateKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[66]);
}
// ===================================================================

class Optional_DynamicTestKind::_Internal {
 public:
};

Optional_DynamicTestKind::Optional_DynamicTestKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_DynamicTestKind)
}
Optional_DynamicTestKind::Optional_DynamicTestKind(const Optional_DynamicTestKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_DynamicTestKind)
}

inline void Optional_DynamicTestKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_DynamicTestKind::~Optional_DynamicTestKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_DynamicTestKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_DynamicTestKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_DynamicTestKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_DynamicTestKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_DynamicTestKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_DynamicTestKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.DynamicTestKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::DynamicTestKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_DynamicTestKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_DynamicTestKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.DynamicTestKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_DynamicTestKind)
  return target;
}

::size_t Optional_DynamicTestKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_DynamicTestKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.DynamicTestKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_DynamicTestKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_DynamicTestKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_DynamicTestKind::GetClassData() const { return &_class_data_; }


void Optional_DynamicTestKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_DynamicTestKind*>(&to_msg);
  auto& from = static_cast<const Optional_DynamicTestKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_DynamicTestKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_DynamicTestKind::CopyFrom(const Optional_DynamicTestKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_DynamicTestKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_DynamicTestKind::IsInitialized() const {
  return true;
}

void Optional_DynamicTestKind::InternalSwap(Optional_DynamicTestKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_DynamicTestKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[67]);
}
// ===================================================================

class ENS_DynamicTestKind::_Internal {
 public:
  static const ::commonmodule::Quality& q(const ENS_DynamicTestKind* msg);
  static const ::commonmodule::Timestamp& t(const ENS_DynamicTestKind* msg);
};

const ::commonmodule::Quality&
ENS_DynamicTestKind::_Internal::q(const ENS_DynamicTestKind* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
ENS_DynamicTestKind::_Internal::t(const ENS_DynamicTestKind* msg) {
  return *msg->_impl_.t_;
}
ENS_DynamicTestKind::ENS_DynamicTestKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENS_DynamicTestKind)
}
ENS_DynamicTestKind::ENS_DynamicTestKind(const ENS_DynamicTestKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ENS_DynamicTestKind* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENS_DynamicTestKind)
}

inline void ENS_DynamicTestKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENS_DynamicTestKind::~ENS_DynamicTestKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENS_DynamicTestKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENS_DynamicTestKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void ENS_DynamicTestKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENS_DynamicTestKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENS_DynamicTestKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENS_DynamicTestKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.DynamicTestKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_stval(static_cast<::commonmodule::DynamicTestKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENS_DynamicTestKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENS_DynamicTestKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.DynamicTestKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENS_DynamicTestKind)
  return target;
}

::size_t ENS_DynamicTestKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENS_DynamicTestKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // .commonmodule.DynamicTestKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENS_DynamicTestKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENS_DynamicTestKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENS_DynamicTestKind::GetClassData() const { return &_class_data_; }


void ENS_DynamicTestKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENS_DynamicTestKind*>(&to_msg);
  auto& from = static_cast<const ENS_DynamicTestKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENS_DynamicTestKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENS_DynamicTestKind::CopyFrom(const ENS_DynamicTestKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENS_DynamicTestKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENS_DynamicTestKind::IsInitialized() const {
  return true;
}

void ENS_DynamicTestKind::InternalSwap(ENS_DynamicTestKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENS_DynamicTestKind, _impl_.stval_)
      + sizeof(ENS_DynamicTestKind::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(ENS_DynamicTestKind, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ENS_DynamicTestKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[68]);
}
// ===================================================================

class ENS_GridConnectModeKind::_Internal {
 public:
};

ENS_GridConnectModeKind::ENS_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENS_GridConnectModeKind)
}
ENS_GridConnectModeKind::ENS_GridConnectModeKind(const ENS_GridConnectModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ENS_GridConnectModeKind* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stvalextension_) {}

    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stvalextension_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stvalextension_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stvalextension().empty()) {
    _this->_impl_.stvalextension_.Set(from._internal_stvalextension(), _this->GetArenaForAllocation());
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENS_GridConnectModeKind)
}

inline void ENS_GridConnectModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.stvalextension_) {}

    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.stvalextension_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stvalextension_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ENS_GridConnectModeKind::~ENS_GridConnectModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENS_GridConnectModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENS_GridConnectModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stvalextension_.Destroy();
}

void ENS_GridConnectModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENS_GridConnectModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENS_GridConnectModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stvalextension_.ClearToEmpty();
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENS_GridConnectModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.GridConnectModeKind stVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_stval(static_cast<::commonmodule::GridConnectModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string stValExtension = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stvalextension();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "commonmodule.ENS_GridConnectModeKind.stValExtension"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENS_GridConnectModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENS_GridConnectModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.GridConnectModeKind stVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_stval(), target);
  }

  // string stValExtension = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_stvalextension().empty()) {
    const std::string& _s = this->_internal_stvalextension();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "commonmodule.ENS_GridConnectModeKind.stValExtension");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENS_GridConnectModeKind)
  return target;
}

::size_t ENS_GridConnectModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENS_GridConnectModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stValExtension = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_stvalextension().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_stvalextension());
  }

  // .commonmodule.GridConnectModeKind stVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENS_GridConnectModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENS_GridConnectModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENS_GridConnectModeKind::GetClassData() const { return &_class_data_; }


void ENS_GridConnectModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENS_GridConnectModeKind*>(&to_msg);
  auto& from = static_cast<const ENS_GridConnectModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENS_GridConnectModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stvalextension().empty()) {
    _this->_internal_set_stvalextension(from._internal_stvalextension());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENS_GridConnectModeKind::CopyFrom(const ENS_GridConnectModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENS_GridConnectModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENS_GridConnectModeKind::IsInitialized() const {
  return true;
}

void ENS_GridConnectModeKind::InternalSwap(ENS_GridConnectModeKind* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stvalextension_, lhs_arena,
                                       &other->_impl_.stvalextension_, rhs_arena);
  swap(_impl_.stval_, other->_impl_.stval_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ENS_GridConnectModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[69]);
}
// ===================================================================

class Optional_HealthKind::_Internal {
 public:
};

Optional_HealthKind::Optional_HealthKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_HealthKind)
}
Optional_HealthKind::Optional_HealthKind(const Optional_HealthKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_HealthKind)
}

inline void Optional_HealthKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_HealthKind::~Optional_HealthKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_HealthKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_HealthKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_HealthKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_HealthKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_HealthKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_HealthKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.HealthKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::HealthKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_HealthKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_HealthKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.HealthKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_HealthKind)
  return target;
}

::size_t Optional_HealthKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_HealthKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.HealthKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_HealthKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_HealthKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_HealthKind::GetClassData() const { return &_class_data_; }


void Optional_HealthKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_HealthKind*>(&to_msg);
  auto& from = static_cast<const Optional_HealthKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_HealthKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_HealthKind::CopyFrom(const Optional_HealthKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_HealthKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_HealthKind::IsInitialized() const {
  return true;
}

void Optional_HealthKind::InternalSwap(Optional_HealthKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_HealthKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[70]);
}
// ===================================================================

class ENS_HealthKind::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& d(const ENS_HealthKind* msg);
};

const ::PROTOBUF_NAMESPACE_ID::StringValue&
ENS_HealthKind::_Internal::d(const ENS_HealthKind* msg) {
  return *msg->_impl_.d_;
}
void ENS_HealthKind::clear_d() {
  if (GetArenaForAllocation() == nullptr && _impl_.d_ != nullptr) {
    delete _impl_.d_;
  }
  _impl_.d_ = nullptr;
}
ENS_HealthKind::ENS_HealthKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENS_HealthKind)
}
ENS_HealthKind::ENS_HealthKind(const ENS_HealthKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ENS_HealthKind* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.d_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_d()) {
    _this->_impl_.d_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.d_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENS_HealthKind)
}

inline void ENS_HealthKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.d_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENS_HealthKind::~ENS_HealthKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENS_HealthKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENS_HealthKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.d_;
}

void ENS_HealthKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENS_HealthKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENS_HealthKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.d_ != nullptr) {
    delete _impl_.d_;
  }
  _impl_.d_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENS_HealthKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.StringValue d = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_d(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.HealthKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_stval(static_cast<::commonmodule::HealthKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENS_HealthKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENS_HealthKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.StringValue d = 1;
  if (this->_internal_has_d()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::d(this),
        _Internal::d(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.HealthKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_stval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENS_HealthKind)
  return target;
}

::size_t ENS_HealthKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENS_HealthKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.StringValue d = 1;
  if (this->_internal_has_d()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.d_);
  }

  // .commonmodule.HealthKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENS_HealthKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENS_HealthKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENS_HealthKind::GetClassData() const { return &_class_data_; }


void ENS_HealthKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENS_HealthKind*>(&to_msg);
  auto& from = static_cast<const ENS_HealthKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENS_HealthKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_d()) {
    _this->_internal_mutable_d()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_d());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENS_HealthKind::CopyFrom(const ENS_HealthKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENS_HealthKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENS_HealthKind::IsInitialized() const {
  return true;
}

void ENS_HealthKind::InternalSwap(ENS_HealthKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENS_HealthKind, _impl_.stval_)
      + sizeof(ENS_HealthKind::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(ENS_HealthKind, _impl_.d_)>(
          reinterpret_cast<char*>(&_impl_.d_),
          reinterpret_cast<char*>(&other->_impl_.d_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ENS_HealthKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[71]);
}
// ===================================================================

class Optional_SwitchingCapabilityKind::_Internal {
 public:
};

Optional_SwitchingCapabilityKind::Optional_SwitchingCapabilityKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_SwitchingCapabilityKind)
}
Optional_SwitchingCapabilityKind::Optional_SwitchingCapabilityKind(const Optional_SwitchingCapabilityKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_SwitchingCapabilityKind)
}

inline void Optional_SwitchingCapabilityKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_SwitchingCapabilityKind::~Optional_SwitchingCapabilityKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_SwitchingCapabilityKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_SwitchingCapabilityKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_SwitchingCapabilityKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_SwitchingCapabilityKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_SwitchingCapabilityKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_SwitchingCapabilityKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.SwitchingCapabilityKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::SwitchingCapabilityKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_SwitchingCapabilityKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_SwitchingCapabilityKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.SwitchingCapabilityKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_SwitchingCapabilityKind)
  return target;
}

::size_t Optional_SwitchingCapabilityKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_SwitchingCapabilityKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.SwitchingCapabilityKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_SwitchingCapabilityKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_SwitchingCapabilityKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_SwitchingCapabilityKind::GetClassData() const { return &_class_data_; }


void Optional_SwitchingCapabilityKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_SwitchingCapabilityKind*>(&to_msg);
  auto& from = static_cast<const Optional_SwitchingCapabilityKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_SwitchingCapabilityKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_SwitchingCapabilityKind::CopyFrom(const Optional_SwitchingCapabilityKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_SwitchingCapabilityKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_SwitchingCapabilityKind::IsInitialized() const {
  return true;
}

void Optional_SwitchingCapabilityKind::InternalSwap(Optional_SwitchingCapabilityKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_SwitchingCapabilityKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[72]);
}
// ===================================================================

class ENS_SwitchingCapabilityKind::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& blkena(const ENS_SwitchingCapabilityKind* msg);
};

const ::PROTOBUF_NAMESPACE_ID::BoolValue&
ENS_SwitchingCapabilityKind::_Internal::blkena(const ENS_SwitchingCapabilityKind* msg) {
  return *msg->_impl_.blkena_;
}
void ENS_SwitchingCapabilityKind::clear_blkena() {
  if (GetArenaForAllocation() == nullptr && _impl_.blkena_ != nullptr) {
    delete _impl_.blkena_;
  }
  _impl_.blkena_ = nullptr;
}
ENS_SwitchingCapabilityKind::ENS_SwitchingCapabilityKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ENS_SwitchingCapabilityKind)
}
ENS_SwitchingCapabilityKind::ENS_SwitchingCapabilityKind(const ENS_SwitchingCapabilityKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ENS_SwitchingCapabilityKind* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.blkena_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_blkena()) {
    _this->_impl_.blkena_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.blkena_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ENS_SwitchingCapabilityKind)
}

inline void ENS_SwitchingCapabilityKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.blkena_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ENS_SwitchingCapabilityKind::~ENS_SwitchingCapabilityKind() {
  // @@protoc_insertion_point(destructor:commonmodule.ENS_SwitchingCapabilityKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ENS_SwitchingCapabilityKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.blkena_;
}

void ENS_SwitchingCapabilityKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ENS_SwitchingCapabilityKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ENS_SwitchingCapabilityKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.blkena_ != nullptr) {
    delete _impl_.blkena_;
  }
  _impl_.blkena_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ENS_SwitchingCapabilityKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.BoolValue blkEna = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_blkena(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.SwitchingCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_stval(static_cast<::commonmodule::SwitchingCapabilityKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ENS_SwitchingCapabilityKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ENS_SwitchingCapabilityKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.BoolValue blkEna = 1;
  if (this->_internal_has_blkena()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::blkena(this),
        _Internal::blkena(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.SwitchingCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_stval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ENS_SwitchingCapabilityKind)
  return target;
}

::size_t ENS_SwitchingCapabilityKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ENS_SwitchingCapabilityKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.BoolValue blkEna = 1;
  if (this->_internal_has_blkena()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.blkena_);
  }

  // .commonmodule.SwitchingCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ENS_SwitchingCapabilityKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ENS_SwitchingCapabilityKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ENS_SwitchingCapabilityKind::GetClassData() const { return &_class_data_; }


void ENS_SwitchingCapabilityKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ENS_SwitchingCapabilityKind*>(&to_msg);
  auto& from = static_cast<const ENS_SwitchingCapabilityKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ENS_SwitchingCapabilityKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_blkena()) {
    _this->_internal_mutable_blkena()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_blkena());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ENS_SwitchingCapabilityKind::CopyFrom(const ENS_SwitchingCapabilityKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ENS_SwitchingCapabilityKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ENS_SwitchingCapabilityKind::IsInitialized() const {
  return true;
}

void ENS_SwitchingCapabilityKind::InternalSwap(ENS_SwitchingCapabilityKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ENS_SwitchingCapabilityKind, _impl_.stval_)
      + sizeof(ENS_SwitchingCapabilityKind::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(ENS_SwitchingCapabilityKind, _impl_.blkena_)>(
          reinterpret_cast<char*>(&_impl_.blkena_),
          reinterpret_cast<char*>(&other->_impl_.blkena_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ENS_SwitchingCapabilityKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[73]);
}
// ===================================================================

class OperationDCTE::_Internal {
 public:
  static const ::commonmodule::ControlING& rnddltmms(const OperationDCTE* msg);
  static const ::commonmodule::ControlING& rtndltmms(const OperationDCTE* msg);
  static const ::commonmodule::ControlING& rtnrmptmms(const OperationDCTE* msg);
};

const ::commonmodule::ControlING&
OperationDCTE::_Internal::rnddltmms(const OperationDCTE* msg) {
  return *msg->_impl_.rnddltmms_;
}
const ::commonmodule::ControlING&
OperationDCTE::_Internal::rtndltmms(const OperationDCTE* msg) {
  return *msg->_impl_.rtndltmms_;
}
const ::commonmodule::ControlING&
OperationDCTE::_Internal::rtnrmptmms(const OperationDCTE* msg) {
  return *msg->_impl_.rtnrmptmms_;
}
OperationDCTE::OperationDCTE(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDCTE)
}
OperationDCTE::OperationDCTE(const OperationDCTE& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OperationDCTE* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rnddltmms_){nullptr}
    , decltype(_impl_.rtndltmms_){nullptr}
    , decltype(_impl_.rtnrmptmms_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rnddltmms()) {
    _this->_impl_.rnddltmms_ = new ::commonmodule::ControlING(*from._impl_.rnddltmms_);
  }
  if (from._internal_has_rtndltmms()) {
    _this->_impl_.rtndltmms_ = new ::commonmodule::ControlING(*from._impl_.rtndltmms_);
  }
  if (from._internal_has_rtnrmptmms()) {
    _this->_impl_.rtnrmptmms_ = new ::commonmodule::ControlING(*from._impl_.rtnrmptmms_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDCTE)
}

inline void OperationDCTE::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.rnddltmms_){nullptr}
    , decltype(_impl_.rtndltmms_){nullptr}
    , decltype(_impl_.rtnrmptmms_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDCTE::~OperationDCTE() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDCTE)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDCTE::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rnddltmms_;
  if (this != internal_default_instance()) delete _impl_.rtndltmms_;
  if (this != internal_default_instance()) delete _impl_.rtnrmptmms_;
}

void OperationDCTE::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDCTE::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDCTE)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.rnddltmms_ != nullptr) {
    delete _impl_.rnddltmms_;
  }
  _impl_.rnddltmms_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rtndltmms_ != nullptr) {
    delete _impl_.rtndltmms_;
  }
  _impl_.rtndltmms_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rtnrmptmms_ != nullptr) {
    delete _impl_.rtnrmptmms_;
  }
  _impl_.rtnrmptmms_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDCTE::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ControlING rndDlTmms = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rnddltmms(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlING rtnDlTmms = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rtndltmms(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlING rtnRmpTmms = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rtnrmptmms(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDCTE::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDCTE)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ControlING rndDlTmms = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_rnddltmms()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rnddltmms(this),
        _Internal::rnddltmms(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlING rtnDlTmms = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_rtndltmms()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rtndltmms(this),
        _Internal::rtndltmms(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlING rtnRmpTmms = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_rtnrmptmms()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rtnrmptmms(this),
        _Internal::rtnrmptmms(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDCTE)
  return target;
}

::size_t OperationDCTE::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDCTE)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ControlING rndDlTmms = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_rnddltmms()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rnddltmms_);
  }

  // .commonmodule.ControlING rtnDlTmms = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_rtndltmms()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rtndltmms_);
  }

  // .commonmodule.ControlING rtnRmpTmms = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_rtnrmptmms()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rtnrmptmms_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDCTE::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDCTE::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDCTE::GetClassData() const { return &_class_data_; }


void OperationDCTE::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDCTE*>(&to_msg);
  auto& from = static_cast<const OperationDCTE&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDCTE)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rnddltmms()) {
    _this->_internal_mutable_rnddltmms()->::commonmodule::ControlING::MergeFrom(
        from._internal_rnddltmms());
  }
  if (from._internal_has_rtndltmms()) {
    _this->_internal_mutable_rtndltmms()->::commonmodule::ControlING::MergeFrom(
        from._internal_rtndltmms());
  }
  if (from._internal_has_rtnrmptmms()) {
    _this->_internal_mutable_rtnrmptmms()->::commonmodule::ControlING::MergeFrom(
        from._internal_rtnrmptmms());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDCTE::CopyFrom(const OperationDCTE& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDCTE)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDCTE::IsInitialized() const {
  return true;
}

void OperationDCTE::InternalSwap(OperationDCTE* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperationDCTE, _impl_.rtnrmptmms_)
      + sizeof(OperationDCTE::_impl_.rtnrmptmms_)
      - PROTOBUF_FIELD_OFFSET(OperationDCTE, _impl_.rnddltmms_)>(
          reinterpret_cast<char*>(&_impl_.rnddltmms_),
          reinterpret_cast<char*>(&other->_impl_.rnddltmms_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDCTE::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[74]);
}
// ===================================================================

class EnterServiceAPC::_Internal {
 public:
  static const ::commonmodule::OperationDCTE& enterserviceparameter(const EnterServiceAPC* msg);
};

const ::commonmodule::OperationDCTE&
EnterServiceAPC::_Internal::enterserviceparameter(const EnterServiceAPC* msg) {
  return *msg->_impl_.enterserviceparameter_;
}
EnterServiceAPC::EnterServiceAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.EnterServiceAPC)
}
EnterServiceAPC::EnterServiceAPC(const EnterServiceAPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnterServiceAPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.enterserviceparameter_){nullptr}
    , decltype(_impl_.hzhilim_) {}

    , decltype(_impl_.hzlolim_) {}

    , decltype(_impl_.rtnsrvauto_) {}

    , decltype(_impl_.vhilim_) {}

    , decltype(_impl_.vlolim_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_enterserviceparameter()) {
    _this->_impl_.enterserviceparameter_ = new ::commonmodule::OperationDCTE(*from._impl_.enterserviceparameter_);
  }
  ::memcpy(&_impl_.hzhilim_, &from._impl_.hzhilim_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.vlolim_) -
    reinterpret_cast<char*>(&_impl_.hzhilim_)) + sizeof(_impl_.vlolim_));
  // @@protoc_insertion_point(copy_constructor:commonmodule.EnterServiceAPC)
}

inline void EnterServiceAPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.enterserviceparameter_){nullptr}
    , decltype(_impl_.hzhilim_) { 0 }

    , decltype(_impl_.hzlolim_) { 0 }

    , decltype(_impl_.rtnsrvauto_) { false }

    , decltype(_impl_.vhilim_) { 0 }

    , decltype(_impl_.vlolim_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EnterServiceAPC::~EnterServiceAPC() {
  // @@protoc_insertion_point(destructor:commonmodule.EnterServiceAPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnterServiceAPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.enterserviceparameter_;
}

void EnterServiceAPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnterServiceAPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.EnterServiceAPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.enterserviceparameter_ != nullptr) {
    delete _impl_.enterserviceparameter_;
  }
  _impl_.enterserviceparameter_ = nullptr;
  ::memset(&_impl_.hzhilim_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.vlolim_) -
      reinterpret_cast<char*>(&_impl_.hzhilim_)) + sizeof(_impl_.vlolim_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnterServiceAPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.OperationDCTE enterServiceParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_enterserviceparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float hzHiLim = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.hzhilim_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float hzLoLim = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.hzlolim_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool rtnSrvAuto = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.rtnsrvauto_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float vHiLim = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _impl_.vhilim_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float vLoLim = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _impl_.vlolim_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EnterServiceAPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.EnterServiceAPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.OperationDCTE enterServiceParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_enterserviceparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::enterserviceparameter(this),
        _Internal::enterserviceparameter(this).GetCachedSize(), target, stream);
  }

  // float hzHiLim = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzhilim = this->_internal_hzhilim();
  ::uint32_t raw_hzhilim;
  memcpy(&raw_hzhilim, &tmp_hzhilim, sizeof(tmp_hzhilim));
  if (raw_hzhilim != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_hzhilim(), target);
  }

  // float hzLoLim = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzlolim = this->_internal_hzlolim();
  ::uint32_t raw_hzlolim;
  memcpy(&raw_hzlolim, &tmp_hzlolim, sizeof(tmp_hzlolim));
  if (raw_hzlolim != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_hzlolim(), target);
  }

  // bool rtnSrvAuto = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_rtnsrvauto() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_rtnsrvauto(), target);
  }

  // float vHiLim = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vhilim = this->_internal_vhilim();
  ::uint32_t raw_vhilim;
  memcpy(&raw_vhilim, &tmp_vhilim, sizeof(tmp_vhilim));
  if (raw_vhilim != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_vhilim(), target);
  }

  // float vLoLim = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vlolim = this->_internal_vlolim();
  ::uint32_t raw_vlolim;
  memcpy(&raw_vlolim, &tmp_vlolim, sizeof(tmp_vlolim));
  if (raw_vlolim != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_vlolim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.EnterServiceAPC)
  return target;
}

::size_t EnterServiceAPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.EnterServiceAPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.OperationDCTE enterServiceParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_enterserviceparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.enterserviceparameter_);
  }

  // float hzHiLim = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzhilim = this->_internal_hzhilim();
  ::uint32_t raw_hzhilim;
  memcpy(&raw_hzhilim, &tmp_hzhilim, sizeof(tmp_hzhilim));
  if (raw_hzhilim != 0) {
    total_size += 5;
  }

  // float hzLoLim = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzlolim = this->_internal_hzlolim();
  ::uint32_t raw_hzlolim;
  memcpy(&raw_hzlolim, &tmp_hzlolim, sizeof(tmp_hzlolim));
  if (raw_hzlolim != 0) {
    total_size += 5;
  }

  // bool rtnSrvAuto = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_rtnsrvauto() != 0) {
    total_size += 2;
  }

  // float vHiLim = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vhilim = this->_internal_vhilim();
  ::uint32_t raw_vhilim;
  memcpy(&raw_vhilim, &tmp_vhilim, sizeof(tmp_vhilim));
  if (raw_vhilim != 0) {
    total_size += 5;
  }

  // float vLoLim = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vlolim = this->_internal_vlolim();
  ::uint32_t raw_vlolim;
  memcpy(&raw_vlolim, &tmp_vlolim, sizeof(tmp_vlolim));
  if (raw_vlolim != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnterServiceAPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnterServiceAPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnterServiceAPC::GetClassData() const { return &_class_data_; }


void EnterServiceAPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnterServiceAPC*>(&to_msg);
  auto& from = static_cast<const EnterServiceAPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.EnterServiceAPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enterserviceparameter()) {
    _this->_internal_mutable_enterserviceparameter()->::commonmodule::OperationDCTE::MergeFrom(
        from._internal_enterserviceparameter());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzhilim = from._internal_hzhilim();
  ::uint32_t raw_hzhilim;
  memcpy(&raw_hzhilim, &tmp_hzhilim, sizeof(tmp_hzhilim));
  if (raw_hzhilim != 0) {
    _this->_internal_set_hzhilim(from._internal_hzhilim());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzlolim = from._internal_hzlolim();
  ::uint32_t raw_hzlolim;
  memcpy(&raw_hzlolim, &tmp_hzlolim, sizeof(tmp_hzlolim));
  if (raw_hzlolim != 0) {
    _this->_internal_set_hzlolim(from._internal_hzlolim());
  }
  if (from._internal_rtnsrvauto() != 0) {
    _this->_internal_set_rtnsrvauto(from._internal_rtnsrvauto());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vhilim = from._internal_vhilim();
  ::uint32_t raw_vhilim;
  memcpy(&raw_vhilim, &tmp_vhilim, sizeof(tmp_vhilim));
  if (raw_vhilim != 0) {
    _this->_internal_set_vhilim(from._internal_vhilim());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vlolim = from._internal_vlolim();
  ::uint32_t raw_vlolim;
  memcpy(&raw_vlolim, &tmp_vlolim, sizeof(tmp_vlolim));
  if (raw_vlolim != 0) {
    _this->_internal_set_vlolim(from._internal_vlolim());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnterServiceAPC::CopyFrom(const EnterServiceAPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.EnterServiceAPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterServiceAPC::IsInitialized() const {
  return true;
}

void EnterServiceAPC::InternalSwap(EnterServiceAPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnterServiceAPC, _impl_.vlolim_)
      + sizeof(EnterServiceAPC::_impl_.vlolim_)
      - PROTOBUF_FIELD_OFFSET(EnterServiceAPC, _impl_.enterserviceparameter_)>(
          reinterpret_cast<char*>(&_impl_.enterserviceparameter_),
          reinterpret_cast<char*>(&other->_impl_.enterserviceparameter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnterServiceAPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[75]);
}
// ===================================================================

class ESS::_Internal {
 public:
  static const ::commonmodule::ConductingEquipment& conductingequipment(const ESS* msg);
};

const ::commonmodule::ConductingEquipment&
ESS::_Internal::conductingequipment(const ESS* msg) {
  return *msg->_impl_.conductingequipment_;
}
ESS::ESS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ESS)
}
ESS::ESS(const ESS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ESS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.conductingequipment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_conductingequipment()) {
    _this->_impl_.conductingequipment_ = new ::commonmodule::ConductingEquipment(*from._impl_.conductingequipment_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ESS)
}

inline void ESS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.conductingequipment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ESS::~ESS() {
  // @@protoc_insertion_point(destructor:commonmodule.ESS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ESS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.conductingequipment_;
}

void ESS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ESS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ESS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.conductingequipment_ != nullptr) {
    delete _impl_.conductingequipment_;
  }
  _impl_.conductingequipment_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ESS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_conductingequipment(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ESS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ESS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_conductingequipment()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::conductingequipment(this),
        _Internal::conductingequipment(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ESS)
  return target;
}

::size_t ESS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ESS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_conductingequipment()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.conductingequipment_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ESS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ESS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ESS::GetClassData() const { return &_class_data_; }


void ESS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ESS*>(&to_msg);
  auto& from = static_cast<const ESS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ESS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_conductingequipment()) {
    _this->_internal_mutable_conductingequipment()->::commonmodule::ConductingEquipment::MergeFrom(
        from._internal_conductingequipment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ESS::CopyFrom(const ESS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ESS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ESS::IsInitialized() const {
  return true;
}

void ESS::InternalSwap(ESS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.conductingequipment_, other->_impl_.conductingequipment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ESS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[76]);
}
// ===================================================================

class EventMessageInfo::_Internal {
 public:
  static const ::commonmodule::MessageInfo& messageinfo(const EventMessageInfo* msg);
};

const ::commonmodule::MessageInfo&
EventMessageInfo::_Internal::messageinfo(const EventMessageInfo* msg) {
  return *msg->_impl_.messageinfo_;
}
EventMessageInfo::EventMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.EventMessageInfo)
}
EventMessageInfo::EventMessageInfo(const EventMessageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventMessageInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_messageinfo()) {
    _this->_impl_.messageinfo_ = new ::commonmodule::MessageInfo(*from._impl_.messageinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.EventMessageInfo)
}

inline void EventMessageInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventMessageInfo::~EventMessageInfo() {
  // @@protoc_insertion_point(destructor:commonmodule.EventMessageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventMessageInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.messageinfo_;
}

void EventMessageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventMessageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.EventMessageInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventMessageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_messageinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventMessageInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.EventMessageInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::messageinfo(this),
        _Internal::messageinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.EventMessageInfo)
  return target;
}

::size_t EventMessageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.EventMessageInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.messageinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventMessageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventMessageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventMessageInfo::GetClassData() const { return &_class_data_; }


void EventMessageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventMessageInfo*>(&to_msg);
  auto& from = static_cast<const EventMessageInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.EventMessageInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_messageinfo()) {
    _this->_internal_mutable_messageinfo()->::commonmodule::MessageInfo::MergeFrom(
        from._internal_messageinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventMessageInfo::CopyFrom(const EventMessageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.EventMessageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventMessageInfo::IsInitialized() const {
  return true;
}

void EventMessageInfo::InternalSwap(EventMessageInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.messageinfo_, other->_impl_.messageinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventMessageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[77]);
}
// ===================================================================

class EventValue::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const EventValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& modblk(const EventValue* msg);
};

const ::commonmodule::IdentifiedObject&
EventValue::_Internal::identifiedobject(const EventValue* msg) {
  return *msg->_impl_.identifiedobject_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
EventValue::_Internal::modblk(const EventValue* msg) {
  return *msg->_impl_.modblk_;
}
void EventValue::clear_modblk() {
  if (GetArenaForAllocation() == nullptr && _impl_.modblk_ != nullptr) {
    delete _impl_.modblk_;
  }
  _impl_.modblk_ = nullptr;
}
EventValue::EventValue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.EventValue)
}
EventValue::EventValue(const EventValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.modblk_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  if (from._internal_has_modblk()) {
    _this->_impl_.modblk_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.modblk_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.EventValue)
}

inline void EventValue::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.modblk_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventValue::~EventValue() {
  // @@protoc_insertion_point(destructor:commonmodule.EventValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventValue::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
  if (this != internal_default_instance()) delete _impl_.modblk_;
}

void EventValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventValue::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.EventValue)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.modblk_ != nullptr) {
    delete _impl_.modblk_;
  }
  _impl_.modblk_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue modBlk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_modblk(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventValue::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.EventValue)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue modBlk = 2;
  if (this->_internal_has_modblk()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::modblk(this),
        _Internal::modblk(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.EventValue)
  return target;
}

::size_t EventValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.EventValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  // .google.protobuf.BoolValue modBlk = 2;
  if (this->_internal_has_modblk()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.modblk_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventValue::GetClassData() const { return &_class_data_; }


void EventValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventValue*>(&to_msg);
  auto& from = static_cast<const EventValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.EventValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  if (from._internal_has_modblk()) {
    _this->_internal_mutable_modblk()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_modblk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventValue::CopyFrom(const EventValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.EventValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventValue::IsInitialized() const {
  return true;
}

void EventValue::InternalSwap(EventValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventValue, _impl_.modblk_)
      + sizeof(EventValue::_impl_.modblk_)
      - PROTOBUF_FIELD_OFFSET(EventValue, _impl_.identifiedobject_)>(
          reinterpret_cast<char*>(&_impl_.identifiedobject_),
          reinterpret_cast<char*>(&other->_impl_.identifiedobject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[78]);
}
// ===================================================================

class ForecastValueSource::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const ForecastValueSource* msg);
};

const ::commonmodule::IdentifiedObject&
ForecastValueSource::_Internal::identifiedobject(const ForecastValueSource* msg) {
  return *msg->_impl_.identifiedobject_;
}
ForecastValueSource::ForecastValueSource(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ForecastValueSource)
}
ForecastValueSource::ForecastValueSource(const ForecastValueSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ForecastValueSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ForecastValueSource)
}

inline void ForecastValueSource::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ForecastValueSource::~ForecastValueSource() {
  // @@protoc_insertion_point(destructor:commonmodule.ForecastValueSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ForecastValueSource::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
}

void ForecastValueSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ForecastValueSource::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ForecastValueSource)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForecastValueSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ForecastValueSource::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ForecastValueSource)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ForecastValueSource)
  return target;
}

::size_t ForecastValueSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ForecastValueSource)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForecastValueSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ForecastValueSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForecastValueSource::GetClassData() const { return &_class_data_; }


void ForecastValueSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ForecastValueSource*>(&to_msg);
  auto& from = static_cast<const ForecastValueSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ForecastValueSource)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForecastValueSource::CopyFrom(const ForecastValueSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ForecastValueSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForecastValueSource::IsInitialized() const {
  return true;
}

void ForecastValueSource::InternalSwap(ForecastValueSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.identifiedobject_, other->_impl_.identifiedobject_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ForecastValueSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[79]);
}
// ===================================================================

class ForecastIED::_Internal {
 public:
  static const ::commonmodule::ForecastValueSource& forecastvaluesource(const ForecastIED* msg);
};

const ::commonmodule::ForecastValueSource&
ForecastIED::_Internal::forecastvaluesource(const ForecastIED* msg) {
  return *msg->_impl_.forecastvaluesource_;
}
ForecastIED::ForecastIED(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ForecastIED)
}
ForecastIED::ForecastIED(const ForecastIED& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ForecastIED* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sourceapplicationid_) {}

    , decltype(_impl_.forecastvaluesource_){nullptr}
    , decltype(_impl_.sourcedatetime_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourceapplicationid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sourceapplicationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sourceapplicationid().empty()) {
    _this->_impl_.sourceapplicationid_.Set(from._internal_sourceapplicationid(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_forecastvaluesource()) {
    _this->_impl_.forecastvaluesource_ = new ::commonmodule::ForecastValueSource(*from._impl_.forecastvaluesource_);
  }
  _this->_impl_.sourcedatetime_ = from._impl_.sourcedatetime_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.ForecastIED)
}

inline void ForecastIED::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.sourceapplicationid_) {}

    , decltype(_impl_.forecastvaluesource_){nullptr}
    , decltype(_impl_.sourcedatetime_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sourceapplicationid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sourceapplicationid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ForecastIED::~ForecastIED() {
  // @@protoc_insertion_point(destructor:commonmodule.ForecastIED)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ForecastIED::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourceapplicationid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.forecastvaluesource_;
}

void ForecastIED::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ForecastIED::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ForecastIED)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sourceapplicationid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.forecastvaluesource_ != nullptr) {
    delete _impl_.forecastvaluesource_;
  }
  _impl_.forecastvaluesource_ = nullptr;
  _impl_.sourcedatetime_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForecastIED::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ForecastValueSource forecastValueSource = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_forecastvaluesource(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string sourceApplicationID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourceapplicationid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "commonmodule.ForecastIED.sourceApplicationID"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 sourceDateTime = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.sourcedatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ForecastIED::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ForecastIED)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ForecastValueSource forecastValueSource = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_forecastvaluesource()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::forecastvaluesource(this),
        _Internal::forecastvaluesource(this).GetCachedSize(), target, stream);
  }

  // string sourceApplicationID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_sourceapplicationid().empty()) {
    const std::string& _s = this->_internal_sourceapplicationid();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "commonmodule.ForecastIED.sourceApplicationID");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int64 sourceDateTime = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_sourcedatetime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_sourcedatetime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ForecastIED)
  return target;
}

::size_t ForecastIED::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ForecastIED)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sourceApplicationID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_sourceapplicationid().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_sourceapplicationid());
  }

  // .commonmodule.ForecastValueSource forecastValueSource = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_forecastvaluesource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.forecastvaluesource_);
  }

  // int64 sourceDateTime = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_sourcedatetime() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_sourcedatetime());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForecastIED::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ForecastIED::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForecastIED::GetClassData() const { return &_class_data_; }


void ForecastIED::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ForecastIED*>(&to_msg);
  auto& from = static_cast<const ForecastIED&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ForecastIED)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sourceapplicationid().empty()) {
    _this->_internal_set_sourceapplicationid(from._internal_sourceapplicationid());
  }
  if (from._internal_has_forecastvaluesource()) {
    _this->_internal_mutable_forecastvaluesource()->::commonmodule::ForecastValueSource::MergeFrom(
        from._internal_forecastvaluesource());
  }
  if (from._internal_sourcedatetime() != 0) {
    _this->_internal_set_sourcedatetime(from._internal_sourcedatetime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForecastIED::CopyFrom(const ForecastIED& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ForecastIED)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForecastIED::IsInitialized() const {
  return true;
}

void ForecastIED::InternalSwap(ForecastIED* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.sourceapplicationid_, lhs_arena,
                                       &other->_impl_.sourceapplicationid_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ForecastIED, _impl_.sourcedatetime_)
      + sizeof(ForecastIED::_impl_.sourcedatetime_)
      - PROTOBUF_FIELD_OFFSET(ForecastIED, _impl_.forecastvaluesource_)>(
          reinterpret_cast<char*>(&_impl_.forecastvaluesource_),
          reinterpret_cast<char*>(&other->_impl_.forecastvaluesource_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ForecastIED::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[80]);
}
// ===================================================================

class ForecastValue::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const ForecastValue* msg);
};

const ::commonmodule::IdentifiedObject&
ForecastValue::_Internal::identifiedobject(const ForecastValue* msg) {
  return *msg->_impl_.identifiedobject_;
}
ForecastValue::ForecastValue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ForecastValue)
}
ForecastValue::ForecastValue(const ForecastValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ForecastValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ForecastValue)
}

inline void ForecastValue::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ForecastValue::~ForecastValue() {
  // @@protoc_insertion_point(destructor:commonmodule.ForecastValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ForecastValue::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
}

void ForecastValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ForecastValue::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ForecastValue)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForecastValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ForecastValue::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ForecastValue)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ForecastValue)
  return target;
}

::size_t ForecastValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ForecastValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForecastValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ForecastValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForecastValue::GetClassData() const { return &_class_data_; }


void ForecastValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ForecastValue*>(&to_msg);
  auto& from = static_cast<const ForecastValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ForecastValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForecastValue::CopyFrom(const ForecastValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ForecastValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForecastValue::IsInitialized() const {
  return true;
}

void ForecastValue::InternalSwap(ForecastValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.identifiedobject_, other->_impl_.identifiedobject_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ForecastValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[81]);
}
// ===================================================================

class OperationDHFW::_Internal {
 public:
  static const ::commonmodule::ClearingTime& opltmmsmax(const OperationDHFW* msg);
};

const ::commonmodule::ClearingTime&
OperationDHFW::_Internal::opltmmsmax(const OperationDHFW* msg) {
  return *msg->_impl_.opltmmsmax_;
}
OperationDHFW::OperationDHFW(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDHFW)
}
OperationDHFW::OperationDHFW(const OperationDHFW& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OperationDHFW* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.modena_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_opltmmsmax()) {
    _this->_impl_.opltmmsmax_ = new ::commonmodule::ClearingTime(*from._impl_.opltmmsmax_);
  }
  _this->_impl_.modena_ = from._impl_.modena_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDHFW)
}

inline void OperationDHFW::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDHFW::~OperationDHFW() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDHFW)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDHFW::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.opltmmsmax_;
}

void OperationDHFW::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDHFW::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDHFW)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDHFW::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_opltmmsmax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDHFW::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDHFW)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::opltmmsmax(this),
        _Internal::opltmmsmax(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDHFW)
  return target;
}

::size_t OperationDHFW::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDHFW)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.opltmmsmax_);
  }

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDHFW::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDHFW::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDHFW::GetClassData() const { return &_class_data_; }


void OperationDHFW::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDHFW*>(&to_msg);
  auto& from = static_cast<const OperationDHFW&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDHFW)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opltmmsmax()) {
    _this->_internal_mutable_opltmmsmax()->::commonmodule::ClearingTime::MergeFrom(
        from._internal_opltmmsmax());
  }
  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDHFW::CopyFrom(const OperationDHFW& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDHFW)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDHFW::IsInitialized() const {
  return true;
}

void OperationDHFW::InternalSwap(OperationDHFW* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperationDHFW, _impl_.modena_)
      + sizeof(OperationDHFW::_impl_.modena_)
      - PROTOBUF_FIELD_OFFSET(OperationDHFW, _impl_.opltmmsmax_)>(
          reinterpret_cast<char*>(&_impl_.opltmmsmax_),
          reinterpret_cast<char*>(&other->_impl_.opltmmsmax_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDHFW::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[82]);
}
// ===================================================================

class OperationDLFW::_Internal {
 public:
  static const ::commonmodule::ClearingTime& opltmmsmax(const OperationDLFW* msg);
};

const ::commonmodule::ClearingTime&
OperationDLFW::_Internal::opltmmsmax(const OperationDLFW* msg) {
  return *msg->_impl_.opltmmsmax_;
}
OperationDLFW::OperationDLFW(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDLFW)
}
OperationDLFW::OperationDLFW(const OperationDLFW& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OperationDLFW* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.modena_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_opltmmsmax()) {
    _this->_impl_.opltmmsmax_ = new ::commonmodule::ClearingTime(*from._impl_.opltmmsmax_);
  }
  _this->_impl_.modena_ = from._impl_.modena_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDLFW)
}

inline void OperationDLFW::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDLFW::~OperationDLFW() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDLFW)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDLFW::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.opltmmsmax_;
}

void OperationDLFW::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDLFW::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDLFW)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDLFW::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_opltmmsmax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDLFW::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDLFW)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::opltmmsmax(this),
        _Internal::opltmmsmax(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDLFW)
  return target;
}

::size_t OperationDLFW::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDLFW)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.opltmmsmax_);
  }

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDLFW::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDLFW::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDLFW::GetClassData() const { return &_class_data_; }


void OperationDLFW::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDLFW*>(&to_msg);
  auto& from = static_cast<const OperationDLFW&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDLFW)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opltmmsmax()) {
    _this->_internal_mutable_opltmmsmax()->::commonmodule::ClearingTime::MergeFrom(
        from._internal_opltmmsmax());
  }
  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDLFW::CopyFrom(const OperationDLFW& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDLFW)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDLFW::IsInitialized() const {
  return true;
}

void OperationDLFW::InternalSwap(OperationDLFW* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperationDLFW, _impl_.modena_)
      + sizeof(OperationDLFW::_impl_.modena_)
      - PROTOBUF_FIELD_OFFSET(OperationDLFW, _impl_.opltmmsmax_)>(
          reinterpret_cast<char*>(&_impl_.opltmmsmax_),
          reinterpret_cast<char*>(&other->_impl_.opltmmsmax_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDLFW::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[83]);
}
// ===================================================================

class HzWPoint::_Internal {
 public:
};

HzWPoint::HzWPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.HzWPoint)
}
HzWPoint::HzWPoint(const HzWPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.HzWPoint)
}

inline void HzWPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.deadbandhzval_) { 0 }

    , decltype(_impl_.slopeval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HzWPoint::~HzWPoint() {
  // @@protoc_insertion_point(destructor:commonmodule.HzWPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HzWPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void HzWPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HzWPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.HzWPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.deadbandhzval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.slopeval_) -
      reinterpret_cast<char*>(&_impl_.deadbandhzval_)) + sizeof(_impl_.slopeval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HzWPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float deadbandHzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.deadbandhzval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float slopeVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.slopeval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HzWPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.HzWPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float deadbandHzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_deadbandhzval = this->_internal_deadbandhzval();
  ::uint32_t raw_deadbandhzval;
  memcpy(&raw_deadbandhzval, &tmp_deadbandhzval, sizeof(tmp_deadbandhzval));
  if (raw_deadbandhzval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_deadbandhzval(), target);
  }

  // float slopeVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slopeval = this->_internal_slopeval();
  ::uint32_t raw_slopeval;
  memcpy(&raw_slopeval, &tmp_slopeval, sizeof(tmp_slopeval));
  if (raw_slopeval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_slopeval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.HzWPoint)
  return target;
}

::size_t HzWPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.HzWPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float deadbandHzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_deadbandhzval = this->_internal_deadbandhzval();
  ::uint32_t raw_deadbandhzval;
  memcpy(&raw_deadbandhzval, &tmp_deadbandhzval, sizeof(tmp_deadbandhzval));
  if (raw_deadbandhzval != 0) {
    total_size += 5;
  }

  // float slopeVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slopeval = this->_internal_slopeval();
  ::uint32_t raw_slopeval;
  memcpy(&raw_slopeval, &tmp_slopeval, sizeof(tmp_slopeval));
  if (raw_slopeval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HzWPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HzWPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HzWPoint::GetClassData() const { return &_class_data_; }


void HzWPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HzWPoint*>(&to_msg);
  auto& from = static_cast<const HzWPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.HzWPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_deadbandhzval = from._internal_deadbandhzval();
  ::uint32_t raw_deadbandhzval;
  memcpy(&raw_deadbandhzval, &tmp_deadbandhzval, sizeof(tmp_deadbandhzval));
  if (raw_deadbandhzval != 0) {
    _this->_internal_set_deadbandhzval(from._internal_deadbandhzval());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_slopeval = from._internal_slopeval();
  ::uint32_t raw_slopeval;
  memcpy(&raw_slopeval, &tmp_slopeval, sizeof(tmp_slopeval));
  if (raw_slopeval != 0) {
    _this->_internal_set_slopeval(from._internal_slopeval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HzWPoint::CopyFrom(const HzWPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.HzWPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HzWPoint::IsInitialized() const {
  return true;
}

void HzWPoint::InternalSwap(HzWPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HzWPoint, _impl_.slopeval_)
      + sizeof(HzWPoint::_impl_.slopeval_)
      - PROTOBUF_FIELD_OFFSET(HzWPoint, _impl_.deadbandhzval_)>(
          reinterpret_cast<char*>(&_impl_.deadbandhzval_),
          reinterpret_cast<char*>(&other->_impl_.deadbandhzval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HzWPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[84]);
}
// ===================================================================

class HzWAPC::_Internal {
 public:
  static const ::commonmodule::HzWPoint& overhzwpt(const HzWAPC* msg);
  static const ::commonmodule::OperationDHFW& overhzwparameter(const HzWAPC* msg);
  static const ::commonmodule::HzWPoint& underhzwpt(const HzWAPC* msg);
  static const ::commonmodule::OperationDLFW& underhzwparameter(const HzWAPC* msg);
};

const ::commonmodule::HzWPoint&
HzWAPC::_Internal::overhzwpt(const HzWAPC* msg) {
  return *msg->_impl_.overhzwpt_;
}
const ::commonmodule::OperationDHFW&
HzWAPC::_Internal::overhzwparameter(const HzWAPC* msg) {
  return *msg->_impl_.overhzwparameter_;
}
const ::commonmodule::HzWPoint&
HzWAPC::_Internal::underhzwpt(const HzWAPC* msg) {
  return *msg->_impl_.underhzwpt_;
}
const ::commonmodule::OperationDLFW&
HzWAPC::_Internal::underhzwparameter(const HzWAPC* msg) {
  return *msg->_impl_.underhzwparameter_;
}
HzWAPC::HzWAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.HzWAPC)
}
HzWAPC::HzWAPC(const HzWAPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HzWAPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.overhzwpt_){nullptr}
    , decltype(_impl_.overhzwparameter_){nullptr}
    , decltype(_impl_.underhzwpt_){nullptr}
    , decltype(_impl_.underhzwparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_overhzwpt()) {
    _this->_impl_.overhzwpt_ = new ::commonmodule::HzWPoint(*from._impl_.overhzwpt_);
  }
  if (from._internal_has_overhzwparameter()) {
    _this->_impl_.overhzwparameter_ = new ::commonmodule::OperationDHFW(*from._impl_.overhzwparameter_);
  }
  if (from._internal_has_underhzwpt()) {
    _this->_impl_.underhzwpt_ = new ::commonmodule::HzWPoint(*from._impl_.underhzwpt_);
  }
  if (from._internal_has_underhzwparameter()) {
    _this->_impl_.underhzwparameter_ = new ::commonmodule::OperationDLFW(*from._impl_.underhzwparameter_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.HzWAPC)
}

inline void HzWAPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.overhzwpt_){nullptr}
    , decltype(_impl_.overhzwparameter_){nullptr}
    , decltype(_impl_.underhzwpt_){nullptr}
    , decltype(_impl_.underhzwparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HzWAPC::~HzWAPC() {
  // @@protoc_insertion_point(destructor:commonmodule.HzWAPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HzWAPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.overhzwpt_;
  if (this != internal_default_instance()) delete _impl_.overhzwparameter_;
  if (this != internal_default_instance()) delete _impl_.underhzwpt_;
  if (this != internal_default_instance()) delete _impl_.underhzwparameter_;
}

void HzWAPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HzWAPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.HzWAPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.overhzwpt_ != nullptr) {
    delete _impl_.overhzwpt_;
  }
  _impl_.overhzwpt_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.overhzwparameter_ != nullptr) {
    delete _impl_.overhzwparameter_;
  }
  _impl_.overhzwparameter_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.underhzwpt_ != nullptr) {
    delete _impl_.underhzwpt_;
  }
  _impl_.underhzwpt_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.underhzwparameter_ != nullptr) {
    delete _impl_.underhzwparameter_;
  }
  _impl_.underhzwparameter_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HzWAPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.HzWPoint overHzWPt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_overhzwpt(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDHFW overHzWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_overhzwparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.HzWPoint underHzWPt = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_underhzwpt(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDLFW underHzWParameter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_underhzwparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HzWAPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.HzWAPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.HzWPoint overHzWPt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_overhzwpt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::overhzwpt(this),
        _Internal::overhzwpt(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.OperationDHFW overHzWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_overhzwparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::overhzwparameter(this),
        _Internal::overhzwparameter(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.HzWPoint underHzWPt = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_underhzwpt()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::underhzwpt(this),
        _Internal::underhzwpt(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.OperationDLFW underHzWParameter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_underhzwparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::underhzwparameter(this),
        _Internal::underhzwparameter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.HzWAPC)
  return target;
}

::size_t HzWAPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.HzWAPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.HzWPoint overHzWPt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_overhzwpt()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.overhzwpt_);
  }

  // .commonmodule.OperationDHFW overHzWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_overhzwparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.overhzwparameter_);
  }

  // .commonmodule.HzWPoint underHzWPt = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_underhzwpt()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.underhzwpt_);
  }

  // .commonmodule.OperationDLFW underHzWParameter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_underhzwparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.underhzwparameter_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HzWAPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HzWAPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HzWAPC::GetClassData() const { return &_class_data_; }


void HzWAPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HzWAPC*>(&to_msg);
  auto& from = static_cast<const HzWAPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.HzWAPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_overhzwpt()) {
    _this->_internal_mutable_overhzwpt()->::commonmodule::HzWPoint::MergeFrom(
        from._internal_overhzwpt());
  }
  if (from._internal_has_overhzwparameter()) {
    _this->_internal_mutable_overhzwparameter()->::commonmodule::OperationDHFW::MergeFrom(
        from._internal_overhzwparameter());
  }
  if (from._internal_has_underhzwpt()) {
    _this->_internal_mutable_underhzwpt()->::commonmodule::HzWPoint::MergeFrom(
        from._internal_underhzwpt());
  }
  if (from._internal_has_underhzwparameter()) {
    _this->_internal_mutable_underhzwparameter()->::commonmodule::OperationDLFW::MergeFrom(
        from._internal_underhzwparameter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HzWAPC::CopyFrom(const HzWAPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.HzWAPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HzWAPC::IsInitialized() const {
  return true;
}

void HzWAPC::InternalSwap(HzWAPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HzWAPC, _impl_.underhzwparameter_)
      + sizeof(HzWAPC::_impl_.underhzwparameter_)
      - PROTOBUF_FIELD_OFFSET(HzWAPC, _impl_.overhzwpt_)>(
          reinterpret_cast<char*>(&_impl_.overhzwpt_),
          reinterpret_cast<char*>(&other->_impl_.overhzwpt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HzWAPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[85]);
}
// ===================================================================

class StatusINS::_Internal {
 public:
  static const ::commonmodule::Quality& q(const StatusINS* msg);
  static const ::commonmodule::Timestamp& t(const StatusINS* msg);
};

const ::commonmodule::Quality&
StatusINS::_Internal::q(const StatusINS* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
StatusINS::_Internal::t(const StatusINS* msg) {
  return *msg->_impl_.t_;
}
StatusINS::StatusINS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusINS)
}
StatusINS::StatusINS(const StatusINS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusINS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusINS)
}

inline void StatusINS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusINS::~StatusINS() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusINS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusINS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void StatusINS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusINS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusINS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusINS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.stval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusINS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusINS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusINS)
  return target;
}

::size_t StatusINS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusINS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusINS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusINS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusINS::GetClassData() const { return &_class_data_; }


void StatusINS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusINS*>(&to_msg);
  auto& from = static_cast<const StatusINS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusINS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusINS::CopyFrom(const StatusINS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusINS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusINS::IsInitialized() const {
  return true;
}

void StatusINS::InternalSwap(StatusINS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusINS, _impl_.stval_)
      + sizeof(StatusINS::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(StatusINS, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusINS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[86]);
}
// ===================================================================

class IntegerEventAndStatusGGIO::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const IntegerEventAndStatusGGIO* msg);
  static const ::commonmodule::StatusINS& intin(const IntegerEventAndStatusGGIO* msg);
  static const ::commonmodule::Optional_PhaseCodeKind& phase(const IntegerEventAndStatusGGIO* msg);
};

const ::commonmodule::LogicalNode&
IntegerEventAndStatusGGIO::_Internal::logicalnode(const IntegerEventAndStatusGGIO* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::StatusINS&
IntegerEventAndStatusGGIO::_Internal::intin(const IntegerEventAndStatusGGIO* msg) {
  return *msg->_impl_.intin_;
}
const ::commonmodule::Optional_PhaseCodeKind&
IntegerEventAndStatusGGIO::_Internal::phase(const IntegerEventAndStatusGGIO* msg) {
  return *msg->_impl_.phase_;
}
IntegerEventAndStatusGGIO::IntegerEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.IntegerEventAndStatusGGIO)
}
IntegerEventAndStatusGGIO::IntegerEventAndStatusGGIO(const IntegerEventAndStatusGGIO& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntegerEventAndStatusGGIO* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.intin_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_intin()) {
    _this->_impl_.intin_ = new ::commonmodule::StatusINS(*from._impl_.intin_);
  }
  if (from._internal_has_phase()) {
    _this->_impl_.phase_ = new ::commonmodule::Optional_PhaseCodeKind(*from._impl_.phase_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.IntegerEventAndStatusGGIO)
}

inline void IntegerEventAndStatusGGIO::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.intin_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IntegerEventAndStatusGGIO::~IntegerEventAndStatusGGIO() {
  // @@protoc_insertion_point(destructor:commonmodule.IntegerEventAndStatusGGIO)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntegerEventAndStatusGGIO::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.intin_;
  if (this != internal_default_instance()) delete _impl_.phase_;
}

void IntegerEventAndStatusGGIO::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntegerEventAndStatusGGIO::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.IntegerEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.intin_ != nullptr) {
    delete _impl_.intin_;
  }
  _impl_.intin_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntegerEventAndStatusGGIO::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusINS IntIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_intin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseCodeKind Phase = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phase(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IntegerEventAndStatusGGIO::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.IntegerEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusINS IntIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_intin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::intin(this),
        _Internal::intin(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  if (this->_internal_has_phase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phase(this),
        _Internal::phase(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.IntegerEventAndStatusGGIO)
  return target;
}

::size_t IntegerEventAndStatusGGIO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.IntegerEventAndStatusGGIO)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.StatusINS IntIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_intin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.intin_);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  if (this->_internal_has_phase()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phase_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntegerEventAndStatusGGIO::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntegerEventAndStatusGGIO::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntegerEventAndStatusGGIO::GetClassData() const { return &_class_data_; }


void IntegerEventAndStatusGGIO::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntegerEventAndStatusGGIO*>(&to_msg);
  auto& from = static_cast<const IntegerEventAndStatusGGIO&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.IntegerEventAndStatusGGIO)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_intin()) {
    _this->_internal_mutable_intin()->::commonmodule::StatusINS::MergeFrom(
        from._internal_intin());
  }
  if (from._internal_has_phase()) {
    _this->_internal_mutable_phase()->::commonmodule::Optional_PhaseCodeKind::MergeFrom(
        from._internal_phase());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntegerEventAndStatusGGIO::CopyFrom(const IntegerEventAndStatusGGIO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.IntegerEventAndStatusGGIO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegerEventAndStatusGGIO::IsInitialized() const {
  return true;
}

void IntegerEventAndStatusGGIO::InternalSwap(IntegerEventAndStatusGGIO* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntegerEventAndStatusGGIO, _impl_.phase_)
      + sizeof(IntegerEventAndStatusGGIO::_impl_.phase_)
      - PROTOBUF_FIELD_OFFSET(IntegerEventAndStatusGGIO, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IntegerEventAndStatusGGIO::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[87]);
}
// ===================================================================

class OperationDWMX::_Internal {
 public:
};

OperationDWMX::OperationDWMX(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDWMX)
}
OperationDWMX::OperationDWMX(const OperationDWMX& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDWMX)
}

inline void OperationDWMX::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDWMX::~OperationDWMX() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDWMX)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDWMX::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OperationDWMX::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDWMX::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDWMX)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDWMX::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDWMX::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDWMX)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDWMX)
  return target;
}

::size_t OperationDWMX::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDWMX)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDWMX::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDWMX::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDWMX::GetClassData() const { return &_class_data_; }


void OperationDWMX::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDWMX*>(&to_msg);
  auto& from = static_cast<const OperationDWMX&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDWMX)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDWMX::CopyFrom(const OperationDWMX& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDWMX)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDWMX::IsInitialized() const {
  return true;
}

void OperationDWMX::InternalSwap(OperationDWMX* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.modena_, other->_impl_.modena_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDWMX::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[88]);
}
// ===================================================================

class OperationDWMN::_Internal {
 public:
};

OperationDWMN::OperationDWMN(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDWMN)
}
OperationDWMN::OperationDWMN(const OperationDWMN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDWMN)
}

inline void OperationDWMN::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDWMN::~OperationDWMN() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDWMN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDWMN::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OperationDWMN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDWMN::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDWMN)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDWMN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDWMN::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDWMN)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDWMN)
  return target;
}

::size_t OperationDWMN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDWMN)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDWMN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDWMN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDWMN::GetClassData() const { return &_class_data_; }


void OperationDWMN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDWMN*>(&to_msg);
  auto& from = static_cast<const OperationDWMN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDWMN)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDWMN::CopyFrom(const OperationDWMN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDWMN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDWMN::IsInitialized() const {
  return true;
}

void OperationDWMN::InternalSwap(OperationDWMN* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.modena_, other->_impl_.modena_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDWMN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[89]);
}
// ===================================================================

class LimitWAPC::_Internal {
 public:
  static const ::commonmodule::OperationDWMX& maxlimparameter(const LimitWAPC* msg);
  static const ::commonmodule::OperationDWMN& minlimparameter(const LimitWAPC* msg);
};

const ::commonmodule::OperationDWMX&
LimitWAPC::_Internal::maxlimparameter(const LimitWAPC* msg) {
  return *msg->_impl_.maxlimparameter_;
}
const ::commonmodule::OperationDWMN&
LimitWAPC::_Internal::minlimparameter(const LimitWAPC* msg) {
  return *msg->_impl_.minlimparameter_;
}
LimitWAPC::LimitWAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.LimitWAPC)
}
LimitWAPC::LimitWAPC(const LimitWAPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LimitWAPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.maxlimparameter_){nullptr}
    , decltype(_impl_.minlimparameter_){nullptr}
    , decltype(_impl_.wmaxsptval_) {}

    , decltype(_impl_.wminsptval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_maxlimparameter()) {
    _this->_impl_.maxlimparameter_ = new ::commonmodule::OperationDWMX(*from._impl_.maxlimparameter_);
  }
  if (from._internal_has_minlimparameter()) {
    _this->_impl_.minlimparameter_ = new ::commonmodule::OperationDWMN(*from._impl_.minlimparameter_);
  }
  ::memcpy(&_impl_.wmaxsptval_, &from._impl_.wmaxsptval_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.wminsptval_) -
    reinterpret_cast<char*>(&_impl_.wmaxsptval_)) + sizeof(_impl_.wminsptval_));
  // @@protoc_insertion_point(copy_constructor:commonmodule.LimitWAPC)
}

inline void LimitWAPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.maxlimparameter_){nullptr}
    , decltype(_impl_.minlimparameter_){nullptr}
    , decltype(_impl_.wmaxsptval_) { 0 }

    , decltype(_impl_.wminsptval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LimitWAPC::~LimitWAPC() {
  // @@protoc_insertion_point(destructor:commonmodule.LimitWAPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LimitWAPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.maxlimparameter_;
  if (this != internal_default_instance()) delete _impl_.minlimparameter_;
}

void LimitWAPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LimitWAPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.LimitWAPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.maxlimparameter_ != nullptr) {
    delete _impl_.maxlimparameter_;
  }
  _impl_.maxlimparameter_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.minlimparameter_ != nullptr) {
    delete _impl_.minlimparameter_;
  }
  _impl_.minlimparameter_ = nullptr;
  ::memset(&_impl_.wmaxsptval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.wminsptval_) -
      reinterpret_cast<char*>(&_impl_.wmaxsptval_)) + sizeof(_impl_.wminsptval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LimitWAPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.OperationDWMX maxLimParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_maxlimparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDWMN minLimParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minlimparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wMaxSptVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.wmaxsptval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wMinSptVal = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 37)) {
          _impl_.wminsptval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LimitWAPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.LimitWAPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.OperationDWMX maxLimParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_maxlimparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::maxlimparameter(this),
        _Internal::maxlimparameter(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.OperationDWMN minLimParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_minlimparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::minlimparameter(this),
        _Internal::minlimparameter(this).GetCachedSize(), target, stream);
  }

  // float wMaxSptVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wmaxsptval = this->_internal_wmaxsptval();
  ::uint32_t raw_wmaxsptval;
  memcpy(&raw_wmaxsptval, &tmp_wmaxsptval, sizeof(tmp_wmaxsptval));
  if (raw_wmaxsptval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_wmaxsptval(), target);
  }

  // float wMinSptVal = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wminsptval = this->_internal_wminsptval();
  ::uint32_t raw_wminsptval;
  memcpy(&raw_wminsptval, &tmp_wminsptval, sizeof(tmp_wminsptval));
  if (raw_wminsptval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_wminsptval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.LimitWAPC)
  return target;
}

::size_t LimitWAPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.LimitWAPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.OperationDWMX maxLimParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_maxlimparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.maxlimparameter_);
  }

  // .commonmodule.OperationDWMN minLimParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_minlimparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.minlimparameter_);
  }

  // float wMaxSptVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wmaxsptval = this->_internal_wmaxsptval();
  ::uint32_t raw_wmaxsptval;
  memcpy(&raw_wmaxsptval, &tmp_wmaxsptval, sizeof(tmp_wmaxsptval));
  if (raw_wmaxsptval != 0) {
    total_size += 5;
  }

  // float wMinSptVal = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wminsptval = this->_internal_wminsptval();
  ::uint32_t raw_wminsptval;
  memcpy(&raw_wminsptval, &tmp_wminsptval, sizeof(tmp_wminsptval));
  if (raw_wminsptval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LimitWAPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LimitWAPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LimitWAPC::GetClassData() const { return &_class_data_; }


void LimitWAPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LimitWAPC*>(&to_msg);
  auto& from = static_cast<const LimitWAPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.LimitWAPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_maxlimparameter()) {
    _this->_internal_mutable_maxlimparameter()->::commonmodule::OperationDWMX::MergeFrom(
        from._internal_maxlimparameter());
  }
  if (from._internal_has_minlimparameter()) {
    _this->_internal_mutable_minlimparameter()->::commonmodule::OperationDWMN::MergeFrom(
        from._internal_minlimparameter());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wmaxsptval = from._internal_wmaxsptval();
  ::uint32_t raw_wmaxsptval;
  memcpy(&raw_wmaxsptval, &tmp_wmaxsptval, sizeof(tmp_wmaxsptval));
  if (raw_wmaxsptval != 0) {
    _this->_internal_set_wmaxsptval(from._internal_wmaxsptval());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wminsptval = from._internal_wminsptval();
  ::uint32_t raw_wminsptval;
  memcpy(&raw_wminsptval, &tmp_wminsptval, sizeof(tmp_wminsptval));
  if (raw_wminsptval != 0) {
    _this->_internal_set_wminsptval(from._internal_wminsptval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LimitWAPC::CopyFrom(const LimitWAPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.LimitWAPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitWAPC::IsInitialized() const {
  return true;
}

void LimitWAPC::InternalSwap(LimitWAPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LimitWAPC, _impl_.wminsptval_)
      + sizeof(LimitWAPC::_impl_.wminsptval_)
      - PROTOBUF_FIELD_OFFSET(LimitWAPC, _impl_.maxlimparameter_)>(
          reinterpret_cast<char*>(&_impl_.maxlimparameter_),
          reinterpret_cast<char*>(&other->_impl_.maxlimparameter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LimitWAPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[90]);
}
// ===================================================================

class LogicalNodeForEventAndStatus::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const LogicalNodeForEventAndStatus* msg);
  static const ::commonmodule::ENS_BehaviourModeKind& beh(const LogicalNodeForEventAndStatus* msg);
  static const ::commonmodule::ENS_HealthKind& eehealth(const LogicalNodeForEventAndStatus* msg);
  static const ::commonmodule::StatusSPS& hotlinetag(const LogicalNodeForEventAndStatus* msg);
  static const ::commonmodule::StatusSPS& remoteblk(const LogicalNodeForEventAndStatus* msg);
};

const ::commonmodule::LogicalNode&
LogicalNodeForEventAndStatus::_Internal::logicalnode(const LogicalNodeForEventAndStatus* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::ENS_BehaviourModeKind&
LogicalNodeForEventAndStatus::_Internal::beh(const LogicalNodeForEventAndStatus* msg) {
  return *msg->_impl_.beh_;
}
const ::commonmodule::ENS_HealthKind&
LogicalNodeForEventAndStatus::_Internal::eehealth(const LogicalNodeForEventAndStatus* msg) {
  return *msg->_impl_.eehealth_;
}
const ::commonmodule::StatusSPS&
LogicalNodeForEventAndStatus::_Internal::hotlinetag(const LogicalNodeForEventAndStatus* msg) {
  return *msg->_impl_.hotlinetag_;
}
const ::commonmodule::StatusSPS&
LogicalNodeForEventAndStatus::_Internal::remoteblk(const LogicalNodeForEventAndStatus* msg) {
  return *msg->_impl_.remoteblk_;
}
LogicalNodeForEventAndStatus::LogicalNodeForEventAndStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.LogicalNodeForEventAndStatus)
}
LogicalNodeForEventAndStatus::LogicalNodeForEventAndStatus(const LogicalNodeForEventAndStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogicalNodeForEventAndStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.beh_){nullptr}
    , decltype(_impl_.eehealth_){nullptr}
    , decltype(_impl_.hotlinetag_){nullptr}
    , decltype(_impl_.remoteblk_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_beh()) {
    _this->_impl_.beh_ = new ::commonmodule::ENS_BehaviourModeKind(*from._impl_.beh_);
  }
  if (from._internal_has_eehealth()) {
    _this->_impl_.eehealth_ = new ::commonmodule::ENS_HealthKind(*from._impl_.eehealth_);
  }
  if (from._internal_has_hotlinetag()) {
    _this->_impl_.hotlinetag_ = new ::commonmodule::StatusSPS(*from._impl_.hotlinetag_);
  }
  if (from._internal_has_remoteblk()) {
    _this->_impl_.remoteblk_ = new ::commonmodule::StatusSPS(*from._impl_.remoteblk_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.LogicalNodeForEventAndStatus)
}

inline void LogicalNodeForEventAndStatus::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.beh_){nullptr}
    , decltype(_impl_.eehealth_){nullptr}
    , decltype(_impl_.hotlinetag_){nullptr}
    , decltype(_impl_.remoteblk_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LogicalNodeForEventAndStatus::~LogicalNodeForEventAndStatus() {
  // @@protoc_insertion_point(destructor:commonmodule.LogicalNodeForEventAndStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogicalNodeForEventAndStatus::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.beh_;
  if (this != internal_default_instance()) delete _impl_.eehealth_;
  if (this != internal_default_instance()) delete _impl_.hotlinetag_;
  if (this != internal_default_instance()) delete _impl_.remoteblk_;
}

void LogicalNodeForEventAndStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogicalNodeForEventAndStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.LogicalNodeForEventAndStatus)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.beh_ != nullptr) {
    delete _impl_.beh_;
  }
  _impl_.beh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.eehealth_ != nullptr) {
    delete _impl_.eehealth_;
  }
  _impl_.eehealth_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.hotlinetag_ != nullptr) {
    delete _impl_.hotlinetag_;
  }
  _impl_.hotlinetag_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.remoteblk_ != nullptr) {
    delete _impl_.remoteblk_;
  }
  _impl_.remoteblk_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogicalNodeForEventAndStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ENS_BehaviourModeKind Beh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_beh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ENS_HealthKind EEHealth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_eehealth(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusSPS HotLineTag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_hotlinetag(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusSPS RemoteBlk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_remoteblk(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LogicalNodeForEventAndStatus::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.LogicalNodeForEventAndStatus)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ENS_BehaviourModeKind Beh = 2;
  if (this->_internal_has_beh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::beh(this),
        _Internal::beh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ENS_HealthKind EEHealth = 3;
  if (this->_internal_has_eehealth()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::eehealth(this),
        _Internal::eehealth(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusSPS HotLineTag = 4;
  if (this->_internal_has_hotlinetag()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::hotlinetag(this),
        _Internal::hotlinetag(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusSPS RemoteBlk = 5;
  if (this->_internal_has_remoteblk()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::remoteblk(this),
        _Internal::remoteblk(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.LogicalNodeForEventAndStatus)
  return target;
}

::size_t LogicalNodeForEventAndStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.LogicalNodeForEventAndStatus)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.ENS_BehaviourModeKind Beh = 2;
  if (this->_internal_has_beh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.beh_);
  }

  // .commonmodule.ENS_HealthKind EEHealth = 3;
  if (this->_internal_has_eehealth()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.eehealth_);
  }

  // .commonmodule.StatusSPS HotLineTag = 4;
  if (this->_internal_has_hotlinetag()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.hotlinetag_);
  }

  // .commonmodule.StatusSPS RemoteBlk = 5;
  if (this->_internal_has_remoteblk()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.remoteblk_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogicalNodeForEventAndStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogicalNodeForEventAndStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogicalNodeForEventAndStatus::GetClassData() const { return &_class_data_; }


void LogicalNodeForEventAndStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogicalNodeForEventAndStatus*>(&to_msg);
  auto& from = static_cast<const LogicalNodeForEventAndStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.LogicalNodeForEventAndStatus)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_beh()) {
    _this->_internal_mutable_beh()->::commonmodule::ENS_BehaviourModeKind::MergeFrom(
        from._internal_beh());
  }
  if (from._internal_has_eehealth()) {
    _this->_internal_mutable_eehealth()->::commonmodule::ENS_HealthKind::MergeFrom(
        from._internal_eehealth());
  }
  if (from._internal_has_hotlinetag()) {
    _this->_internal_mutable_hotlinetag()->::commonmodule::StatusSPS::MergeFrom(
        from._internal_hotlinetag());
  }
  if (from._internal_has_remoteblk()) {
    _this->_internal_mutable_remoteblk()->::commonmodule::StatusSPS::MergeFrom(
        from._internal_remoteblk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalNodeForEventAndStatus::CopyFrom(const LogicalNodeForEventAndStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.LogicalNodeForEventAndStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalNodeForEventAndStatus::IsInitialized() const {
  return true;
}

void LogicalNodeForEventAndStatus::InternalSwap(LogicalNodeForEventAndStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalNodeForEventAndStatus, _impl_.remoteblk_)
      + sizeof(LogicalNodeForEventAndStatus::_impl_.remoteblk_)
      - PROTOBUF_FIELD_OFFSET(LogicalNodeForEventAndStatus, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicalNodeForEventAndStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[91]);
}
// ===================================================================

class MeasurementValue::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const MeasurementValue* msg);
};

const ::commonmodule::IdentifiedObject&
MeasurementValue::_Internal::identifiedobject(const MeasurementValue* msg) {
  return *msg->_impl_.identifiedobject_;
}
MeasurementValue::MeasurementValue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.MeasurementValue)
}
MeasurementValue::MeasurementValue(const MeasurementValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MeasurementValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.MeasurementValue)
}

inline void MeasurementValue::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MeasurementValue::~MeasurementValue() {
  // @@protoc_insertion_point(destructor:commonmodule.MeasurementValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MeasurementValue::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
}

void MeasurementValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MeasurementValue::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.MeasurementValue)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MeasurementValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MeasurementValue::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.MeasurementValue)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.MeasurementValue)
  return target;
}

::size_t MeasurementValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.MeasurementValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MeasurementValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MeasurementValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MeasurementValue::GetClassData() const { return &_class_data_; }


void MeasurementValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MeasurementValue*>(&to_msg);
  auto& from = static_cast<const MeasurementValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.MeasurementValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MeasurementValue::CopyFrom(const MeasurementValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.MeasurementValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MeasurementValue::IsInitialized() const {
  return true;
}

void MeasurementValue::InternalSwap(MeasurementValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.identifiedobject_, other->_impl_.identifiedobject_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MeasurementValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[92]);
}
// ===================================================================

class Meter::_Internal {
 public:
  static const ::commonmodule::ConductingEquipment& conductingequipment(const Meter* msg);
};

const ::commonmodule::ConductingEquipment&
Meter::_Internal::conductingequipment(const Meter* msg) {
  return *msg->_impl_.conductingequipment_;
}
Meter::Meter(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Meter)
}
Meter::Meter(const Meter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Meter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.conductingequipment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_conductingequipment()) {
    _this->_impl_.conductingequipment_ = new ::commonmodule::ConductingEquipment(*from._impl_.conductingequipment_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.Meter)
}

inline void Meter::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.conductingequipment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Meter::~Meter() {
  // @@protoc_insertion_point(destructor:commonmodule.Meter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Meter::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.conductingequipment_;
}

void Meter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Meter::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Meter)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.conductingequipment_ != nullptr) {
    delete _impl_.conductingequipment_;
  }
  _impl_.conductingequipment_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Meter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_conductingequipment(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Meter::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Meter)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_conductingequipment()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::conductingequipment(this),
        _Internal::conductingequipment(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Meter)
  return target;
}

::size_t Meter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Meter)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_conductingequipment()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.conductingequipment_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Meter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Meter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Meter::GetClassData() const { return &_class_data_; }


void Meter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Meter*>(&to_msg);
  auto& from = static_cast<const Meter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Meter)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_conductingequipment()) {
    _this->_internal_mutable_conductingequipment()->::commonmodule::ConductingEquipment::MergeFrom(
        from._internal_conductingequipment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Meter::CopyFrom(const Meter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Meter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Meter::IsInitialized() const {
  return true;
}

void Meter::InternalSwap(Meter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.conductingequipment_, other->_impl_.conductingequipment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Meter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[93]);
}
// ===================================================================

class NameplateValue::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const NameplateValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& model(const NameplateValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& sernum(const NameplateValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& swrev(const NameplateValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::StringValue& vendor(const NameplateValue* msg);
};

const ::commonmodule::IdentifiedObject&
NameplateValue::_Internal::identifiedobject(const NameplateValue* msg) {
  return *msg->_impl_.identifiedobject_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
NameplateValue::_Internal::model(const NameplateValue* msg) {
  return *msg->_impl_.model_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
NameplateValue::_Internal::sernum(const NameplateValue* msg) {
  return *msg->_impl_.sernum_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
NameplateValue::_Internal::swrev(const NameplateValue* msg) {
  return *msg->_impl_.swrev_;
}
const ::PROTOBUF_NAMESPACE_ID::StringValue&
NameplateValue::_Internal::vendor(const NameplateValue* msg) {
  return *msg->_impl_.vendor_;
}
void NameplateValue::clear_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_ != nullptr) {
    delete _impl_.model_;
  }
  _impl_.model_ = nullptr;
}
void NameplateValue::clear_sernum() {
  if (GetArenaForAllocation() == nullptr && _impl_.sernum_ != nullptr) {
    delete _impl_.sernum_;
  }
  _impl_.sernum_ = nullptr;
}
void NameplateValue::clear_swrev() {
  if (GetArenaForAllocation() == nullptr && _impl_.swrev_ != nullptr) {
    delete _impl_.swrev_;
  }
  _impl_.swrev_ = nullptr;
}
void NameplateValue::clear_vendor() {
  if (GetArenaForAllocation() == nullptr && _impl_.vendor_ != nullptr) {
    delete _impl_.vendor_;
  }
  _impl_.vendor_ = nullptr;
}
NameplateValue::NameplateValue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.NameplateValue)
}
NameplateValue::NameplateValue(const NameplateValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NameplateValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.model_){nullptr}
    , decltype(_impl_.sernum_){nullptr}
    , decltype(_impl_.swrev_){nullptr}
    , decltype(_impl_.vendor_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  if (from._internal_has_model()) {
    _this->_impl_.model_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.model_);
  }
  if (from._internal_has_sernum()) {
    _this->_impl_.sernum_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.sernum_);
  }
  if (from._internal_has_swrev()) {
    _this->_impl_.swrev_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.swrev_);
  }
  if (from._internal_has_vendor()) {
    _this->_impl_.vendor_ = new ::PROTOBUF_NAMESPACE_ID::StringValue(*from._impl_.vendor_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.NameplateValue)
}

inline void NameplateValue::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.model_){nullptr}
    , decltype(_impl_.sernum_){nullptr}
    , decltype(_impl_.swrev_){nullptr}
    , decltype(_impl_.vendor_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NameplateValue::~NameplateValue() {
  // @@protoc_insertion_point(destructor:commonmodule.NameplateValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NameplateValue::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
  if (this != internal_default_instance()) delete _impl_.model_;
  if (this != internal_default_instance()) delete _impl_.sernum_;
  if (this != internal_default_instance()) delete _impl_.swrev_;
  if (this != internal_default_instance()) delete _impl_.vendor_;
}

void NameplateValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NameplateValue::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.NameplateValue)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.model_ != nullptr) {
    delete _impl_.model_;
  }
  _impl_.model_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.sernum_ != nullptr) {
    delete _impl_.sernum_;
  }
  _impl_.sernum_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.swrev_ != nullptr) {
    delete _impl_.swrev_;
  }
  _impl_.swrev_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vendor_ != nullptr) {
    delete _impl_.vendor_;
  }
  _impl_.vendor_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NameplateValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue sernum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sernum(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue swRev = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_swrev(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.StringValue vendor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_vendor(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* NameplateValue::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.NameplateValue)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue model = 2;
  if (this->_internal_has_model()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::model(this),
        _Internal::model(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue sernum = 3;
  if (this->_internal_has_sernum()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sernum(this),
        _Internal::sernum(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue swRev = 4;
  if (this->_internal_has_swrev()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::swrev(this),
        _Internal::swrev(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.StringValue vendor = 5;
  if (this->_internal_has_vendor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::vendor(this),
        _Internal::vendor(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.NameplateValue)
  return target;
}

::size_t NameplateValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.NameplateValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  // .google.protobuf.StringValue model = 2;
  if (this->_internal_has_model()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.model_);
  }

  // .google.protobuf.StringValue sernum = 3;
  if (this->_internal_has_sernum()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sernum_);
  }

  // .google.protobuf.StringValue swRev = 4;
  if (this->_internal_has_swrev()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.swrev_);
  }

  // .google.protobuf.StringValue vendor = 5;
  if (this->_internal_has_vendor()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vendor_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NameplateValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NameplateValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NameplateValue::GetClassData() const { return &_class_data_; }


void NameplateValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NameplateValue*>(&to_msg);
  auto& from = static_cast<const NameplateValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.NameplateValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  if (from._internal_has_model()) {
    _this->_internal_mutable_model()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_model());
  }
  if (from._internal_has_sernum()) {
    _this->_internal_mutable_sernum()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_sernum());
  }
  if (from._internal_has_swrev()) {
    _this->_internal_mutable_swrev()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_swrev());
  }
  if (from._internal_has_vendor()) {
    _this->_internal_mutable_vendor()->::PROTOBUF_NAMESPACE_ID::StringValue::MergeFrom(
        from._internal_vendor());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NameplateValue::CopyFrom(const NameplateValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.NameplateValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NameplateValue::IsInitialized() const {
  return true;
}

void NameplateValue::InternalSwap(NameplateValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NameplateValue, _impl_.vendor_)
      + sizeof(NameplateValue::_impl_.vendor_)
      - PROTOBUF_FIELD_OFFSET(NameplateValue, _impl_.identifiedobject_)>(
          reinterpret_cast<char*>(&_impl_.identifiedobject_),
          reinterpret_cast<char*>(&other->_impl_.identifiedobject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NameplateValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[94]);
}
// ===================================================================

class OperationDFPF::_Internal {
 public:
};

OperationDFPF::OperationDFPF(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDFPF)
}
OperationDFPF::OperationDFPF(const OperationDFPF& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDFPF)
}

inline void OperationDFPF::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.modena_) { false }

    , decltype(_impl_.pfextset_) { false }

    , decltype(_impl_.pfgntgtmxval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDFPF::~OperationDFPF() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDFPF)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDFPF::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OperationDFPF::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDFPF::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDFPF)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.modena_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.pfgntgtmxval_) -
      reinterpret_cast<char*>(&_impl_.modena_)) + sizeof(_impl_.pfgntgtmxval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDFPF::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool pFExtSet = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.pfextset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float pFGnTgtMxVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.pfgntgtmxval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDFPF::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDFPF)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  // bool pFExtSet = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_pfextset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_pfextset(), target);
  }

  // float pFGnTgtMxVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pfgntgtmxval = this->_internal_pfgntgtmxval();
  ::uint32_t raw_pfgntgtmxval;
  memcpy(&raw_pfgntgtmxval, &tmp_pfgntgtmxval, sizeof(tmp_pfgntgtmxval));
  if (raw_pfgntgtmxval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_pfgntgtmxval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDFPF)
  return target;
}

::size_t OperationDFPF::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDFPF)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  // bool pFExtSet = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_pfextset() != 0) {
    total_size += 2;
  }

  // float pFGnTgtMxVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pfgntgtmxval = this->_internal_pfgntgtmxval();
  ::uint32_t raw_pfgntgtmxval;
  memcpy(&raw_pfgntgtmxval, &tmp_pfgntgtmxval, sizeof(tmp_pfgntgtmxval));
  if (raw_pfgntgtmxval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDFPF::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDFPF::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDFPF::GetClassData() const { return &_class_data_; }


void OperationDFPF::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDFPF*>(&to_msg);
  auto& from = static_cast<const OperationDFPF&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDFPF)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  if (from._internal_pfextset() != 0) {
    _this->_internal_set_pfextset(from._internal_pfextset());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_pfgntgtmxval = from._internal_pfgntgtmxval();
  ::uint32_t raw_pfgntgtmxval;
  memcpy(&raw_pfgntgtmxval, &tmp_pfgntgtmxval, sizeof(tmp_pfgntgtmxval));
  if (raw_pfgntgtmxval != 0) {
    _this->_internal_set_pfgntgtmxval(from._internal_pfgntgtmxval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDFPF::CopyFrom(const OperationDFPF& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDFPF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDFPF::IsInitialized() const {
  return true;
}

void OperationDFPF::InternalSwap(OperationDFPF* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperationDFPF, _impl_.pfgntgtmxval_)
      + sizeof(OperationDFPF::_impl_.pfgntgtmxval_)
      - PROTOBUF_FIELD_OFFSET(OperationDFPF, _impl_.modena_)>(
          reinterpret_cast<char*>(&_impl_.modena_),
          reinterpret_cast<char*>(&other->_impl_.modena_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDFPF::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[95]);
}
// ===================================================================

class OperationDVAR::_Internal {
 public:
};

OperationDVAR::OperationDVAR(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDVAR)
}
OperationDVAR::OperationDVAR(const OperationDVAR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDVAR)
}

inline void OperationDVAR::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.vartgtspt_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDVAR::~OperationDVAR() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDVAR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDVAR::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OperationDVAR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDVAR::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDVAR)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vartgtspt_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDVAR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float varTgtSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.vartgtspt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDVAR::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDVAR)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float varTgtSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vartgtspt = this->_internal_vartgtspt();
  ::uint32_t raw_vartgtspt;
  memcpy(&raw_vartgtspt, &tmp_vartgtspt, sizeof(tmp_vartgtspt));
  if (raw_vartgtspt != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_vartgtspt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDVAR)
  return target;
}

::size_t OperationDVAR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDVAR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float varTgtSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vartgtspt = this->_internal_vartgtspt();
  ::uint32_t raw_vartgtspt;
  memcpy(&raw_vartgtspt, &tmp_vartgtspt, sizeof(tmp_vartgtspt));
  if (raw_vartgtspt != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDVAR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDVAR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDVAR::GetClassData() const { return &_class_data_; }


void OperationDVAR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDVAR*>(&to_msg);
  auto& from = static_cast<const OperationDVAR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDVAR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vartgtspt = from._internal_vartgtspt();
  ::uint32_t raw_vartgtspt;
  memcpy(&raw_vartgtspt, &tmp_vartgtspt, sizeof(tmp_vartgtspt));
  if (raw_vartgtspt != 0) {
    _this->_internal_set_vartgtspt(from._internal_vartgtspt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDVAR::CopyFrom(const OperationDVAR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDVAR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDVAR::IsInitialized() const {
  return true;
}

void OperationDVAR::InternalSwap(OperationDVAR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.vartgtspt_, other->_impl_.vartgtspt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDVAR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[96]);
}
// ===================================================================

class OperationDVVR::_Internal {
 public:
  static const ::commonmodule::ClearingTime& opltmmsmax(const OperationDVVR* msg);
  static const ::commonmodule::ControlING& vreftmms(const OperationDVVR* msg);
};

const ::commonmodule::ClearingTime&
OperationDVVR::_Internal::opltmmsmax(const OperationDVVR* msg) {
  return *msg->_impl_.opltmmsmax_;
}
const ::commonmodule::ControlING&
OperationDVVR::_Internal::vreftmms(const OperationDVVR* msg) {
  return *msg->_impl_.vreftmms_;
}
OperationDVVR::OperationDVVR(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDVVR)
}
OperationDVVR::OperationDVVR(const OperationDVVR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OperationDVVR* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.vreftmms_){nullptr}
    , decltype(_impl_.modena_) {}

    , decltype(_impl_.vrefadjena_) {}

    , decltype(_impl_.vref_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_opltmmsmax()) {
    _this->_impl_.opltmmsmax_ = new ::commonmodule::ClearingTime(*from._impl_.opltmmsmax_);
  }
  if (from._internal_has_vreftmms()) {
    _this->_impl_.vreftmms_ = new ::commonmodule::ControlING(*from._impl_.vreftmms_);
  }
  ::memcpy(&_impl_.modena_, &from._impl_.modena_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.vref_) -
    reinterpret_cast<char*>(&_impl_.modena_)) + sizeof(_impl_.vref_));
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDVVR)
}

inline void OperationDVVR::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.vreftmms_){nullptr}
    , decltype(_impl_.modena_) { false }

    , decltype(_impl_.vrefadjena_) { false }

    , decltype(_impl_.vref_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDVVR::~OperationDVVR() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDVVR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDVVR::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.opltmmsmax_;
  if (this != internal_default_instance()) delete _impl_.vreftmms_;
}

void OperationDVVR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDVVR::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDVVR)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vreftmms_ != nullptr) {
    delete _impl_.vreftmms_;
  }
  _impl_.vreftmms_ = nullptr;
  ::memset(&_impl_.modena_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.vref_) -
      reinterpret_cast<char*>(&_impl_.modena_)) + sizeof(_impl_.vref_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDVVR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_opltmmsmax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float VRef = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.vref_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool VRefAdjEna = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.vrefadjena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlING VRefTmms = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_vreftmms(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDVVR::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDVVR)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::opltmmsmax(this),
        _Internal::opltmmsmax(this).GetCachedSize(), target, stream);
  }

  // float VRef = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vref = this->_internal_vref();
  ::uint32_t raw_vref;
  memcpy(&raw_vref, &tmp_vref, sizeof(tmp_vref));
  if (raw_vref != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_vref(), target);
  }

  // bool VRefAdjEna = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_vrefadjena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_vrefadjena(), target);
  }

  // .commonmodule.ControlING VRefTmms = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vreftmms()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::vreftmms(this),
        _Internal::vreftmms(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDVVR)
  return target;
}

::size_t OperationDVVR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDVVR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.opltmmsmax_);
  }

  // .commonmodule.ControlING VRefTmms = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vreftmms()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vreftmms_);
  }

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  // bool VRefAdjEna = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_vrefadjena() != 0) {
    total_size += 2;
  }

  // float VRef = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vref = this->_internal_vref();
  ::uint32_t raw_vref;
  memcpy(&raw_vref, &tmp_vref, sizeof(tmp_vref));
  if (raw_vref != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDVVR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDVVR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDVVR::GetClassData() const { return &_class_data_; }


void OperationDVVR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDVVR*>(&to_msg);
  auto& from = static_cast<const OperationDVVR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDVVR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opltmmsmax()) {
    _this->_internal_mutable_opltmmsmax()->::commonmodule::ClearingTime::MergeFrom(
        from._internal_opltmmsmax());
  }
  if (from._internal_has_vreftmms()) {
    _this->_internal_mutable_vreftmms()->::commonmodule::ControlING::MergeFrom(
        from._internal_vreftmms());
  }
  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  if (from._internal_vrefadjena() != 0) {
    _this->_internal_set_vrefadjena(from._internal_vrefadjena());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_vref = from._internal_vref();
  ::uint32_t raw_vref;
  memcpy(&raw_vref, &tmp_vref, sizeof(tmp_vref));
  if (raw_vref != 0) {
    _this->_internal_set_vref(from._internal_vref());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDVVR::CopyFrom(const OperationDVVR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDVVR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDVVR::IsInitialized() const {
  return true;
}

void OperationDVVR::InternalSwap(OperationDVVR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperationDVVR, _impl_.vref_)
      + sizeof(OperationDVVR::_impl_.vref_)
      - PROTOBUF_FIELD_OFFSET(OperationDVVR, _impl_.opltmmsmax_)>(
          reinterpret_cast<char*>(&_impl_.opltmmsmax_),
          reinterpret_cast<char*>(&other->_impl_.opltmmsmax_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDVVR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[97]);
}
// ===================================================================

class OperationDVWC::_Internal {
 public:
  static const ::commonmodule::ClearingTime& opltmmsmax(const OperationDVWC* msg);
};

const ::commonmodule::ClearingTime&
OperationDVWC::_Internal::opltmmsmax(const OperationDVWC* msg) {
  return *msg->_impl_.opltmmsmax_;
}
OperationDVWC::OperationDVWC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDVWC)
}
OperationDVWC::OperationDVWC(const OperationDVWC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OperationDVWC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.modena_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_opltmmsmax()) {
    _this->_impl_.opltmmsmax_ = new ::commonmodule::ClearingTime(*from._impl_.opltmmsmax_);
  }
  _this->_impl_.modena_ = from._impl_.modena_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDVWC)
}

inline void OperationDVWC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.opltmmsmax_){nullptr}
    , decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDVWC::~OperationDVWC() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDVWC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDVWC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.opltmmsmax_;
}

void OperationDVWC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDVWC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDVWC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDVWC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_opltmmsmax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDVWC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDVWC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::opltmmsmax(this),
        _Internal::opltmmsmax(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDVWC)
  return target;
}

::size_t OperationDVWC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDVWC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_opltmmsmax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.opltmmsmax_);
  }

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDVWC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDVWC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDVWC::GetClassData() const { return &_class_data_; }


void OperationDVWC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDVWC*>(&to_msg);
  auto& from = static_cast<const OperationDVWC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDVWC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opltmmsmax()) {
    _this->_internal_mutable_opltmmsmax()->::commonmodule::ClearingTime::MergeFrom(
        from._internal_opltmmsmax());
  }
  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDVWC::CopyFrom(const OperationDVWC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDVWC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDVWC::IsInitialized() const {
  return true;
}

void OperationDVWC::InternalSwap(OperationDVWC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperationDVWC, _impl_.modena_)
      + sizeof(OperationDVWC::_impl_.modena_)
      - PROTOBUF_FIELD_OFFSET(OperationDVWC, _impl_.opltmmsmax_)>(
          reinterpret_cast<char*>(&_impl_.opltmmsmax_),
          reinterpret_cast<char*>(&other->_impl_.opltmmsmax_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDVWC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[98]);
}
// ===================================================================

class OperationDWGC::_Internal {
 public:
};

OperationDWGC::OperationDWGC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDWGC)
}
OperationDWGC::OperationDWGC(const OperationDWGC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDWGC)
}

inline void OperationDWGC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.wspt_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDWGC::~OperationDWGC() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDWGC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDWGC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OperationDWGC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDWGC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDWGC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wspt_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDWGC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float wSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.wspt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDWGC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDWGC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float wSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wspt = this->_internal_wspt();
  ::uint32_t raw_wspt;
  memcpy(&raw_wspt, &tmp_wspt, sizeof(tmp_wspt));
  if (raw_wspt != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_wspt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDWGC)
  return target;
}

::size_t OperationDWGC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDWGC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float wSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wspt = this->_internal_wspt();
  ::uint32_t raw_wspt;
  memcpy(&raw_wspt, &tmp_wspt, sizeof(tmp_wspt));
  if (raw_wspt != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDWGC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDWGC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDWGC::GetClassData() const { return &_class_data_; }


void OperationDWGC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDWGC*>(&to_msg);
  auto& from = static_cast<const OperationDWGC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDWGC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wspt = from._internal_wspt();
  ::uint32_t raw_wspt;
  memcpy(&raw_wspt, &tmp_wspt, sizeof(tmp_wspt));
  if (raw_wspt != 0) {
    _this->_internal_set_wspt(from._internal_wspt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDWGC::CopyFrom(const OperationDWGC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDWGC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDWGC::IsInitialized() const {
  return true;
}

void OperationDWGC::InternalSwap(OperationDWGC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.wspt_, other->_impl_.wspt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDWGC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[99]);
}
// ===================================================================

class OperationDWVR::_Internal {
 public:
};

OperationDWVR::OperationDWVR(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OperationDWVR)
}
OperationDWVR::OperationDWVR(const OperationDWVR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.OperationDWVR)
}

inline void OperationDWVR::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OperationDWVR::~OperationDWVR() {
  // @@protoc_insertion_point(destructor:commonmodule.OperationDWVR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperationDWVR::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void OperationDWVR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperationDWVR::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OperationDWVR)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperationDWVR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OperationDWVR::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OperationDWVR)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OperationDWVR)
  return target;
}

::size_t OperationDWVR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OperationDWVR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperationDWVR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperationDWVR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperationDWVR::GetClassData() const { return &_class_data_; }


void OperationDWVR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperationDWVR*>(&to_msg);
  auto& from = static_cast<const OperationDWVR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OperationDWVR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperationDWVR::CopyFrom(const OperationDWVR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OperationDWVR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperationDWVR::IsInitialized() const {
  return true;
}

void OperationDWVR::InternalSwap(OperationDWVR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.modena_, other->_impl_.modena_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OperationDWVR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[100]);
}
// ===================================================================

class OptimizationMessageInfo::_Internal {
 public:
  static const ::commonmodule::MessageInfo& messageinfo(const OptimizationMessageInfo* msg);
};

const ::commonmodule::MessageInfo&
OptimizationMessageInfo::_Internal::messageinfo(const OptimizationMessageInfo* msg) {
  return *msg->_impl_.messageinfo_;
}
OptimizationMessageInfo::OptimizationMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.OptimizationMessageInfo)
}
OptimizationMessageInfo::OptimizationMessageInfo(const OptimizationMessageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OptimizationMessageInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_messageinfo()) {
    _this->_impl_.messageinfo_ = new ::commonmodule::MessageInfo(*from._impl_.messageinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.OptimizationMessageInfo)
}

inline void OptimizationMessageInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OptimizationMessageInfo::~OptimizationMessageInfo() {
  // @@protoc_insertion_point(destructor:commonmodule.OptimizationMessageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OptimizationMessageInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.messageinfo_;
}

void OptimizationMessageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OptimizationMessageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.OptimizationMessageInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OptimizationMessageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_messageinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OptimizationMessageInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.OptimizationMessageInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::messageinfo(this),
        _Internal::messageinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.OptimizationMessageInfo)
  return target;
}

::size_t OptimizationMessageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.OptimizationMessageInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.messageinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OptimizationMessageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OptimizationMessageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OptimizationMessageInfo::GetClassData() const { return &_class_data_; }


void OptimizationMessageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OptimizationMessageInfo*>(&to_msg);
  auto& from = static_cast<const OptimizationMessageInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.OptimizationMessageInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_messageinfo()) {
    _this->_internal_mutable_messageinfo()->::commonmodule::MessageInfo::MergeFrom(
        from._internal_messageinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OptimizationMessageInfo::CopyFrom(const OptimizationMessageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.OptimizationMessageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OptimizationMessageInfo::IsInitialized() const {
  return true;
}

void OptimizationMessageInfo::InternalSwap(OptimizationMessageInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.messageinfo_, other->_impl_.messageinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OptimizationMessageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[101]);
}
// ===================================================================

class PFSPC::_Internal {
 public:
  static const ::commonmodule::OperationDFPF& pfparameter(const PFSPC* msg);
};

const ::commonmodule::OperationDFPF&
PFSPC::_Internal::pfparameter(const PFSPC* msg) {
  return *msg->_impl_.pfparameter_;
}
PFSPC::PFSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PFSPC)
}
PFSPC::PFSPC(const PFSPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PFSPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pfparameter_){nullptr}
    , decltype(_impl_.ctlval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pfparameter()) {
    _this->_impl_.pfparameter_ = new ::commonmodule::OperationDFPF(*from._impl_.pfparameter_);
  }
  _this->_impl_.ctlval_ = from._impl_.ctlval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.PFSPC)
}

inline void PFSPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.pfparameter_){nullptr}
    , decltype(_impl_.ctlval_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PFSPC::~PFSPC() {
  // @@protoc_insertion_point(destructor:commonmodule.PFSPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PFSPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pfparameter_;
}

void PFSPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PFSPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PFSPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pfparameter_ != nullptr) {
    delete _impl_.pfparameter_;
  }
  _impl_.pfparameter_ = nullptr;
  _impl_.ctlval_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PFSPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.ctlval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDFPF pFParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pfparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PFSPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PFSPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_ctlval(), target);
  }

  // .commonmodule.OperationDFPF pFParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_pfparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pfparameter(this),
        _Internal::pfparameter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PFSPC)
  return target;
}

::size_t PFSPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PFSPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.OperationDFPF pFParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_pfparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pfparameter_);
  }

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_ctlval() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PFSPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PFSPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PFSPC::GetClassData() const { return &_class_data_; }


void PFSPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PFSPC*>(&to_msg);
  auto& from = static_cast<const PFSPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PFSPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pfparameter()) {
    _this->_internal_mutable_pfparameter()->::commonmodule::OperationDFPF::MergeFrom(
        from._internal_pfparameter());
  }
  if (from._internal_ctlval() != 0) {
    _this->_internal_set_ctlval(from._internal_ctlval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PFSPC::CopyFrom(const PFSPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PFSPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PFSPC::IsInitialized() const {
  return true;
}

void PFSPC::InternalSwap(PFSPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PFSPC, _impl_.ctlval_)
      + sizeof(PFSPC::_impl_.ctlval_)
      - PROTOBUF_FIELD_OFFSET(PFSPC, _impl_.pfparameter_)>(
          reinterpret_cast<char*>(&_impl_.pfparameter_),
          reinterpret_cast<char*>(&other->_impl_.pfparameter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PFSPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[102]);
}
// ===================================================================

class PhaseAPC::_Internal {
 public:
  static const ::commonmodule::ControlAPC& phs3(const PhaseAPC* msg);
  static const ::commonmodule::ControlAPC& phsa(const PhaseAPC* msg);
  static const ::commonmodule::ControlAPC& phsb(const PhaseAPC* msg);
  static const ::commonmodule::ControlAPC& phsc(const PhaseAPC* msg);
};

const ::commonmodule::ControlAPC&
PhaseAPC::_Internal::phs3(const PhaseAPC* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::ControlAPC&
PhaseAPC::_Internal::phsa(const PhaseAPC* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::ControlAPC&
PhaseAPC::_Internal::phsb(const PhaseAPC* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::ControlAPC&
PhaseAPC::_Internal::phsc(const PhaseAPC* msg) {
  return *msg->_impl_.phsc_;
}
PhaseAPC::PhaseAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseAPC)
}
PhaseAPC::PhaseAPC(const PhaseAPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseAPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::ControlAPC(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::ControlAPC(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::ControlAPC(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::ControlAPC(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseAPC)
}

inline void PhaseAPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseAPC::~PhaseAPC() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseAPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseAPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseAPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseAPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseAPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseAPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ControlAPC phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlAPC phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlAPC phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlAPC phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseAPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseAPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ControlAPC phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlAPC phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlAPC phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlAPC phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseAPC)
  return target;
}

::size_t PhaseAPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseAPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ControlAPC phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.ControlAPC phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.ControlAPC phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.ControlAPC phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseAPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseAPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseAPC::GetClassData() const { return &_class_data_; }


void PhaseAPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseAPC*>(&to_msg);
  auto& from = static_cast<const PhaseAPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseAPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::ControlAPC::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::ControlAPC::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::ControlAPC::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::ControlAPC::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseAPC::CopyFrom(const PhaseAPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseAPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseAPC::IsInitialized() const {
  return true;
}

void PhaseAPC::InternalSwap(PhaseAPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseAPC, _impl_.phsc_)
      + sizeof(PhaseAPC::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseAPC, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseAPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[103]);
}
// ===================================================================

class Optional_DbPosKind::_Internal {
 public:
};

Optional_DbPosKind::Optional_DbPosKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_DbPosKind)
}
Optional_DbPosKind::Optional_DbPosKind(const Optional_DbPosKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_DbPosKind)
}

inline void Optional_DbPosKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_DbPosKind::~Optional_DbPosKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_DbPosKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_DbPosKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_DbPosKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_DbPosKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_DbPosKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_DbPosKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.DbPosKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::DbPosKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_DbPosKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_DbPosKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.DbPosKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_DbPosKind)
  return target;
}

::size_t Optional_DbPosKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_DbPosKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.DbPosKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_DbPosKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_DbPosKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_DbPosKind::GetClassData() const { return &_class_data_; }


void Optional_DbPosKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_DbPosKind*>(&to_msg);
  auto& from = static_cast<const Optional_DbPosKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_DbPosKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_DbPosKind::CopyFrom(const Optional_DbPosKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_DbPosKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_DbPosKind::IsInitialized() const {
  return true;
}

void Optional_DbPosKind::InternalSwap(Optional_DbPosKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_DbPosKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[104]);
}
// ===================================================================

class StatusDPS::_Internal {
 public:
  static const ::commonmodule::Quality& q(const StatusDPS* msg);
  static const ::commonmodule::Timestamp& t(const StatusDPS* msg);
};

const ::commonmodule::Quality&
StatusDPS::_Internal::q(const StatusDPS* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
StatusDPS::_Internal::t(const StatusDPS* msg) {
  return *msg->_impl_.t_;
}
StatusDPS::StatusDPS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusDPS)
}
StatusDPS::StatusDPS(const StatusDPS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusDPS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusDPS)
}

inline void StatusDPS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusDPS::~StatusDPS() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusDPS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusDPS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void StatusDPS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusDPS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusDPS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusDPS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.DbPosKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_stval(static_cast<::commonmodule::DbPosKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusDPS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusDPS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.DbPosKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusDPS)
  return target;
}

::size_t StatusDPS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusDPS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // .commonmodule.DbPosKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusDPS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusDPS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusDPS::GetClassData() const { return &_class_data_; }


void StatusDPS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusDPS*>(&to_msg);
  auto& from = static_cast<const StatusDPS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusDPS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusDPS::CopyFrom(const StatusDPS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusDPS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusDPS::IsInitialized() const {
  return true;
}

void StatusDPS::InternalSwap(StatusDPS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusDPS, _impl_.stval_)
      + sizeof(StatusDPS::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(StatusDPS, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusDPS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[105]);
}
// ===================================================================

class PhaseDPS::_Internal {
 public:
  static const ::commonmodule::StatusDPS& phs3(const PhaseDPS* msg);
  static const ::commonmodule::StatusDPS& phsa(const PhaseDPS* msg);
  static const ::commonmodule::StatusDPS& phsb(const PhaseDPS* msg);
  static const ::commonmodule::StatusDPS& phsc(const PhaseDPS* msg);
};

const ::commonmodule::StatusDPS&
PhaseDPS::_Internal::phs3(const PhaseDPS* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::StatusDPS&
PhaseDPS::_Internal::phsa(const PhaseDPS* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::StatusDPS&
PhaseDPS::_Internal::phsb(const PhaseDPS* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::StatusDPS&
PhaseDPS::_Internal::phsc(const PhaseDPS* msg) {
  return *msg->_impl_.phsc_;
}
PhaseDPS::PhaseDPS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseDPS)
}
PhaseDPS::PhaseDPS(const PhaseDPS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseDPS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::StatusDPS(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::StatusDPS(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::StatusDPS(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::StatusDPS(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseDPS)
}

inline void PhaseDPS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseDPS::~PhaseDPS() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseDPS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseDPS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseDPS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseDPS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseDPS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseDPS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.StatusDPS phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusDPS phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusDPS phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusDPS phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseDPS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseDPS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.StatusDPS phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusDPS phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusDPS phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusDPS phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseDPS)
  return target;
}

::size_t PhaseDPS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseDPS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.StatusDPS phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.StatusDPS phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.StatusDPS phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.StatusDPS phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseDPS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseDPS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseDPS::GetClassData() const { return &_class_data_; }


void PhaseDPS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseDPS*>(&to_msg);
  auto& from = static_cast<const PhaseDPS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseDPS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::StatusDPS::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::StatusDPS::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::StatusDPS::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::StatusDPS::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseDPS::CopyFrom(const PhaseDPS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseDPS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseDPS::IsInitialized() const {
  return true;
}

void PhaseDPS::InternalSwap(PhaseDPS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseDPS, _impl_.phsc_)
      + sizeof(PhaseDPS::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseDPS, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseDPS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[106]);
}
// ===================================================================

class PhaseINS::_Internal {
 public:
  static const ::commonmodule::StatusINS& phs3(const PhaseINS* msg);
  static const ::commonmodule::StatusINS& phsa(const PhaseINS* msg);
  static const ::commonmodule::StatusINS& phsb(const PhaseINS* msg);
  static const ::commonmodule::StatusINS& phsc(const PhaseINS* msg);
};

const ::commonmodule::StatusINS&
PhaseINS::_Internal::phs3(const PhaseINS* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::StatusINS&
PhaseINS::_Internal::phsa(const PhaseINS* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::StatusINS&
PhaseINS::_Internal::phsb(const PhaseINS* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::StatusINS&
PhaseINS::_Internal::phsc(const PhaseINS* msg) {
  return *msg->_impl_.phsc_;
}
PhaseINS::PhaseINS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseINS)
}
PhaseINS::PhaseINS(const PhaseINS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseINS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::StatusINS(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::StatusINS(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::StatusINS(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::StatusINS(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseINS)
}

inline void PhaseINS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseINS::~PhaseINS() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseINS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseINS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseINS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseINS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseINS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseINS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.StatusINS phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusINS phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusINS phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusINS phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseINS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseINS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.StatusINS phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusINS phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusINS phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusINS phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseINS)
  return target;
}

::size_t PhaseINS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseINS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.StatusINS phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.StatusINS phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.StatusINS phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.StatusINS phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseINS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseINS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseINS::GetClassData() const { return &_class_data_; }


void PhaseINS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseINS*>(&to_msg);
  auto& from = static_cast<const PhaseINS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseINS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::StatusINS::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::StatusINS::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::StatusINS::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::StatusINS::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseINS::CopyFrom(const PhaseINS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseINS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseINS::IsInitialized() const {
  return true;
}

void PhaseINS::InternalSwap(PhaseINS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseINS, _impl_.phsc_)
      + sizeof(PhaseINS::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseINS, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseINS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[107]);
}
// ===================================================================

class PhaseISC::_Internal {
 public:
  static const ::commonmodule::ControlISC& phs3(const PhaseISC* msg);
  static const ::commonmodule::ControlISC& phsa(const PhaseISC* msg);
  static const ::commonmodule::ControlISC& phsb(const PhaseISC* msg);
  static const ::commonmodule::ControlISC& phsc(const PhaseISC* msg);
};

const ::commonmodule::ControlISC&
PhaseISC::_Internal::phs3(const PhaseISC* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::ControlISC&
PhaseISC::_Internal::phsa(const PhaseISC* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::ControlISC&
PhaseISC::_Internal::phsb(const PhaseISC* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::ControlISC&
PhaseISC::_Internal::phsc(const PhaseISC* msg) {
  return *msg->_impl_.phsc_;
}
PhaseISC::PhaseISC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseISC)
}
PhaseISC::PhaseISC(const PhaseISC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseISC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::ControlISC(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::ControlISC(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::ControlISC(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::ControlISC(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseISC)
}

inline void PhaseISC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseISC::~PhaseISC() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseISC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseISC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseISC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseISC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseISC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseISC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ControlISC phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlISC phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlISC phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlISC phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseISC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseISC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ControlISC phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlISC phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlISC phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlISC phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseISC)
  return target;
}

::size_t PhaseISC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseISC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ControlISC phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.ControlISC phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.ControlISC phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.ControlISC phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseISC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseISC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseISC::GetClassData() const { return &_class_data_; }


void PhaseISC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseISC*>(&to_msg);
  auto& from = static_cast<const PhaseISC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseISC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::ControlISC::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::ControlISC::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::ControlISC::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::ControlISC::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseISC::CopyFrom(const PhaseISC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseISC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseISC::IsInitialized() const {
  return true;
}

void PhaseISC::InternalSwap(PhaseISC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseISC, _impl_.phsc_)
      + sizeof(PhaseISC::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseISC, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseISC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[108]);
}
// ===================================================================

class ReadingMMTN::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& dmdvah(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& dmdvarh(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& dmdwh(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& supvah(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& supvarh(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& supwh(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& totvah(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& totvarh(const ReadingMMTN* msg);
  static const ::commonmodule::BCR& totwh(const ReadingMMTN* msg);
};

const ::commonmodule::LogicalNode&
ReadingMMTN::_Internal::logicalnode(const ReadingMMTN* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::dmdvah(const ReadingMMTN* msg) {
  return *msg->_impl_.dmdvah_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::dmdvarh(const ReadingMMTN* msg) {
  return *msg->_impl_.dmdvarh_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::dmdwh(const ReadingMMTN* msg) {
  return *msg->_impl_.dmdwh_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::supvah(const ReadingMMTN* msg) {
  return *msg->_impl_.supvah_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::supvarh(const ReadingMMTN* msg) {
  return *msg->_impl_.supvarh_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::supwh(const ReadingMMTN* msg) {
  return *msg->_impl_.supwh_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::totvah(const ReadingMMTN* msg) {
  return *msg->_impl_.totvah_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::totvarh(const ReadingMMTN* msg) {
  return *msg->_impl_.totvarh_;
}
const ::commonmodule::BCR&
ReadingMMTN::_Internal::totwh(const ReadingMMTN* msg) {
  return *msg->_impl_.totwh_;
}
ReadingMMTN::ReadingMMTN(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ReadingMMTN)
}
ReadingMMTN::ReadingMMTN(const ReadingMMTN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadingMMTN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.dmdvah_){nullptr}
    , decltype(_impl_.dmdvarh_){nullptr}
    , decltype(_impl_.dmdwh_){nullptr}
    , decltype(_impl_.supvah_){nullptr}
    , decltype(_impl_.supvarh_){nullptr}
    , decltype(_impl_.supwh_){nullptr}
    , decltype(_impl_.totvah_){nullptr}
    , decltype(_impl_.totvarh_){nullptr}
    , decltype(_impl_.totwh_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_dmdvah()) {
    _this->_impl_.dmdvah_ = new ::commonmodule::BCR(*from._impl_.dmdvah_);
  }
  if (from._internal_has_dmdvarh()) {
    _this->_impl_.dmdvarh_ = new ::commonmodule::BCR(*from._impl_.dmdvarh_);
  }
  if (from._internal_has_dmdwh()) {
    _this->_impl_.dmdwh_ = new ::commonmodule::BCR(*from._impl_.dmdwh_);
  }
  if (from._internal_has_supvah()) {
    _this->_impl_.supvah_ = new ::commonmodule::BCR(*from._impl_.supvah_);
  }
  if (from._internal_has_supvarh()) {
    _this->_impl_.supvarh_ = new ::commonmodule::BCR(*from._impl_.supvarh_);
  }
  if (from._internal_has_supwh()) {
    _this->_impl_.supwh_ = new ::commonmodule::BCR(*from._impl_.supwh_);
  }
  if (from._internal_has_totvah()) {
    _this->_impl_.totvah_ = new ::commonmodule::BCR(*from._impl_.totvah_);
  }
  if (from._internal_has_totvarh()) {
    _this->_impl_.totvarh_ = new ::commonmodule::BCR(*from._impl_.totvarh_);
  }
  if (from._internal_has_totwh()) {
    _this->_impl_.totwh_ = new ::commonmodule::BCR(*from._impl_.totwh_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ReadingMMTN)
}

inline void ReadingMMTN::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.dmdvah_){nullptr}
    , decltype(_impl_.dmdvarh_){nullptr}
    , decltype(_impl_.dmdwh_){nullptr}
    , decltype(_impl_.supvah_){nullptr}
    , decltype(_impl_.supvarh_){nullptr}
    , decltype(_impl_.supwh_){nullptr}
    , decltype(_impl_.totvah_){nullptr}
    , decltype(_impl_.totvarh_){nullptr}
    , decltype(_impl_.totwh_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadingMMTN::~ReadingMMTN() {
  // @@protoc_insertion_point(destructor:commonmodule.ReadingMMTN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadingMMTN::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.dmdvah_;
  if (this != internal_default_instance()) delete _impl_.dmdvarh_;
  if (this != internal_default_instance()) delete _impl_.dmdwh_;
  if (this != internal_default_instance()) delete _impl_.supvah_;
  if (this != internal_default_instance()) delete _impl_.supvarh_;
  if (this != internal_default_instance()) delete _impl_.supwh_;
  if (this != internal_default_instance()) delete _impl_.totvah_;
  if (this != internal_default_instance()) delete _impl_.totvarh_;
  if (this != internal_default_instance()) delete _impl_.totwh_;
}

void ReadingMMTN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadingMMTN::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ReadingMMTN)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvah_ != nullptr) {
    delete _impl_.dmdvah_;
  }
  _impl_.dmdvah_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvarh_ != nullptr) {
    delete _impl_.dmdvarh_;
  }
  _impl_.dmdvarh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dmdwh_ != nullptr) {
    delete _impl_.dmdwh_;
  }
  _impl_.dmdwh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.supvah_ != nullptr) {
    delete _impl_.supvah_;
  }
  _impl_.supvah_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.supvarh_ != nullptr) {
    delete _impl_.supvarh_;
  }
  _impl_.supvarh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.supwh_ != nullptr) {
    delete _impl_.supwh_;
  }
  _impl_.supwh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.totvah_ != nullptr) {
    delete _impl_.totvah_;
  }
  _impl_.totvah_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.totvarh_ != nullptr) {
    delete _impl_.totvarh_;
  }
  _impl_.totvarh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.totwh_ != nullptr) {
    delete _impl_.totwh_;
  }
  _impl_.totwh_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadingMMTN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR DmdVAh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmdvah(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR DmdVArh = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmdvarh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR DmdWh = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmdwh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR SupVAh = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_supvah(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR SupVArh = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_supvarh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR SupWh = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_supwh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR TotVAh = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_totvah(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR TotVArh = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_totvarh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR TotWh = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_totwh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReadingMMTN::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ReadingMMTN)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR DmdVAh = 2;
  if (this->_internal_has_dmdvah()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dmdvah(this),
        _Internal::dmdvah(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR DmdVArh = 3;
  if (this->_internal_has_dmdvarh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dmdvarh(this),
        _Internal::dmdvarh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR DmdWh = 4;
  if (this->_internal_has_dmdwh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::dmdwh(this),
        _Internal::dmdwh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR SupVAh = 5;
  if (this->_internal_has_supvah()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::supvah(this),
        _Internal::supvah(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR SupVArh = 6;
  if (this->_internal_has_supvarh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::supvarh(this),
        _Internal::supvarh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR SupWh = 7;
  if (this->_internal_has_supwh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::supwh(this),
        _Internal::supwh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR TotVAh = 8;
  if (this->_internal_has_totvah()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::totvah(this),
        _Internal::totvah(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR TotVArh = 9;
  if (this->_internal_has_totvarh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::totvarh(this),
        _Internal::totvarh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR TotWh = 10;
  if (this->_internal_has_totwh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::totwh(this),
        _Internal::totwh(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ReadingMMTN)
  return target;
}

::size_t ReadingMMTN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ReadingMMTN)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.BCR DmdVAh = 2;
  if (this->_internal_has_dmdvah()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dmdvah_);
  }

  // .commonmodule.BCR DmdVArh = 3;
  if (this->_internal_has_dmdvarh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dmdvarh_);
  }

  // .commonmodule.BCR DmdWh = 4;
  if (this->_internal_has_dmdwh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dmdwh_);
  }

  // .commonmodule.BCR SupVAh = 5;
  if (this->_internal_has_supvah()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.supvah_);
  }

  // .commonmodule.BCR SupVArh = 6;
  if (this->_internal_has_supvarh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.supvarh_);
  }

  // .commonmodule.BCR SupWh = 7;
  if (this->_internal_has_supwh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.supwh_);
  }

  // .commonmodule.BCR TotVAh = 8;
  if (this->_internal_has_totvah()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.totvah_);
  }

  // .commonmodule.BCR TotVArh = 9;
  if (this->_internal_has_totvarh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.totvarh_);
  }

  // .commonmodule.BCR TotWh = 10;
  if (this->_internal_has_totwh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.totwh_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadingMMTN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadingMMTN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadingMMTN::GetClassData() const { return &_class_data_; }


void ReadingMMTN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadingMMTN*>(&to_msg);
  auto& from = static_cast<const ReadingMMTN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ReadingMMTN)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_dmdvah()) {
    _this->_internal_mutable_dmdvah()->::commonmodule::BCR::MergeFrom(
        from._internal_dmdvah());
  }
  if (from._internal_has_dmdvarh()) {
    _this->_internal_mutable_dmdvarh()->::commonmodule::BCR::MergeFrom(
        from._internal_dmdvarh());
  }
  if (from._internal_has_dmdwh()) {
    _this->_internal_mutable_dmdwh()->::commonmodule::BCR::MergeFrom(
        from._internal_dmdwh());
  }
  if (from._internal_has_supvah()) {
    _this->_internal_mutable_supvah()->::commonmodule::BCR::MergeFrom(
        from._internal_supvah());
  }
  if (from._internal_has_supvarh()) {
    _this->_internal_mutable_supvarh()->::commonmodule::BCR::MergeFrom(
        from._internal_supvarh());
  }
  if (from._internal_has_supwh()) {
    _this->_internal_mutable_supwh()->::commonmodule::BCR::MergeFrom(
        from._internal_supwh());
  }
  if (from._internal_has_totvah()) {
    _this->_internal_mutable_totvah()->::commonmodule::BCR::MergeFrom(
        from._internal_totvah());
  }
  if (from._internal_has_totvarh()) {
    _this->_internal_mutable_totvarh()->::commonmodule::BCR::MergeFrom(
        from._internal_totvarh());
  }
  if (from._internal_has_totwh()) {
    _this->_internal_mutable_totwh()->::commonmodule::BCR::MergeFrom(
        from._internal_totwh());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadingMMTN::CopyFrom(const ReadingMMTN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ReadingMMTN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadingMMTN::IsInitialized() const {
  return true;
}

void ReadingMMTN::InternalSwap(ReadingMMTN* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReadingMMTN, _impl_.totwh_)
      + sizeof(ReadingMMTN::_impl_.totwh_)
      - PROTOBUF_FIELD_OFFSET(ReadingMMTN, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadingMMTN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[109]);
}
// ===================================================================

class PhaseMMTN::_Internal {
 public:
  static const ::commonmodule::ReadingMMTN& phsa(const PhaseMMTN* msg);
  static const ::commonmodule::ReadingMMTN& phsab(const PhaseMMTN* msg);
  static const ::commonmodule::ReadingMMTN& phsb(const PhaseMMTN* msg);
  static const ::commonmodule::ReadingMMTN& phsbc(const PhaseMMTN* msg);
  static const ::commonmodule::ReadingMMTN& phsc(const PhaseMMTN* msg);
  static const ::commonmodule::ReadingMMTN& phsca(const PhaseMMTN* msg);
};

const ::commonmodule::ReadingMMTN&
PhaseMMTN::_Internal::phsa(const PhaseMMTN* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::ReadingMMTN&
PhaseMMTN::_Internal::phsab(const PhaseMMTN* msg) {
  return *msg->_impl_.phsab_;
}
const ::commonmodule::ReadingMMTN&
PhaseMMTN::_Internal::phsb(const PhaseMMTN* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::ReadingMMTN&
PhaseMMTN::_Internal::phsbc(const PhaseMMTN* msg) {
  return *msg->_impl_.phsbc_;
}
const ::commonmodule::ReadingMMTN&
PhaseMMTN::_Internal::phsc(const PhaseMMTN* msg) {
  return *msg->_impl_.phsc_;
}
const ::commonmodule::ReadingMMTN&
PhaseMMTN::_Internal::phsca(const PhaseMMTN* msg) {
  return *msg->_impl_.phsca_;
}
PhaseMMTN::PhaseMMTN(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseMMTN)
}
PhaseMMTN::PhaseMMTN(const PhaseMMTN& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseMMTN* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsab_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsbc_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , decltype(_impl_.phsca_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::ReadingMMTN(*from._impl_.phsa_);
  }
  if (from._internal_has_phsab()) {
    _this->_impl_.phsab_ = new ::commonmodule::ReadingMMTN(*from._impl_.phsab_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::ReadingMMTN(*from._impl_.phsb_);
  }
  if (from._internal_has_phsbc()) {
    _this->_impl_.phsbc_ = new ::commonmodule::ReadingMMTN(*from._impl_.phsbc_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::ReadingMMTN(*from._impl_.phsc_);
  }
  if (from._internal_has_phsca()) {
    _this->_impl_.phsca_ = new ::commonmodule::ReadingMMTN(*from._impl_.phsca_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseMMTN)
}

inline void PhaseMMTN::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsab_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsbc_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , decltype(_impl_.phsca_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseMMTN::~PhaseMMTN() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseMMTN)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseMMTN::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsab_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsbc_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
  if (this != internal_default_instance()) delete _impl_.phsca_;
}

void PhaseMMTN::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseMMTN::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseMMTN)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsab_ != nullptr) {
    delete _impl_.phsab_;
  }
  _impl_.phsab_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsbc_ != nullptr) {
    delete _impl_.phsbc_;
  }
  _impl_.phsbc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsca_ != nullptr) {
    delete _impl_.phsca_;
  }
  _impl_.phsca_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseMMTN::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ReadingMMTN phsA = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ReadingMMTN phsAB = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsab(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ReadingMMTN phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ReadingMMTN phsBC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsbc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ReadingMMTN phsC = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ReadingMMTN phsCA = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsca(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseMMTN::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseMMTN)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ReadingMMTN phsA = 1;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ReadingMMTN phsAB = 2;
  if (this->_internal_has_phsab()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsab(this),
        _Internal::phsab(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ReadingMMTN phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ReadingMMTN phsBC = 4;
  if (this->_internal_has_phsbc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsbc(this),
        _Internal::phsbc(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ReadingMMTN phsC = 5;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ReadingMMTN phsCA = 6;
  if (this->_internal_has_phsca()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::phsca(this),
        _Internal::phsca(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseMMTN)
  return target;
}

::size_t PhaseMMTN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseMMTN)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ReadingMMTN phsA = 1;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.ReadingMMTN phsAB = 2;
  if (this->_internal_has_phsab()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsab_);
  }

  // .commonmodule.ReadingMMTN phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.ReadingMMTN phsBC = 4;
  if (this->_internal_has_phsbc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsbc_);
  }

  // .commonmodule.ReadingMMTN phsC = 5;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  // .commonmodule.ReadingMMTN phsCA = 6;
  if (this->_internal_has_phsca()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsca_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseMMTN::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseMMTN::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseMMTN::GetClassData() const { return &_class_data_; }


void PhaseMMTN::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseMMTN*>(&to_msg);
  auto& from = static_cast<const PhaseMMTN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseMMTN)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::ReadingMMTN::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsab()) {
    _this->_internal_mutable_phsab()->::commonmodule::ReadingMMTN::MergeFrom(
        from._internal_phsab());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::ReadingMMTN::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsbc()) {
    _this->_internal_mutable_phsbc()->::commonmodule::ReadingMMTN::MergeFrom(
        from._internal_phsbc());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::ReadingMMTN::MergeFrom(
        from._internal_phsc());
  }
  if (from._internal_has_phsca()) {
    _this->_internal_mutable_phsca()->::commonmodule::ReadingMMTN::MergeFrom(
        from._internal_phsca());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseMMTN::CopyFrom(const PhaseMMTN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseMMTN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseMMTN::IsInitialized() const {
  return true;
}

void PhaseMMTN::InternalSwap(PhaseMMTN* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseMMTN, _impl_.phsca_)
      + sizeof(PhaseMMTN::_impl_.phsca_)
      - PROTOBUF_FIELD_OFFSET(PhaseMMTN, _impl_.phsa_)>(
          reinterpret_cast<char*>(&_impl_.phsa_),
          reinterpret_cast<char*>(&other->_impl_.phsa_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseMMTN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[110]);
}
// ===================================================================

class Optional_RecloseActionKind::_Internal {
 public:
};

Optional_RecloseActionKind::Optional_RecloseActionKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_RecloseActionKind)
}
Optional_RecloseActionKind::Optional_RecloseActionKind(const Optional_RecloseActionKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_RecloseActionKind)
}

inline void Optional_RecloseActionKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_RecloseActionKind::~Optional_RecloseActionKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_RecloseActionKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_RecloseActionKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_RecloseActionKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_RecloseActionKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_RecloseActionKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_RecloseActionKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.RecloseActionKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::RecloseActionKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_RecloseActionKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_RecloseActionKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.RecloseActionKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_RecloseActionKind)
  return target;
}

::size_t Optional_RecloseActionKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_RecloseActionKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.RecloseActionKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_RecloseActionKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_RecloseActionKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_RecloseActionKind::GetClassData() const { return &_class_data_; }


void Optional_RecloseActionKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_RecloseActionKind*>(&to_msg);
  auto& from = static_cast<const Optional_RecloseActionKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_RecloseActionKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_RecloseActionKind::CopyFrom(const Optional_RecloseActionKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_RecloseActionKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_RecloseActionKind::IsInitialized() const {
  return true;
}

void Optional_RecloseActionKind::InternalSwap(Optional_RecloseActionKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_RecloseActionKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[111]);
}
// ===================================================================

class PhaseRecloseAction::_Internal {
 public:
  static const ::commonmodule::Optional_RecloseActionKind& phs3(const PhaseRecloseAction* msg);
  static const ::commonmodule::Optional_RecloseActionKind& phsa(const PhaseRecloseAction* msg);
  static const ::commonmodule::Optional_RecloseActionKind& phsb(const PhaseRecloseAction* msg);
  static const ::commonmodule::Optional_RecloseActionKind& phsc(const PhaseRecloseAction* msg);
};

const ::commonmodule::Optional_RecloseActionKind&
PhaseRecloseAction::_Internal::phs3(const PhaseRecloseAction* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::Optional_RecloseActionKind&
PhaseRecloseAction::_Internal::phsa(const PhaseRecloseAction* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::Optional_RecloseActionKind&
PhaseRecloseAction::_Internal::phsb(const PhaseRecloseAction* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::Optional_RecloseActionKind&
PhaseRecloseAction::_Internal::phsc(const PhaseRecloseAction* msg) {
  return *msg->_impl_.phsc_;
}
PhaseRecloseAction::PhaseRecloseAction(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseRecloseAction)
}
PhaseRecloseAction::PhaseRecloseAction(const PhaseRecloseAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseRecloseAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::Optional_RecloseActionKind(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::Optional_RecloseActionKind(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::Optional_RecloseActionKind(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::Optional_RecloseActionKind(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseRecloseAction)
}

inline void PhaseRecloseAction::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseRecloseAction::~PhaseRecloseAction() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseRecloseAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseRecloseAction::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseRecloseAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseRecloseAction::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseRecloseAction)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseRecloseAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Optional_RecloseActionKind phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_RecloseActionKind phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_RecloseActionKind phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_RecloseActionKind phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseRecloseAction::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseRecloseAction)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Optional_RecloseActionKind phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_RecloseActionKind phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_RecloseActionKind phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_RecloseActionKind phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseRecloseAction)
  return target;
}

::size_t PhaseRecloseAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseRecloseAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Optional_RecloseActionKind phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.Optional_RecloseActionKind phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.Optional_RecloseActionKind phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.Optional_RecloseActionKind phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseRecloseAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseRecloseAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseRecloseAction::GetClassData() const { return &_class_data_; }


void PhaseRecloseAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseRecloseAction*>(&to_msg);
  auto& from = static_cast<const PhaseRecloseAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseRecloseAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::Optional_RecloseActionKind::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::Optional_RecloseActionKind::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::Optional_RecloseActionKind::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::Optional_RecloseActionKind::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseRecloseAction::CopyFrom(const PhaseRecloseAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseRecloseAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseRecloseAction::IsInitialized() const {
  return true;
}

void PhaseRecloseAction::InternalSwap(PhaseRecloseAction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseRecloseAction, _impl_.phsc_)
      + sizeof(PhaseRecloseAction::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseRecloseAction, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseRecloseAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[112]);
}
// ===================================================================

class PhaseSPC::_Internal {
 public:
  static const ::commonmodule::ControlSPC& phs3(const PhaseSPC* msg);
  static const ::commonmodule::ControlSPC& phsa(const PhaseSPC* msg);
  static const ::commonmodule::ControlSPC& phsb(const PhaseSPC* msg);
  static const ::commonmodule::ControlSPC& phsc(const PhaseSPC* msg);
};

const ::commonmodule::ControlSPC&
PhaseSPC::_Internal::phs3(const PhaseSPC* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::ControlSPC&
PhaseSPC::_Internal::phsa(const PhaseSPC* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::ControlSPC&
PhaseSPC::_Internal::phsb(const PhaseSPC* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::ControlSPC&
PhaseSPC::_Internal::phsc(const PhaseSPC* msg) {
  return *msg->_impl_.phsc_;
}
PhaseSPC::PhaseSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseSPC)
}
PhaseSPC::PhaseSPC(const PhaseSPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseSPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::ControlSPC(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::ControlSPC(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::ControlSPC(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::ControlSPC(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseSPC)
}

inline void PhaseSPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseSPC::~PhaseSPC() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseSPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseSPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseSPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseSPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseSPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseSPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ControlSPC phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlSPC phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlSPC phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlSPC phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseSPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseSPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ControlSPC phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlSPC phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlSPC phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlSPC phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseSPC)
  return target;
}

::size_t PhaseSPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseSPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ControlSPC phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.ControlSPC phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.ControlSPC phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.ControlSPC phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseSPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseSPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseSPC::GetClassData() const { return &_class_data_; }


void PhaseSPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseSPC*>(&to_msg);
  auto& from = static_cast<const PhaseSPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseSPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::ControlSPC::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::ControlSPC::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::ControlSPC::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::ControlSPC::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseSPC::CopyFrom(const PhaseSPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseSPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseSPC::IsInitialized() const {
  return true;
}

void PhaseSPC::InternalSwap(PhaseSPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseSPC, _impl_.phsc_)
      + sizeof(PhaseSPC::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseSPC, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseSPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[113]);
}
// ===================================================================

class PhaseSPS::_Internal {
 public:
  static const ::commonmodule::StatusSPS& phs3(const PhaseSPS* msg);
  static const ::commonmodule::StatusSPS& phsa(const PhaseSPS* msg);
  static const ::commonmodule::StatusSPS& phsb(const PhaseSPS* msg);
  static const ::commonmodule::StatusSPS& phsc(const PhaseSPS* msg);
};

const ::commonmodule::StatusSPS&
PhaseSPS::_Internal::phs3(const PhaseSPS* msg) {
  return *msg->_impl_.phs3_;
}
const ::commonmodule::StatusSPS&
PhaseSPS::_Internal::phsa(const PhaseSPS* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::StatusSPS&
PhaseSPS::_Internal::phsb(const PhaseSPS* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::StatusSPS&
PhaseSPS::_Internal::phsc(const PhaseSPS* msg) {
  return *msg->_impl_.phsc_;
}
PhaseSPS::PhaseSPS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PhaseSPS)
}
PhaseSPS::PhaseSPS(const PhaseSPS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhaseSPS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phs3()) {
    _this->_impl_.phs3_ = new ::commonmodule::StatusSPS(*from._impl_.phs3_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::StatusSPS(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::StatusSPS(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::StatusSPS(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PhaseSPS)
}

inline void PhaseSPS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.phs3_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PhaseSPS::~PhaseSPS() {
  // @@protoc_insertion_point(destructor:commonmodule.PhaseSPS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhaseSPS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.phs3_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PhaseSPS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhaseSPS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PhaseSPS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhaseSPS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.StatusSPS phs3 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_phs3(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusSPS phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusSPS phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusSPS phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhaseSPS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PhaseSPS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.StatusSPS phs3 = 1;
  if (this->_internal_has_phs3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::phs3(this),
        _Internal::phs3(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusSPS phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusSPS phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusSPS phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PhaseSPS)
  return target;
}

::size_t PhaseSPS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PhaseSPS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.StatusSPS phs3 = 1;
  if (this->_internal_has_phs3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phs3_);
  }

  // .commonmodule.StatusSPS phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.StatusSPS phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.StatusSPS phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhaseSPS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhaseSPS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhaseSPS::GetClassData() const { return &_class_data_; }


void PhaseSPS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhaseSPS*>(&to_msg);
  auto& from = static_cast<const PhaseSPS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PhaseSPS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_phs3()) {
    _this->_internal_mutable_phs3()->::commonmodule::StatusSPS::MergeFrom(
        from._internal_phs3());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::StatusSPS::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::StatusSPS::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::StatusSPS::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhaseSPS::CopyFrom(const PhaseSPS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PhaseSPS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhaseSPS::IsInitialized() const {
  return true;
}

void PhaseSPS::InternalSwap(PhaseSPS* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhaseSPS, _impl_.phsc_)
      + sizeof(PhaseSPS::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PhaseSPS, _impl_.phs3_)>(
          reinterpret_cast<char*>(&_impl_.phs3_),
          reinterpret_cast<char*>(&other->_impl_.phs3_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhaseSPS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[114]);
}
// ===================================================================

class PMG::_Internal {
 public:
  static const ::commonmodule::MV& net(const PMG* msg);
  static const ::commonmodule::MV& phsa(const PMG* msg);
  static const ::commonmodule::MV& phsb(const PMG* msg);
  static const ::commonmodule::MV& phsc(const PMG* msg);
};

const ::commonmodule::MV&
PMG::_Internal::net(const PMG* msg) {
  return *msg->_impl_.net_;
}
const ::commonmodule::MV&
PMG::_Internal::phsa(const PMG* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::MV&
PMG::_Internal::phsb(const PMG* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::MV&
PMG::_Internal::phsc(const PMG* msg) {
  return *msg->_impl_.phsc_;
}
PMG::PMG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.PMG)
}
PMG::PMG(const PMG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PMG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_net()) {
    _this->_impl_.net_ = new ::commonmodule::MV(*from._impl_.net_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::MV(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::MV(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::MV(*from._impl_.phsc_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.PMG)
}

inline void PMG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PMG::~PMG() {
  // @@protoc_insertion_point(destructor:commonmodule.PMG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PMG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.net_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
}

void PMG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PMG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.PMG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.net_ != nullptr) {
    delete _impl_.net_;
  }
  _impl_.net_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PMG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.MV net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_net(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.MV phsA = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.MV phsB = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.MV phsC = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PMG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.PMG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.MV net = 1;
  if (this->_internal_has_net()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::net(this),
        _Internal::net(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.MV phsA = 2;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.MV phsB = 3;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.MV phsC = 4;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.PMG)
  return target;
}

::size_t PMG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.PMG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.MV net = 1;
  if (this->_internal_has_net()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.net_);
  }

  // .commonmodule.MV phsA = 2;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.MV phsB = 3;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.MV phsC = 4;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PMG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PMG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PMG::GetClassData() const { return &_class_data_; }


void PMG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PMG*>(&to_msg);
  auto& from = static_cast<const PMG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.PMG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_net()) {
    _this->_internal_mutable_net()->::commonmodule::MV::MergeFrom(
        from._internal_net());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::MV::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::MV::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::MV::MergeFrom(
        from._internal_phsc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PMG::CopyFrom(const PMG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.PMG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PMG::IsInitialized() const {
  return true;
}

void PMG::InternalSwap(PMG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PMG, _impl_.phsc_)
      + sizeof(PMG::_impl_.phsc_)
      - PROTOBUF_FIELD_OFFSET(PMG, _impl_.net_)>(
          reinterpret_cast<char*>(&_impl_.net_),
          reinterpret_cast<char*>(&other->_impl_.net_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PMG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[115]);
}
// ===================================================================

class RampRate::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::FloatValue& negativereactivepowerkvarpermin(const RampRate* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FloatValue& negativerealpowerkwpermin(const RampRate* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FloatValue& positivereactivepowerkvarpermin(const RampRate* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FloatValue& positiverealpowerkwpermin(const RampRate* msg);
};

const ::PROTOBUF_NAMESPACE_ID::FloatValue&
RampRate::_Internal::negativereactivepowerkvarpermin(const RampRate* msg) {
  return *msg->_impl_.negativereactivepowerkvarpermin_;
}
const ::PROTOBUF_NAMESPACE_ID::FloatValue&
RampRate::_Internal::negativerealpowerkwpermin(const RampRate* msg) {
  return *msg->_impl_.negativerealpowerkwpermin_;
}
const ::PROTOBUF_NAMESPACE_ID::FloatValue&
RampRate::_Internal::positivereactivepowerkvarpermin(const RampRate* msg) {
  return *msg->_impl_.positivereactivepowerkvarpermin_;
}
const ::PROTOBUF_NAMESPACE_ID::FloatValue&
RampRate::_Internal::positiverealpowerkwpermin(const RampRate* msg) {
  return *msg->_impl_.positiverealpowerkwpermin_;
}
void RampRate::clear_negativereactivepowerkvarpermin() {
  if (GetArenaForAllocation() == nullptr && _impl_.negativereactivepowerkvarpermin_ != nullptr) {
    delete _impl_.negativereactivepowerkvarpermin_;
  }
  _impl_.negativereactivepowerkvarpermin_ = nullptr;
}
void RampRate::clear_negativerealpowerkwpermin() {
  if (GetArenaForAllocation() == nullptr && _impl_.negativerealpowerkwpermin_ != nullptr) {
    delete _impl_.negativerealpowerkwpermin_;
  }
  _impl_.negativerealpowerkwpermin_ = nullptr;
}
void RampRate::clear_positivereactivepowerkvarpermin() {
  if (GetArenaForAllocation() == nullptr && _impl_.positivereactivepowerkvarpermin_ != nullptr) {
    delete _impl_.positivereactivepowerkvarpermin_;
  }
  _impl_.positivereactivepowerkvarpermin_ = nullptr;
}
void RampRate::clear_positiverealpowerkwpermin() {
  if (GetArenaForAllocation() == nullptr && _impl_.positiverealpowerkwpermin_ != nullptr) {
    delete _impl_.positiverealpowerkwpermin_;
  }
  _impl_.positiverealpowerkwpermin_ = nullptr;
}
RampRate::RampRate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.RampRate)
}
RampRate::RampRate(const RampRate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RampRate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.negativereactivepowerkvarpermin_){nullptr}
    , decltype(_impl_.negativerealpowerkwpermin_){nullptr}
    , decltype(_impl_.positivereactivepowerkvarpermin_){nullptr}
    , decltype(_impl_.positiverealpowerkwpermin_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_negativereactivepowerkvarpermin()) {
    _this->_impl_.negativereactivepowerkvarpermin_ = new ::PROTOBUF_NAMESPACE_ID::FloatValue(*from._impl_.negativereactivepowerkvarpermin_);
  }
  if (from._internal_has_negativerealpowerkwpermin()) {
    _this->_impl_.negativerealpowerkwpermin_ = new ::PROTOBUF_NAMESPACE_ID::FloatValue(*from._impl_.negativerealpowerkwpermin_);
  }
  if (from._internal_has_positivereactivepowerkvarpermin()) {
    _this->_impl_.positivereactivepowerkvarpermin_ = new ::PROTOBUF_NAMESPACE_ID::FloatValue(*from._impl_.positivereactivepowerkvarpermin_);
  }
  if (from._internal_has_positiverealpowerkwpermin()) {
    _this->_impl_.positiverealpowerkwpermin_ = new ::PROTOBUF_NAMESPACE_ID::FloatValue(*from._impl_.positiverealpowerkwpermin_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.RampRate)
}

inline void RampRate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.negativereactivepowerkvarpermin_){nullptr}
    , decltype(_impl_.negativerealpowerkwpermin_){nullptr}
    , decltype(_impl_.positivereactivepowerkvarpermin_){nullptr}
    , decltype(_impl_.positiverealpowerkwpermin_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RampRate::~RampRate() {
  // @@protoc_insertion_point(destructor:commonmodule.RampRate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RampRate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.negativereactivepowerkvarpermin_;
  if (this != internal_default_instance()) delete _impl_.negativerealpowerkwpermin_;
  if (this != internal_default_instance()) delete _impl_.positivereactivepowerkvarpermin_;
  if (this != internal_default_instance()) delete _impl_.positiverealpowerkwpermin_;
}

void RampRate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RampRate::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.RampRate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.negativereactivepowerkvarpermin_ != nullptr) {
    delete _impl_.negativereactivepowerkvarpermin_;
  }
  _impl_.negativereactivepowerkvarpermin_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.negativerealpowerkwpermin_ != nullptr) {
    delete _impl_.negativerealpowerkwpermin_;
  }
  _impl_.negativerealpowerkwpermin_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.positivereactivepowerkvarpermin_ != nullptr) {
    delete _impl_.positivereactivepowerkvarpermin_;
  }
  _impl_.positivereactivepowerkvarpermin_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.positiverealpowerkwpermin_ != nullptr) {
    delete _impl_.positiverealpowerkwpermin_;
  }
  _impl_.positiverealpowerkwpermin_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RampRate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_negativereactivepowerkvarpermin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_negativerealpowerkwpermin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_positivereactivepowerkvarpermin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_positiverealpowerkwpermin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RampRate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.RampRate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;
  if (this->_internal_has_negativereactivepowerkvarpermin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::negativereactivepowerkvarpermin(this),
        _Internal::negativereactivepowerkvarpermin(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;
  if (this->_internal_has_negativerealpowerkwpermin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::negativerealpowerkwpermin(this),
        _Internal::negativerealpowerkwpermin(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;
  if (this->_internal_has_positivereactivepowerkvarpermin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::positivereactivepowerkvarpermin(this),
        _Internal::positivereactivepowerkvarpermin(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;
  if (this->_internal_has_positiverealpowerkwpermin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::positiverealpowerkwpermin(this),
        _Internal::positiverealpowerkwpermin(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.RampRate)
  return target;
}

::size_t RampRate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.RampRate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;
  if (this->_internal_has_negativereactivepowerkvarpermin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.negativereactivepowerkvarpermin_);
  }

  // .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;
  if (this->_internal_has_negativerealpowerkwpermin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.negativerealpowerkwpermin_);
  }

  // .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;
  if (this->_internal_has_positivereactivepowerkvarpermin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.positivereactivepowerkvarpermin_);
  }

  // .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;
  if (this->_internal_has_positiverealpowerkwpermin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.positiverealpowerkwpermin_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RampRate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RampRate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RampRate::GetClassData() const { return &_class_data_; }


void RampRate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RampRate*>(&to_msg);
  auto& from = static_cast<const RampRate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.RampRate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_negativereactivepowerkvarpermin()) {
    _this->_internal_mutable_negativereactivepowerkvarpermin()->::PROTOBUF_NAMESPACE_ID::FloatValue::MergeFrom(
        from._internal_negativereactivepowerkvarpermin());
  }
  if (from._internal_has_negativerealpowerkwpermin()) {
    _this->_internal_mutable_negativerealpowerkwpermin()->::PROTOBUF_NAMESPACE_ID::FloatValue::MergeFrom(
        from._internal_negativerealpowerkwpermin());
  }
  if (from._internal_has_positivereactivepowerkvarpermin()) {
    _this->_internal_mutable_positivereactivepowerkvarpermin()->::PROTOBUF_NAMESPACE_ID::FloatValue::MergeFrom(
        from._internal_positivereactivepowerkvarpermin());
  }
  if (from._internal_has_positiverealpowerkwpermin()) {
    _this->_internal_mutable_positiverealpowerkwpermin()->::PROTOBUF_NAMESPACE_ID::FloatValue::MergeFrom(
        from._internal_positiverealpowerkwpermin());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RampRate::CopyFrom(const RampRate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.RampRate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RampRate::IsInitialized() const {
  return true;
}

void RampRate::InternalSwap(RampRate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RampRate, _impl_.positiverealpowerkwpermin_)
      + sizeof(RampRate::_impl_.positiverealpowerkwpermin_)
      - PROTOBUF_FIELD_OFFSET(RampRate, _impl_.negativereactivepowerkvarpermin_)>(
          reinterpret_cast<char*>(&_impl_.negativereactivepowerkvarpermin_),
          reinterpret_cast<char*>(&other->_impl_.negativereactivepowerkvarpermin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RampRate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[116]);
}
// ===================================================================

class ReadingMessageInfo::_Internal {
 public:
  static const ::commonmodule::MessageInfo& messageinfo(const ReadingMessageInfo* msg);
};

const ::commonmodule::MessageInfo&
ReadingMessageInfo::_Internal::messageinfo(const ReadingMessageInfo* msg) {
  return *msg->_impl_.messageinfo_;
}
ReadingMessageInfo::ReadingMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ReadingMessageInfo)
}
ReadingMessageInfo::ReadingMessageInfo(const ReadingMessageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadingMessageInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_messageinfo()) {
    _this->_impl_.messageinfo_ = new ::commonmodule::MessageInfo(*from._impl_.messageinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ReadingMessageInfo)
}

inline void ReadingMessageInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadingMessageInfo::~ReadingMessageInfo() {
  // @@protoc_insertion_point(destructor:commonmodule.ReadingMessageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadingMessageInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.messageinfo_;
}

void ReadingMessageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadingMessageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ReadingMessageInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadingMessageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_messageinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReadingMessageInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ReadingMessageInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::messageinfo(this),
        _Internal::messageinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ReadingMessageInfo)
  return target;
}

::size_t ReadingMessageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ReadingMessageInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.messageinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadingMessageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadingMessageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadingMessageInfo::GetClassData() const { return &_class_data_; }


void ReadingMessageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadingMessageInfo*>(&to_msg);
  auto& from = static_cast<const ReadingMessageInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ReadingMessageInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_messageinfo()) {
    _this->_internal_mutable_messageinfo()->::commonmodule::MessageInfo::MergeFrom(
        from._internal_messageinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadingMessageInfo::CopyFrom(const ReadingMessageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ReadingMessageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadingMessageInfo::IsInitialized() const {
  return true;
}

void ReadingMessageInfo::InternalSwap(ReadingMessageInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.messageinfo_, other->_impl_.messageinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadingMessageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[117]);
}
// ===================================================================

class ReadingMMTR::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& dmdvah(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& dmdvarh(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& dmdwh(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& supvah(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& supvarh(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& supwh(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& totvah(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& totvarh(const ReadingMMTR* msg);
  static const ::commonmodule::BCR& totwh(const ReadingMMTR* msg);
};

const ::commonmodule::LogicalNode&
ReadingMMTR::_Internal::logicalnode(const ReadingMMTR* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::dmdvah(const ReadingMMTR* msg) {
  return *msg->_impl_.dmdvah_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::dmdvarh(const ReadingMMTR* msg) {
  return *msg->_impl_.dmdvarh_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::dmdwh(const ReadingMMTR* msg) {
  return *msg->_impl_.dmdwh_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::supvah(const ReadingMMTR* msg) {
  return *msg->_impl_.supvah_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::supvarh(const ReadingMMTR* msg) {
  return *msg->_impl_.supvarh_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::supwh(const ReadingMMTR* msg) {
  return *msg->_impl_.supwh_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::totvah(const ReadingMMTR* msg) {
  return *msg->_impl_.totvah_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::totvarh(const ReadingMMTR* msg) {
  return *msg->_impl_.totvarh_;
}
const ::commonmodule::BCR&
ReadingMMTR::_Internal::totwh(const ReadingMMTR* msg) {
  return *msg->_impl_.totwh_;
}
ReadingMMTR::ReadingMMTR(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ReadingMMTR)
}
ReadingMMTR::ReadingMMTR(const ReadingMMTR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadingMMTR* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.dmdvah_){nullptr}
    , decltype(_impl_.dmdvarh_){nullptr}
    , decltype(_impl_.dmdwh_){nullptr}
    , decltype(_impl_.supvah_){nullptr}
    , decltype(_impl_.supvarh_){nullptr}
    , decltype(_impl_.supwh_){nullptr}
    , decltype(_impl_.totvah_){nullptr}
    , decltype(_impl_.totvarh_){nullptr}
    , decltype(_impl_.totwh_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_dmdvah()) {
    _this->_impl_.dmdvah_ = new ::commonmodule::BCR(*from._impl_.dmdvah_);
  }
  if (from._internal_has_dmdvarh()) {
    _this->_impl_.dmdvarh_ = new ::commonmodule::BCR(*from._impl_.dmdvarh_);
  }
  if (from._internal_has_dmdwh()) {
    _this->_impl_.dmdwh_ = new ::commonmodule::BCR(*from._impl_.dmdwh_);
  }
  if (from._internal_has_supvah()) {
    _this->_impl_.supvah_ = new ::commonmodule::BCR(*from._impl_.supvah_);
  }
  if (from._internal_has_supvarh()) {
    _this->_impl_.supvarh_ = new ::commonmodule::BCR(*from._impl_.supvarh_);
  }
  if (from._internal_has_supwh()) {
    _this->_impl_.supwh_ = new ::commonmodule::BCR(*from._impl_.supwh_);
  }
  if (from._internal_has_totvah()) {
    _this->_impl_.totvah_ = new ::commonmodule::BCR(*from._impl_.totvah_);
  }
  if (from._internal_has_totvarh()) {
    _this->_impl_.totvarh_ = new ::commonmodule::BCR(*from._impl_.totvarh_);
  }
  if (from._internal_has_totwh()) {
    _this->_impl_.totwh_ = new ::commonmodule::BCR(*from._impl_.totwh_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ReadingMMTR)
}

inline void ReadingMMTR::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.dmdvah_){nullptr}
    , decltype(_impl_.dmdvarh_){nullptr}
    , decltype(_impl_.dmdwh_){nullptr}
    , decltype(_impl_.supvah_){nullptr}
    , decltype(_impl_.supvarh_){nullptr}
    , decltype(_impl_.supwh_){nullptr}
    , decltype(_impl_.totvah_){nullptr}
    , decltype(_impl_.totvarh_){nullptr}
    , decltype(_impl_.totwh_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadingMMTR::~ReadingMMTR() {
  // @@protoc_insertion_point(destructor:commonmodule.ReadingMMTR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadingMMTR::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.dmdvah_;
  if (this != internal_default_instance()) delete _impl_.dmdvarh_;
  if (this != internal_default_instance()) delete _impl_.dmdwh_;
  if (this != internal_default_instance()) delete _impl_.supvah_;
  if (this != internal_default_instance()) delete _impl_.supvarh_;
  if (this != internal_default_instance()) delete _impl_.supwh_;
  if (this != internal_default_instance()) delete _impl_.totvah_;
  if (this != internal_default_instance()) delete _impl_.totvarh_;
  if (this != internal_default_instance()) delete _impl_.totwh_;
}

void ReadingMMTR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadingMMTR::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ReadingMMTR)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvah_ != nullptr) {
    delete _impl_.dmdvah_;
  }
  _impl_.dmdvah_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvarh_ != nullptr) {
    delete _impl_.dmdvarh_;
  }
  _impl_.dmdvarh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dmdwh_ != nullptr) {
    delete _impl_.dmdwh_;
  }
  _impl_.dmdwh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.supvah_ != nullptr) {
    delete _impl_.supvah_;
  }
  _impl_.supvah_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.supvarh_ != nullptr) {
    delete _impl_.supvarh_;
  }
  _impl_.supvarh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.supwh_ != nullptr) {
    delete _impl_.supwh_;
  }
  _impl_.supwh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.totvah_ != nullptr) {
    delete _impl_.totvah_;
  }
  _impl_.totvah_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.totvarh_ != nullptr) {
    delete _impl_.totvarh_;
  }
  _impl_.totvarh_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.totwh_ != nullptr) {
    delete _impl_.totwh_;
  }
  _impl_.totwh_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadingMMTR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR DmdVAh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmdvah(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR DmdVArh = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmdvarh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR DmdWh = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmdwh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR SupVAh = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_supvah(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR SupVArh = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_supvarh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR SupWh = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_supwh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR TotVAh = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_totvah(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR TotVArh = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_totvarh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.BCR TotWh = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_totwh(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReadingMMTR::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ReadingMMTR)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR DmdVAh = 2;
  if (this->_internal_has_dmdvah()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dmdvah(this),
        _Internal::dmdvah(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR DmdVArh = 3;
  if (this->_internal_has_dmdvarh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dmdvarh(this),
        _Internal::dmdvarh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR DmdWh = 4;
  if (this->_internal_has_dmdwh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::dmdwh(this),
        _Internal::dmdwh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR SupVAh = 5;
  if (this->_internal_has_supvah()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::supvah(this),
        _Internal::supvah(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR SupVArh = 6;
  if (this->_internal_has_supvarh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::supvarh(this),
        _Internal::supvarh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR SupWh = 7;
  if (this->_internal_has_supwh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::supwh(this),
        _Internal::supwh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR TotVAh = 8;
  if (this->_internal_has_totvah()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::totvah(this),
        _Internal::totvah(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR TotVArh = 9;
  if (this->_internal_has_totvarh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::totvarh(this),
        _Internal::totvarh(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.BCR TotWh = 10;
  if (this->_internal_has_totwh()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::totwh(this),
        _Internal::totwh(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ReadingMMTR)
  return target;
}

::size_t ReadingMMTR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ReadingMMTR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.BCR DmdVAh = 2;
  if (this->_internal_has_dmdvah()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dmdvah_);
  }

  // .commonmodule.BCR DmdVArh = 3;
  if (this->_internal_has_dmdvarh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dmdvarh_);
  }

  // .commonmodule.BCR DmdWh = 4;
  if (this->_internal_has_dmdwh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dmdwh_);
  }

  // .commonmodule.BCR SupVAh = 5;
  if (this->_internal_has_supvah()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.supvah_);
  }

  // .commonmodule.BCR SupVArh = 6;
  if (this->_internal_has_supvarh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.supvarh_);
  }

  // .commonmodule.BCR SupWh = 7;
  if (this->_internal_has_supwh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.supwh_);
  }

  // .commonmodule.BCR TotVAh = 8;
  if (this->_internal_has_totvah()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.totvah_);
  }

  // .commonmodule.BCR TotVArh = 9;
  if (this->_internal_has_totvarh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.totvarh_);
  }

  // .commonmodule.BCR TotWh = 10;
  if (this->_internal_has_totwh()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.totwh_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadingMMTR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadingMMTR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadingMMTR::GetClassData() const { return &_class_data_; }


void ReadingMMTR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadingMMTR*>(&to_msg);
  auto& from = static_cast<const ReadingMMTR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ReadingMMTR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_dmdvah()) {
    _this->_internal_mutable_dmdvah()->::commonmodule::BCR::MergeFrom(
        from._internal_dmdvah());
  }
  if (from._internal_has_dmdvarh()) {
    _this->_internal_mutable_dmdvarh()->::commonmodule::BCR::MergeFrom(
        from._internal_dmdvarh());
  }
  if (from._internal_has_dmdwh()) {
    _this->_internal_mutable_dmdwh()->::commonmodule::BCR::MergeFrom(
        from._internal_dmdwh());
  }
  if (from._internal_has_supvah()) {
    _this->_internal_mutable_supvah()->::commonmodule::BCR::MergeFrom(
        from._internal_supvah());
  }
  if (from._internal_has_supvarh()) {
    _this->_internal_mutable_supvarh()->::commonmodule::BCR::MergeFrom(
        from._internal_supvarh());
  }
  if (from._internal_has_supwh()) {
    _this->_internal_mutable_supwh()->::commonmodule::BCR::MergeFrom(
        from._internal_supwh());
  }
  if (from._internal_has_totvah()) {
    _this->_internal_mutable_totvah()->::commonmodule::BCR::MergeFrom(
        from._internal_totvah());
  }
  if (from._internal_has_totvarh()) {
    _this->_internal_mutable_totvarh()->::commonmodule::BCR::MergeFrom(
        from._internal_totvarh());
  }
  if (from._internal_has_totwh()) {
    _this->_internal_mutable_totwh()->::commonmodule::BCR::MergeFrom(
        from._internal_totwh());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadingMMTR::CopyFrom(const ReadingMMTR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ReadingMMTR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadingMMTR::IsInitialized() const {
  return true;
}

void ReadingMMTR::InternalSwap(ReadingMMTR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReadingMMTR, _impl_.totwh_)
      + sizeof(ReadingMMTR::_impl_.totwh_)
      - PROTOBUF_FIELD_OFFSET(ReadingMMTR, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadingMMTR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[118]);
}
// ===================================================================

class WYE::_Internal {
 public:
  static const ::commonmodule::CMV& net(const WYE* msg);
  static const ::commonmodule::CMV& neut(const WYE* msg);
  static const ::commonmodule::CMV& phsa(const WYE* msg);
  static const ::commonmodule::CMV& phsb(const WYE* msg);
  static const ::commonmodule::CMV& phsc(const WYE* msg);
  static const ::commonmodule::CMV& res(const WYE* msg);
};

const ::commonmodule::CMV&
WYE::_Internal::net(const WYE* msg) {
  return *msg->_impl_.net_;
}
const ::commonmodule::CMV&
WYE::_Internal::neut(const WYE* msg) {
  return *msg->_impl_.neut_;
}
const ::commonmodule::CMV&
WYE::_Internal::phsa(const WYE* msg) {
  return *msg->_impl_.phsa_;
}
const ::commonmodule::CMV&
WYE::_Internal::phsb(const WYE* msg) {
  return *msg->_impl_.phsb_;
}
const ::commonmodule::CMV&
WYE::_Internal::phsc(const WYE* msg) {
  return *msg->_impl_.phsc_;
}
const ::commonmodule::CMV&
WYE::_Internal::res(const WYE* msg) {
  return *msg->_impl_.res_;
}
WYE::WYE(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.WYE)
}
WYE::WYE(const WYE& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WYE* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){nullptr}
    , decltype(_impl_.neut_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , decltype(_impl_.res_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_net()) {
    _this->_impl_.net_ = new ::commonmodule::CMV(*from._impl_.net_);
  }
  if (from._internal_has_neut()) {
    _this->_impl_.neut_ = new ::commonmodule::CMV(*from._impl_.neut_);
  }
  if (from._internal_has_phsa()) {
    _this->_impl_.phsa_ = new ::commonmodule::CMV(*from._impl_.phsa_);
  }
  if (from._internal_has_phsb()) {
    _this->_impl_.phsb_ = new ::commonmodule::CMV(*from._impl_.phsb_);
  }
  if (from._internal_has_phsc()) {
    _this->_impl_.phsc_ = new ::commonmodule::CMV(*from._impl_.phsc_);
  }
  if (from._internal_has_res()) {
    _this->_impl_.res_ = new ::commonmodule::CMV(*from._impl_.res_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.WYE)
}

inline void WYE::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){nullptr}
    , decltype(_impl_.neut_){nullptr}
    , decltype(_impl_.phsa_){nullptr}
    , decltype(_impl_.phsb_){nullptr}
    , decltype(_impl_.phsc_){nullptr}
    , decltype(_impl_.res_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WYE::~WYE() {
  // @@protoc_insertion_point(destructor:commonmodule.WYE)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WYE::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.net_;
  if (this != internal_default_instance()) delete _impl_.neut_;
  if (this != internal_default_instance()) delete _impl_.phsa_;
  if (this != internal_default_instance()) delete _impl_.phsb_;
  if (this != internal_default_instance()) delete _impl_.phsc_;
  if (this != internal_default_instance()) delete _impl_.res_;
}

void WYE::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WYE::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.WYE)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.net_ != nullptr) {
    delete _impl_.net_;
  }
  _impl_.net_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.neut_ != nullptr) {
    delete _impl_.neut_;
  }
  _impl_.neut_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.res_ != nullptr) {
    delete _impl_.res_;
  }
  _impl_.res_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WYE::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.CMV net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_net(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.CMV neut = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_neut(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.CMV phsA = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsa(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.CMV phsB = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsb(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.CMV phsC = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_phsc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.CMV res = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_res(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WYE::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.WYE)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.CMV net = 1;
  if (this->_internal_has_net()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::net(this),
        _Internal::net(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.CMV neut = 2;
  if (this->_internal_has_neut()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::neut(this),
        _Internal::neut(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.CMV phsA = 3;
  if (this->_internal_has_phsa()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::phsa(this),
        _Internal::phsa(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.CMV phsB = 4;
  if (this->_internal_has_phsb()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phsb(this),
        _Internal::phsb(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.CMV phsC = 5;
  if (this->_internal_has_phsc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::phsc(this),
        _Internal::phsc(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.CMV res = 6;
  if (this->_internal_has_res()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::res(this),
        _Internal::res(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.WYE)
  return target;
}

::size_t WYE::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.WYE)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.CMV net = 1;
  if (this->_internal_has_net()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.net_);
  }

  // .commonmodule.CMV neut = 2;
  if (this->_internal_has_neut()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.neut_);
  }

  // .commonmodule.CMV phsA = 3;
  if (this->_internal_has_phsa()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsa_);
  }

  // .commonmodule.CMV phsB = 4;
  if (this->_internal_has_phsb()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsb_);
  }

  // .commonmodule.CMV phsC = 5;
  if (this->_internal_has_phsc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phsc_);
  }

  // .commonmodule.CMV res = 6;
  if (this->_internal_has_res()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.res_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WYE::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WYE::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WYE::GetClassData() const { return &_class_data_; }


void WYE::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WYE*>(&to_msg);
  auto& from = static_cast<const WYE&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.WYE)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_net()) {
    _this->_internal_mutable_net()->::commonmodule::CMV::MergeFrom(
        from._internal_net());
  }
  if (from._internal_has_neut()) {
    _this->_internal_mutable_neut()->::commonmodule::CMV::MergeFrom(
        from._internal_neut());
  }
  if (from._internal_has_phsa()) {
    _this->_internal_mutable_phsa()->::commonmodule::CMV::MergeFrom(
        from._internal_phsa());
  }
  if (from._internal_has_phsb()) {
    _this->_internal_mutable_phsb()->::commonmodule::CMV::MergeFrom(
        from._internal_phsb());
  }
  if (from._internal_has_phsc()) {
    _this->_internal_mutable_phsc()->::commonmodule::CMV::MergeFrom(
        from._internal_phsc());
  }
  if (from._internal_has_res()) {
    _this->_internal_mutable_res()->::commonmodule::CMV::MergeFrom(
        from._internal_res());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WYE::CopyFrom(const WYE& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.WYE)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WYE::IsInitialized() const {
  return true;
}

void WYE::InternalSwap(WYE* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WYE, _impl_.res_)
      + sizeof(WYE::_impl_.res_)
      - PROTOBUF_FIELD_OFFSET(WYE, _impl_.net_)>(
          reinterpret_cast<char*>(&_impl_.net_),
          reinterpret_cast<char*>(&other->_impl_.net_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WYE::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[119]);
}
// ===================================================================

class ReadingMMXU::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const ReadingMMXU* msg);
  static const ::commonmodule::WYE& a(const ReadingMMXU* msg);
  static const ::commonmodule::ENG_CalcMethodKind& clcmth(const ReadingMMXU* msg);
  static const ::commonmodule::MV& hz(const ReadingMMXU* msg);
  static const ::commonmodule::WYE& pf(const ReadingMMXU* msg);
  static const ::commonmodule::ENG_PFSignKind& pfsign(const ReadingMMXU* msg);
  static const ::commonmodule::WYE& phv(const ReadingMMXU* msg);
  static const ::commonmodule::DEL& ppv(const ReadingMMXU* msg);
  static const ::commonmodule::WYE& va(const ReadingMMXU* msg);
  static const ::commonmodule::WYE& var(const ReadingMMXU* msg);
  static const ::commonmodule::WYE& w(const ReadingMMXU* msg);
};

const ::commonmodule::LogicalNode&
ReadingMMXU::_Internal::logicalnode(const ReadingMMXU* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::WYE&
ReadingMMXU::_Internal::a(const ReadingMMXU* msg) {
  return *msg->_impl_.a_;
}
const ::commonmodule::ENG_CalcMethodKind&
ReadingMMXU::_Internal::clcmth(const ReadingMMXU* msg) {
  return *msg->_impl_.clcmth_;
}
const ::commonmodule::MV&
ReadingMMXU::_Internal::hz(const ReadingMMXU* msg) {
  return *msg->_impl_.hz_;
}
const ::commonmodule::WYE&
ReadingMMXU::_Internal::pf(const ReadingMMXU* msg) {
  return *msg->_impl_.pf_;
}
const ::commonmodule::ENG_PFSignKind&
ReadingMMXU::_Internal::pfsign(const ReadingMMXU* msg) {
  return *msg->_impl_.pfsign_;
}
const ::commonmodule::WYE&
ReadingMMXU::_Internal::phv(const ReadingMMXU* msg) {
  return *msg->_impl_.phv_;
}
const ::commonmodule::DEL&
ReadingMMXU::_Internal::ppv(const ReadingMMXU* msg) {
  return *msg->_impl_.ppv_;
}
const ::commonmodule::WYE&
ReadingMMXU::_Internal::va(const ReadingMMXU* msg) {
  return *msg->_impl_.va_;
}
const ::commonmodule::WYE&
ReadingMMXU::_Internal::var(const ReadingMMXU* msg) {
  return *msg->_impl_.var_;
}
const ::commonmodule::WYE&
ReadingMMXU::_Internal::w(const ReadingMMXU* msg) {
  return *msg->_impl_.w_;
}
ReadingMMXU::ReadingMMXU(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.ReadingMMXU)
}
ReadingMMXU::ReadingMMXU(const ReadingMMXU& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadingMMXU* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.a_){nullptr}
    , decltype(_impl_.clcmth_){nullptr}
    , decltype(_impl_.hz_){nullptr}
    , decltype(_impl_.pf_){nullptr}
    , decltype(_impl_.pfsign_){nullptr}
    , decltype(_impl_.phv_){nullptr}
    , decltype(_impl_.ppv_){nullptr}
    , decltype(_impl_.va_){nullptr}
    , decltype(_impl_.var_){nullptr}
    , decltype(_impl_.w_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_a()) {
    _this->_impl_.a_ = new ::commonmodule::WYE(*from._impl_.a_);
  }
  if (from._internal_has_clcmth()) {
    _this->_impl_.clcmth_ = new ::commonmodule::ENG_CalcMethodKind(*from._impl_.clcmth_);
  }
  if (from._internal_has_hz()) {
    _this->_impl_.hz_ = new ::commonmodule::MV(*from._impl_.hz_);
  }
  if (from._internal_has_pf()) {
    _this->_impl_.pf_ = new ::commonmodule::WYE(*from._impl_.pf_);
  }
  if (from._internal_has_pfsign()) {
    _this->_impl_.pfsign_ = new ::commonmodule::ENG_PFSignKind(*from._impl_.pfsign_);
  }
  if (from._internal_has_phv()) {
    _this->_impl_.phv_ = new ::commonmodule::WYE(*from._impl_.phv_);
  }
  if (from._internal_has_ppv()) {
    _this->_impl_.ppv_ = new ::commonmodule::DEL(*from._impl_.ppv_);
  }
  if (from._internal_has_va()) {
    _this->_impl_.va_ = new ::commonmodule::WYE(*from._impl_.va_);
  }
  if (from._internal_has_var()) {
    _this->_impl_.var_ = new ::commonmodule::WYE(*from._impl_.var_);
  }
  if (from._internal_has_w()) {
    _this->_impl_.w_ = new ::commonmodule::WYE(*from._impl_.w_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.ReadingMMXU)
}

inline void ReadingMMXU::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.a_){nullptr}
    , decltype(_impl_.clcmth_){nullptr}
    , decltype(_impl_.hz_){nullptr}
    , decltype(_impl_.pf_){nullptr}
    , decltype(_impl_.pfsign_){nullptr}
    , decltype(_impl_.phv_){nullptr}
    , decltype(_impl_.ppv_){nullptr}
    , decltype(_impl_.va_){nullptr}
    , decltype(_impl_.var_){nullptr}
    , decltype(_impl_.w_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadingMMXU::~ReadingMMXU() {
  // @@protoc_insertion_point(destructor:commonmodule.ReadingMMXU)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadingMMXU::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.a_;
  if (this != internal_default_instance()) delete _impl_.clcmth_;
  if (this != internal_default_instance()) delete _impl_.hz_;
  if (this != internal_default_instance()) delete _impl_.pf_;
  if (this != internal_default_instance()) delete _impl_.pfsign_;
  if (this != internal_default_instance()) delete _impl_.phv_;
  if (this != internal_default_instance()) delete _impl_.ppv_;
  if (this != internal_default_instance()) delete _impl_.va_;
  if (this != internal_default_instance()) delete _impl_.var_;
  if (this != internal_default_instance()) delete _impl_.w_;
}

void ReadingMMXU::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadingMMXU::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.ReadingMMXU)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.a_ != nullptr) {
    delete _impl_.a_;
  }
  _impl_.a_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.clcmth_ != nullptr) {
    delete _impl_.clcmth_;
  }
  _impl_.clcmth_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.hz_ != nullptr) {
    delete _impl_.hz_;
  }
  _impl_.hz_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pf_ != nullptr) {
    delete _impl_.pf_;
  }
  _impl_.pf_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pfsign_ != nullptr) {
    delete _impl_.pfsign_;
  }
  _impl_.pfsign_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phv_ != nullptr) {
    delete _impl_.phv_;
  }
  _impl_.phv_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.ppv_ != nullptr) {
    delete _impl_.ppv_;
  }
  _impl_.ppv_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.va_ != nullptr) {
    delete _impl_.va_;
  }
  _impl_.va_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.var_ != nullptr) {
    delete _impl_.var_;
  }
  _impl_.var_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.w_ != nullptr) {
    delete _impl_.w_;
  }
  _impl_.w_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadingMMXU::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.WYE A = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_a(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ENG_CalcMethodKind ClcMth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_clcmth(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.MV Hz = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_hz(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.WYE PF = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_pf(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ENG_PFSignKind PFSign = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pfsign(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.WYE PhV = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_phv(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.DEL PPV = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_ppv(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.WYE VA = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_va(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.WYE VAr = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_var(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.WYE W = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_w(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReadingMMXU::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.ReadingMMXU)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.WYE A = 2;
  if (this->_internal_has_a()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::a(this),
        _Internal::a(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ENG_CalcMethodKind ClcMth = 3;
  if (this->_internal_has_clcmth()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::clcmth(this),
        _Internal::clcmth(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.MV Hz = 4;
  if (this->_internal_has_hz()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::hz(this),
        _Internal::hz(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.WYE PF = 5;
  if (this->_internal_has_pf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::pf(this),
        _Internal::pf(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ENG_PFSignKind PFSign = 6;
  if (this->_internal_has_pfsign()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::pfsign(this),
        _Internal::pfsign(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.WYE PhV = 7;
  if (this->_internal_has_phv()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::phv(this),
        _Internal::phv(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.DEL PPV = 8;
  if (this->_internal_has_ppv()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::ppv(this),
        _Internal::ppv(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.WYE VA = 9;
  if (this->_internal_has_va()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::va(this),
        _Internal::va(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.WYE VAr = 10;
  if (this->_internal_has_var()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::var(this),
        _Internal::var(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.WYE W = 11;
  if (this->_internal_has_w()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::w(this),
        _Internal::w(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.ReadingMMXU)
  return target;
}

::size_t ReadingMMXU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.ReadingMMXU)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.WYE A = 2;
  if (this->_internal_has_a()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.a_);
  }

  // .commonmodule.ENG_CalcMethodKind ClcMth = 3;
  if (this->_internal_has_clcmth()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.clcmth_);
  }

  // .commonmodule.MV Hz = 4;
  if (this->_internal_has_hz()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.hz_);
  }

  // .commonmodule.WYE PF = 5;
  if (this->_internal_has_pf()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pf_);
  }

  // .commonmodule.ENG_PFSignKind PFSign = 6;
  if (this->_internal_has_pfsign()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pfsign_);
  }

  // .commonmodule.WYE PhV = 7;
  if (this->_internal_has_phv()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phv_);
  }

  // .commonmodule.DEL PPV = 8;
  if (this->_internal_has_ppv()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ppv_);
  }

  // .commonmodule.WYE VA = 9;
  if (this->_internal_has_va()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.va_);
  }

  // .commonmodule.WYE VAr = 10;
  if (this->_internal_has_var()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.var_);
  }

  // .commonmodule.WYE W = 11;
  if (this->_internal_has_w()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.w_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadingMMXU::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadingMMXU::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadingMMXU::GetClassData() const { return &_class_data_; }


void ReadingMMXU::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadingMMXU*>(&to_msg);
  auto& from = static_cast<const ReadingMMXU&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.ReadingMMXU)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_a()) {
    _this->_internal_mutable_a()->::commonmodule::WYE::MergeFrom(
        from._internal_a());
  }
  if (from._internal_has_clcmth()) {
    _this->_internal_mutable_clcmth()->::commonmodule::ENG_CalcMethodKind::MergeFrom(
        from._internal_clcmth());
  }
  if (from._internal_has_hz()) {
    _this->_internal_mutable_hz()->::commonmodule::MV::MergeFrom(
        from._internal_hz());
  }
  if (from._internal_has_pf()) {
    _this->_internal_mutable_pf()->::commonmodule::WYE::MergeFrom(
        from._internal_pf());
  }
  if (from._internal_has_pfsign()) {
    _this->_internal_mutable_pfsign()->::commonmodule::ENG_PFSignKind::MergeFrom(
        from._internal_pfsign());
  }
  if (from._internal_has_phv()) {
    _this->_internal_mutable_phv()->::commonmodule::WYE::MergeFrom(
        from._internal_phv());
  }
  if (from._internal_has_ppv()) {
    _this->_internal_mutable_ppv()->::commonmodule::DEL::MergeFrom(
        from._internal_ppv());
  }
  if (from._internal_has_va()) {
    _this->_internal_mutable_va()->::commonmodule::WYE::MergeFrom(
        from._internal_va());
  }
  if (from._internal_has_var()) {
    _this->_internal_mutable_var()->::commonmodule::WYE::MergeFrom(
        from._internal_var());
  }
  if (from._internal_has_w()) {
    _this->_internal_mutable_w()->::commonmodule::WYE::MergeFrom(
        from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadingMMXU::CopyFrom(const ReadingMMXU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.ReadingMMXU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadingMMXU::IsInitialized() const {
  return true;
}

void ReadingMMXU::InternalSwap(ReadingMMXU* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReadingMMXU, _impl_.w_)
      + sizeof(ReadingMMXU::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(ReadingMMXU, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadingMMXU::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[120]);
}
// ===================================================================

class SourceCapabilityConfiguration::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& amax(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& vamax(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& varmaxabs(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& varmaxinj(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& vmax(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& vmin(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& vnom(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& wmax(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& wovrext(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& wovrextpf(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& wundext(const SourceCapabilityConfiguration* msg);
  static const ::commonmodule::ASG& wundextpf(const SourceCapabilityConfiguration* msg);
};

const ::commonmodule::LogicalNode&
SourceCapabilityConfiguration::_Internal::logicalnode(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::amax(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.amax_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::vamax(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.vamax_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::varmaxabs(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.varmaxabs_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::varmaxinj(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.varmaxinj_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::vmax(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.vmax_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::vmin(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.vmin_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::vnom(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.vnom_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::wmax(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.wmax_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::wovrext(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.wovrext_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::wovrextpf(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.wovrextpf_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::wundext(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.wundext_;
}
const ::commonmodule::ASG&
SourceCapabilityConfiguration::_Internal::wundextpf(const SourceCapabilityConfiguration* msg) {
  return *msg->_impl_.wundextpf_;
}
SourceCapabilityConfiguration::SourceCapabilityConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.SourceCapabilityConfiguration)
}
SourceCapabilityConfiguration::SourceCapabilityConfiguration(const SourceCapabilityConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SourceCapabilityConfiguration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.amax_){nullptr}
    , decltype(_impl_.vamax_){nullptr}
    , decltype(_impl_.varmaxabs_){nullptr}
    , decltype(_impl_.varmaxinj_){nullptr}
    , decltype(_impl_.vmax_){nullptr}
    , decltype(_impl_.vmin_){nullptr}
    , decltype(_impl_.vnom_){nullptr}
    , decltype(_impl_.wmax_){nullptr}
    , decltype(_impl_.wovrext_){nullptr}
    , decltype(_impl_.wovrextpf_){nullptr}
    , decltype(_impl_.wundext_){nullptr}
    , decltype(_impl_.wundextpf_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_amax()) {
    _this->_impl_.amax_ = new ::commonmodule::ASG(*from._impl_.amax_);
  }
  if (from._internal_has_vamax()) {
    _this->_impl_.vamax_ = new ::commonmodule::ASG(*from._impl_.vamax_);
  }
  if (from._internal_has_varmaxabs()) {
    _this->_impl_.varmaxabs_ = new ::commonmodule::ASG(*from._impl_.varmaxabs_);
  }
  if (from._internal_has_varmaxinj()) {
    _this->_impl_.varmaxinj_ = new ::commonmodule::ASG(*from._impl_.varmaxinj_);
  }
  if (from._internal_has_vmax()) {
    _this->_impl_.vmax_ = new ::commonmodule::ASG(*from._impl_.vmax_);
  }
  if (from._internal_has_vmin()) {
    _this->_impl_.vmin_ = new ::commonmodule::ASG(*from._impl_.vmin_);
  }
  if (from._internal_has_vnom()) {
    _this->_impl_.vnom_ = new ::commonmodule::ASG(*from._impl_.vnom_);
  }
  if (from._internal_has_wmax()) {
    _this->_impl_.wmax_ = new ::commonmodule::ASG(*from._impl_.wmax_);
  }
  if (from._internal_has_wovrext()) {
    _this->_impl_.wovrext_ = new ::commonmodule::ASG(*from._impl_.wovrext_);
  }
  if (from._internal_has_wovrextpf()) {
    _this->_impl_.wovrextpf_ = new ::commonmodule::ASG(*from._impl_.wovrextpf_);
  }
  if (from._internal_has_wundext()) {
    _this->_impl_.wundext_ = new ::commonmodule::ASG(*from._impl_.wundext_);
  }
  if (from._internal_has_wundextpf()) {
    _this->_impl_.wundextpf_ = new ::commonmodule::ASG(*from._impl_.wundextpf_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.SourceCapabilityConfiguration)
}

inline void SourceCapabilityConfiguration::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.amax_){nullptr}
    , decltype(_impl_.vamax_){nullptr}
    , decltype(_impl_.varmaxabs_){nullptr}
    , decltype(_impl_.varmaxinj_){nullptr}
    , decltype(_impl_.vmax_){nullptr}
    , decltype(_impl_.vmin_){nullptr}
    , decltype(_impl_.vnom_){nullptr}
    , decltype(_impl_.wmax_){nullptr}
    , decltype(_impl_.wovrext_){nullptr}
    , decltype(_impl_.wovrextpf_){nullptr}
    , decltype(_impl_.wundext_){nullptr}
    , decltype(_impl_.wundextpf_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SourceCapabilityConfiguration::~SourceCapabilityConfiguration() {
  // @@protoc_insertion_point(destructor:commonmodule.SourceCapabilityConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SourceCapabilityConfiguration::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.amax_;
  if (this != internal_default_instance()) delete _impl_.vamax_;
  if (this != internal_default_instance()) delete _impl_.varmaxabs_;
  if (this != internal_default_instance()) delete _impl_.varmaxinj_;
  if (this != internal_default_instance()) delete _impl_.vmax_;
  if (this != internal_default_instance()) delete _impl_.vmin_;
  if (this != internal_default_instance()) delete _impl_.vnom_;
  if (this != internal_default_instance()) delete _impl_.wmax_;
  if (this != internal_default_instance()) delete _impl_.wovrext_;
  if (this != internal_default_instance()) delete _impl_.wovrextpf_;
  if (this != internal_default_instance()) delete _impl_.wundext_;
  if (this != internal_default_instance()) delete _impl_.wundextpf_;
}

void SourceCapabilityConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SourceCapabilityConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.SourceCapabilityConfiguration)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.amax_ != nullptr) {
    delete _impl_.amax_;
  }
  _impl_.amax_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vamax_ != nullptr) {
    delete _impl_.vamax_;
  }
  _impl_.vamax_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxabs_ != nullptr) {
    delete _impl_.varmaxabs_;
  }
  _impl_.varmaxabs_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxinj_ != nullptr) {
    delete _impl_.varmaxinj_;
  }
  _impl_.varmaxinj_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vmax_ != nullptr) {
    delete _impl_.vmax_;
  }
  _impl_.vmax_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vmin_ != nullptr) {
    delete _impl_.vmin_;
  }
  _impl_.vmin_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vnom_ != nullptr) {
    delete _impl_.vnom_;
  }
  _impl_.vnom_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wmax_ != nullptr) {
    delete _impl_.wmax_;
  }
  _impl_.wmax_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wovrext_ != nullptr) {
    delete _impl_.wovrext_;
  }
  _impl_.wovrext_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wovrextpf_ != nullptr) {
    delete _impl_.wovrextpf_;
  }
  _impl_.wovrextpf_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wundext_ != nullptr) {
    delete _impl_.wundext_;
  }
  _impl_.wundext_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wundextpf_ != nullptr) {
    delete _impl_.wundextpf_;
  }
  _impl_.wundextpf_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SourceCapabilityConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG AMax = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_amax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VAMax = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_vamax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VarMaxAbs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_varmaxabs(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VarMaxInj = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_varmaxinj(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VMax = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_vmax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VMin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_vmin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VNom = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_vnom(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WMax = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_wmax(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WOvrExt = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_wovrext(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WOvrExtPF = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_wovrextpf(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WUndExt = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_wundext(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WUndExtPF = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_wundextpf(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SourceCapabilityConfiguration::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.SourceCapabilityConfiguration)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG AMax = 2;
  if (this->_internal_has_amax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::amax(this),
        _Internal::amax(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VAMax = 3;
  if (this->_internal_has_vamax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::vamax(this),
        _Internal::vamax(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VarMaxAbs = 4;
  if (this->_internal_has_varmaxabs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::varmaxabs(this),
        _Internal::varmaxabs(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VarMaxInj = 5;
  if (this->_internal_has_varmaxinj()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::varmaxinj(this),
        _Internal::varmaxinj(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VMax = 6;
  if (this->_internal_has_vmax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::vmax(this),
        _Internal::vmax(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VMin = 7;
  if (this->_internal_has_vmin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::vmin(this),
        _Internal::vmin(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VNom = 8;
  if (this->_internal_has_vnom()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::vnom(this),
        _Internal::vnom(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WMax = 9;
  if (this->_internal_has_wmax()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::wmax(this),
        _Internal::wmax(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WOvrExt = 10;
  if (this->_internal_has_wovrext()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::wovrext(this),
        _Internal::wovrext(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WOvrExtPF = 11;
  if (this->_internal_has_wovrextpf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::wovrextpf(this),
        _Internal::wovrextpf(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WUndExt = 12;
  if (this->_internal_has_wundext()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::wundext(this),
        _Internal::wundext(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WUndExtPF = 13;
  if (this->_internal_has_wundextpf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::wundextpf(this),
        _Internal::wundextpf(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.SourceCapabilityConfiguration)
  return target;
}

::size_t SourceCapabilityConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.SourceCapabilityConfiguration)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.ASG AMax = 2;
  if (this->_internal_has_amax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amax_);
  }

  // .commonmodule.ASG VAMax = 3;
  if (this->_internal_has_vamax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vamax_);
  }

  // .commonmodule.ASG VarMaxAbs = 4;
  if (this->_internal_has_varmaxabs()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.varmaxabs_);
  }

  // .commonmodule.ASG VarMaxInj = 5;
  if (this->_internal_has_varmaxinj()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.varmaxinj_);
  }

  // .commonmodule.ASG VMax = 6;
  if (this->_internal_has_vmax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vmax_);
  }

  // .commonmodule.ASG VMin = 7;
  if (this->_internal_has_vmin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vmin_);
  }

  // .commonmodule.ASG VNom = 8;
  if (this->_internal_has_vnom()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vnom_);
  }

  // .commonmodule.ASG WMax = 9;
  if (this->_internal_has_wmax()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wmax_);
  }

  // .commonmodule.ASG WOvrExt = 10;
  if (this->_internal_has_wovrext()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wovrext_);
  }

  // .commonmodule.ASG WOvrExtPF = 11;
  if (this->_internal_has_wovrextpf()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wovrextpf_);
  }

  // .commonmodule.ASG WUndExt = 12;
  if (this->_internal_has_wundext()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wundext_);
  }

  // .commonmodule.ASG WUndExtPF = 13;
  if (this->_internal_has_wundextpf()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wundextpf_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SourceCapabilityConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SourceCapabilityConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SourceCapabilityConfiguration::GetClassData() const { return &_class_data_; }


void SourceCapabilityConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SourceCapabilityConfiguration*>(&to_msg);
  auto& from = static_cast<const SourceCapabilityConfiguration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.SourceCapabilityConfiguration)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_amax()) {
    _this->_internal_mutable_amax()->::commonmodule::ASG::MergeFrom(
        from._internal_amax());
  }
  if (from._internal_has_vamax()) {
    _this->_internal_mutable_vamax()->::commonmodule::ASG::MergeFrom(
        from._internal_vamax());
  }
  if (from._internal_has_varmaxabs()) {
    _this->_internal_mutable_varmaxabs()->::commonmodule::ASG::MergeFrom(
        from._internal_varmaxabs());
  }
  if (from._internal_has_varmaxinj()) {
    _this->_internal_mutable_varmaxinj()->::commonmodule::ASG::MergeFrom(
        from._internal_varmaxinj());
  }
  if (from._internal_has_vmax()) {
    _this->_internal_mutable_vmax()->::commonmodule::ASG::MergeFrom(
        from._internal_vmax());
  }
  if (from._internal_has_vmin()) {
    _this->_internal_mutable_vmin()->::commonmodule::ASG::MergeFrom(
        from._internal_vmin());
  }
  if (from._internal_has_vnom()) {
    _this->_internal_mutable_vnom()->::commonmodule::ASG::MergeFrom(
        from._internal_vnom());
  }
  if (from._internal_has_wmax()) {
    _this->_internal_mutable_wmax()->::commonmodule::ASG::MergeFrom(
        from._internal_wmax());
  }
  if (from._internal_has_wovrext()) {
    _this->_internal_mutable_wovrext()->::commonmodule::ASG::MergeFrom(
        from._internal_wovrext());
  }
  if (from._internal_has_wovrextpf()) {
    _this->_internal_mutable_wovrextpf()->::commonmodule::ASG::MergeFrom(
        from._internal_wovrextpf());
  }
  if (from._internal_has_wundext()) {
    _this->_internal_mutable_wundext()->::commonmodule::ASG::MergeFrom(
        from._internal_wundext());
  }
  if (from._internal_has_wundextpf()) {
    _this->_internal_mutable_wundextpf()->::commonmodule::ASG::MergeFrom(
        from._internal_wundextpf());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SourceCapabilityConfiguration::CopyFrom(const SourceCapabilityConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.SourceCapabilityConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourceCapabilityConfiguration::IsInitialized() const {
  return true;
}

void SourceCapabilityConfiguration::InternalSwap(SourceCapabilityConfiguration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SourceCapabilityConfiguration, _impl_.wundextpf_)
      + sizeof(SourceCapabilityConfiguration::_impl_.wundextpf_)
      - PROTOBUF_FIELD_OFFSET(SourceCapabilityConfiguration, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SourceCapabilityConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[121]);
}
// ===================================================================

class Optional_NorOpCatKind::_Internal {
 public:
};

Optional_NorOpCatKind::Optional_NorOpCatKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_NorOpCatKind)
}
Optional_NorOpCatKind::Optional_NorOpCatKind(const Optional_NorOpCatKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_NorOpCatKind)
}

inline void Optional_NorOpCatKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_NorOpCatKind::~Optional_NorOpCatKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_NorOpCatKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_NorOpCatKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_NorOpCatKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_NorOpCatKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_NorOpCatKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_NorOpCatKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.NorOpCatKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::NorOpCatKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_NorOpCatKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_NorOpCatKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.NorOpCatKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_NorOpCatKind)
  return target;
}

::size_t Optional_NorOpCatKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_NorOpCatKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.NorOpCatKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_NorOpCatKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_NorOpCatKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_NorOpCatKind::GetClassData() const { return &_class_data_; }


void Optional_NorOpCatKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_NorOpCatKind*>(&to_msg);
  auto& from = static_cast<const Optional_NorOpCatKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_NorOpCatKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_NorOpCatKind::CopyFrom(const Optional_NorOpCatKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_NorOpCatKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_NorOpCatKind::IsInitialized() const {
  return true;
}

void Optional_NorOpCatKind::InternalSwap(Optional_NorOpCatKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_NorOpCatKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[122]);
}
// ===================================================================

class Optional_AbnOpCatKind::_Internal {
 public:
};

Optional_AbnOpCatKind::Optional_AbnOpCatKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_AbnOpCatKind)
}
Optional_AbnOpCatKind::Optional_AbnOpCatKind(const Optional_AbnOpCatKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_AbnOpCatKind)
}

inline void Optional_AbnOpCatKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_AbnOpCatKind::~Optional_AbnOpCatKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_AbnOpCatKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_AbnOpCatKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_AbnOpCatKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_AbnOpCatKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_AbnOpCatKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_AbnOpCatKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.AbnOpCatKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::AbnOpCatKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_AbnOpCatKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_AbnOpCatKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.AbnOpCatKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_AbnOpCatKind)
  return target;
}

::size_t Optional_AbnOpCatKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_AbnOpCatKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.AbnOpCatKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_AbnOpCatKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_AbnOpCatKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_AbnOpCatKind::GetClassData() const { return &_class_data_; }


void Optional_AbnOpCatKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_AbnOpCatKind*>(&to_msg);
  auto& from = static_cast<const Optional_AbnOpCatKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_AbnOpCatKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_AbnOpCatKind::CopyFrom(const Optional_AbnOpCatKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_AbnOpCatKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_AbnOpCatKind::IsInitialized() const {
  return true;
}

void Optional_AbnOpCatKind::InternalSwap(Optional_AbnOpCatKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_AbnOpCatKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[123]);
}
// ===================================================================

class SourceCapabilityRatings::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& amaxrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& freqnomrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& reactsusceptrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& vamaxrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& varmaxabsrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& varmaxinjrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& vmaxrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& vminrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& vnomrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& wmaxrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& wovrextrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& wovrextrtgpf(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& wundextrtg(const SourceCapabilityRatings* msg);
  static const ::commonmodule::ASG& wundextrtgpf(const SourceCapabilityRatings* msg);
};

const ::commonmodule::LogicalNode&
SourceCapabilityRatings::_Internal::logicalnode(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::amaxrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.amaxrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::freqnomrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.freqnomrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::reactsusceptrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.reactsusceptrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::vamaxrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.vamaxrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::varmaxabsrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.varmaxabsrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::varmaxinjrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.varmaxinjrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::vmaxrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.vmaxrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::vminrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.vminrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::vnomrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.vnomrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::wmaxrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.wmaxrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::wovrextrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.wovrextrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::wovrextrtgpf(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.wovrextrtgpf_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::wundextrtg(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.wundextrtg_;
}
const ::commonmodule::ASG&
SourceCapabilityRatings::_Internal::wundextrtgpf(const SourceCapabilityRatings* msg) {
  return *msg->_impl_.wundextrtgpf_;
}
SourceCapabilityRatings::SourceCapabilityRatings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.SourceCapabilityRatings)
}
SourceCapabilityRatings::SourceCapabilityRatings(const SourceCapabilityRatings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SourceCapabilityRatings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.amaxrtg_){nullptr}
    , decltype(_impl_.freqnomrtg_){nullptr}
    , decltype(_impl_.reactsusceptrtg_){nullptr}
    , decltype(_impl_.vamaxrtg_){nullptr}
    , decltype(_impl_.varmaxabsrtg_){nullptr}
    , decltype(_impl_.varmaxinjrtg_){nullptr}
    , decltype(_impl_.vmaxrtg_){nullptr}
    , decltype(_impl_.vminrtg_){nullptr}
    , decltype(_impl_.vnomrtg_){nullptr}
    , decltype(_impl_.wmaxrtg_){nullptr}
    , decltype(_impl_.wovrextrtg_){nullptr}
    , decltype(_impl_.wovrextrtgpf_){nullptr}
    , decltype(_impl_.wundextrtg_){nullptr}
    , decltype(_impl_.wundextrtgpf_){nullptr}
    , decltype(_impl_.abnopcatrtg_) {}

    , decltype(_impl_.noropcatrtg_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_amaxrtg()) {
    _this->_impl_.amaxrtg_ = new ::commonmodule::ASG(*from._impl_.amaxrtg_);
  }
  if (from._internal_has_freqnomrtg()) {
    _this->_impl_.freqnomrtg_ = new ::commonmodule::ASG(*from._impl_.freqnomrtg_);
  }
  if (from._internal_has_reactsusceptrtg()) {
    _this->_impl_.reactsusceptrtg_ = new ::commonmodule::ASG(*from._impl_.reactsusceptrtg_);
  }
  if (from._internal_has_vamaxrtg()) {
    _this->_impl_.vamaxrtg_ = new ::commonmodule::ASG(*from._impl_.vamaxrtg_);
  }
  if (from._internal_has_varmaxabsrtg()) {
    _this->_impl_.varmaxabsrtg_ = new ::commonmodule::ASG(*from._impl_.varmaxabsrtg_);
  }
  if (from._internal_has_varmaxinjrtg()) {
    _this->_impl_.varmaxinjrtg_ = new ::commonmodule::ASG(*from._impl_.varmaxinjrtg_);
  }
  if (from._internal_has_vmaxrtg()) {
    _this->_impl_.vmaxrtg_ = new ::commonmodule::ASG(*from._impl_.vmaxrtg_);
  }
  if (from._internal_has_vminrtg()) {
    _this->_impl_.vminrtg_ = new ::commonmodule::ASG(*from._impl_.vminrtg_);
  }
  if (from._internal_has_vnomrtg()) {
    _this->_impl_.vnomrtg_ = new ::commonmodule::ASG(*from._impl_.vnomrtg_);
  }
  if (from._internal_has_wmaxrtg()) {
    _this->_impl_.wmaxrtg_ = new ::commonmodule::ASG(*from._impl_.wmaxrtg_);
  }
  if (from._internal_has_wovrextrtg()) {
    _this->_impl_.wovrextrtg_ = new ::commonmodule::ASG(*from._impl_.wovrextrtg_);
  }
  if (from._internal_has_wovrextrtgpf()) {
    _this->_impl_.wovrextrtgpf_ = new ::commonmodule::ASG(*from._impl_.wovrextrtgpf_);
  }
  if (from._internal_has_wundextrtg()) {
    _this->_impl_.wundextrtg_ = new ::commonmodule::ASG(*from._impl_.wundextrtg_);
  }
  if (from._internal_has_wundextrtgpf()) {
    _this->_impl_.wundextrtgpf_ = new ::commonmodule::ASG(*from._impl_.wundextrtgpf_);
  }
  ::memcpy(&_impl_.abnopcatrtg_, &from._impl_.abnopcatrtg_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.noropcatrtg_) -
    reinterpret_cast<char*>(&_impl_.abnopcatrtg_)) + sizeof(_impl_.noropcatrtg_));
  // @@protoc_insertion_point(copy_constructor:commonmodule.SourceCapabilityRatings)
}

inline void SourceCapabilityRatings::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.amaxrtg_){nullptr}
    , decltype(_impl_.freqnomrtg_){nullptr}
    , decltype(_impl_.reactsusceptrtg_){nullptr}
    , decltype(_impl_.vamaxrtg_){nullptr}
    , decltype(_impl_.varmaxabsrtg_){nullptr}
    , decltype(_impl_.varmaxinjrtg_){nullptr}
    , decltype(_impl_.vmaxrtg_){nullptr}
    , decltype(_impl_.vminrtg_){nullptr}
    , decltype(_impl_.vnomrtg_){nullptr}
    , decltype(_impl_.wmaxrtg_){nullptr}
    , decltype(_impl_.wovrextrtg_){nullptr}
    , decltype(_impl_.wovrextrtgpf_){nullptr}
    , decltype(_impl_.wundextrtg_){nullptr}
    , decltype(_impl_.wundextrtgpf_){nullptr}
    , decltype(_impl_.abnopcatrtg_) { 0 }

    , decltype(_impl_.noropcatrtg_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SourceCapabilityRatings::~SourceCapabilityRatings() {
  // @@protoc_insertion_point(destructor:commonmodule.SourceCapabilityRatings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SourceCapabilityRatings::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.amaxrtg_;
  if (this != internal_default_instance()) delete _impl_.freqnomrtg_;
  if (this != internal_default_instance()) delete _impl_.reactsusceptrtg_;
  if (this != internal_default_instance()) delete _impl_.vamaxrtg_;
  if (this != internal_default_instance()) delete _impl_.varmaxabsrtg_;
  if (this != internal_default_instance()) delete _impl_.varmaxinjrtg_;
  if (this != internal_default_instance()) delete _impl_.vmaxrtg_;
  if (this != internal_default_instance()) delete _impl_.vminrtg_;
  if (this != internal_default_instance()) delete _impl_.vnomrtg_;
  if (this != internal_default_instance()) delete _impl_.wmaxrtg_;
  if (this != internal_default_instance()) delete _impl_.wovrextrtg_;
  if (this != internal_default_instance()) delete _impl_.wovrextrtgpf_;
  if (this != internal_default_instance()) delete _impl_.wundextrtg_;
  if (this != internal_default_instance()) delete _impl_.wundextrtgpf_;
}

void SourceCapabilityRatings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SourceCapabilityRatings::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.SourceCapabilityRatings)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.amaxrtg_ != nullptr) {
    delete _impl_.amaxrtg_;
  }
  _impl_.amaxrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.freqnomrtg_ != nullptr) {
    delete _impl_.freqnomrtg_;
  }
  _impl_.freqnomrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.reactsusceptrtg_ != nullptr) {
    delete _impl_.reactsusceptrtg_;
  }
  _impl_.reactsusceptrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vamaxrtg_ != nullptr) {
    delete _impl_.vamaxrtg_;
  }
  _impl_.vamaxrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxabsrtg_ != nullptr) {
    delete _impl_.varmaxabsrtg_;
  }
  _impl_.varmaxabsrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxinjrtg_ != nullptr) {
    delete _impl_.varmaxinjrtg_;
  }
  _impl_.varmaxinjrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vmaxrtg_ != nullptr) {
    delete _impl_.vmaxrtg_;
  }
  _impl_.vmaxrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vminrtg_ != nullptr) {
    delete _impl_.vminrtg_;
  }
  _impl_.vminrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vnomrtg_ != nullptr) {
    delete _impl_.vnomrtg_;
  }
  _impl_.vnomrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wmaxrtg_ != nullptr) {
    delete _impl_.wmaxrtg_;
  }
  _impl_.wmaxrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wovrextrtg_ != nullptr) {
    delete _impl_.wovrextrtg_;
  }
  _impl_.wovrextrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wovrextrtgpf_ != nullptr) {
    delete _impl_.wovrextrtgpf_;
  }
  _impl_.wovrextrtgpf_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wundextrtg_ != nullptr) {
    delete _impl_.wundextrtg_;
  }
  _impl_.wundextrtg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.wundextrtgpf_ != nullptr) {
    delete _impl_.wundextrtgpf_;
  }
  _impl_.wundextrtgpf_ = nullptr;
  ::memset(&_impl_.abnopcatrtg_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.noropcatrtg_) -
      reinterpret_cast<char*>(&_impl_.abnopcatrtg_)) + sizeof(_impl_.noropcatrtg_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SourceCapabilityRatings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.AbnOpCatKind AbnOpCatRtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_abnopcatrtg(static_cast<::commonmodule::AbnOpCatKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG AMaxRtg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_amaxrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG FreqNomRtg = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_freqnomrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.NorOpCatKind NorOpCatRtg = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_noropcatrtg(static_cast<::commonmodule::NorOpCatKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG ReactSusceptRtg = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_reactsusceptrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VAMaxRtg = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_vamaxrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VarMaxAbsRtg = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_varmaxabsrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VarMaxInjRtg = 9 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_varmaxinjrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VMaxRtg = 10 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_vmaxrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VMinRtg = 11 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_vminrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG VNomRtg = 12 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_vnomrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WMaxRtg = 13 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_wmaxrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WOvrExtRtg = 14 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_wovrextrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WOvrExtRtgPF = 15 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_wovrextrtgpf(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WUndExtRtg = 16 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_wundextrtg(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ASG WUndExtRtgPF = 17 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_wundextrtgpf(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SourceCapabilityRatings::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.SourceCapabilityRatings)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.AbnOpCatKind AbnOpCatRtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_abnopcatrtg() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_abnopcatrtg(), target);
  }

  // .commonmodule.ASG AMaxRtg = 3;
  if (this->_internal_has_amaxrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::amaxrtg(this),
        _Internal::amaxrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG FreqNomRtg = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_freqnomrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::freqnomrtg(this),
        _Internal::freqnomrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.NorOpCatKind NorOpCatRtg = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_noropcatrtg() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_noropcatrtg(), target);
  }

  // .commonmodule.ASG ReactSusceptRtg = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_reactsusceptrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::reactsusceptrtg(this),
        _Internal::reactsusceptrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VAMaxRtg = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vamaxrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::vamaxrtg(this),
        _Internal::vamaxrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VarMaxAbsRtg = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_varmaxabsrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::varmaxabsrtg(this),
        _Internal::varmaxabsrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VarMaxInjRtg = 9 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_varmaxinjrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::varmaxinjrtg(this),
        _Internal::varmaxinjrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VMaxRtg = 10 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vmaxrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::vmaxrtg(this),
        _Internal::vmaxrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VMinRtg = 11 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vminrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::vminrtg(this),
        _Internal::vminrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG VNomRtg = 12 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vnomrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::vnomrtg(this),
        _Internal::vnomrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WMaxRtg = 13 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wmaxrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::wmaxrtg(this),
        _Internal::wmaxrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WOvrExtRtg = 14 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wovrextrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::wovrextrtg(this),
        _Internal::wovrextrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WOvrExtRtgPF = 15 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wovrextrtgpf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::wovrextrtgpf(this),
        _Internal::wovrextrtgpf(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WUndExtRtg = 16 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wundextrtg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::wundextrtg(this),
        _Internal::wundextrtg(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ASG WUndExtRtgPF = 17 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wundextrtgpf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::wundextrtgpf(this),
        _Internal::wundextrtgpf(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.SourceCapabilityRatings)
  return target;
}

::size_t SourceCapabilityRatings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.SourceCapabilityRatings)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.ASG AMaxRtg = 3;
  if (this->_internal_has_amaxrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amaxrtg_);
  }

  // .commonmodule.ASG FreqNomRtg = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_freqnomrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.freqnomrtg_);
  }

  // .commonmodule.ASG ReactSusceptRtg = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_reactsusceptrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reactsusceptrtg_);
  }

  // .commonmodule.ASG VAMaxRtg = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vamaxrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vamaxrtg_);
  }

  // .commonmodule.ASG VarMaxAbsRtg = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_varmaxabsrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.varmaxabsrtg_);
  }

  // .commonmodule.ASG VarMaxInjRtg = 9 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_varmaxinjrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.varmaxinjrtg_);
  }

  // .commonmodule.ASG VMaxRtg = 10 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vmaxrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vmaxrtg_);
  }

  // .commonmodule.ASG VMinRtg = 11 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vminrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vminrtg_);
  }

  // .commonmodule.ASG VNomRtg = 12 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vnomrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vnomrtg_);
  }

  // .commonmodule.ASG WMaxRtg = 13 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wmaxrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wmaxrtg_);
  }

  // .commonmodule.ASG WOvrExtRtg = 14 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wovrextrtg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wovrextrtg_);
  }

  // .commonmodule.ASG WOvrExtRtgPF = 15 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wovrextrtgpf()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wovrextrtgpf_);
  }

  // .commonmodule.ASG WUndExtRtg = 16 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wundextrtg()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wundextrtg_);
  }

  // .commonmodule.ASG WUndExtRtgPF = 17 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wundextrtgpf()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wundextrtgpf_);
  }

  // .commonmodule.AbnOpCatKind AbnOpCatRtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_abnopcatrtg() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_abnopcatrtg());
  }

  // .commonmodule.NorOpCatKind NorOpCatRtg = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_noropcatrtg() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_noropcatrtg());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SourceCapabilityRatings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SourceCapabilityRatings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SourceCapabilityRatings::GetClassData() const { return &_class_data_; }


void SourceCapabilityRatings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SourceCapabilityRatings*>(&to_msg);
  auto& from = static_cast<const SourceCapabilityRatings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.SourceCapabilityRatings)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_amaxrtg()) {
    _this->_internal_mutable_amaxrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_amaxrtg());
  }
  if (from._internal_has_freqnomrtg()) {
    _this->_internal_mutable_freqnomrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_freqnomrtg());
  }
  if (from._internal_has_reactsusceptrtg()) {
    _this->_internal_mutable_reactsusceptrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_reactsusceptrtg());
  }
  if (from._internal_has_vamaxrtg()) {
    _this->_internal_mutable_vamaxrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_vamaxrtg());
  }
  if (from._internal_has_varmaxabsrtg()) {
    _this->_internal_mutable_varmaxabsrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_varmaxabsrtg());
  }
  if (from._internal_has_varmaxinjrtg()) {
    _this->_internal_mutable_varmaxinjrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_varmaxinjrtg());
  }
  if (from._internal_has_vmaxrtg()) {
    _this->_internal_mutable_vmaxrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_vmaxrtg());
  }
  if (from._internal_has_vminrtg()) {
    _this->_internal_mutable_vminrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_vminrtg());
  }
  if (from._internal_has_vnomrtg()) {
    _this->_internal_mutable_vnomrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_vnomrtg());
  }
  if (from._internal_has_wmaxrtg()) {
    _this->_internal_mutable_wmaxrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_wmaxrtg());
  }
  if (from._internal_has_wovrextrtg()) {
    _this->_internal_mutable_wovrextrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_wovrextrtg());
  }
  if (from._internal_has_wovrextrtgpf()) {
    _this->_internal_mutable_wovrextrtgpf()->::commonmodule::ASG::MergeFrom(
        from._internal_wovrextrtgpf());
  }
  if (from._internal_has_wundextrtg()) {
    _this->_internal_mutable_wundextrtg()->::commonmodule::ASG::MergeFrom(
        from._internal_wundextrtg());
  }
  if (from._internal_has_wundextrtgpf()) {
    _this->_internal_mutable_wundextrtgpf()->::commonmodule::ASG::MergeFrom(
        from._internal_wundextrtgpf());
  }
  if (from._internal_abnopcatrtg() != 0) {
    _this->_internal_set_abnopcatrtg(from._internal_abnopcatrtg());
  }
  if (from._internal_noropcatrtg() != 0) {
    _this->_internal_set_noropcatrtg(from._internal_noropcatrtg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SourceCapabilityRatings::CopyFrom(const SourceCapabilityRatings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.SourceCapabilityRatings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourceCapabilityRatings::IsInitialized() const {
  return true;
}

void SourceCapabilityRatings::InternalSwap(SourceCapabilityRatings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SourceCapabilityRatings, _impl_.noropcatrtg_)
      + sizeof(SourceCapabilityRatings::_impl_.noropcatrtg_)
      - PROTOBUF_FIELD_OFFSET(SourceCapabilityRatings, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SourceCapabilityRatings::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[124]);
}
// ===================================================================

class StatusAndEventXCBR::_Internal {
 public:
  static const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus(const StatusAndEventXCBR* msg);
  static const ::commonmodule::ENS_DynamicTestKind& dynamictest(const StatusAndEventXCBR* msg);
  static const ::commonmodule::PhaseDPS& pos(const StatusAndEventXCBR* msg);
  static const ::commonmodule::ACD& protectionpickup(const StatusAndEventXCBR* msg);
  static const ::commonmodule::StatusINS& protectionmode(const StatusAndEventXCBR* msg);
  static const ::commonmodule::PhaseSPS& recloseenabled(const StatusAndEventXCBR* msg);
  static const ::commonmodule::PhaseRecloseAction& reclosingaction(const StatusAndEventXCBR* msg);
};

const ::commonmodule::LogicalNodeForEventAndStatus&
StatusAndEventXCBR::_Internal::logicalnodeforeventandstatus(const StatusAndEventXCBR* msg) {
  return *msg->_impl_.logicalnodeforeventandstatus_;
}
const ::commonmodule::ENS_DynamicTestKind&
StatusAndEventXCBR::_Internal::dynamictest(const StatusAndEventXCBR* msg) {
  return *msg->_impl_.dynamictest_;
}
const ::commonmodule::PhaseDPS&
StatusAndEventXCBR::_Internal::pos(const StatusAndEventXCBR* msg) {
  return *msg->_impl_.pos_;
}
const ::commonmodule::ACD&
StatusAndEventXCBR::_Internal::protectionpickup(const StatusAndEventXCBR* msg) {
  return *msg->_impl_.protectionpickup_;
}
const ::commonmodule::StatusINS&
StatusAndEventXCBR::_Internal::protectionmode(const StatusAndEventXCBR* msg) {
  return *msg->_impl_.protectionmode_;
}
const ::commonmodule::PhaseSPS&
StatusAndEventXCBR::_Internal::recloseenabled(const StatusAndEventXCBR* msg) {
  return *msg->_impl_.recloseenabled_;
}
const ::commonmodule::PhaseRecloseAction&
StatusAndEventXCBR::_Internal::reclosingaction(const StatusAndEventXCBR* msg) {
  return *msg->_impl_.reclosingaction_;
}
StatusAndEventXCBR::StatusAndEventXCBR(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusAndEventXCBR)
}
StatusAndEventXCBR::StatusAndEventXCBR(const StatusAndEventXCBR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusAndEventXCBR* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnodeforeventandstatus_){nullptr}
    , decltype(_impl_.dynamictest_){nullptr}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.protectionpickup_){nullptr}
    , decltype(_impl_.protectionmode_){nullptr}
    , decltype(_impl_.recloseenabled_){nullptr}
    , decltype(_impl_.reclosingaction_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnodeforeventandstatus()) {
    _this->_impl_.logicalnodeforeventandstatus_ = new ::commonmodule::LogicalNodeForEventAndStatus(*from._impl_.logicalnodeforeventandstatus_);
  }
  if (from._internal_has_dynamictest()) {
    _this->_impl_.dynamictest_ = new ::commonmodule::ENS_DynamicTestKind(*from._impl_.dynamictest_);
  }
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::commonmodule::PhaseDPS(*from._impl_.pos_);
  }
  if (from._internal_has_protectionpickup()) {
    _this->_impl_.protectionpickup_ = new ::commonmodule::ACD(*from._impl_.protectionpickup_);
  }
  if (from._internal_has_protectionmode()) {
    _this->_impl_.protectionmode_ = new ::commonmodule::StatusINS(*from._impl_.protectionmode_);
  }
  if (from._internal_has_recloseenabled()) {
    _this->_impl_.recloseenabled_ = new ::commonmodule::PhaseSPS(*from._impl_.recloseenabled_);
  }
  if (from._internal_has_reclosingaction()) {
    _this->_impl_.reclosingaction_ = new ::commonmodule::PhaseRecloseAction(*from._impl_.reclosingaction_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusAndEventXCBR)
}

inline void StatusAndEventXCBR::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnodeforeventandstatus_){nullptr}
    , decltype(_impl_.dynamictest_){nullptr}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.protectionpickup_){nullptr}
    , decltype(_impl_.protectionmode_){nullptr}
    , decltype(_impl_.recloseenabled_){nullptr}
    , decltype(_impl_.reclosingaction_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusAndEventXCBR::~StatusAndEventXCBR() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusAndEventXCBR)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusAndEventXCBR::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnodeforeventandstatus_;
  if (this != internal_default_instance()) delete _impl_.dynamictest_;
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.protectionpickup_;
  if (this != internal_default_instance()) delete _impl_.protectionmode_;
  if (this != internal_default_instance()) delete _impl_.recloseenabled_;
  if (this != internal_default_instance()) delete _impl_.reclosingaction_;
}

void StatusAndEventXCBR::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusAndEventXCBR::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusAndEventXCBR)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnodeforeventandstatus_ != nullptr) {
    delete _impl_.logicalnodeforeventandstatus_;
  }
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dynamictest_ != nullptr) {
    delete _impl_.dynamictest_;
  }
  _impl_.dynamictest_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.protectionpickup_ != nullptr) {
    delete _impl_.protectionpickup_;
  }
  _impl_.protectionpickup_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.protectionmode_ != nullptr) {
    delete _impl_.protectionmode_;
  }
  _impl_.protectionmode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.recloseenabled_ != nullptr) {
    delete _impl_.recloseenabled_;
  }
  _impl_.recloseenabled_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.reclosingaction_ != nullptr) {
    delete _impl_.reclosingaction_;
  }
  _impl_.reclosingaction_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusAndEventXCBR::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnodeforeventandstatus(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dynamictest(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.PhaseDPS Pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ACD ProtectionPickup = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_protectionpickup(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.StatusINS ProtectionMode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_protectionmode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.PhaseSPS RecloseEnabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_recloseenabled(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.PhaseRecloseAction ReclosingAction = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_reclosingaction(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusAndEventXCBR::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusAndEventXCBR)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnodeforeventandstatus()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnodeforeventandstatus(this),
        _Internal::logicalnodeforeventandstatus(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  if (this->_internal_has_dynamictest()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dynamictest(this),
        _Internal::dynamictest(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.PhaseDPS Pos = 3;
  if (this->_internal_has_pos()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ACD ProtectionPickup = 4;
  if (this->_internal_has_protectionpickup()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::protectionpickup(this),
        _Internal::protectionpickup(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.StatusINS ProtectionMode = 5;
  if (this->_internal_has_protectionmode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::protectionmode(this),
        _Internal::protectionmode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.PhaseSPS RecloseEnabled = 6;
  if (this->_internal_has_recloseenabled()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::recloseenabled(this),
        _Internal::recloseenabled(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.PhaseRecloseAction ReclosingAction = 7;
  if (this->_internal_has_reclosingaction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::reclosingaction(this),
        _Internal::reclosingaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusAndEventXCBR)
  return target;
}

::size_t StatusAndEventXCBR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusAndEventXCBR)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnodeforeventandstatus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnodeforeventandstatus_);
  }

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  if (this->_internal_has_dynamictest()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dynamictest_);
  }

  // .commonmodule.PhaseDPS Pos = 3;
  if (this->_internal_has_pos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pos_);
  }

  // .commonmodule.ACD ProtectionPickup = 4;
  if (this->_internal_has_protectionpickup()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.protectionpickup_);
  }

  // .commonmodule.StatusINS ProtectionMode = 5;
  if (this->_internal_has_protectionmode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.protectionmode_);
  }

  // .commonmodule.PhaseSPS RecloseEnabled = 6;
  if (this->_internal_has_recloseenabled()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.recloseenabled_);
  }

  // .commonmodule.PhaseRecloseAction ReclosingAction = 7;
  if (this->_internal_has_reclosingaction()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reclosingaction_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusAndEventXCBR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusAndEventXCBR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusAndEventXCBR::GetClassData() const { return &_class_data_; }


void StatusAndEventXCBR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusAndEventXCBR*>(&to_msg);
  auto& from = static_cast<const StatusAndEventXCBR&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusAndEventXCBR)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnodeforeventandstatus()) {
    _this->_internal_mutable_logicalnodeforeventandstatus()->::commonmodule::LogicalNodeForEventAndStatus::MergeFrom(
        from._internal_logicalnodeforeventandstatus());
  }
  if (from._internal_has_dynamictest()) {
    _this->_internal_mutable_dynamictest()->::commonmodule::ENS_DynamicTestKind::MergeFrom(
        from._internal_dynamictest());
  }
  if (from._internal_has_pos()) {
    _this->_internal_mutable_pos()->::commonmodule::PhaseDPS::MergeFrom(
        from._internal_pos());
  }
  if (from._internal_has_protectionpickup()) {
    _this->_internal_mutable_protectionpickup()->::commonmodule::ACD::MergeFrom(
        from._internal_protectionpickup());
  }
  if (from._internal_has_protectionmode()) {
    _this->_internal_mutable_protectionmode()->::commonmodule::StatusINS::MergeFrom(
        from._internal_protectionmode());
  }
  if (from._internal_has_recloseenabled()) {
    _this->_internal_mutable_recloseenabled()->::commonmodule::PhaseSPS::MergeFrom(
        from._internal_recloseenabled());
  }
  if (from._internal_has_reclosingaction()) {
    _this->_internal_mutable_reclosingaction()->::commonmodule::PhaseRecloseAction::MergeFrom(
        from._internal_reclosingaction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusAndEventXCBR::CopyFrom(const StatusAndEventXCBR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusAndEventXCBR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusAndEventXCBR::IsInitialized() const {
  return true;
}

void StatusAndEventXCBR::InternalSwap(StatusAndEventXCBR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusAndEventXCBR, _impl_.reclosingaction_)
      + sizeof(StatusAndEventXCBR::_impl_.reclosingaction_)
      - PROTOBUF_FIELD_OFFSET(StatusAndEventXCBR, _impl_.logicalnodeforeventandstatus_)>(
          reinterpret_cast<char*>(&_impl_.logicalnodeforeventandstatus_),
          reinterpret_cast<char*>(&other->_impl_.logicalnodeforeventandstatus_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusAndEventXCBR::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[125]);
}
// ===================================================================

class StatusINC::_Internal {
 public:
  static const ::commonmodule::Quality& q(const StatusINC* msg);
  static const ::commonmodule::Timestamp& t(const StatusINC* msg);
};

const ::commonmodule::Quality&
StatusINC::_Internal::q(const StatusINC* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
StatusINC::_Internal::t(const StatusINC* msg) {
  return *msg->_impl_.t_;
}
StatusINC::StatusINC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusINC)
}
StatusINC::StatusINC(const StatusINC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusINC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusINC)
}

inline void StatusINC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusINC::~StatusINC() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusINC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusINC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void StatusINC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusINC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusINC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusINC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.stval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusINC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusINC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusINC)
  return target;
}

::size_t StatusINC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusINC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusINC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusINC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusINC::GetClassData() const { return &_class_data_; }


void StatusINC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusINC*>(&to_msg);
  auto& from = static_cast<const StatusINC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusINC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusINC::CopyFrom(const StatusINC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusINC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusINC::IsInitialized() const {
  return true;
}

void StatusINC::InternalSwap(StatusINC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusINC, _impl_.stval_)
      + sizeof(StatusINC::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(StatusINC, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusINC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[126]);
}
// ===================================================================

class StatusISC::_Internal {
 public:
  static const ::commonmodule::Quality& q(const StatusISC* msg);
  static const ::commonmodule::Timestamp& t(const StatusISC* msg);
};

const ::commonmodule::Quality&
StatusISC::_Internal::q(const StatusISC* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
StatusISC::_Internal::t(const StatusISC* msg) {
  return *msg->_impl_.t_;
}
StatusISC::StatusISC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusISC)
}
StatusISC::StatusISC(const StatusISC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusISC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  _this->_impl_.stval_ = from._impl_.stval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusISC)
}

inline void StatusISC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , decltype(_impl_.stval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusISC::~StatusISC() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusISC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusISC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void StatusISC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusISC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusISC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _impl_.stval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusISC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.stval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusISC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusISC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_stval(), target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusISC)
  return target;
}

::size_t StatusISC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusISC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_stval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_stval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusISC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusISC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusISC::GetClassData() const { return &_class_data_; }


void StatusISC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusISC*>(&to_msg);
  auto& from = static_cast<const StatusISC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusISC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  if (from._internal_stval() != 0) {
    _this->_internal_set_stval(from._internal_stval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusISC::CopyFrom(const StatusISC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusISC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusISC::IsInitialized() const {
  return true;
}

void StatusISC::InternalSwap(StatusISC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusISC, _impl_.stval_)
      + sizeof(StatusISC::_impl_.stval_)
      - PROTOBUF_FIELD_OFFSET(StatusISC, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusISC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[127]);
}
// ===================================================================

class StatusMessageInfo::_Internal {
 public:
  static const ::commonmodule::MessageInfo& messageinfo(const StatusMessageInfo* msg);
};

const ::commonmodule::MessageInfo&
StatusMessageInfo::_Internal::messageinfo(const StatusMessageInfo* msg) {
  return *msg->_impl_.messageinfo_;
}
StatusMessageInfo::StatusMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusMessageInfo)
}
StatusMessageInfo::StatusMessageInfo(const StatusMessageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusMessageInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_messageinfo()) {
    _this->_impl_.messageinfo_ = new ::commonmodule::MessageInfo(*from._impl_.messageinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusMessageInfo)
}

inline void StatusMessageInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messageinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusMessageInfo::~StatusMessageInfo() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusMessageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusMessageInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.messageinfo_;
}

void StatusMessageInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusMessageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusMessageInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusMessageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_messageinfo(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusMessageInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusMessageInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::messageinfo(this),
        _Internal::messageinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusMessageInfo)
  return target;
}

::size_t StatusMessageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusMessageInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_messageinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.messageinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusMessageInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusMessageInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusMessageInfo::GetClassData() const { return &_class_data_; }


void StatusMessageInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusMessageInfo*>(&to_msg);
  auto& from = static_cast<const StatusMessageInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusMessageInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_messageinfo()) {
    _this->_internal_mutable_messageinfo()->::commonmodule::MessageInfo::MergeFrom(
        from._internal_messageinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusMessageInfo::CopyFrom(const StatusMessageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusMessageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusMessageInfo::IsInitialized() const {
  return true;
}

void StatusMessageInfo::InternalSwap(StatusMessageInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.messageinfo_, other->_impl_.messageinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusMessageInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[128]);
}
// ===================================================================

class StatusValue::_Internal {
 public:
  static const ::commonmodule::IdentifiedObject& identifiedobject(const StatusValue* msg);
  static const ::PROTOBUF_NAMESPACE_ID::BoolValue& modblk(const StatusValue* msg);
};

const ::commonmodule::IdentifiedObject&
StatusValue::_Internal::identifiedobject(const StatusValue* msg) {
  return *msg->_impl_.identifiedobject_;
}
const ::PROTOBUF_NAMESPACE_ID::BoolValue&
StatusValue::_Internal::modblk(const StatusValue* msg) {
  return *msg->_impl_.modblk_;
}
void StatusValue::clear_modblk() {
  if (GetArenaForAllocation() == nullptr && _impl_.modblk_ != nullptr) {
    delete _impl_.modblk_;
  }
  _impl_.modblk_ = nullptr;
}
StatusValue::StatusValue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StatusValue)
}
StatusValue::StatusValue(const StatusValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.modblk_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_identifiedobject()) {
    _this->_impl_.identifiedobject_ = new ::commonmodule::IdentifiedObject(*from._impl_.identifiedobject_);
  }
  if (from._internal_has_modblk()) {
    _this->_impl_.modblk_ = new ::PROTOBUF_NAMESPACE_ID::BoolValue(*from._impl_.modblk_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.StatusValue)
}

inline void StatusValue::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.identifiedobject_){nullptr}
    , decltype(_impl_.modblk_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusValue::~StatusValue() {
  // @@protoc_insertion_point(destructor:commonmodule.StatusValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusValue::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.identifiedobject_;
  if (this != internal_default_instance()) delete _impl_.modblk_;
}

void StatusValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusValue::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StatusValue)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.modblk_ != nullptr) {
    delete _impl_.modblk_;
  }
  _impl_.modblk_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_identifiedobject(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.BoolValue modBlk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_modblk(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StatusValue::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StatusValue)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::identifiedobject(this),
        _Internal::identifiedobject(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue modBlk = 2;
  if (this->_internal_has_modblk()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::modblk(this),
        _Internal::modblk(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StatusValue)
  return target;
}

::size_t StatusValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StatusValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_identifiedobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.identifiedobject_);
  }

  // .google.protobuf.BoolValue modBlk = 2;
  if (this->_internal_has_modblk()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.modblk_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusValue::GetClassData() const { return &_class_data_; }


void StatusValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusValue*>(&to_msg);
  auto& from = static_cast<const StatusValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StatusValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifiedobject()) {
    _this->_internal_mutable_identifiedobject()->::commonmodule::IdentifiedObject::MergeFrom(
        from._internal_identifiedobject());
  }
  if (from._internal_has_modblk()) {
    _this->_internal_mutable_modblk()->::PROTOBUF_NAMESPACE_ID::BoolValue::MergeFrom(
        from._internal_modblk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusValue::CopyFrom(const StatusValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StatusValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusValue::IsInitialized() const {
  return true;
}

void StatusValue::InternalSwap(StatusValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusValue, _impl_.modblk_)
      + sizeof(StatusValue::_impl_.modblk_)
      - PROTOBUF_FIELD_OFFSET(StatusValue, _impl_.identifiedobject_)>(
          reinterpret_cast<char*>(&_impl_.identifiedobject_),
          reinterpret_cast<char*>(&other->_impl_.identifiedobject_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[129]);
}
// ===================================================================

class VSS::_Internal {
 public:
  static const ::commonmodule::Quality& q(const VSS* msg);
  static const ::commonmodule::Timestamp& t(const VSS* msg);
};

const ::commonmodule::Quality&
VSS::_Internal::q(const VSS* msg) {
  return *msg->_impl_.q_;
}
const ::commonmodule::Timestamp&
VSS::_Internal::t(const VSS* msg) {
  return *msg->_impl_.t_;
}
VSS::VSS(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.VSS)
}
VSS::VSS(const VSS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VSS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stval_) {}

    , decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stval_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stval_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stval().empty()) {
    _this->_impl_.stval_.Set(from._internal_stval(), _this->GetArenaForAllocation());
  }
  if (from._internal_has_q()) {
    _this->_impl_.q_ = new ::commonmodule::Quality(*from._impl_.q_);
  }
  if (from._internal_has_t()) {
    _this->_impl_.t_ = new ::commonmodule::Timestamp(*from._impl_.t_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.VSS)
}

inline void VSS::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.stval_) {}

    , decltype(_impl_.q_){nullptr}
    , decltype(_impl_.t_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.stval_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stval_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VSS::~VSS() {
  // @@protoc_insertion_point(destructor:commonmodule.VSS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VSS::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stval_.Destroy();
  if (this != internal_default_instance()) delete _impl_.q_;
  if (this != internal_default_instance()) delete _impl_.t_;
}

void VSS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VSS::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.VSS)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stval_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VSS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.Quality q = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_q(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stval();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "commonmodule.VSS.stVal"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Timestamp t = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VSS::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.VSS)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::q(this),
        _Internal::q(this).GetCachedSize(), target, stream);
  }

  // string stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_stval().empty()) {
    const std::string& _s = this->_internal_stval();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "commonmodule.VSS.stVal");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t(this),
        _Internal::t(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.VSS)
  return target;
}

::size_t VSS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.VSS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_stval().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_stval());
  }

  // .commonmodule.Quality q = 1;
  if (this->_internal_has_q()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.q_);
  }

  // .commonmodule.Timestamp t = 3;
  if (this->_internal_has_t()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VSS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VSS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VSS::GetClassData() const { return &_class_data_; }


void VSS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VSS*>(&to_msg);
  auto& from = static_cast<const VSS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.VSS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stval().empty()) {
    _this->_internal_set_stval(from._internal_stval());
  }
  if (from._internal_has_q()) {
    _this->_internal_mutable_q()->::commonmodule::Quality::MergeFrom(
        from._internal_q());
  }
  if (from._internal_has_t()) {
    _this->_internal_mutable_t()->::commonmodule::Timestamp::MergeFrom(
        from._internal_t());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VSS::CopyFrom(const VSS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.VSS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VSS::IsInitialized() const {
  return true;
}

void VSS::InternalSwap(VSS* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stval_, lhs_arena,
                                       &other->_impl_.stval_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VSS, _impl_.t_)
      + sizeof(VSS::_impl_.t_)
      - PROTOBUF_FIELD_OFFSET(VSS, _impl_.q_)>(
          reinterpret_cast<char*>(&_impl_.q_),
          reinterpret_cast<char*>(&other->_impl_.q_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VSS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[130]);
}
// ===================================================================

class StringEventAndStatusGGIO::_Internal {
 public:
  static const ::commonmodule::LogicalNode& logicalnode(const StringEventAndStatusGGIO* msg);
  static const ::commonmodule::Optional_PhaseCodeKind& phase(const StringEventAndStatusGGIO* msg);
  static const ::commonmodule::VSS& strin(const StringEventAndStatusGGIO* msg);
};

const ::commonmodule::LogicalNode&
StringEventAndStatusGGIO::_Internal::logicalnode(const StringEventAndStatusGGIO* msg) {
  return *msg->_impl_.logicalnode_;
}
const ::commonmodule::Optional_PhaseCodeKind&
StringEventAndStatusGGIO::_Internal::phase(const StringEventAndStatusGGIO* msg) {
  return *msg->_impl_.phase_;
}
const ::commonmodule::VSS&
StringEventAndStatusGGIO::_Internal::strin(const StringEventAndStatusGGIO* msg) {
  return *msg->_impl_.strin_;
}
StringEventAndStatusGGIO::StringEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.StringEventAndStatusGGIO)
}
StringEventAndStatusGGIO::StringEventAndStatusGGIO(const StringEventAndStatusGGIO& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StringEventAndStatusGGIO* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , decltype(_impl_.strin_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_logicalnode()) {
    _this->_impl_.logicalnode_ = new ::commonmodule::LogicalNode(*from._impl_.logicalnode_);
  }
  if (from._internal_has_phase()) {
    _this->_impl_.phase_ = new ::commonmodule::Optional_PhaseCodeKind(*from._impl_.phase_);
  }
  if (from._internal_has_strin()) {
    _this->_impl_.strin_ = new ::commonmodule::VSS(*from._impl_.strin_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.StringEventAndStatusGGIO)
}

inline void StringEventAndStatusGGIO::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.logicalnode_){nullptr}
    , decltype(_impl_.phase_){nullptr}
    , decltype(_impl_.strin_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StringEventAndStatusGGIO::~StringEventAndStatusGGIO() {
  // @@protoc_insertion_point(destructor:commonmodule.StringEventAndStatusGGIO)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StringEventAndStatusGGIO::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.logicalnode_;
  if (this != internal_default_instance()) delete _impl_.phase_;
  if (this != internal_default_instance()) delete _impl_.strin_;
}

void StringEventAndStatusGGIO::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StringEventAndStatusGGIO::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.StringEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.strin_ != nullptr) {
    delete _impl_.strin_;
  }
  _impl_.strin_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StringEventAndStatusGGIO::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_logicalnode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.Optional_PhaseCodeKind Phase = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_phase(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.VSS StrIn = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_strin(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StringEventAndStatusGGIO::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.StringEventAndStatusGGIO)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::logicalnode(this),
        _Internal::logicalnode(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 2;
  if (this->_internal_has_phase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::phase(this),
        _Internal::phase(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.VSS StrIn = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_strin()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::strin(this),
        _Internal::strin(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.StringEventAndStatusGGIO)
  return target;
}

::size_t StringEventAndStatusGGIO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.StringEventAndStatusGGIO)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  if (this->_internal_has_logicalnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.logicalnode_);
  }

  // .commonmodule.Optional_PhaseCodeKind Phase = 2;
  if (this->_internal_has_phase()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.phase_);
  }

  // .commonmodule.VSS StrIn = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_strin()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.strin_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StringEventAndStatusGGIO::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StringEventAndStatusGGIO::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StringEventAndStatusGGIO::GetClassData() const { return &_class_data_; }


void StringEventAndStatusGGIO::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StringEventAndStatusGGIO*>(&to_msg);
  auto& from = static_cast<const StringEventAndStatusGGIO&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.StringEventAndStatusGGIO)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logicalnode()) {
    _this->_internal_mutable_logicalnode()->::commonmodule::LogicalNode::MergeFrom(
        from._internal_logicalnode());
  }
  if (from._internal_has_phase()) {
    _this->_internal_mutable_phase()->::commonmodule::Optional_PhaseCodeKind::MergeFrom(
        from._internal_phase());
  }
  if (from._internal_has_strin()) {
    _this->_internal_mutable_strin()->::commonmodule::VSS::MergeFrom(
        from._internal_strin());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StringEventAndStatusGGIO::CopyFrom(const StringEventAndStatusGGIO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.StringEventAndStatusGGIO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringEventAndStatusGGIO::IsInitialized() const {
  return true;
}

void StringEventAndStatusGGIO::InternalSwap(StringEventAndStatusGGIO* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StringEventAndStatusGGIO, _impl_.strin_)
      + sizeof(StringEventAndStatusGGIO::_impl_.strin_)
      - PROTOBUF_FIELD_OFFSET(StringEventAndStatusGGIO, _impl_.logicalnode_)>(
          reinterpret_cast<char*>(&_impl_.logicalnode_),
          reinterpret_cast<char*>(&other->_impl_.logicalnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StringEventAndStatusGGIO::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[131]);
}
// ===================================================================

class SwitchPoint::_Internal {
 public:
  static const ::commonmodule::ControlDPC& pos(const SwitchPoint* msg);
  static const ::commonmodule::ControlTimestamp& starttime(const SwitchPoint* msg);
};

const ::commonmodule::ControlDPC&
SwitchPoint::_Internal::pos(const SwitchPoint* msg) {
  return *msg->_impl_.pos_;
}
const ::commonmodule::ControlTimestamp&
SwitchPoint::_Internal::starttime(const SwitchPoint* msg) {
  return *msg->_impl_.starttime_;
}
SwitchPoint::SwitchPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.SwitchPoint)
}
SwitchPoint::SwitchPoint(const SwitchPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SwitchPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.starttime_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::commonmodule::ControlDPC(*from._impl_.pos_);
  }
  if (from._internal_has_starttime()) {
    _this->_impl_.starttime_ = new ::commonmodule::ControlTimestamp(*from._impl_.starttime_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.SwitchPoint)
}

inline void SwitchPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.starttime_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SwitchPoint::~SwitchPoint() {
  // @@protoc_insertion_point(destructor:commonmodule.SwitchPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SwitchPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.starttime_;
}

void SwitchPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SwitchPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.SwitchPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.starttime_ != nullptr) {
    delete _impl_.starttime_;
  }
  _impl_.starttime_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SwitchPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ControlDPC Pos = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_starttime(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SwitchPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.SwitchPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ControlDPC Pos = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_pos()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_starttime()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::starttime(this),
        _Internal::starttime(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.SwitchPoint)
  return target;
}

::size_t SwitchPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.SwitchPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ControlDPC Pos = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_pos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pos_);
  }

  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_starttime()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.starttime_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SwitchPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SwitchPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SwitchPoint::GetClassData() const { return &_class_data_; }


void SwitchPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SwitchPoint*>(&to_msg);
  auto& from = static_cast<const SwitchPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.SwitchPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pos()) {
    _this->_internal_mutable_pos()->::commonmodule::ControlDPC::MergeFrom(
        from._internal_pos());
  }
  if (from._internal_has_starttime()) {
    _this->_internal_mutable_starttime()->::commonmodule::ControlTimestamp::MergeFrom(
        from._internal_starttime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SwitchPoint::CopyFrom(const SwitchPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.SwitchPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwitchPoint::IsInitialized() const {
  return true;
}

void SwitchPoint::InternalSwap(SwitchPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SwitchPoint, _impl_.starttime_)
      + sizeof(SwitchPoint::_impl_.starttime_)
      - PROTOBUF_FIELD_OFFSET(SwitchPoint, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SwitchPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[132]);
}
// ===================================================================

class SwitchCSG::_Internal {
 public:
};

SwitchCSG::SwitchCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.SwitchCSG)
}
SwitchCSG::SwitchCSG(const SwitchCSG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SwitchCSG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){from._impl_.crvpts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.SwitchCSG)
}

inline void SwitchCSG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SwitchCSG::~SwitchCSG() {
  // @@protoc_insertion_point(destructor:commonmodule.SwitchCSG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SwitchCSG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.crvpts_.~RepeatedPtrField();
}

void SwitchCSG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SwitchCSG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.SwitchCSG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.crvpts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SwitchCSG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.SwitchPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_crvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SwitchCSG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.SwitchCSG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.SwitchPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_crvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_crvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.SwitchCSG)
  return target;
}

::size_t SwitchCSG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.SwitchCSG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.SwitchPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_crvpts_size();
  for (const auto& msg : this->_impl_.crvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SwitchCSG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SwitchCSG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SwitchCSG::GetClassData() const { return &_class_data_; }


void SwitchCSG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SwitchCSG*>(&to_msg);
  auto& from = static_cast<const SwitchCSG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.SwitchCSG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.crvpts_.MergeFrom(from._impl_.crvpts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SwitchCSG::CopyFrom(const SwitchCSG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.SwitchCSG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwitchCSG::IsInitialized() const {
  return true;
}

void SwitchCSG::InternalSwap(SwitchCSG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.crvpts_.InternalSwap(&other->_impl_.crvpts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SwitchCSG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[133]);
}
// ===================================================================

class TmHzPoint::_Internal {
 public:
  static const ::commonmodule::ClearingTime& tmval(const TmHzPoint* msg);
};

const ::commonmodule::ClearingTime&
TmHzPoint::_Internal::tmval(const TmHzPoint* msg) {
  return *msg->_impl_.tmval_;
}
TmHzPoint::TmHzPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.TmHzPoint)
}
TmHzPoint::TmHzPoint(const TmHzPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TmHzPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tmval_){nullptr}
    , decltype(_impl_.hzval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tmval()) {
    _this->_impl_.tmval_ = new ::commonmodule::ClearingTime(*from._impl_.tmval_);
  }
  _this->_impl_.hzval_ = from._impl_.hzval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.TmHzPoint)
}

inline void TmHzPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.tmval_){nullptr}
    , decltype(_impl_.hzval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TmHzPoint::~TmHzPoint() {
  // @@protoc_insertion_point(destructor:commonmodule.TmHzPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TmHzPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tmval_;
}

void TmHzPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TmHzPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.TmHzPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tmval_ != nullptr) {
    delete _impl_.tmval_;
  }
  _impl_.tmval_ = nullptr;
  _impl_.hzval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TmHzPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float hzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.hzval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.ClearingTime tmVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tmval(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TmHzPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.TmHzPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float hzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzval = this->_internal_hzval();
  ::uint32_t raw_hzval;
  memcpy(&raw_hzval, &tmp_hzval, sizeof(tmp_hzval));
  if (raw_hzval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_hzval(), target);
  }

  // .commonmodule.ClearingTime tmVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_tmval()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tmval(this),
        _Internal::tmval(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.TmHzPoint)
  return target;
}

::size_t TmHzPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.TmHzPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ClearingTime tmVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_tmval()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tmval_);
  }

  // float hzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzval = this->_internal_hzval();
  ::uint32_t raw_hzval;
  memcpy(&raw_hzval, &tmp_hzval, sizeof(tmp_hzval));
  if (raw_hzval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TmHzPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TmHzPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TmHzPoint::GetClassData() const { return &_class_data_; }


void TmHzPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TmHzPoint*>(&to_msg);
  auto& from = static_cast<const TmHzPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.TmHzPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tmval()) {
    _this->_internal_mutable_tmval()->::commonmodule::ClearingTime::MergeFrom(
        from._internal_tmval());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_hzval = from._internal_hzval();
  ::uint32_t raw_hzval;
  memcpy(&raw_hzval, &tmp_hzval, sizeof(tmp_hzval));
  if (raw_hzval != 0) {
    _this->_internal_set_hzval(from._internal_hzval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TmHzPoint::CopyFrom(const TmHzPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.TmHzPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TmHzPoint::IsInitialized() const {
  return true;
}

void TmHzPoint::InternalSwap(TmHzPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TmHzPoint, _impl_.hzval_)
      + sizeof(TmHzPoint::_impl_.hzval_)
      - PROTOBUF_FIELD_OFFSET(TmHzPoint, _impl_.tmval_)>(
          reinterpret_cast<char*>(&_impl_.tmval_),
          reinterpret_cast<char*>(&other->_impl_.tmval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TmHzPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[134]);
}
// ===================================================================

class TmHzCSG::_Internal {
 public:
};

TmHzCSG::TmHzCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.TmHzCSG)
}
TmHzCSG::TmHzCSG(const TmHzCSG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TmHzCSG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.overcrvpts_){from._impl_.overcrvpts_}
    , decltype(_impl_.undercrvpts_){from._impl_.undercrvpts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.TmHzCSG)
}

inline void TmHzCSG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.overcrvpts_){arena}
    , decltype(_impl_.undercrvpts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TmHzCSG::~TmHzCSG() {
  // @@protoc_insertion_point(destructor:commonmodule.TmHzCSG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TmHzCSG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.overcrvpts_.~RepeatedPtrField();
  _impl_.undercrvpts_.~RepeatedPtrField();
}

void TmHzCSG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TmHzCSG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.TmHzCSG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.overcrvpts_.Clear();
  _impl_.undercrvpts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TmHzCSG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.TmHzPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_overcrvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .commonmodule.TmHzPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_undercrvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TmHzCSG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.TmHzCSG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.TmHzPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_overcrvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_overcrvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .commonmodule.TmHzPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_undercrvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_undercrvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.TmHzCSG)
  return target;
}

::size_t TmHzCSG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.TmHzCSG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.TmHzPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_overcrvpts_size();
  for (const auto& msg : this->_impl_.overcrvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .commonmodule.TmHzPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_undercrvpts_size();
  for (const auto& msg : this->_impl_.undercrvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TmHzCSG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TmHzCSG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TmHzCSG::GetClassData() const { return &_class_data_; }


void TmHzCSG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TmHzCSG*>(&to_msg);
  auto& from = static_cast<const TmHzCSG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.TmHzCSG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.overcrvpts_.MergeFrom(from._impl_.overcrvpts_);
  _this->_impl_.undercrvpts_.MergeFrom(from._impl_.undercrvpts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TmHzCSG::CopyFrom(const TmHzCSG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.TmHzCSG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TmHzCSG::IsInitialized() const {
  return true;
}

void TmHzCSG::InternalSwap(TmHzCSG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.overcrvpts_.InternalSwap(&other->_impl_.overcrvpts_);
  _impl_.undercrvpts_.InternalSwap(&other->_impl_.undercrvpts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TmHzCSG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[135]);
}
// ===================================================================

class TmVoltPoint::_Internal {
 public:
  static const ::commonmodule::ClearingTime& tmval(const TmVoltPoint* msg);
};

const ::commonmodule::ClearingTime&
TmVoltPoint::_Internal::tmval(const TmVoltPoint* msg) {
  return *msg->_impl_.tmval_;
}
TmVoltPoint::TmVoltPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.TmVoltPoint)
}
TmVoltPoint::TmVoltPoint(const TmVoltPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TmVoltPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tmval_){nullptr}
    , decltype(_impl_.voltval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tmval()) {
    _this->_impl_.tmval_ = new ::commonmodule::ClearingTime(*from._impl_.tmval_);
  }
  _this->_impl_.voltval_ = from._impl_.voltval_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.TmVoltPoint)
}

inline void TmVoltPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.tmval_){nullptr}
    , decltype(_impl_.voltval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TmVoltPoint::~TmVoltPoint() {
  // @@protoc_insertion_point(destructor:commonmodule.TmVoltPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TmVoltPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tmval_;
}

void TmVoltPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TmVoltPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.TmVoltPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tmval_ != nullptr) {
    delete _impl_.tmval_;
  }
  _impl_.tmval_ = nullptr;
  _impl_.voltval_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TmVoltPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ClearingTime tmVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tmval(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.voltval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TmVoltPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.TmVoltPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ClearingTime tmVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_tmval()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tmval(this),
        _Internal::tmval(this).GetCachedSize(), target, stream);
  }

  // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = this->_internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_voltval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.TmVoltPoint)
  return target;
}

::size_t TmVoltPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.TmVoltPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ClearingTime tmVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_tmval()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tmval_);
  }

  // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = this->_internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TmVoltPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TmVoltPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TmVoltPoint::GetClassData() const { return &_class_data_; }


void TmVoltPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TmVoltPoint*>(&to_msg);
  auto& from = static_cast<const TmVoltPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.TmVoltPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tmval()) {
    _this->_internal_mutable_tmval()->::commonmodule::ClearingTime::MergeFrom(
        from._internal_tmval());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = from._internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    _this->_internal_set_voltval(from._internal_voltval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TmVoltPoint::CopyFrom(const TmVoltPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.TmVoltPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TmVoltPoint::IsInitialized() const {
  return true;
}

void TmVoltPoint::InternalSwap(TmVoltPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TmVoltPoint, _impl_.voltval_)
      + sizeof(TmVoltPoint::_impl_.voltval_)
      - PROTOBUF_FIELD_OFFSET(TmVoltPoint, _impl_.tmval_)>(
          reinterpret_cast<char*>(&_impl_.tmval_),
          reinterpret_cast<char*>(&other->_impl_.tmval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TmVoltPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[136]);
}
// ===================================================================

class TmVoltCSG::_Internal {
 public:
};

TmVoltCSG::TmVoltCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.TmVoltCSG)
}
TmVoltCSG::TmVoltCSG(const TmVoltCSG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TmVoltCSG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.overcrvpts_){from._impl_.overcrvpts_}
    , decltype(_impl_.undercrvpts_){from._impl_.undercrvpts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.TmVoltCSG)
}

inline void TmVoltCSG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.overcrvpts_){arena}
    , decltype(_impl_.undercrvpts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TmVoltCSG::~TmVoltCSG() {
  // @@protoc_insertion_point(destructor:commonmodule.TmVoltCSG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TmVoltCSG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.overcrvpts_.~RepeatedPtrField();
  _impl_.undercrvpts_.~RepeatedPtrField();
}

void TmVoltCSG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TmVoltCSG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.TmVoltCSG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.overcrvpts_.Clear();
  _impl_.undercrvpts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TmVoltCSG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.TmVoltPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_overcrvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .commonmodule.TmVoltPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_undercrvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TmVoltCSG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.TmVoltCSG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.TmVoltPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_overcrvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_overcrvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .commonmodule.TmVoltPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_undercrvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_undercrvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.TmVoltCSG)
  return target;
}

::size_t TmVoltCSG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.TmVoltCSG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.TmVoltPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_overcrvpts_size();
  for (const auto& msg : this->_impl_.overcrvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .commonmodule.TmVoltPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_undercrvpts_size();
  for (const auto& msg : this->_impl_.undercrvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TmVoltCSG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TmVoltCSG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TmVoltCSG::GetClassData() const { return &_class_data_; }


void TmVoltCSG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TmVoltCSG*>(&to_msg);
  auto& from = static_cast<const TmVoltCSG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.TmVoltCSG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.overcrvpts_.MergeFrom(from._impl_.overcrvpts_);
  _this->_impl_.undercrvpts_.MergeFrom(from._impl_.undercrvpts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TmVoltCSG::CopyFrom(const TmVoltCSG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.TmVoltCSG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TmVoltCSG::IsInitialized() const {
  return true;
}

void TmVoltCSG::InternalSwap(TmVoltCSG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.overcrvpts_.InternalSwap(&other->_impl_.overcrvpts_);
  _impl_.undercrvpts_.InternalSwap(&other->_impl_.undercrvpts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TmVoltCSG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[137]);
}
// ===================================================================

class VarSPC::_Internal {
 public:
  static const ::commonmodule::OperationDVAR& varparameter(const VarSPC* msg);
};

const ::commonmodule::OperationDVAR&
VarSPC::_Internal::varparameter(const VarSPC* msg) {
  return *msg->_impl_.varparameter_;
}
VarSPC::VarSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.VarSPC)
}
VarSPC::VarSPC(const VarSPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VarSPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.varparameter_){nullptr}
    , decltype(_impl_.modena_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_varparameter()) {
    _this->_impl_.varparameter_ = new ::commonmodule::OperationDVAR(*from._impl_.varparameter_);
  }
  _this->_impl_.modena_ = from._impl_.modena_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.VarSPC)
}

inline void VarSPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.varparameter_){nullptr}
    , decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VarSPC::~VarSPC() {
  // @@protoc_insertion_point(destructor:commonmodule.VarSPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VarSPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.varparameter_;
}

void VarSPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VarSPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.VarSPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.varparameter_ != nullptr) {
    delete _impl_.varparameter_;
  }
  _impl_.varparameter_ = nullptr;
  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VarSPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDVAR varParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_varparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VarSPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.VarSPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  // .commonmodule.OperationDVAR varParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_varparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::varparameter(this),
        _Internal::varparameter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.VarSPC)
  return target;
}

::size_t VarSPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.VarSPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.OperationDVAR varParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_varparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.varparameter_);
  }

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VarSPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VarSPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VarSPC::GetClassData() const { return &_class_data_; }


void VarSPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VarSPC*>(&to_msg);
  auto& from = static_cast<const VarSPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.VarSPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_varparameter()) {
    _this->_internal_mutable_varparameter()->::commonmodule::OperationDVAR::MergeFrom(
        from._internal_varparameter());
  }
  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VarSPC::CopyFrom(const VarSPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.VarSPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VarSPC::IsInitialized() const {
  return true;
}

void VarSPC::InternalSwap(VarSPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VarSPC, _impl_.modena_)
      + sizeof(VarSPC::_impl_.modena_)
      - PROTOBUF_FIELD_OFFSET(VarSPC, _impl_.varparameter_)>(
          reinterpret_cast<char*>(&_impl_.varparameter_),
          reinterpret_cast<char*>(&other->_impl_.varparameter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VarSPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[138]);
}
// ===================================================================

class VoltVarPoint::_Internal {
 public:
};

VoltVarPoint::VoltVarPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.VoltVarPoint)
}
VoltVarPoint::VoltVarPoint(const VoltVarPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.VoltVarPoint)
}

inline void VoltVarPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.varval_) { 0 }

    , decltype(_impl_.voltval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VoltVarPoint::~VoltVarPoint() {
  // @@protoc_insertion_point(destructor:commonmodule.VoltVarPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VoltVarPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void VoltVarPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VoltVarPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.VoltVarPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.varval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.voltval_) -
      reinterpret_cast<char*>(&_impl_.varval_)) + sizeof(_impl_.voltval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VoltVarPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.varval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.voltval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VoltVarPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.VoltVarPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_varval = this->_internal_varval();
  ::uint32_t raw_varval;
  memcpy(&raw_varval, &tmp_varval, sizeof(tmp_varval));
  if (raw_varval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_varval(), target);
  }

  // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = this->_internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_voltval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.VoltVarPoint)
  return target;
}

::size_t VoltVarPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.VoltVarPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_varval = this->_internal_varval();
  ::uint32_t raw_varval;
  memcpy(&raw_varval, &tmp_varval, sizeof(tmp_varval));
  if (raw_varval != 0) {
    total_size += 5;
  }

  // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = this->_internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VoltVarPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VoltVarPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VoltVarPoint::GetClassData() const { return &_class_data_; }


void VoltVarPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VoltVarPoint*>(&to_msg);
  auto& from = static_cast<const VoltVarPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.VoltVarPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_varval = from._internal_varval();
  ::uint32_t raw_varval;
  memcpy(&raw_varval, &tmp_varval, sizeof(tmp_varval));
  if (raw_varval != 0) {
    _this->_internal_set_varval(from._internal_varval());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = from._internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    _this->_internal_set_voltval(from._internal_voltval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VoltVarPoint::CopyFrom(const VoltVarPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.VoltVarPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoltVarPoint::IsInitialized() const {
  return true;
}

void VoltVarPoint::InternalSwap(VoltVarPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VoltVarPoint, _impl_.voltval_)
      + sizeof(VoltVarPoint::_impl_.voltval_)
      - PROTOBUF_FIELD_OFFSET(VoltVarPoint, _impl_.varval_)>(
          reinterpret_cast<char*>(&_impl_.varval_),
          reinterpret_cast<char*>(&other->_impl_.varval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VoltVarPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[139]);
}
// ===================================================================

class VoltVarCSG::_Internal {
 public:
  static const ::commonmodule::OperationDVVR& vvarparameter(const VoltVarCSG* msg);
};

const ::commonmodule::OperationDVVR&
VoltVarCSG::_Internal::vvarparameter(const VoltVarCSG* msg) {
  return *msg->_impl_.vvarparameter_;
}
VoltVarCSG::VoltVarCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.VoltVarCSG)
}
VoltVarCSG::VoltVarCSG(const VoltVarCSG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VoltVarCSG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){from._impl_.crvpts_}
    , decltype(_impl_.vvarparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_vvarparameter()) {
    _this->_impl_.vvarparameter_ = new ::commonmodule::OperationDVVR(*from._impl_.vvarparameter_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.VoltVarCSG)
}

inline void VoltVarCSG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){arena}
    , decltype(_impl_.vvarparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VoltVarCSG::~VoltVarCSG() {
  // @@protoc_insertion_point(destructor:commonmodule.VoltVarCSG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VoltVarCSG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.crvpts_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.vvarparameter_;
}

void VoltVarCSG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VoltVarCSG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.VoltVarCSG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.crvpts_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.vvarparameter_ != nullptr) {
    delete _impl_.vvarparameter_;
  }
  _impl_.vvarparameter_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VoltVarCSG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.VoltVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_crvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDVVR vVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_vvarparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VoltVarCSG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.VoltVarCSG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.VoltVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_crvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_crvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .commonmodule.OperationDVVR vVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vvarparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::vvarparameter(this),
        _Internal::vvarparameter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.VoltVarCSG)
  return target;
}

::size_t VoltVarCSG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.VoltVarCSG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.VoltVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_crvpts_size();
  for (const auto& msg : this->_impl_.crvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .commonmodule.OperationDVVR vVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_vvarparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vvarparameter_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VoltVarCSG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VoltVarCSG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VoltVarCSG::GetClassData() const { return &_class_data_; }


void VoltVarCSG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VoltVarCSG*>(&to_msg);
  auto& from = static_cast<const VoltVarCSG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.VoltVarCSG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.crvpts_.MergeFrom(from._impl_.crvpts_);
  if (from._internal_has_vvarparameter()) {
    _this->_internal_mutable_vvarparameter()->::commonmodule::OperationDVVR::MergeFrom(
        from._internal_vvarparameter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VoltVarCSG::CopyFrom(const VoltVarCSG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.VoltVarCSG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoltVarCSG::IsInitialized() const {
  return true;
}

void VoltVarCSG::InternalSwap(VoltVarCSG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.crvpts_.InternalSwap(&other->_impl_.crvpts_);
  swap(_impl_.vvarparameter_, other->_impl_.vvarparameter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VoltVarCSG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[140]);
}
// ===================================================================

class VoltWPoint::_Internal {
 public:
};

VoltWPoint::VoltWPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.VoltWPoint)
}
VoltWPoint::VoltWPoint(const VoltWPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.VoltWPoint)
}

inline void VoltWPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.voltval_) { 0 }

    , decltype(_impl_.wval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VoltWPoint::~VoltWPoint() {
  // @@protoc_insertion_point(destructor:commonmodule.VoltWPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VoltWPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void VoltWPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VoltWPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.VoltWPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.voltval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.wval_) -
      reinterpret_cast<char*>(&_impl_.voltval_)) + sizeof(_impl_.wval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VoltWPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float voltVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.voltval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.wval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VoltWPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.VoltWPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float voltVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = this->_internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_voltval(), target);
  }

  // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wval = this->_internal_wval();
  ::uint32_t raw_wval;
  memcpy(&raw_wval, &tmp_wval, sizeof(tmp_wval));
  if (raw_wval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_wval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.VoltWPoint)
  return target;
}

::size_t VoltWPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.VoltWPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float voltVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = this->_internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    total_size += 5;
  }

  // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wval = this->_internal_wval();
  ::uint32_t raw_wval;
  memcpy(&raw_wval, &tmp_wval, sizeof(tmp_wval));
  if (raw_wval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VoltWPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VoltWPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VoltWPoint::GetClassData() const { return &_class_data_; }


void VoltWPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VoltWPoint*>(&to_msg);
  auto& from = static_cast<const VoltWPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.VoltWPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_voltval = from._internal_voltval();
  ::uint32_t raw_voltval;
  memcpy(&raw_voltval, &tmp_voltval, sizeof(tmp_voltval));
  if (raw_voltval != 0) {
    _this->_internal_set_voltval(from._internal_voltval());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wval = from._internal_wval();
  ::uint32_t raw_wval;
  memcpy(&raw_wval, &tmp_wval, sizeof(tmp_wval));
  if (raw_wval != 0) {
    _this->_internal_set_wval(from._internal_wval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VoltWPoint::CopyFrom(const VoltWPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.VoltWPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoltWPoint::IsInitialized() const {
  return true;
}

void VoltWPoint::InternalSwap(VoltWPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VoltWPoint, _impl_.wval_)
      + sizeof(VoltWPoint::_impl_.wval_)
      - PROTOBUF_FIELD_OFFSET(VoltWPoint, _impl_.voltval_)>(
          reinterpret_cast<char*>(&_impl_.voltval_),
          reinterpret_cast<char*>(&other->_impl_.voltval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VoltWPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[141]);
}
// ===================================================================

class VoltWCSG::_Internal {
 public:
  static const ::commonmodule::OperationDVWC& voltwparameter(const VoltWCSG* msg);
};

const ::commonmodule::OperationDVWC&
VoltWCSG::_Internal::voltwparameter(const VoltWCSG* msg) {
  return *msg->_impl_.voltwparameter_;
}
VoltWCSG::VoltWCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.VoltWCSG)
}
VoltWCSG::VoltWCSG(const VoltWCSG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VoltWCSG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){from._impl_.crvpts_}
    , decltype(_impl_.voltwparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_voltwparameter()) {
    _this->_impl_.voltwparameter_ = new ::commonmodule::OperationDVWC(*from._impl_.voltwparameter_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.VoltWCSG)
}

inline void VoltWCSG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){arena}
    , decltype(_impl_.voltwparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VoltWCSG::~VoltWCSG() {
  // @@protoc_insertion_point(destructor:commonmodule.VoltWCSG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VoltWCSG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.crvpts_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.voltwparameter_;
}

void VoltWCSG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VoltWCSG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.VoltWCSG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.crvpts_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.voltwparameter_ != nullptr) {
    delete _impl_.voltwparameter_;
  }
  _impl_.voltwparameter_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VoltWCSG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.VoltWPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_crvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDVWC voltWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_voltwparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VoltWCSG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.VoltWCSG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.VoltWPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_crvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_crvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .commonmodule.OperationDVWC voltWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_voltwparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::voltwparameter(this),
        _Internal::voltwparameter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.VoltWCSG)
  return target;
}

::size_t VoltWCSG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.VoltWCSG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.VoltWPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_crvpts_size();
  for (const auto& msg : this->_impl_.crvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .commonmodule.OperationDVWC voltWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_voltwparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.voltwparameter_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VoltWCSG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VoltWCSG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VoltWCSG::GetClassData() const { return &_class_data_; }


void VoltWCSG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VoltWCSG*>(&to_msg);
  auto& from = static_cast<const VoltWCSG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.VoltWCSG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.crvpts_.MergeFrom(from._impl_.crvpts_);
  if (from._internal_has_voltwparameter()) {
    _this->_internal_mutable_voltwparameter()->::commonmodule::OperationDVWC::MergeFrom(
        from._internal_voltwparameter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VoltWCSG::CopyFrom(const VoltWCSG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.VoltWCSG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoltWCSG::IsInitialized() const {
  return true;
}

void VoltWCSG::InternalSwap(VoltWCSG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.crvpts_.InternalSwap(&other->_impl_.crvpts_);
  swap(_impl_.voltwparameter_, other->_impl_.voltwparameter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VoltWCSG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[142]);
}
// ===================================================================

class VSC::_Internal {
 public:
};

VSC::VSC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.VSC)
}
VSC::VSC(const VSC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VSC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ctlval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ctlval_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ctlval_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ctlval().empty()) {
    _this->_impl_.ctlval_.Set(from._internal_ctlval(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.VSC)
}

inline void VSC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ctlval_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ctlval_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ctlval_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VSC::~VSC() {
  // @@protoc_insertion_point(destructor:commonmodule.VSC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VSC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ctlval_.Destroy();
}

void VSC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VSC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.VSC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctlval_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VSC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ctlval();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "commonmodule.VSC.ctlVal"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VSC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.VSC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_ctlval().empty()) {
    const std::string& _s = this->_internal_ctlval();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "commonmodule.VSC.ctlVal");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.VSC)
  return target;
}

::size_t VSC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.VSC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (!this->_internal_ctlval().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ctlval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VSC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VSC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VSC::GetClassData() const { return &_class_data_; }


void VSC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VSC*>(&to_msg);
  auto& from = static_cast<const VSC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.VSC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ctlval().empty()) {
    _this->_internal_set_ctlval(from._internal_ctlval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VSC::CopyFrom(const VSC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.VSC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VSC::IsInitialized() const {
  return true;
}

void VSC::InternalSwap(VSC* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ctlval_, lhs_arena,
                                       &other->_impl_.ctlval_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata VSC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[143]);
}
// ===================================================================

class WSPC::_Internal {
 public:
  static const ::commonmodule::OperationDWGC& wparameter(const WSPC* msg);
};

const ::commonmodule::OperationDWGC&
WSPC::_Internal::wparameter(const WSPC* msg) {
  return *msg->_impl_.wparameter_;
}
WSPC::WSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.WSPC)
}
WSPC::WSPC(const WSPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WSPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.wparameter_){nullptr}
    , decltype(_impl_.modena_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_wparameter()) {
    _this->_impl_.wparameter_ = new ::commonmodule::OperationDWGC(*from._impl_.wparameter_);
  }
  _this->_impl_.modena_ = from._impl_.modena_;
  // @@protoc_insertion_point(copy_constructor:commonmodule.WSPC)
}

inline void WSPC::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.wparameter_){nullptr}
    , decltype(_impl_.modena_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WSPC::~WSPC() {
  // @@protoc_insertion_point(destructor:commonmodule.WSPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WSPC::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.wparameter_;
}

void WSPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WSPC::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.WSPC)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.wparameter_ != nullptr) {
    delete _impl_.wparameter_;
  }
  _impl_.wparameter_ = nullptr;
  _impl_.modena_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WSPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.modena_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDWGC wParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_wparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WSPC::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.WSPC)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_modena(), target);
  }

  // .commonmodule.OperationDWGC wParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::wparameter(this),
        _Internal::wparameter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.WSPC)
  return target;
}

::size_t WSPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.WSPC)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.OperationDWGC wParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wparameter_);
  }

  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_modena() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WSPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WSPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WSPC::GetClassData() const { return &_class_data_; }


void WSPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WSPC*>(&to_msg);
  auto& from = static_cast<const WSPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.WSPC)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_wparameter()) {
    _this->_internal_mutable_wparameter()->::commonmodule::OperationDWGC::MergeFrom(
        from._internal_wparameter());
  }
  if (from._internal_modena() != 0) {
    _this->_internal_set_modena(from._internal_modena());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WSPC::CopyFrom(const WSPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.WSPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSPC::IsInitialized() const {
  return true;
}

void WSPC::InternalSwap(WSPC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WSPC, _impl_.modena_)
      + sizeof(WSPC::_impl_.modena_)
      - PROTOBUF_FIELD_OFFSET(WSPC, _impl_.wparameter_)>(
          reinterpret_cast<char*>(&_impl_.wparameter_),
          reinterpret_cast<char*>(&other->_impl_.wparameter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WSPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[144]);
}
// ===================================================================

class WVarPoint::_Internal {
 public:
};

WVarPoint::WVarPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.WVarPoint)
}
WVarPoint::WVarPoint(const WVarPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.WVarPoint)
}

inline void WVarPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.varval_) { 0 }

    , decltype(_impl_.wval_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WVarPoint::~WVarPoint() {
  // @@protoc_insertion_point(destructor:commonmodule.WVarPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WVarPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void WVarPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WVarPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.WVarPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.varval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.wval_) -
      reinterpret_cast<char*>(&_impl_.varval_)) + sizeof(_impl_.wval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WVarPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.varval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.wval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WVarPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.WVarPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_varval = this->_internal_varval();
  ::uint32_t raw_varval;
  memcpy(&raw_varval, &tmp_varval, sizeof(tmp_varval));
  if (raw_varval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_varval(), target);
  }

  // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wval = this->_internal_wval();
  ::uint32_t raw_wval;
  memcpy(&raw_wval, &tmp_wval, sizeof(tmp_wval));
  if (raw_wval != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_wval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.WVarPoint)
  return target;
}

::size_t WVarPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.WVarPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_varval = this->_internal_varval();
  ::uint32_t raw_varval;
  memcpy(&raw_varval, &tmp_varval, sizeof(tmp_varval));
  if (raw_varval != 0) {
    total_size += 5;
  }

  // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wval = this->_internal_wval();
  ::uint32_t raw_wval;
  memcpy(&raw_wval, &tmp_wval, sizeof(tmp_wval));
  if (raw_wval != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WVarPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WVarPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WVarPoint::GetClassData() const { return &_class_data_; }


void WVarPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WVarPoint*>(&to_msg);
  auto& from = static_cast<const WVarPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.WVarPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_varval = from._internal_varval();
  ::uint32_t raw_varval;
  memcpy(&raw_varval, &tmp_varval, sizeof(tmp_varval));
  if (raw_varval != 0) {
    _this->_internal_set_varval(from._internal_varval());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_wval = from._internal_wval();
  ::uint32_t raw_wval;
  memcpy(&raw_wval, &tmp_wval, sizeof(tmp_wval));
  if (raw_wval != 0) {
    _this->_internal_set_wval(from._internal_wval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WVarPoint::CopyFrom(const WVarPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.WVarPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WVarPoint::IsInitialized() const {
  return true;
}

void WVarPoint::InternalSwap(WVarPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WVarPoint, _impl_.wval_)
      + sizeof(WVarPoint::_impl_.wval_)
      - PROTOBUF_FIELD_OFFSET(WVarPoint, _impl_.varval_)>(
          reinterpret_cast<char*>(&_impl_.varval_),
          reinterpret_cast<char*>(&other->_impl_.varval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WVarPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[145]);
}
// ===================================================================

class WVarCSG::_Internal {
 public:
  static const ::commonmodule::OperationDWVR& wvarparameter(const WVarCSG* msg);
};

const ::commonmodule::OperationDWVR&
WVarCSG::_Internal::wvarparameter(const WVarCSG* msg) {
  return *msg->_impl_.wvarparameter_;
}
WVarCSG::WVarCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.WVarCSG)
}
WVarCSG::WVarCSG(const WVarCSG& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WVarCSG* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){from._impl_.crvpts_}
    , decltype(_impl_.wvarparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_wvarparameter()) {
    _this->_impl_.wvarparameter_ = new ::commonmodule::OperationDWVR(*from._impl_.wvarparameter_);
  }
  // @@protoc_insertion_point(copy_constructor:commonmodule.WVarCSG)
}

inline void WVarCSG::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.crvpts_){arena}
    , decltype(_impl_.wvarparameter_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WVarCSG::~WVarCSG() {
  // @@protoc_insertion_point(destructor:commonmodule.WVarCSG)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WVarCSG::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.crvpts_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.wvarparameter_;
}

void WVarCSG::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WVarCSG::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.WVarCSG)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.crvpts_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.wvarparameter_ != nullptr) {
    delete _impl_.wvarparameter_;
  }
  _impl_.wvarparameter_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WVarCSG::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .commonmodule.WVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_crvpts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .commonmodule.OperationDWVR wVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_wvarparameter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WVarCSG::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.WVarCSG)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .commonmodule.WVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_crvpts_size()); i < n; i++) {
    const auto& repfield = this->_internal_crvpts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .commonmodule.OperationDWVR wVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wvarparameter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::wvarparameter(this),
        _Internal::wvarparameter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.WVarCSG)
  return target;
}

::size_t WVarCSG::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.WVarCSG)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .commonmodule.WVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  total_size += 1UL * this->_internal_crvpts_size();
  for (const auto& msg : this->_impl_.crvpts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .commonmodule.OperationDWVR wVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  if (this->_internal_has_wvarparameter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.wvarparameter_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WVarCSG::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WVarCSG::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WVarCSG::GetClassData() const { return &_class_data_; }


void WVarCSG::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WVarCSG*>(&to_msg);
  auto& from = static_cast<const WVarCSG&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.WVarCSG)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.crvpts_.MergeFrom(from._impl_.crvpts_);
  if (from._internal_has_wvarparameter()) {
    _this->_internal_mutable_wvarparameter()->::commonmodule::OperationDWVR::MergeFrom(
        from._internal_wvarparameter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WVarCSG::CopyFrom(const WVarCSG& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.WVarCSG)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WVarCSG::IsInitialized() const {
  return true;
}

void WVarCSG::InternalSwap(WVarCSG* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.crvpts_.InternalSwap(&other->_impl_.crvpts_);
  swap(_impl_.wvarparameter_, other->_impl_.wvarparameter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WVarCSG::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[146]);
}
// ===================================================================

class Optional_AlrmKind::_Internal {
 public:
};

Optional_AlrmKind::Optional_AlrmKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_AlrmKind)
}
Optional_AlrmKind::Optional_AlrmKind(const Optional_AlrmKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_AlrmKind)
}

inline void Optional_AlrmKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_AlrmKind::~Optional_AlrmKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_AlrmKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_AlrmKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_AlrmKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_AlrmKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_AlrmKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_AlrmKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.AlrmKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::AlrmKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_AlrmKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_AlrmKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.AlrmKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_AlrmKind)
  return target;
}

::size_t Optional_AlrmKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_AlrmKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.AlrmKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_AlrmKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_AlrmKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_AlrmKind::GetClassData() const { return &_class_data_; }


void Optional_AlrmKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_AlrmKind*>(&to_msg);
  auto& from = static_cast<const Optional_AlrmKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_AlrmKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_AlrmKind::CopyFrom(const Optional_AlrmKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_AlrmKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_AlrmKind::IsInitialized() const {
  return true;
}

void Optional_AlrmKind::InternalSwap(Optional_AlrmKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_AlrmKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[147]);
}
// ===================================================================

class Optional_ControlModeKind::_Internal {
 public:
};

Optional_ControlModeKind::Optional_ControlModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_ControlModeKind)
}
Optional_ControlModeKind::Optional_ControlModeKind(const Optional_ControlModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_ControlModeKind)
}

inline void Optional_ControlModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_ControlModeKind::~Optional_ControlModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_ControlModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_ControlModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_ControlModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_ControlModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_ControlModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_ControlModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ControlModeKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::ControlModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_ControlModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_ControlModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ControlModeKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_ControlModeKind)
  return target;
}

::size_t Optional_ControlModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_ControlModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ControlModeKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_ControlModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_ControlModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_ControlModeKind::GetClassData() const { return &_class_data_; }


void Optional_ControlModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_ControlModeKind*>(&to_msg);
  auto& from = static_cast<const Optional_ControlModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_ControlModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_ControlModeKind::CopyFrom(const Optional_ControlModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_ControlModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_ControlModeKind::IsInitialized() const {
  return true;
}

void Optional_ControlModeKind::InternalSwap(Optional_ControlModeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_ControlModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[148]);
}
// ===================================================================

class Optional_DirectionModeKind::_Internal {
 public:
};

Optional_DirectionModeKind::Optional_DirectionModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_DirectionModeKind)
}
Optional_DirectionModeKind::Optional_DirectionModeKind(const Optional_DirectionModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_DirectionModeKind)
}

inline void Optional_DirectionModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_DirectionModeKind::~Optional_DirectionModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_DirectionModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_DirectionModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_DirectionModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_DirectionModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_DirectionModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_DirectionModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.DirectionModeKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::DirectionModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_DirectionModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_DirectionModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.DirectionModeKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_DirectionModeKind)
  return target;
}

::size_t Optional_DirectionModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_DirectionModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.DirectionModeKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_DirectionModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_DirectionModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_DirectionModeKind::GetClassData() const { return &_class_data_; }


void Optional_DirectionModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_DirectionModeKind*>(&to_msg);
  auto& from = static_cast<const Optional_DirectionModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_DirectionModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_DirectionModeKind::CopyFrom(const Optional_DirectionModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_DirectionModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_DirectionModeKind::IsInitialized() const {
  return true;
}

void Optional_DirectionModeKind::InternalSwap(Optional_DirectionModeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_DirectionModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[149]);
}
// ===================================================================

class Optional_GridConnectionStateKind::_Internal {
 public:
};

Optional_GridConnectionStateKind::Optional_GridConnectionStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_GridConnectionStateKind)
}
Optional_GridConnectionStateKind::Optional_GridConnectionStateKind(const Optional_GridConnectionStateKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_GridConnectionStateKind)
}

inline void Optional_GridConnectionStateKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_GridConnectionStateKind::~Optional_GridConnectionStateKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_GridConnectionStateKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_GridConnectionStateKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_GridConnectionStateKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_GridConnectionStateKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_GridConnectionStateKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_GridConnectionStateKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.GridConnectionStateKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::GridConnectionStateKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_GridConnectionStateKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_GridConnectionStateKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.GridConnectionStateKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_GridConnectionStateKind)
  return target;
}

::size_t Optional_GridConnectionStateKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_GridConnectionStateKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.GridConnectionStateKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_GridConnectionStateKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_GridConnectionStateKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_GridConnectionStateKind::GetClassData() const { return &_class_data_; }


void Optional_GridConnectionStateKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_GridConnectionStateKind*>(&to_msg);
  auto& from = static_cast<const Optional_GridConnectionStateKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_GridConnectionStateKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_GridConnectionStateKind::CopyFrom(const Optional_GridConnectionStateKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_GridConnectionStateKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_GridConnectionStateKind::IsInitialized() const {
  return true;
}

void Optional_GridConnectionStateKind::InternalSwap(Optional_GridConnectionStateKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_GridConnectionStateKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[150]);
}
// ===================================================================

class Optional_OperatingStateKind::_Internal {
 public:
};

Optional_OperatingStateKind::Optional_OperatingStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_OperatingStateKind)
}
Optional_OperatingStateKind::Optional_OperatingStateKind(const Optional_OperatingStateKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_OperatingStateKind)
}

inline void Optional_OperatingStateKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_OperatingStateKind::~Optional_OperatingStateKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_OperatingStateKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_OperatingStateKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_OperatingStateKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_OperatingStateKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_OperatingStateKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_OperatingStateKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.OperatingStateKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::OperatingStateKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_OperatingStateKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_OperatingStateKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.OperatingStateKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_OperatingStateKind)
  return target;
}

::size_t Optional_OperatingStateKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_OperatingStateKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.OperatingStateKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_OperatingStateKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_OperatingStateKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_OperatingStateKind::GetClassData() const { return &_class_data_; }


void Optional_OperatingStateKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_OperatingStateKind*>(&to_msg);
  auto& from = static_cast<const Optional_OperatingStateKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_OperatingStateKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_OperatingStateKind::CopyFrom(const Optional_OperatingStateKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_OperatingStateKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_OperatingStateKind::IsInitialized() const {
  return true;
}

void Optional_OperatingStateKind::InternalSwap(Optional_OperatingStateKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_OperatingStateKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[151]);
}
// ===================================================================

class Optional_ReactivePowerControlKind::_Internal {
 public:
};

Optional_ReactivePowerControlKind::Optional_ReactivePowerControlKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_ReactivePowerControlKind)
}
Optional_ReactivePowerControlKind::Optional_ReactivePowerControlKind(const Optional_ReactivePowerControlKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_ReactivePowerControlKind)
}

inline void Optional_ReactivePowerControlKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_ReactivePowerControlKind::~Optional_ReactivePowerControlKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_ReactivePowerControlKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_ReactivePowerControlKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_ReactivePowerControlKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_ReactivePowerControlKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_ReactivePowerControlKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_ReactivePowerControlKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.ReactivePowerControlKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::ReactivePowerControlKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_ReactivePowerControlKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_ReactivePowerControlKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.ReactivePowerControlKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_ReactivePowerControlKind)
  return target;
}

::size_t Optional_ReactivePowerControlKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_ReactivePowerControlKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.ReactivePowerControlKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_ReactivePowerControlKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_ReactivePowerControlKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_ReactivePowerControlKind::GetClassData() const { return &_class_data_; }


void Optional_ReactivePowerControlKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_ReactivePowerControlKind*>(&to_msg);
  auto& from = static_cast<const Optional_ReactivePowerControlKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_ReactivePowerControlKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_ReactivePowerControlKind::CopyFrom(const Optional_ReactivePowerControlKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_ReactivePowerControlKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_ReactivePowerControlKind::IsInitialized() const {
  return true;
}

void Optional_ReactivePowerControlKind::InternalSwap(Optional_ReactivePowerControlKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_ReactivePowerControlKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[152]);
}
// ===================================================================

class Optional_RealPowerControlKind::_Internal {
 public:
};

Optional_RealPowerControlKind::Optional_RealPowerControlKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_RealPowerControlKind)
}
Optional_RealPowerControlKind::Optional_RealPowerControlKind(const Optional_RealPowerControlKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_RealPowerControlKind)
}

inline void Optional_RealPowerControlKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_RealPowerControlKind::~Optional_RealPowerControlKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_RealPowerControlKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_RealPowerControlKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_RealPowerControlKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_RealPowerControlKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_RealPowerControlKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_RealPowerControlKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.RealPowerControlKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::RealPowerControlKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_RealPowerControlKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_RealPowerControlKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.RealPowerControlKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_RealPowerControlKind)
  return target;
}

::size_t Optional_RealPowerControlKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_RealPowerControlKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.RealPowerControlKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_RealPowerControlKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_RealPowerControlKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_RealPowerControlKind::GetClassData() const { return &_class_data_; }


void Optional_RealPowerControlKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_RealPowerControlKind*>(&to_msg);
  auto& from = static_cast<const Optional_RealPowerControlKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_RealPowerControlKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_RealPowerControlKind::CopyFrom(const Optional_RealPowerControlKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_RealPowerControlKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_RealPowerControlKind::IsInitialized() const {
  return true;
}

void Optional_RealPowerControlKind::InternalSwap(Optional_RealPowerControlKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_RealPowerControlKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[153]);
}
// ===================================================================

class Optional_StateKind::_Internal {
 public:
};

Optional_StateKind::Optional_StateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_StateKind)
}
Optional_StateKind::Optional_StateKind(const Optional_StateKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_StateKind)
}

inline void Optional_StateKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_StateKind::~Optional_StateKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_StateKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_StateKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_StateKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_StateKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_StateKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_StateKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.StateKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::StateKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_StateKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_StateKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.StateKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_StateKind)
  return target;
}

::size_t Optional_StateKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_StateKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.StateKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_StateKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_StateKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_StateKind::GetClassData() const { return &_class_data_; }


void Optional_StateKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_StateKind*>(&to_msg);
  auto& from = static_cast<const Optional_StateKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_StateKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_StateKind::CopyFrom(const Optional_StateKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_StateKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_StateKind::IsInitialized() const {
  return true;
}

void Optional_StateKind::InternalSwap(Optional_StateKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_StateKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[154]);
}
// ===================================================================

class Optional_VoltLimitModeKind::_Internal {
 public:
};

Optional_VoltLimitModeKind::Optional_VoltLimitModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:commonmodule.Optional_VoltLimitModeKind)
}
Optional_VoltLimitModeKind::Optional_VoltLimitModeKind(const Optional_VoltLimitModeKind& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:commonmodule.Optional_VoltLimitModeKind)
}

inline void Optional_VoltLimitModeKind::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.value_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Optional_VoltLimitModeKind::~Optional_VoltLimitModeKind() {
  // @@protoc_insertion_point(destructor:commonmodule.Optional_VoltLimitModeKind)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optional_VoltLimitModeKind::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Optional_VoltLimitModeKind::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Optional_VoltLimitModeKind::Clear() {
// @@protoc_insertion_point(message_clear_start:commonmodule.Optional_VoltLimitModeKind)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional_VoltLimitModeKind::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .commonmodule.VoltLimitModeKind value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::commonmodule::VoltLimitModeKind>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Optional_VoltLimitModeKind::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:commonmodule.Optional_VoltLimitModeKind)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .commonmodule.VoltLimitModeKind value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:commonmodule.Optional_VoltLimitModeKind)
  return target;
}

::size_t Optional_VoltLimitModeKind::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:commonmodule.Optional_VoltLimitModeKind)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .commonmodule.VoltLimitModeKind value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional_VoltLimitModeKind::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Optional_VoltLimitModeKind::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional_VoltLimitModeKind::GetClassData() const { return &_class_data_; }


void Optional_VoltLimitModeKind::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Optional_VoltLimitModeKind*>(&to_msg);
  auto& from = static_cast<const Optional_VoltLimitModeKind&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:commonmodule.Optional_VoltLimitModeKind)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional_VoltLimitModeKind::CopyFrom(const Optional_VoltLimitModeKind& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:commonmodule.Optional_VoltLimitModeKind)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional_VoltLimitModeKind::IsInitialized() const {
  return true;
}

void Optional_VoltLimitModeKind::InternalSwap(Optional_VoltLimitModeKind* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional_VoltLimitModeKind::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_commonmodule_2fcommonmodule_2eproto_getter, &descriptor_table_commonmodule_2fcommonmodule_2eproto_once,
      file_level_metadata_commonmodule_2fcommonmodule_2eproto[155]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace commonmodule
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_FaultDirectionKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_FaultDirectionKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_FaultDirectionKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_PhaseFaultDirectionKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_PhaseFaultDirectionKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_PhaseFaultDirectionKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ACD*
Arena::CreateMaybeMessage< ::commonmodule::ACD >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ACD >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::IdentifiedObject*
Arena::CreateMaybeMessage< ::commonmodule::IdentifiedObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::IdentifiedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ACDCTerminal*
Arena::CreateMaybeMessage< ::commonmodule::ACDCTerminal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ACDCTerminal >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_UnitSymbolKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_UnitSymbolKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_UnitSymbolKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_UnitMultiplierKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_UnitMultiplierKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_UnitMultiplierKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ActivePower*
Arena::CreateMaybeMessage< ::commonmodule::ActivePower >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ActivePower >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_PhaseCodeKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_PhaseCodeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_PhaseCodeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Unit*
Arena::CreateMaybeMessage< ::commonmodule::Unit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Unit >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_ValidityKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_ValidityKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_ValidityKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::DetailQual*
Arena::CreateMaybeMessage< ::commonmodule::DetailQual >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::DetailQual >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_SourceKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_SourceKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_SourceKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Quality*
Arena::CreateMaybeMessage< ::commonmodule::Quality >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Quality >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_TimeAccuracyKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_TimeAccuracyKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_TimeAccuracyKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::TimeQuality*
Arena::CreateMaybeMessage< ::commonmodule::TimeQuality >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::TimeQuality >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Timestamp*
Arena::CreateMaybeMessage< ::commonmodule::Timestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Timestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::MV*
Arena::CreateMaybeMessage< ::commonmodule::MV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::MV >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::LogicalNode*
Arena::CreateMaybeMessage< ::commonmodule::LogicalNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::LogicalNode >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::AnalogEventAndStatusGGIO*
Arena::CreateMaybeMessage< ::commonmodule::AnalogEventAndStatusGGIO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::AnalogEventAndStatusGGIO >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::NamedObject*
Arena::CreateMaybeMessage< ::commonmodule::NamedObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::NamedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ApplicationSystem*
Arena::CreateMaybeMessage< ::commonmodule::ApplicationSystem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ApplicationSystem >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ASG*
Arena::CreateMaybeMessage< ::commonmodule::ASG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ASG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::BCR*
Arena::CreateMaybeMessage< ::commonmodule::BCR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::BCR >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusSPS*
Arena::CreateMaybeMessage< ::commonmodule::StatusSPS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusSPS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::BooleanEventAndStatusGGIO*
Arena::CreateMaybeMessage< ::commonmodule::BooleanEventAndStatusGGIO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::BooleanEventAndStatusGGIO >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::MessageInfo*
Arena::CreateMaybeMessage< ::commonmodule::MessageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::MessageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::CapabilityMessageInfo*
Arena::CreateMaybeMessage< ::commonmodule::CapabilityMessageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::CapabilityMessageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::CheckConditions*
Arena::CreateMaybeMessage< ::commonmodule::CheckConditions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::CheckConditions >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ClearingTime*
Arena::CreateMaybeMessage< ::commonmodule::ClearingTime >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ClearingTime >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Vector*
Arena::CreateMaybeMessage< ::commonmodule::Vector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Vector >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::CMV*
Arena::CreateMaybeMessage< ::commonmodule::CMV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::CMV >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ConductingEquipment*
Arena::CreateMaybeMessage< ::commonmodule::ConductingEquipment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ConductingEquipment >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Terminal*
Arena::CreateMaybeMessage< ::commonmodule::Terminal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Terminal >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ConductingEquipmentTerminalReading*
Arena::CreateMaybeMessage< ::commonmodule::ConductingEquipmentTerminalReading >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ConductingEquipmentTerminalReading >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlAPC*
Arena::CreateMaybeMessage< ::commonmodule::ControlAPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlAPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlDPC*
Arena::CreateMaybeMessage< ::commonmodule::ControlDPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlDPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlTimestamp*
Arena::CreateMaybeMessage< ::commonmodule::ControlTimestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlTimestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_ScheduleParameterKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_ScheduleParameterKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_ScheduleParameterKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENG_ScheduleParameter*
Arena::CreateMaybeMessage< ::commonmodule::ENG_ScheduleParameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENG_ScheduleParameter >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::SchedulePoint*
Arena::CreateMaybeMessage< ::commonmodule::SchedulePoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::SchedulePoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ScheduleCSG*
Arena::CreateMaybeMessage< ::commonmodule::ScheduleCSG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ScheduleCSG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlScheduleFSCH*
Arena::CreateMaybeMessage< ::commonmodule::ControlScheduleFSCH >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlScheduleFSCH >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::LogicalNodeForControl*
Arena::CreateMaybeMessage< ::commonmodule::LogicalNodeForControl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::LogicalNodeForControl >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlFSCC*
Arena::CreateMaybeMessage< ::commonmodule::ControlFSCC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlFSCC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlINC*
Arena::CreateMaybeMessage< ::commonmodule::ControlINC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlINC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlING*
Arena::CreateMaybeMessage< ::commonmodule::ControlING >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlING >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlISC*
Arena::CreateMaybeMessage< ::commonmodule::ControlISC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlISC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlMessageInfo*
Arena::CreateMaybeMessage< ::commonmodule::ControlMessageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlMessageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlSPC*
Arena::CreateMaybeMessage< ::commonmodule::ControlSPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlSPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ControlValue*
Arena::CreateMaybeMessage< ::commonmodule::ControlValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ControlValue >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::CumulativeTime*
Arena::CreateMaybeMessage< ::commonmodule::CumulativeTime >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::CumulativeTime >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::DateTimeInterval*
Arena::CreateMaybeMessage< ::commonmodule::DateTimeInterval >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::DateTimeInterval >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::DEL*
Arena::CreateMaybeMessage< ::commonmodule::DEL >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::DEL >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseDPC*
Arena::CreateMaybeMessage< ::commonmodule::PhaseDPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseDPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::DiscreteControlXCBR*
Arena::CreateMaybeMessage< ::commonmodule::DiscreteControlXCBR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::DiscreteControlXCBR >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::EnergyConsumer*
Arena::CreateMaybeMessage< ::commonmodule::EnergyConsumer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::EnergyConsumer >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_CalcMethodKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_CalcMethodKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_CalcMethodKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENG_CalcMethodKind*
Arena::CreateMaybeMessage< ::commonmodule::ENG_CalcMethodKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENG_CalcMethodKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_GridConnectModeKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_GridConnectModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_GridConnectModeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENG_GridConnectModeKind*
Arena::CreateMaybeMessage< ::commonmodule::ENG_GridConnectModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENG_GridConnectModeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_PFSignKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_PFSignKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_PFSignKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENG_PFSignKind*
Arena::CreateMaybeMessage< ::commonmodule::ENG_PFSignKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENG_PFSignKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_BehaviourModeKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_BehaviourModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_BehaviourModeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENS_BehaviourModeKind*
Arena::CreateMaybeMessage< ::commonmodule::ENS_BehaviourModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENS_BehaviourModeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_DERGeneratorStateKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_DERGeneratorStateKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_DERGeneratorStateKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENS_DERGeneratorStateKind*
Arena::CreateMaybeMessage< ::commonmodule::ENS_DERGeneratorStateKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENS_DERGeneratorStateKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_DynamicTestKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_DynamicTestKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_DynamicTestKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENS_DynamicTestKind*
Arena::CreateMaybeMessage< ::commonmodule::ENS_DynamicTestKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENS_DynamicTestKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENS_GridConnectModeKind*
Arena::CreateMaybeMessage< ::commonmodule::ENS_GridConnectModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENS_GridConnectModeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_HealthKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_HealthKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_HealthKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENS_HealthKind*
Arena::CreateMaybeMessage< ::commonmodule::ENS_HealthKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENS_HealthKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_SwitchingCapabilityKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_SwitchingCapabilityKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_SwitchingCapabilityKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ENS_SwitchingCapabilityKind*
Arena::CreateMaybeMessage< ::commonmodule::ENS_SwitchingCapabilityKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ENS_SwitchingCapabilityKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDCTE*
Arena::CreateMaybeMessage< ::commonmodule::OperationDCTE >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDCTE >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::EnterServiceAPC*
Arena::CreateMaybeMessage< ::commonmodule::EnterServiceAPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::EnterServiceAPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ESS*
Arena::CreateMaybeMessage< ::commonmodule::ESS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ESS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::EventMessageInfo*
Arena::CreateMaybeMessage< ::commonmodule::EventMessageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::EventMessageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::EventValue*
Arena::CreateMaybeMessage< ::commonmodule::EventValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::EventValue >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ForecastValueSource*
Arena::CreateMaybeMessage< ::commonmodule::ForecastValueSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ForecastValueSource >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ForecastIED*
Arena::CreateMaybeMessage< ::commonmodule::ForecastIED >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ForecastIED >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ForecastValue*
Arena::CreateMaybeMessage< ::commonmodule::ForecastValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ForecastValue >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDHFW*
Arena::CreateMaybeMessage< ::commonmodule::OperationDHFW >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDHFW >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDLFW*
Arena::CreateMaybeMessage< ::commonmodule::OperationDLFW >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDLFW >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::HzWPoint*
Arena::CreateMaybeMessage< ::commonmodule::HzWPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::HzWPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::HzWAPC*
Arena::CreateMaybeMessage< ::commonmodule::HzWAPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::HzWAPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusINS*
Arena::CreateMaybeMessage< ::commonmodule::StatusINS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusINS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::IntegerEventAndStatusGGIO*
Arena::CreateMaybeMessage< ::commonmodule::IntegerEventAndStatusGGIO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::IntegerEventAndStatusGGIO >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDWMX*
Arena::CreateMaybeMessage< ::commonmodule::OperationDWMX >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDWMX >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDWMN*
Arena::CreateMaybeMessage< ::commonmodule::OperationDWMN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDWMN >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::LimitWAPC*
Arena::CreateMaybeMessage< ::commonmodule::LimitWAPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::LimitWAPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::LogicalNodeForEventAndStatus*
Arena::CreateMaybeMessage< ::commonmodule::LogicalNodeForEventAndStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::LogicalNodeForEventAndStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::MeasurementValue*
Arena::CreateMaybeMessage< ::commonmodule::MeasurementValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::MeasurementValue >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Meter*
Arena::CreateMaybeMessage< ::commonmodule::Meter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Meter >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::NameplateValue*
Arena::CreateMaybeMessage< ::commonmodule::NameplateValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::NameplateValue >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDFPF*
Arena::CreateMaybeMessage< ::commonmodule::OperationDFPF >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDFPF >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDVAR*
Arena::CreateMaybeMessage< ::commonmodule::OperationDVAR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDVAR >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDVVR*
Arena::CreateMaybeMessage< ::commonmodule::OperationDVVR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDVVR >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDVWC*
Arena::CreateMaybeMessage< ::commonmodule::OperationDVWC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDVWC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDWGC*
Arena::CreateMaybeMessage< ::commonmodule::OperationDWGC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDWGC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OperationDWVR*
Arena::CreateMaybeMessage< ::commonmodule::OperationDWVR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OperationDWVR >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::OptimizationMessageInfo*
Arena::CreateMaybeMessage< ::commonmodule::OptimizationMessageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::OptimizationMessageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PFSPC*
Arena::CreateMaybeMessage< ::commonmodule::PFSPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PFSPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseAPC*
Arena::CreateMaybeMessage< ::commonmodule::PhaseAPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseAPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_DbPosKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_DbPosKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_DbPosKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusDPS*
Arena::CreateMaybeMessage< ::commonmodule::StatusDPS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusDPS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseDPS*
Arena::CreateMaybeMessage< ::commonmodule::PhaseDPS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseDPS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseINS*
Arena::CreateMaybeMessage< ::commonmodule::PhaseINS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseINS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseISC*
Arena::CreateMaybeMessage< ::commonmodule::PhaseISC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseISC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ReadingMMTN*
Arena::CreateMaybeMessage< ::commonmodule::ReadingMMTN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ReadingMMTN >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseMMTN*
Arena::CreateMaybeMessage< ::commonmodule::PhaseMMTN >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseMMTN >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_RecloseActionKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_RecloseActionKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_RecloseActionKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseRecloseAction*
Arena::CreateMaybeMessage< ::commonmodule::PhaseRecloseAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseRecloseAction >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseSPC*
Arena::CreateMaybeMessage< ::commonmodule::PhaseSPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseSPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PhaseSPS*
Arena::CreateMaybeMessage< ::commonmodule::PhaseSPS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PhaseSPS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::PMG*
Arena::CreateMaybeMessage< ::commonmodule::PMG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::PMG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::RampRate*
Arena::CreateMaybeMessage< ::commonmodule::RampRate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::RampRate >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ReadingMessageInfo*
Arena::CreateMaybeMessage< ::commonmodule::ReadingMessageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ReadingMessageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ReadingMMTR*
Arena::CreateMaybeMessage< ::commonmodule::ReadingMMTR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ReadingMMTR >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::WYE*
Arena::CreateMaybeMessage< ::commonmodule::WYE >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::WYE >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::ReadingMMXU*
Arena::CreateMaybeMessage< ::commonmodule::ReadingMMXU >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::ReadingMMXU >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::SourceCapabilityConfiguration*
Arena::CreateMaybeMessage< ::commonmodule::SourceCapabilityConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::SourceCapabilityConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_NorOpCatKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_NorOpCatKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_NorOpCatKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_AbnOpCatKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_AbnOpCatKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_AbnOpCatKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::SourceCapabilityRatings*
Arena::CreateMaybeMessage< ::commonmodule::SourceCapabilityRatings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::SourceCapabilityRatings >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusAndEventXCBR*
Arena::CreateMaybeMessage< ::commonmodule::StatusAndEventXCBR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusAndEventXCBR >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusINC*
Arena::CreateMaybeMessage< ::commonmodule::StatusINC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusINC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusISC*
Arena::CreateMaybeMessage< ::commonmodule::StatusISC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusISC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusMessageInfo*
Arena::CreateMaybeMessage< ::commonmodule::StatusMessageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusMessageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StatusValue*
Arena::CreateMaybeMessage< ::commonmodule::StatusValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StatusValue >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::VSS*
Arena::CreateMaybeMessage< ::commonmodule::VSS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::VSS >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::StringEventAndStatusGGIO*
Arena::CreateMaybeMessage< ::commonmodule::StringEventAndStatusGGIO >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::StringEventAndStatusGGIO >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::SwitchPoint*
Arena::CreateMaybeMessage< ::commonmodule::SwitchPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::SwitchPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::SwitchCSG*
Arena::CreateMaybeMessage< ::commonmodule::SwitchCSG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::SwitchCSG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::TmHzPoint*
Arena::CreateMaybeMessage< ::commonmodule::TmHzPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::TmHzPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::TmHzCSG*
Arena::CreateMaybeMessage< ::commonmodule::TmHzCSG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::TmHzCSG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::TmVoltPoint*
Arena::CreateMaybeMessage< ::commonmodule::TmVoltPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::TmVoltPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::TmVoltCSG*
Arena::CreateMaybeMessage< ::commonmodule::TmVoltCSG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::TmVoltCSG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::VarSPC*
Arena::CreateMaybeMessage< ::commonmodule::VarSPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::VarSPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::VoltVarPoint*
Arena::CreateMaybeMessage< ::commonmodule::VoltVarPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::VoltVarPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::VoltVarCSG*
Arena::CreateMaybeMessage< ::commonmodule::VoltVarCSG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::VoltVarCSG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::VoltWPoint*
Arena::CreateMaybeMessage< ::commonmodule::VoltWPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::VoltWPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::VoltWCSG*
Arena::CreateMaybeMessage< ::commonmodule::VoltWCSG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::VoltWCSG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::VSC*
Arena::CreateMaybeMessage< ::commonmodule::VSC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::VSC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::WSPC*
Arena::CreateMaybeMessage< ::commonmodule::WSPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::WSPC >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::WVarPoint*
Arena::CreateMaybeMessage< ::commonmodule::WVarPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::WVarPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::WVarCSG*
Arena::CreateMaybeMessage< ::commonmodule::WVarCSG >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::WVarCSG >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_AlrmKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_AlrmKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_AlrmKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_ControlModeKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_ControlModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_ControlModeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_DirectionModeKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_DirectionModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_DirectionModeKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_GridConnectionStateKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_GridConnectionStateKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_GridConnectionStateKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_OperatingStateKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_OperatingStateKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_OperatingStateKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_ReactivePowerControlKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_ReactivePowerControlKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_ReactivePowerControlKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_RealPowerControlKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_RealPowerControlKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_RealPowerControlKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_StateKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_StateKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_StateKind >(arena);
}
template<> PROTOBUF_NOINLINE ::commonmodule::Optional_VoltLimitModeKind*
Arena::CreateMaybeMessage< ::commonmodule::Optional_VoltLimitModeKind >(Arena* arena) {
  return Arena::CreateMessageInternal< ::commonmodule::Optional_VoltLimitModeKind >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
