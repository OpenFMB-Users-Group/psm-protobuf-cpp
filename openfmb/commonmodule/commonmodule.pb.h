// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commonmodule/commonmodule.proto

#ifndef PROTOBUF_INCLUDED_commonmodule_2fcommonmodule_2eproto
#define PROTOBUF_INCLUDED_commonmodule_2fcommonmodule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "uml.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_commonmodule_2fcommonmodule_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_commonmodule_2fcommonmodule_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[97]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_commonmodule_2fcommonmodule_2eproto();
namespace commonmodule {
class ACDCTerminal;
class ACDCTerminalDefaultTypeInternal;
extern ACDCTerminalDefaultTypeInternal _ACDCTerminal_default_instance_;
class ASG;
class ASGDefaultTypeInternal;
extern ASGDefaultTypeInternal _ASG_default_instance_;
class ActivePower;
class ActivePowerDefaultTypeInternal;
extern ActivePowerDefaultTypeInternal _ActivePower_default_instance_;
class AnalogStatusGGIO;
class AnalogStatusGGIODefaultTypeInternal;
extern AnalogStatusGGIODefaultTypeInternal _AnalogStatusGGIO_default_instance_;
class AnalogueValue;
class AnalogueValueDefaultTypeInternal;
extern AnalogueValueDefaultTypeInternal _AnalogueValue_default_instance_;
class AnalogueValueCtl;
class AnalogueValueCtlDefaultTypeInternal;
extern AnalogueValueCtlDefaultTypeInternal _AnalogueValueCtl_default_instance_;
class ApplicationSystem;
class ApplicationSystemDefaultTypeInternal;
extern ApplicationSystemDefaultTypeInternal _ApplicationSystem_default_instance_;
class BCR;
class BCRDefaultTypeInternal;
extern BCRDefaultTypeInternal _BCR_default_instance_;
class BooleanStatusGGIO;
class BooleanStatusGGIODefaultTypeInternal;
extern BooleanStatusGGIODefaultTypeInternal _BooleanStatusGGIO_default_instance_;
class CMV;
class CMVDefaultTypeInternal;
extern CMVDefaultTypeInternal _CMV_default_instance_;
class CheckConditions;
class CheckConditionsDefaultTypeInternal;
extern CheckConditionsDefaultTypeInternal _CheckConditions_default_instance_;
class ConductingEquipment;
class ConductingEquipmentDefaultTypeInternal;
extern ConductingEquipmentDefaultTypeInternal _ConductingEquipment_default_instance_;
class ConductingEquipmentTerminalReading;
class ConductingEquipmentTerminalReadingDefaultTypeInternal;
extern ConductingEquipmentTerminalReadingDefaultTypeInternal _ConductingEquipmentTerminalReading_default_instance_;
class ControlDPC;
class ControlDPCDefaultTypeInternal;
extern ControlDPCDefaultTypeInternal _ControlDPC_default_instance_;
class ControlFSCC;
class ControlFSCCDefaultTypeInternal;
extern ControlFSCCDefaultTypeInternal _ControlFSCC_default_instance_;
class ControlING;
class ControlINGDefaultTypeInternal;
extern ControlINGDefaultTypeInternal _ControlING_default_instance_;
class ControlISC;
class ControlISCDefaultTypeInternal;
extern ControlISCDefaultTypeInternal _ControlISC_default_instance_;
class ControlMessageInfo;
class ControlMessageInfoDefaultTypeInternal;
extern ControlMessageInfoDefaultTypeInternal _ControlMessageInfo_default_instance_;
class ControlSPC;
class ControlSPCDefaultTypeInternal;
extern ControlSPCDefaultTypeInternal _ControlSPC_default_instance_;
class ControlScheduleFSCH;
class ControlScheduleFSCHDefaultTypeInternal;
extern ControlScheduleFSCHDefaultTypeInternal _ControlScheduleFSCH_default_instance_;
class ControlTimestamp;
class ControlTimestampDefaultTypeInternal;
extern ControlTimestampDefaultTypeInternal _ControlTimestamp_default_instance_;
class ControlValue;
class ControlValueDefaultTypeInternal;
extern ControlValueDefaultTypeInternal _ControlValue_default_instance_;
class DEL;
class DELDefaultTypeInternal;
extern DELDefaultTypeInternal _DEL_default_instance_;
class DateTimeInterval;
class DateTimeIntervalDefaultTypeInternal;
extern DateTimeIntervalDefaultTypeInternal _DateTimeInterval_default_instance_;
class DetailQual;
class DetailQualDefaultTypeInternal;
extern DetailQualDefaultTypeInternal _DetailQual_default_instance_;
class ENG_CalcMethodKind;
class ENG_CalcMethodKindDefaultTypeInternal;
extern ENG_CalcMethodKindDefaultTypeInternal _ENG_CalcMethodKind_default_instance_;
class ENG_GridConnectModeKind;
class ENG_GridConnectModeKindDefaultTypeInternal;
extern ENG_GridConnectModeKindDefaultTypeInternal _ENG_GridConnectModeKind_default_instance_;
class ENG_PFSignKind;
class ENG_PFSignKindDefaultTypeInternal;
extern ENG_PFSignKindDefaultTypeInternal _ENG_PFSignKind_default_instance_;
class ENG_ScheduleParameter;
class ENG_ScheduleParameterDefaultTypeInternal;
extern ENG_ScheduleParameterDefaultTypeInternal _ENG_ScheduleParameter_default_instance_;
class ENS_BehaviourModeKind;
class ENS_BehaviourModeKindDefaultTypeInternal;
extern ENS_BehaviourModeKindDefaultTypeInternal _ENS_BehaviourModeKind_default_instance_;
class ENS_DERGeneratorStateKind;
class ENS_DERGeneratorStateKindDefaultTypeInternal;
extern ENS_DERGeneratorStateKindDefaultTypeInternal _ENS_DERGeneratorStateKind_default_instance_;
class ENS_DynamicTestKind;
class ENS_DynamicTestKindDefaultTypeInternal;
extern ENS_DynamicTestKindDefaultTypeInternal _ENS_DynamicTestKind_default_instance_;
class ENS_GridConnectModeKind;
class ENS_GridConnectModeKindDefaultTypeInternal;
extern ENS_GridConnectModeKindDefaultTypeInternal _ENS_GridConnectModeKind_default_instance_;
class ENS_HealthKind;
class ENS_HealthKindDefaultTypeInternal;
extern ENS_HealthKindDefaultTypeInternal _ENS_HealthKind_default_instance_;
class ESS;
class ESSDefaultTypeInternal;
extern ESSDefaultTypeInternal _ESS_default_instance_;
class EnergyConsumer;
class EnergyConsumerDefaultTypeInternal;
extern EnergyConsumerDefaultTypeInternal _EnergyConsumer_default_instance_;
class EventMessageInfo;
class EventMessageInfoDefaultTypeInternal;
extern EventMessageInfoDefaultTypeInternal _EventMessageInfo_default_instance_;
class EventValue;
class EventValueDefaultTypeInternal;
extern EventValueDefaultTypeInternal _EventValue_default_instance_;
class ForecastIED;
class ForecastIEDDefaultTypeInternal;
extern ForecastIEDDefaultTypeInternal _ForecastIED_default_instance_;
class ForecastValue;
class ForecastValueDefaultTypeInternal;
extern ForecastValueDefaultTypeInternal _ForecastValue_default_instance_;
class ForecastValueSource;
class ForecastValueSourceDefaultTypeInternal;
extern ForecastValueSourceDefaultTypeInternal _ForecastValueSource_default_instance_;
class IED;
class IEDDefaultTypeInternal;
extern IEDDefaultTypeInternal _IED_default_instance_;
class IdentifiedObject;
class IdentifiedObjectDefaultTypeInternal;
extern IdentifiedObjectDefaultTypeInternal _IdentifiedObject_default_instance_;
class IntegerStatusGGIO;
class IntegerStatusGGIODefaultTypeInternal;
extern IntegerStatusGGIODefaultTypeInternal _IntegerStatusGGIO_default_instance_;
class LogicalNode;
class LogicalNodeDefaultTypeInternal;
extern LogicalNodeDefaultTypeInternal _LogicalNode_default_instance_;
class LogicalNodeForControl;
class LogicalNodeForControlDefaultTypeInternal;
extern LogicalNodeForControlDefaultTypeInternal _LogicalNodeForControl_default_instance_;
class LogicalNodeForEventAndStatus;
class LogicalNodeForEventAndStatusDefaultTypeInternal;
extern LogicalNodeForEventAndStatusDefaultTypeInternal _LogicalNodeForEventAndStatus_default_instance_;
class MV;
class MVDefaultTypeInternal;
extern MVDefaultTypeInternal _MV_default_instance_;
class MeasurementValue;
class MeasurementValueDefaultTypeInternal;
extern MeasurementValueDefaultTypeInternal _MeasurementValue_default_instance_;
class MessageInfo;
class MessageInfoDefaultTypeInternal;
extern MessageInfoDefaultTypeInternal _MessageInfo_default_instance_;
class Meter;
class MeterDefaultTypeInternal;
extern MeterDefaultTypeInternal _Meter_default_instance_;
class NamedObject;
class NamedObjectDefaultTypeInternal;
extern NamedObjectDefaultTypeInternal _NamedObject_default_instance_;
class OptimizationMessageInfo;
class OptimizationMessageInfoDefaultTypeInternal;
extern OptimizationMessageInfoDefaultTypeInternal _OptimizationMessageInfo_default_instance_;
class Optional_BehaviourModeKind;
class Optional_BehaviourModeKindDefaultTypeInternal;
extern Optional_BehaviourModeKindDefaultTypeInternal _Optional_BehaviourModeKind_default_instance_;
class Optional_CalcMethodKind;
class Optional_CalcMethodKindDefaultTypeInternal;
extern Optional_CalcMethodKindDefaultTypeInternal _Optional_CalcMethodKind_default_instance_;
class Optional_DERGeneratorStateKind;
class Optional_DERGeneratorStateKindDefaultTypeInternal;
extern Optional_DERGeneratorStateKindDefaultTypeInternal _Optional_DERGeneratorStateKind_default_instance_;
class Optional_DbPosKind;
class Optional_DbPosKindDefaultTypeInternal;
extern Optional_DbPosKindDefaultTypeInternal _Optional_DbPosKind_default_instance_;
class Optional_DynamicTestKind;
class Optional_DynamicTestKindDefaultTypeInternal;
extern Optional_DynamicTestKindDefaultTypeInternal _Optional_DynamicTestKind_default_instance_;
class Optional_GridConnectModeKind;
class Optional_GridConnectModeKindDefaultTypeInternal;
extern Optional_GridConnectModeKindDefaultTypeInternal _Optional_GridConnectModeKind_default_instance_;
class Optional_HealthKind;
class Optional_HealthKindDefaultTypeInternal;
extern Optional_HealthKindDefaultTypeInternal _Optional_HealthKind_default_instance_;
class Optional_PFSignKind;
class Optional_PFSignKindDefaultTypeInternal;
extern Optional_PFSignKindDefaultTypeInternal _Optional_PFSignKind_default_instance_;
class Optional_PhaseCodeKind;
class Optional_PhaseCodeKindDefaultTypeInternal;
extern Optional_PhaseCodeKindDefaultTypeInternal _Optional_PhaseCodeKind_default_instance_;
class Optional_ScheduleParameterKind;
class Optional_ScheduleParameterKindDefaultTypeInternal;
extern Optional_ScheduleParameterKindDefaultTypeInternal _Optional_ScheduleParameterKind_default_instance_;
class Optional_SourceKind;
class Optional_SourceKindDefaultTypeInternal;
extern Optional_SourceKindDefaultTypeInternal _Optional_SourceKind_default_instance_;
class Optional_StateKind;
class Optional_StateKindDefaultTypeInternal;
extern Optional_StateKindDefaultTypeInternal _Optional_StateKind_default_instance_;
class Optional_TimeAccuracyKind;
class Optional_TimeAccuracyKindDefaultTypeInternal;
extern Optional_TimeAccuracyKindDefaultTypeInternal _Optional_TimeAccuracyKind_default_instance_;
class Optional_UnitMultiplierKind;
class Optional_UnitMultiplierKindDefaultTypeInternal;
extern Optional_UnitMultiplierKindDefaultTypeInternal _Optional_UnitMultiplierKind_default_instance_;
class Optional_UnitSymbolKind;
class Optional_UnitSymbolKindDefaultTypeInternal;
extern Optional_UnitSymbolKindDefaultTypeInternal _Optional_UnitSymbolKind_default_instance_;
class Optional_ValidityKind;
class Optional_ValidityKindDefaultTypeInternal;
extern Optional_ValidityKindDefaultTypeInternal _Optional_ValidityKind_default_instance_;
class PhaseMMTN;
class PhaseMMTNDefaultTypeInternal;
extern PhaseMMTNDefaultTypeInternal _PhaseMMTN_default_instance_;
class Quality;
class QualityDefaultTypeInternal;
extern QualityDefaultTypeInternal _Quality_default_instance_;
class RampRate;
class RampRateDefaultTypeInternal;
extern RampRateDefaultTypeInternal _RampRate_default_instance_;
class ReadingMMTN;
class ReadingMMTNDefaultTypeInternal;
extern ReadingMMTNDefaultTypeInternal _ReadingMMTN_default_instance_;
class ReadingMMTR;
class ReadingMMTRDefaultTypeInternal;
extern ReadingMMTRDefaultTypeInternal _ReadingMMTR_default_instance_;
class ReadingMMXU;
class ReadingMMXUDefaultTypeInternal;
extern ReadingMMXUDefaultTypeInternal _ReadingMMXU_default_instance_;
class ReadingMessageInfo;
class ReadingMessageInfoDefaultTypeInternal;
extern ReadingMessageInfoDefaultTypeInternal _ReadingMessageInfo_default_instance_;
class ScheduleCSG;
class ScheduleCSGDefaultTypeInternal;
extern ScheduleCSGDefaultTypeInternal _ScheduleCSG_default_instance_;
class SchedulePoint;
class SchedulePointDefaultTypeInternal;
extern SchedulePointDefaultTypeInternal _SchedulePoint_default_instance_;
class StatusAndEventXCBR;
class StatusAndEventXCBRDefaultTypeInternal;
extern StatusAndEventXCBRDefaultTypeInternal _StatusAndEventXCBR_default_instance_;
class StatusDPS;
class StatusDPSDefaultTypeInternal;
extern StatusDPSDefaultTypeInternal _StatusDPS_default_instance_;
class StatusINS;
class StatusINSDefaultTypeInternal;
extern StatusINSDefaultTypeInternal _StatusINS_default_instance_;
class StatusISC;
class StatusISCDefaultTypeInternal;
extern StatusISCDefaultTypeInternal _StatusISC_default_instance_;
class StatusMessageInfo;
class StatusMessageInfoDefaultTypeInternal;
extern StatusMessageInfoDefaultTypeInternal _StatusMessageInfo_default_instance_;
class StatusSPC;
class StatusSPCDefaultTypeInternal;
extern StatusSPCDefaultTypeInternal _StatusSPC_default_instance_;
class StatusSPS;
class StatusSPSDefaultTypeInternal;
extern StatusSPSDefaultTypeInternal _StatusSPS_default_instance_;
class StatusValue;
class StatusValueDefaultTypeInternal;
extern StatusValueDefaultTypeInternal _StatusValue_default_instance_;
class StringStatusGGIO;
class StringStatusGGIODefaultTypeInternal;
extern StringStatusGGIODefaultTypeInternal _StringStatusGGIO_default_instance_;
class SwitchCSG;
class SwitchCSGDefaultTypeInternal;
extern SwitchCSGDefaultTypeInternal _SwitchCSG_default_instance_;
class SwitchControlScheduleFSCH;
class SwitchControlScheduleFSCHDefaultTypeInternal;
extern SwitchControlScheduleFSCHDefaultTypeInternal _SwitchControlScheduleFSCH_default_instance_;
class SwitchPoint;
class SwitchPointDefaultTypeInternal;
extern SwitchPointDefaultTypeInternal _SwitchPoint_default_instance_;
class Terminal;
class TerminalDefaultTypeInternal;
extern TerminalDefaultTypeInternal _Terminal_default_instance_;
class TimeQuality;
class TimeQualityDefaultTypeInternal;
extern TimeQualityDefaultTypeInternal _TimeQuality_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class Unit;
class UnitDefaultTypeInternal;
extern UnitDefaultTypeInternal _Unit_default_instance_;
class VSS;
class VSSDefaultTypeInternal;
extern VSSDefaultTypeInternal _VSS_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class WYE;
class WYEDefaultTypeInternal;
extern WYEDefaultTypeInternal _WYE_default_instance_;
}  // namespace commonmodule
namespace google {
namespace protobuf {
template<> ::commonmodule::ACDCTerminal* Arena::CreateMaybeMessage<::commonmodule::ACDCTerminal>(Arena*);
template<> ::commonmodule::ASG* Arena::CreateMaybeMessage<::commonmodule::ASG>(Arena*);
template<> ::commonmodule::ActivePower* Arena::CreateMaybeMessage<::commonmodule::ActivePower>(Arena*);
template<> ::commonmodule::AnalogStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::AnalogStatusGGIO>(Arena*);
template<> ::commonmodule::AnalogueValue* Arena::CreateMaybeMessage<::commonmodule::AnalogueValue>(Arena*);
template<> ::commonmodule::AnalogueValueCtl* Arena::CreateMaybeMessage<::commonmodule::AnalogueValueCtl>(Arena*);
template<> ::commonmodule::ApplicationSystem* Arena::CreateMaybeMessage<::commonmodule::ApplicationSystem>(Arena*);
template<> ::commonmodule::BCR* Arena::CreateMaybeMessage<::commonmodule::BCR>(Arena*);
template<> ::commonmodule::BooleanStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::BooleanStatusGGIO>(Arena*);
template<> ::commonmodule::CMV* Arena::CreateMaybeMessage<::commonmodule::CMV>(Arena*);
template<> ::commonmodule::CheckConditions* Arena::CreateMaybeMessage<::commonmodule::CheckConditions>(Arena*);
template<> ::commonmodule::ConductingEquipment* Arena::CreateMaybeMessage<::commonmodule::ConductingEquipment>(Arena*);
template<> ::commonmodule::ConductingEquipmentTerminalReading* Arena::CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(Arena*);
template<> ::commonmodule::ControlDPC* Arena::CreateMaybeMessage<::commonmodule::ControlDPC>(Arena*);
template<> ::commonmodule::ControlFSCC* Arena::CreateMaybeMessage<::commonmodule::ControlFSCC>(Arena*);
template<> ::commonmodule::ControlING* Arena::CreateMaybeMessage<::commonmodule::ControlING>(Arena*);
template<> ::commonmodule::ControlISC* Arena::CreateMaybeMessage<::commonmodule::ControlISC>(Arena*);
template<> ::commonmodule::ControlMessageInfo* Arena::CreateMaybeMessage<::commonmodule::ControlMessageInfo>(Arena*);
template<> ::commonmodule::ControlSPC* Arena::CreateMaybeMessage<::commonmodule::ControlSPC>(Arena*);
template<> ::commonmodule::ControlScheduleFSCH* Arena::CreateMaybeMessage<::commonmodule::ControlScheduleFSCH>(Arena*);
template<> ::commonmodule::ControlTimestamp* Arena::CreateMaybeMessage<::commonmodule::ControlTimestamp>(Arena*);
template<> ::commonmodule::ControlValue* Arena::CreateMaybeMessage<::commonmodule::ControlValue>(Arena*);
template<> ::commonmodule::DEL* Arena::CreateMaybeMessage<::commonmodule::DEL>(Arena*);
template<> ::commonmodule::DateTimeInterval* Arena::CreateMaybeMessage<::commonmodule::DateTimeInterval>(Arena*);
template<> ::commonmodule::DetailQual* Arena::CreateMaybeMessage<::commonmodule::DetailQual>(Arena*);
template<> ::commonmodule::ENG_CalcMethodKind* Arena::CreateMaybeMessage<::commonmodule::ENG_CalcMethodKind>(Arena*);
template<> ::commonmodule::ENG_GridConnectModeKind* Arena::CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(Arena*);
template<> ::commonmodule::ENG_PFSignKind* Arena::CreateMaybeMessage<::commonmodule::ENG_PFSignKind>(Arena*);
template<> ::commonmodule::ENG_ScheduleParameter* Arena::CreateMaybeMessage<::commonmodule::ENG_ScheduleParameter>(Arena*);
template<> ::commonmodule::ENS_BehaviourModeKind* Arena::CreateMaybeMessage<::commonmodule::ENS_BehaviourModeKind>(Arena*);
template<> ::commonmodule::ENS_DERGeneratorStateKind* Arena::CreateMaybeMessage<::commonmodule::ENS_DERGeneratorStateKind>(Arena*);
template<> ::commonmodule::ENS_DynamicTestKind* Arena::CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(Arena*);
template<> ::commonmodule::ENS_GridConnectModeKind* Arena::CreateMaybeMessage<::commonmodule::ENS_GridConnectModeKind>(Arena*);
template<> ::commonmodule::ENS_HealthKind* Arena::CreateMaybeMessage<::commonmodule::ENS_HealthKind>(Arena*);
template<> ::commonmodule::ESS* Arena::CreateMaybeMessage<::commonmodule::ESS>(Arena*);
template<> ::commonmodule::EnergyConsumer* Arena::CreateMaybeMessage<::commonmodule::EnergyConsumer>(Arena*);
template<> ::commonmodule::EventMessageInfo* Arena::CreateMaybeMessage<::commonmodule::EventMessageInfo>(Arena*);
template<> ::commonmodule::EventValue* Arena::CreateMaybeMessage<::commonmodule::EventValue>(Arena*);
template<> ::commonmodule::ForecastIED* Arena::CreateMaybeMessage<::commonmodule::ForecastIED>(Arena*);
template<> ::commonmodule::ForecastValue* Arena::CreateMaybeMessage<::commonmodule::ForecastValue>(Arena*);
template<> ::commonmodule::ForecastValueSource* Arena::CreateMaybeMessage<::commonmodule::ForecastValueSource>(Arena*);
template<> ::commonmodule::IED* Arena::CreateMaybeMessage<::commonmodule::IED>(Arena*);
template<> ::commonmodule::IdentifiedObject* Arena::CreateMaybeMessage<::commonmodule::IdentifiedObject>(Arena*);
template<> ::commonmodule::IntegerStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::IntegerStatusGGIO>(Arena*);
template<> ::commonmodule::LogicalNode* Arena::CreateMaybeMessage<::commonmodule::LogicalNode>(Arena*);
template<> ::commonmodule::LogicalNodeForControl* Arena::CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(Arena*);
template<> ::commonmodule::LogicalNodeForEventAndStatus* Arena::CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(Arena*);
template<> ::commonmodule::MV* Arena::CreateMaybeMessage<::commonmodule::MV>(Arena*);
template<> ::commonmodule::MeasurementValue* Arena::CreateMaybeMessage<::commonmodule::MeasurementValue>(Arena*);
template<> ::commonmodule::MessageInfo* Arena::CreateMaybeMessage<::commonmodule::MessageInfo>(Arena*);
template<> ::commonmodule::Meter* Arena::CreateMaybeMessage<::commonmodule::Meter>(Arena*);
template<> ::commonmodule::NamedObject* Arena::CreateMaybeMessage<::commonmodule::NamedObject>(Arena*);
template<> ::commonmodule::OptimizationMessageInfo* Arena::CreateMaybeMessage<::commonmodule::OptimizationMessageInfo>(Arena*);
template<> ::commonmodule::Optional_BehaviourModeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_BehaviourModeKind>(Arena*);
template<> ::commonmodule::Optional_CalcMethodKind* Arena::CreateMaybeMessage<::commonmodule::Optional_CalcMethodKind>(Arena*);
template<> ::commonmodule::Optional_DERGeneratorStateKind* Arena::CreateMaybeMessage<::commonmodule::Optional_DERGeneratorStateKind>(Arena*);
template<> ::commonmodule::Optional_DbPosKind* Arena::CreateMaybeMessage<::commonmodule::Optional_DbPosKind>(Arena*);
template<> ::commonmodule::Optional_DynamicTestKind* Arena::CreateMaybeMessage<::commonmodule::Optional_DynamicTestKind>(Arena*);
template<> ::commonmodule::Optional_GridConnectModeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_GridConnectModeKind>(Arena*);
template<> ::commonmodule::Optional_HealthKind* Arena::CreateMaybeMessage<::commonmodule::Optional_HealthKind>(Arena*);
template<> ::commonmodule::Optional_PFSignKind* Arena::CreateMaybeMessage<::commonmodule::Optional_PFSignKind>(Arena*);
template<> ::commonmodule::Optional_PhaseCodeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(Arena*);
template<> ::commonmodule::Optional_ScheduleParameterKind* Arena::CreateMaybeMessage<::commonmodule::Optional_ScheduleParameterKind>(Arena*);
template<> ::commonmodule::Optional_SourceKind* Arena::CreateMaybeMessage<::commonmodule::Optional_SourceKind>(Arena*);
template<> ::commonmodule::Optional_StateKind* Arena::CreateMaybeMessage<::commonmodule::Optional_StateKind>(Arena*);
template<> ::commonmodule::Optional_TimeAccuracyKind* Arena::CreateMaybeMessage<::commonmodule::Optional_TimeAccuracyKind>(Arena*);
template<> ::commonmodule::Optional_UnitMultiplierKind* Arena::CreateMaybeMessage<::commonmodule::Optional_UnitMultiplierKind>(Arena*);
template<> ::commonmodule::Optional_UnitSymbolKind* Arena::CreateMaybeMessage<::commonmodule::Optional_UnitSymbolKind>(Arena*);
template<> ::commonmodule::Optional_ValidityKind* Arena::CreateMaybeMessage<::commonmodule::Optional_ValidityKind>(Arena*);
template<> ::commonmodule::PhaseMMTN* Arena::CreateMaybeMessage<::commonmodule::PhaseMMTN>(Arena*);
template<> ::commonmodule::Quality* Arena::CreateMaybeMessage<::commonmodule::Quality>(Arena*);
template<> ::commonmodule::RampRate* Arena::CreateMaybeMessage<::commonmodule::RampRate>(Arena*);
template<> ::commonmodule::ReadingMMTN* Arena::CreateMaybeMessage<::commonmodule::ReadingMMTN>(Arena*);
template<> ::commonmodule::ReadingMMTR* Arena::CreateMaybeMessage<::commonmodule::ReadingMMTR>(Arena*);
template<> ::commonmodule::ReadingMMXU* Arena::CreateMaybeMessage<::commonmodule::ReadingMMXU>(Arena*);
template<> ::commonmodule::ReadingMessageInfo* Arena::CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(Arena*);
template<> ::commonmodule::ScheduleCSG* Arena::CreateMaybeMessage<::commonmodule::ScheduleCSG>(Arena*);
template<> ::commonmodule::SchedulePoint* Arena::CreateMaybeMessage<::commonmodule::SchedulePoint>(Arena*);
template<> ::commonmodule::StatusAndEventXCBR* Arena::CreateMaybeMessage<::commonmodule::StatusAndEventXCBR>(Arena*);
template<> ::commonmodule::StatusDPS* Arena::CreateMaybeMessage<::commonmodule::StatusDPS>(Arena*);
template<> ::commonmodule::StatusINS* Arena::CreateMaybeMessage<::commonmodule::StatusINS>(Arena*);
template<> ::commonmodule::StatusISC* Arena::CreateMaybeMessage<::commonmodule::StatusISC>(Arena*);
template<> ::commonmodule::StatusMessageInfo* Arena::CreateMaybeMessage<::commonmodule::StatusMessageInfo>(Arena*);
template<> ::commonmodule::StatusSPC* Arena::CreateMaybeMessage<::commonmodule::StatusSPC>(Arena*);
template<> ::commonmodule::StatusSPS* Arena::CreateMaybeMessage<::commonmodule::StatusSPS>(Arena*);
template<> ::commonmodule::StatusValue* Arena::CreateMaybeMessage<::commonmodule::StatusValue>(Arena*);
template<> ::commonmodule::StringStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::StringStatusGGIO>(Arena*);
template<> ::commonmodule::SwitchCSG* Arena::CreateMaybeMessage<::commonmodule::SwitchCSG>(Arena*);
template<> ::commonmodule::SwitchControlScheduleFSCH* Arena::CreateMaybeMessage<::commonmodule::SwitchControlScheduleFSCH>(Arena*);
template<> ::commonmodule::SwitchPoint* Arena::CreateMaybeMessage<::commonmodule::SwitchPoint>(Arena*);
template<> ::commonmodule::Terminal* Arena::CreateMaybeMessage<::commonmodule::Terminal>(Arena*);
template<> ::commonmodule::TimeQuality* Arena::CreateMaybeMessage<::commonmodule::TimeQuality>(Arena*);
template<> ::commonmodule::Timestamp* Arena::CreateMaybeMessage<::commonmodule::Timestamp>(Arena*);
template<> ::commonmodule::Unit* Arena::CreateMaybeMessage<::commonmodule::Unit>(Arena*);
template<> ::commonmodule::VSS* Arena::CreateMaybeMessage<::commonmodule::VSS>(Arena*);
template<> ::commonmodule::Vector* Arena::CreateMaybeMessage<::commonmodule::Vector>(Arena*);
template<> ::commonmodule::WYE* Arena::CreateMaybeMessage<::commonmodule::WYE>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace commonmodule {

enum UnitSymbolKind {
  UnitSymbolKind_none = 0,
  UnitSymbolKind_meter = 2,
  UnitSymbolKind_gram = 3,
  UnitSymbolKind_Amp = 5,
  UnitSymbolKind_deg = 9,
  UnitSymbolKind_rad = 10,
  UnitSymbolKind_degC = 23,
  UnitSymbolKind_Farad = 25,
  UnitSymbolKind_sec = 27,
  UnitSymbolKind_Henry = 28,
  UnitSymbolKind_V = 29,
  UnitSymbolKind_ohm = 30,
  UnitSymbolKind_Joule = 31,
  UnitSymbolKind_Newton = 32,
  UnitSymbolKind_Hz = 33,
  UnitSymbolKind_W = 38,
  UnitSymbolKind_Pa = 39,
  UnitSymbolKind_m2 = 41,
  UnitSymbolKind_Siemens = 53,
  UnitSymbolKind_VA = 61,
  UnitSymbolKind_VAr = 63,
  UnitSymbolKind_wPerVA = 65,
  UnitSymbolKind_VAh = 71,
  UnitSymbolKind_Wh = 72,
  UnitSymbolKind_VArh = 73,
  UnitSymbolKind_hzPerS = 75,
  UnitSymbolKind_wPerS = 81,
  UnitSymbolKind_other = 100,
  UnitSymbolKind_Ah = 106,
  UnitSymbolKind_min = 159,
  UnitSymbolKind_hour = 160,
  UnitSymbolKind_m3 = 166,
  UnitSymbolKind_wPerM2 = 179,
  UnitSymbolKind_degF = 279,
  UnitSymbolKind_mph = 500,
  UnitSymbolKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  UnitSymbolKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool UnitSymbolKind_IsValid(int value);
const UnitSymbolKind UnitSymbolKind_MIN = UnitSymbolKind_none;
const UnitSymbolKind UnitSymbolKind_MAX = UnitSymbolKind_mph;
const int UnitSymbolKind_ARRAYSIZE = UnitSymbolKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitSymbolKind_descriptor();
inline const ::std::string& UnitSymbolKind_Name(UnitSymbolKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitSymbolKind_descriptor(), value);
}
inline bool UnitSymbolKind_Parse(
    const ::std::string& name, UnitSymbolKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitSymbolKind>(
    UnitSymbolKind_descriptor(), name, value);
}
enum UnitMultiplierKind {
  UnitMultiplierKind_none = 0,
  UnitMultiplierKind_other = 1,
  UnitMultiplierKind_centi = 2,
  UnitMultiplierKind_deci = 3,
  UnitMultiplierKind_Giga = 4,
  UnitMultiplierKind_kilo = 5,
  UnitMultiplierKind_Mega = 6,
  UnitMultiplierKind_micro = 7,
  UnitMultiplierKind_milli = 8,
  UnitMultiplierKind_nano = 9,
  UnitMultiplierKind_pico = 10,
  UnitMultiplierKind_Tera = 11,
  UnitMultiplierKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  UnitMultiplierKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool UnitMultiplierKind_IsValid(int value);
const UnitMultiplierKind UnitMultiplierKind_MIN = UnitMultiplierKind_none;
const UnitMultiplierKind UnitMultiplierKind_MAX = UnitMultiplierKind_Tera;
const int UnitMultiplierKind_ARRAYSIZE = UnitMultiplierKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitMultiplierKind_descriptor();
inline const ::std::string& UnitMultiplierKind_Name(UnitMultiplierKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitMultiplierKind_descriptor(), value);
}
inline bool UnitMultiplierKind_Parse(
    const ::std::string& name, UnitMultiplierKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitMultiplierKind>(
    UnitMultiplierKind_descriptor(), name, value);
}
enum PhaseCodeKind {
  PhaseCodeKind_none = 0,
  PhaseCodeKind_other = 1,
  PhaseCodeKind_N = 16,
  PhaseCodeKind_C = 32,
  PhaseCodeKind_CN = 33,
  PhaseCodeKind_AC = 40,
  PhaseCodeKind_ACN = 41,
  PhaseCodeKind_B = 64,
  PhaseCodeKind_BN = 65,
  PhaseCodeKind_BC = 66,
  PhaseCodeKind_BCN = 97,
  PhaseCodeKind_A = 128,
  PhaseCodeKind_AN = 129,
  PhaseCodeKind_AB = 132,
  PhaseCodeKind_ABN = 193,
  PhaseCodeKind_ABC = 224,
  PhaseCodeKind_ABCN = 225,
  PhaseCodeKind_s2 = 256,
  PhaseCodeKind_s2N = 257,
  PhaseCodeKind_s1 = 512,
  PhaseCodeKind_s1N = 513,
  PhaseCodeKind_s12 = 768,
  PhaseCodeKind_s12N = 769,
  PhaseCodeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PhaseCodeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PhaseCodeKind_IsValid(int value);
const PhaseCodeKind PhaseCodeKind_MIN = PhaseCodeKind_none;
const PhaseCodeKind PhaseCodeKind_MAX = PhaseCodeKind_s12N;
const int PhaseCodeKind_ARRAYSIZE = PhaseCodeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* PhaseCodeKind_descriptor();
inline const ::std::string& PhaseCodeKind_Name(PhaseCodeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    PhaseCodeKind_descriptor(), value);
}
inline bool PhaseCodeKind_Parse(
    const ::std::string& name, PhaseCodeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PhaseCodeKind>(
    PhaseCodeKind_descriptor(), name, value);
}
enum ValidityKind {
  ValidityKind_good = 0,
  ValidityKind_invalid = 1,
  ValidityKind_reserved = 2,
  ValidityKind_questionable = 3,
  ValidityKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ValidityKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ValidityKind_IsValid(int value);
const ValidityKind ValidityKind_MIN = ValidityKind_good;
const ValidityKind ValidityKind_MAX = ValidityKind_questionable;
const int ValidityKind_ARRAYSIZE = ValidityKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ValidityKind_descriptor();
inline const ::std::string& ValidityKind_Name(ValidityKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ValidityKind_descriptor(), value);
}
inline bool ValidityKind_Parse(
    const ::std::string& name, ValidityKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ValidityKind>(
    ValidityKind_descriptor(), name, value);
}
enum SourceKind {
  SourceKind_process = 0,
  SourceKind_substituted = 1,
  SourceKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SourceKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SourceKind_IsValid(int value);
const SourceKind SourceKind_MIN = SourceKind_process;
const SourceKind SourceKind_MAX = SourceKind_substituted;
const int SourceKind_ARRAYSIZE = SourceKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* SourceKind_descriptor();
inline const ::std::string& SourceKind_Name(SourceKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    SourceKind_descriptor(), value);
}
inline bool SourceKind_Parse(
    const ::std::string& name, SourceKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SourceKind>(
    SourceKind_descriptor(), name, value);
}
enum TimeAccuracyKind {
  TimeAccuracyKind_UNDEFINED = 0,
  TimeAccuracyKind_T0 = 7,
  TimeAccuracyKind_T1 = 10,
  TimeAccuracyKind_T2 = 14,
  TimeAccuracyKind_T3 = 16,
  TimeAccuracyKind_T4 = 18,
  TimeAccuracyKind_T5 = 20,
  TimeAccuracyKind_unspecified = 31,
  TimeAccuracyKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  TimeAccuracyKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool TimeAccuracyKind_IsValid(int value);
const TimeAccuracyKind TimeAccuracyKind_MIN = TimeAccuracyKind_UNDEFINED;
const TimeAccuracyKind TimeAccuracyKind_MAX = TimeAccuracyKind_unspecified;
const int TimeAccuracyKind_ARRAYSIZE = TimeAccuracyKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeAccuracyKind_descriptor();
inline const ::std::string& TimeAccuracyKind_Name(TimeAccuracyKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeAccuracyKind_descriptor(), value);
}
inline bool TimeAccuracyKind_Parse(
    const ::std::string& name, TimeAccuracyKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeAccuracyKind>(
    TimeAccuracyKind_descriptor(), name, value);
}
enum ScheduleParameterKind {
  ScheduleParameterKind_none = 0,
  ScheduleParameterKind_other = 1,
  ScheduleParameterKind_A_net_mag = 2,
  ScheduleParameterKind_A_neut_mag = 3,
  ScheduleParameterKind_A_phsA_mag = 4,
  ScheduleParameterKind_A_phsB_mag = 5,
  ScheduleParameterKind_A_phsC_mag = 6,
  ScheduleParameterKind_Hz_mag = 7,
  ScheduleParameterKind_PF_net_mag = 8,
  ScheduleParameterKind_PF_neut_mag = 9,
  ScheduleParameterKind_PF_phsA_mag = 10,
  ScheduleParameterKind_PF_phsB_mag = 11,
  ScheduleParameterKind_PF_phsC_mag = 12,
  ScheduleParameterKind_PhV_net_ang = 13,
  ScheduleParameterKind_PhV_net_mag = 14,
  ScheduleParameterKind_PhV_neut_ang = 15,
  ScheduleParameterKind_PhV_neut_mag = 16,
  ScheduleParameterKind_PhV_phsA_ang = 17,
  ScheduleParameterKind_PhV_phsA_mag = 18,
  ScheduleParameterKind_PhV_phsB_ang = 19,
  ScheduleParameterKind_PhV_phsB_mag = 20,
  ScheduleParameterKind_PhV_phsC_ang = 21,
  ScheduleParameterKind_PhV_phsC_mag = 22,
  ScheduleParameterKind_PPV_phsAB_ang = 23,
  ScheduleParameterKind_PPV_phsAB_mag = 24,
  ScheduleParameterKind_PPV_phsBC_ang = 25,
  ScheduleParameterKind_PPV_phsBC_mag = 26,
  ScheduleParameterKind_PPV_phsCA_ang = 27,
  ScheduleParameterKind_PPV_phsCA_mag = 28,
  ScheduleParameterKind_VA_net_mag = 29,
  ScheduleParameterKind_VA_neut_mag = 30,
  ScheduleParameterKind_VA_phsA_mag = 31,
  ScheduleParameterKind_VA_phsB_mag = 32,
  ScheduleParameterKind_VA_phsC_mag = 33,
  ScheduleParameterKind_VAr_net_mag = 34,
  ScheduleParameterKind_VAr_neut_mag = 35,
  ScheduleParameterKind_VAr_phsA_mag = 36,
  ScheduleParameterKind_VAr_phsB_mag = 37,
  ScheduleParameterKind_VAr_phsC_mag = 38,
  ScheduleParameterKind_W_net_mag = 39,
  ScheduleParameterKind_W_neut_mag = 40,
  ScheduleParameterKind_W_phsA_mag = 41,
  ScheduleParameterKind_W_phsB_mag = 42,
  ScheduleParameterKind_W_phsC_mag = 43,
  ScheduleParameterKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ScheduleParameterKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ScheduleParameterKind_IsValid(int value);
const ScheduleParameterKind ScheduleParameterKind_MIN = ScheduleParameterKind_none;
const ScheduleParameterKind ScheduleParameterKind_MAX = ScheduleParameterKind_W_phsC_mag;
const int ScheduleParameterKind_ARRAYSIZE = ScheduleParameterKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScheduleParameterKind_descriptor();
inline const ::std::string& ScheduleParameterKind_Name(ScheduleParameterKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScheduleParameterKind_descriptor(), value);
}
inline bool ScheduleParameterKind_Parse(
    const ::std::string& name, ScheduleParameterKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScheduleParameterKind>(
    ScheduleParameterKind_descriptor(), name, value);
}
enum CalcMethodKind {
  CalcMethodKind_UNDEFINED = 0,
  CalcMethodKind_P_CLASS = 11,
  CalcMethodKind_M_CLASS = 12,
  CalcMethodKind_DIFF = 13,
  CalcMethodKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  CalcMethodKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool CalcMethodKind_IsValid(int value);
const CalcMethodKind CalcMethodKind_MIN = CalcMethodKind_UNDEFINED;
const CalcMethodKind CalcMethodKind_MAX = CalcMethodKind_DIFF;
const int CalcMethodKind_ARRAYSIZE = CalcMethodKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* CalcMethodKind_descriptor();
inline const ::std::string& CalcMethodKind_Name(CalcMethodKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    CalcMethodKind_descriptor(), value);
}
inline bool CalcMethodKind_Parse(
    const ::std::string& name, CalcMethodKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CalcMethodKind>(
    CalcMethodKind_descriptor(), name, value);
}
enum GridConnectModeKind {
  GridConnectModeKind_UNDEFINED = 0,
  GridConnectModeKind_CSI = 1,
  GridConnectModeKind_VC_VSI = 2,
  GridConnectModeKind_CC_VSI = 3,
  GridConnectModeKind_none = 98,
  GridConnectModeKind_other = 99,
  GridConnectModeKind_VSI_PQ = 2000,
  GridConnectModeKind_VSI_VF = 2001,
  GridConnectModeKind_VSI_ISO = 2002,
  GridConnectModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  GridConnectModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool GridConnectModeKind_IsValid(int value);
const GridConnectModeKind GridConnectModeKind_MIN = GridConnectModeKind_UNDEFINED;
const GridConnectModeKind GridConnectModeKind_MAX = GridConnectModeKind_VSI_ISO;
const int GridConnectModeKind_ARRAYSIZE = GridConnectModeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* GridConnectModeKind_descriptor();
inline const ::std::string& GridConnectModeKind_Name(GridConnectModeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    GridConnectModeKind_descriptor(), value);
}
inline bool GridConnectModeKind_Parse(
    const ::std::string& name, GridConnectModeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GridConnectModeKind>(
    GridConnectModeKind_descriptor(), name, value);
}
enum PFSignKind {
  PFSignKind_UNDEFINED = 0,
  PFSignKind_IEC = 1,
  PFSignKind_EEI = 2,
  PFSignKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PFSignKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PFSignKind_IsValid(int value);
const PFSignKind PFSignKind_MIN = PFSignKind_UNDEFINED;
const PFSignKind PFSignKind_MAX = PFSignKind_EEI;
const int PFSignKind_ARRAYSIZE = PFSignKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* PFSignKind_descriptor();
inline const ::std::string& PFSignKind_Name(PFSignKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    PFSignKind_descriptor(), value);
}
inline bool PFSignKind_Parse(
    const ::std::string& name, PFSignKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PFSignKind>(
    PFSignKind_descriptor(), name, value);
}
enum BehaviourModeKind {
  BehaviourModeKind_UNDEFINED = 0,
  BehaviourModeKind_on = 1,
  BehaviourModeKind_blocked = 2,
  BehaviourModeKind_test = 3,
  BehaviourModeKind_test_blocked = 4,
  BehaviourModeKind_off = 5,
  BehaviourModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  BehaviourModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool BehaviourModeKind_IsValid(int value);
const BehaviourModeKind BehaviourModeKind_MIN = BehaviourModeKind_UNDEFINED;
const BehaviourModeKind BehaviourModeKind_MAX = BehaviourModeKind_off;
const int BehaviourModeKind_ARRAYSIZE = BehaviourModeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* BehaviourModeKind_descriptor();
inline const ::std::string& BehaviourModeKind_Name(BehaviourModeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    BehaviourModeKind_descriptor(), value);
}
inline bool BehaviourModeKind_Parse(
    const ::std::string& name, BehaviourModeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BehaviourModeKind>(
    BehaviourModeKind_descriptor(), name, value);
}
enum DERGeneratorStateKind {
  DERGeneratorStateKind_UNDEFINED = 0,
  DERGeneratorStateKind_Not_operating = 1,
  DERGeneratorStateKind_Operating = 2,
  DERGeneratorStateKind_Starting_up = 3,
  DERGeneratorStateKind_Shutting_down = 4,
  DERGeneratorStateKind_At_disconnect_level = 5,
  DERGeneratorStateKind_Ramping_in_power = 6,
  DERGeneratorStateKind_Ramping_in_reactive_power = 7,
  DERGeneratorStateKind_Standby = 8,
  DERGeneratorStateKind_Not_applicable_Unknown = 98,
  DERGeneratorStateKind_Other = 99,
  DERGeneratorStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DERGeneratorStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DERGeneratorStateKind_IsValid(int value);
const DERGeneratorStateKind DERGeneratorStateKind_MIN = DERGeneratorStateKind_UNDEFINED;
const DERGeneratorStateKind DERGeneratorStateKind_MAX = DERGeneratorStateKind_Other;
const int DERGeneratorStateKind_ARRAYSIZE = DERGeneratorStateKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* DERGeneratorStateKind_descriptor();
inline const ::std::string& DERGeneratorStateKind_Name(DERGeneratorStateKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    DERGeneratorStateKind_descriptor(), value);
}
inline bool DERGeneratorStateKind_Parse(
    const ::std::string& name, DERGeneratorStateKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DERGeneratorStateKind>(
    DERGeneratorStateKind_descriptor(), name, value);
}
enum DynamicTestKind {
  DynamicTestKind_none = 0,
  DynamicTestKind_testing = 1,
  DynamicTestKind_operating = 2,
  DynamicTestKind_failed = 3,
  DynamicTestKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DynamicTestKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DynamicTestKind_IsValid(int value);
const DynamicTestKind DynamicTestKind_MIN = DynamicTestKind_none;
const DynamicTestKind DynamicTestKind_MAX = DynamicTestKind_failed;
const int DynamicTestKind_ARRAYSIZE = DynamicTestKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* DynamicTestKind_descriptor();
inline const ::std::string& DynamicTestKind_Name(DynamicTestKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    DynamicTestKind_descriptor(), value);
}
inline bool DynamicTestKind_Parse(
    const ::std::string& name, DynamicTestKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DynamicTestKind>(
    DynamicTestKind_descriptor(), name, value);
}
enum HealthKind {
  HealthKind_none = 0,
  HealthKind_OK = 1,
  HealthKind_Warning = 2,
  HealthKind_Alarm = 3,
  HealthKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  HealthKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool HealthKind_IsValid(int value);
const HealthKind HealthKind_MIN = HealthKind_none;
const HealthKind HealthKind_MAX = HealthKind_Alarm;
const int HealthKind_ARRAYSIZE = HealthKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* HealthKind_descriptor();
inline const ::std::string& HealthKind_Name(HealthKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    HealthKind_descriptor(), value);
}
inline bool HealthKind_Parse(
    const ::std::string& name, HealthKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HealthKind>(
    HealthKind_descriptor(), name, value);
}
enum DbPosKind {
  DbPosKind_transient = 0,
  DbPosKind_closed = 1,
  DbPosKind_open = 2,
  DbPosKind_invalid = 3,
  DbPosKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DbPosKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DbPosKind_IsValid(int value);
const DbPosKind DbPosKind_MIN = DbPosKind_transient;
const DbPosKind DbPosKind_MAX = DbPosKind_invalid;
const int DbPosKind_ARRAYSIZE = DbPosKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* DbPosKind_descriptor();
inline const ::std::string& DbPosKind_Name(DbPosKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    DbPosKind_descriptor(), value);
}
inline bool DbPosKind_Parse(
    const ::std::string& name, DbPosKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DbPosKind>(
    DbPosKind_descriptor(), name, value);
}
enum StateKind {
  StateKind_off = 0,
  StateKind_on = 1,
  StateKind_standby = 2,
  StateKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  StateKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool StateKind_IsValid(int value);
const StateKind StateKind_MIN = StateKind_off;
const StateKind StateKind_MAX = StateKind_standby;
const int StateKind_ARRAYSIZE = StateKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* StateKind_descriptor();
inline const ::std::string& StateKind_Name(StateKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    StateKind_descriptor(), value);
}
inline bool StateKind_Parse(
    const ::std::string& name, StateKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StateKind>(
    StateKind_descriptor(), name, value);
}
// ===================================================================

class IdentifiedObject :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.IdentifiedObject) */ {
 public:
  IdentifiedObject();
  virtual ~IdentifiedObject();

  IdentifiedObject(const IdentifiedObject& from);

  inline IdentifiedObject& operator=(const IdentifiedObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IdentifiedObject(IdentifiedObject&& from) noexcept
    : IdentifiedObject() {
    *this = ::std::move(from);
  }

  inline IdentifiedObject& operator=(IdentifiedObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IdentifiedObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IdentifiedObject* internal_default_instance() {
    return reinterpret_cast<const IdentifiedObject*>(
               &_IdentifiedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(IdentifiedObject* other);
  friend void swap(IdentifiedObject& a, IdentifiedObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IdentifiedObject* New() const final {
    return CreateMaybeMessage<IdentifiedObject>(nullptr);
  }

  IdentifiedObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IdentifiedObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IdentifiedObject& from);
  void MergeFrom(const IdentifiedObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdentifiedObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue description = 1;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::google::protobuf::StringValue& description() const;
  ::google::protobuf::StringValue* release_description();
  ::google::protobuf::StringValue* mutable_description();
  void set_allocated_description(::google::protobuf::StringValue* description);

  // .google.protobuf.StringValue mRID = 2 [(.uml.option_uuid) = true];
  bool has_mrid() const;
  void clear_mrid();
  static const int kMRIDFieldNumber = 2;
  const ::google::protobuf::StringValue& mrid() const;
  ::google::protobuf::StringValue* release_mrid();
  ::google::protobuf::StringValue* mutable_mrid();
  void set_allocated_mrid(::google::protobuf::StringValue* mrid);

  // .google.protobuf.StringValue name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::google::protobuf::StringValue& name() const;
  ::google::protobuf::StringValue* release_name();
  ::google::protobuf::StringValue* mutable_name();
  void set_allocated_name(::google::protobuf::StringValue* name);

  // @@protoc_insertion_point(class_scope:commonmodule.IdentifiedObject)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* description_;
  ::google::protobuf::StringValue* mrid_;
  ::google::protobuf::StringValue* name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ACDCTerminal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ACDCTerminal) */ {
 public:
  ACDCTerminal();
  virtual ~ACDCTerminal();

  ACDCTerminal(const ACDCTerminal& from);

  inline ACDCTerminal& operator=(const ACDCTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACDCTerminal(ACDCTerminal&& from) noexcept
    : ACDCTerminal() {
    *this = ::std::move(from);
  }

  inline ACDCTerminal& operator=(ACDCTerminal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ACDCTerminal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACDCTerminal* internal_default_instance() {
    return reinterpret_cast<const ACDCTerminal*>(
               &_ACDCTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ACDCTerminal* other);
  friend void swap(ACDCTerminal& a, ACDCTerminal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACDCTerminal* New() const final {
    return CreateMaybeMessage<ACDCTerminal>(nullptr);
  }

  ACDCTerminal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACDCTerminal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACDCTerminal& from);
  void MergeFrom(const ACDCTerminal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACDCTerminal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // .google.protobuf.BoolValue connected = 2;
  bool has_connected() const;
  void clear_connected();
  static const int kConnectedFieldNumber = 2;
  const ::google::protobuf::BoolValue& connected() const;
  ::google::protobuf::BoolValue* release_connected();
  ::google::protobuf::BoolValue* mutable_connected();
  void set_allocated_connected(::google::protobuf::BoolValue* connected);

  // .google.protobuf.Int32Value sequenceNumber = 3;
  bool has_sequencenumber() const;
  void clear_sequencenumber();
  static const int kSequenceNumberFieldNumber = 3;
  const ::google::protobuf::Int32Value& sequencenumber() const;
  ::google::protobuf::Int32Value* release_sequencenumber();
  ::google::protobuf::Int32Value* mutable_sequencenumber();
  void set_allocated_sequencenumber(::google::protobuf::Int32Value* sequencenumber);

  // @@protoc_insertion_point(class_scope:commonmodule.ACDCTerminal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  ::google::protobuf::BoolValue* connected_;
  ::google::protobuf::Int32Value* sequencenumber_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_UnitSymbolKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_UnitSymbolKind) */ {
 public:
  Optional_UnitSymbolKind();
  virtual ~Optional_UnitSymbolKind();

  Optional_UnitSymbolKind(const Optional_UnitSymbolKind& from);

  inline Optional_UnitSymbolKind& operator=(const Optional_UnitSymbolKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_UnitSymbolKind(Optional_UnitSymbolKind&& from) noexcept
    : Optional_UnitSymbolKind() {
    *this = ::std::move(from);
  }

  inline Optional_UnitSymbolKind& operator=(Optional_UnitSymbolKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_UnitSymbolKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_UnitSymbolKind* internal_default_instance() {
    return reinterpret_cast<const Optional_UnitSymbolKind*>(
               &_Optional_UnitSymbolKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Optional_UnitSymbolKind* other);
  friend void swap(Optional_UnitSymbolKind& a, Optional_UnitSymbolKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_UnitSymbolKind* New() const final {
    return CreateMaybeMessage<Optional_UnitSymbolKind>(nullptr);
  }

  Optional_UnitSymbolKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_UnitSymbolKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_UnitSymbolKind& from);
  void MergeFrom(const Optional_UnitSymbolKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_UnitSymbolKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.UnitSymbolKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::UnitSymbolKind value() const;
  void set_value(::commonmodule::UnitSymbolKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_UnitSymbolKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_UnitMultiplierKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_UnitMultiplierKind) */ {
 public:
  Optional_UnitMultiplierKind();
  virtual ~Optional_UnitMultiplierKind();

  Optional_UnitMultiplierKind(const Optional_UnitMultiplierKind& from);

  inline Optional_UnitMultiplierKind& operator=(const Optional_UnitMultiplierKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_UnitMultiplierKind(Optional_UnitMultiplierKind&& from) noexcept
    : Optional_UnitMultiplierKind() {
    *this = ::std::move(from);
  }

  inline Optional_UnitMultiplierKind& operator=(Optional_UnitMultiplierKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_UnitMultiplierKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_UnitMultiplierKind* internal_default_instance() {
    return reinterpret_cast<const Optional_UnitMultiplierKind*>(
               &_Optional_UnitMultiplierKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Optional_UnitMultiplierKind* other);
  friend void swap(Optional_UnitMultiplierKind& a, Optional_UnitMultiplierKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_UnitMultiplierKind* New() const final {
    return CreateMaybeMessage<Optional_UnitMultiplierKind>(nullptr);
  }

  Optional_UnitMultiplierKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_UnitMultiplierKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_UnitMultiplierKind& from);
  void MergeFrom(const Optional_UnitMultiplierKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_UnitMultiplierKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.UnitMultiplierKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::UnitMultiplierKind value() const;
  void set_value(::commonmodule::UnitMultiplierKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_UnitMultiplierKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ActivePower :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ActivePower) */ {
 public:
  ActivePower();
  virtual ~ActivePower();

  ActivePower(const ActivePower& from);

  inline ActivePower& operator=(const ActivePower& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActivePower(ActivePower&& from) noexcept
    : ActivePower() {
    *this = ::std::move(from);
  }

  inline ActivePower& operator=(ActivePower&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ActivePower& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActivePower* internal_default_instance() {
    return reinterpret_cast<const ActivePower*>(
               &_ActivePower_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ActivePower* other);
  friend void swap(ActivePower& a, ActivePower& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActivePower* New() const final {
    return CreateMaybeMessage<ActivePower>(nullptr);
  }

  ActivePower* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActivePower>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActivePower& from);
  void MergeFrom(const ActivePower& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivePower* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  bool has_multiplier() const;
  void clear_multiplier();
  static const int kMultiplierFieldNumber = 1;
  const ::commonmodule::Optional_UnitMultiplierKind& multiplier() const;
  ::commonmodule::Optional_UnitMultiplierKind* release_multiplier();
  ::commonmodule::Optional_UnitMultiplierKind* mutable_multiplier();
  void set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier);

  // .commonmodule.Optional_UnitSymbolKind unit = 2;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 2;
  const ::commonmodule::Optional_UnitSymbolKind& unit() const;
  ::commonmodule::Optional_UnitSymbolKind* release_unit();
  ::commonmodule::Optional_UnitSymbolKind* mutable_unit();
  void set_allocated_unit(::commonmodule::Optional_UnitSymbolKind* unit);

  // .google.protobuf.FloatValue value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::google::protobuf::FloatValue& value() const;
  ::google::protobuf::FloatValue* release_value();
  ::google::protobuf::FloatValue* mutable_value();
  void set_allocated_value(::google::protobuf::FloatValue* value);

  // @@protoc_insertion_point(class_scope:commonmodule.ActivePower)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Optional_UnitMultiplierKind* multiplier_;
  ::commonmodule::Optional_UnitSymbolKind* unit_;
  ::google::protobuf::FloatValue* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_PhaseCodeKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_PhaseCodeKind) */ {
 public:
  Optional_PhaseCodeKind();
  virtual ~Optional_PhaseCodeKind();

  Optional_PhaseCodeKind(const Optional_PhaseCodeKind& from);

  inline Optional_PhaseCodeKind& operator=(const Optional_PhaseCodeKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_PhaseCodeKind(Optional_PhaseCodeKind&& from) noexcept
    : Optional_PhaseCodeKind() {
    *this = ::std::move(from);
  }

  inline Optional_PhaseCodeKind& operator=(Optional_PhaseCodeKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_PhaseCodeKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_PhaseCodeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_PhaseCodeKind*>(
               &_Optional_PhaseCodeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Optional_PhaseCodeKind* other);
  friend void swap(Optional_PhaseCodeKind& a, Optional_PhaseCodeKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_PhaseCodeKind* New() const final {
    return CreateMaybeMessage<Optional_PhaseCodeKind>(nullptr);
  }

  Optional_PhaseCodeKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_PhaseCodeKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_PhaseCodeKind& from);
  void MergeFrom(const Optional_PhaseCodeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_PhaseCodeKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.PhaseCodeKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::PhaseCodeKind value() const;
  void set_value(::commonmodule::PhaseCodeKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_PhaseCodeKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class AnalogueValue :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.AnalogueValue) */ {
 public:
  AnalogueValue();
  virtual ~AnalogueValue();

  AnalogueValue(const AnalogueValue& from);

  inline AnalogueValue& operator=(const AnalogueValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalogueValue(AnalogueValue&& from) noexcept
    : AnalogueValue() {
    *this = ::std::move(from);
  }

  inline AnalogueValue& operator=(AnalogueValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AnalogueValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalogueValue* internal_default_instance() {
    return reinterpret_cast<const AnalogueValue*>(
               &_AnalogueValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AnalogueValue* other);
  friend void swap(AnalogueValue& a, AnalogueValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalogueValue* New() const final {
    return CreateMaybeMessage<AnalogueValue>(nullptr);
  }

  AnalogueValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalogueValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalogueValue& from);
  void MergeFrom(const AnalogueValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogueValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue f = 1;
  bool has_f() const;
  void clear_f();
  static const int kFFieldNumber = 1;
  const ::google::protobuf::FloatValue& f() const;
  ::google::protobuf::FloatValue* release_f();
  ::google::protobuf::FloatValue* mutable_f();
  void set_allocated_f(::google::protobuf::FloatValue* f);

  // .google.protobuf.Int32Value i = 2;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 2;
  const ::google::protobuf::Int32Value& i() const;
  ::google::protobuf::Int32Value* release_i();
  ::google::protobuf::Int32Value* mutable_i();
  void set_allocated_i(::google::protobuf::Int32Value* i);

  // @@protoc_insertion_point(class_scope:commonmodule.AnalogueValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* f_;
  ::google::protobuf::Int32Value* i_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_ValidityKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_ValidityKind) */ {
 public:
  Optional_ValidityKind();
  virtual ~Optional_ValidityKind();

  Optional_ValidityKind(const Optional_ValidityKind& from);

  inline Optional_ValidityKind& operator=(const Optional_ValidityKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_ValidityKind(Optional_ValidityKind&& from) noexcept
    : Optional_ValidityKind() {
    *this = ::std::move(from);
  }

  inline Optional_ValidityKind& operator=(Optional_ValidityKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_ValidityKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_ValidityKind* internal_default_instance() {
    return reinterpret_cast<const Optional_ValidityKind*>(
               &_Optional_ValidityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Optional_ValidityKind* other);
  friend void swap(Optional_ValidityKind& a, Optional_ValidityKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_ValidityKind* New() const final {
    return CreateMaybeMessage<Optional_ValidityKind>(nullptr);
  }

  Optional_ValidityKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_ValidityKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_ValidityKind& from);
  void MergeFrom(const Optional_ValidityKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_ValidityKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ValidityKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::ValidityKind value() const;
  void set_value(::commonmodule::ValidityKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_ValidityKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class DetailQual :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.DetailQual) */ {
 public:
  DetailQual();
  virtual ~DetailQual();

  DetailQual(const DetailQual& from);

  inline DetailQual& operator=(const DetailQual& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetailQual(DetailQual&& from) noexcept
    : DetailQual() {
    *this = ::std::move(from);
  }

  inline DetailQual& operator=(DetailQual&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DetailQual& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetailQual* internal_default_instance() {
    return reinterpret_cast<const DetailQual*>(
               &_DetailQual_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DetailQual* other);
  friend void swap(DetailQual& a, DetailQual& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetailQual* New() const final {
    return CreateMaybeMessage<DetailQual>(nullptr);
  }

  DetailQual* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DetailQual>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DetailQual& from);
  void MergeFrom(const DetailQual& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailQual* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool badReference = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_badreference();
  static const int kBadReferenceFieldNumber = 1;
  bool badreference() const;
  void set_badreference(bool value);

  // bool failure = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_failure();
  static const int kFailureFieldNumber = 2;
  bool failure() const;
  void set_failure(bool value);

  // bool inaccurate = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_inaccurate();
  static const int kInaccurateFieldNumber = 3;
  bool inaccurate() const;
  void set_inaccurate(bool value);

  // bool inconsistent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_inconsistent();
  static const int kInconsistentFieldNumber = 4;
  bool inconsistent() const;
  void set_inconsistent(bool value);

  // bool oldData = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_olddata();
  static const int kOldDataFieldNumber = 5;
  bool olddata() const;
  void set_olddata(bool value);

  // bool oscillatory = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_oscillatory();
  static const int kOscillatoryFieldNumber = 6;
  bool oscillatory() const;
  void set_oscillatory(bool value);

  // bool outOfRange = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_outofrange();
  static const int kOutOfRangeFieldNumber = 7;
  bool outofrange() const;
  void set_outofrange(bool value);

  // bool overflow = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_overflow();
  static const int kOverflowFieldNumber = 8;
  bool overflow() const;
  void set_overflow(bool value);

  // @@protoc_insertion_point(class_scope:commonmodule.DetailQual)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool badreference_;
  bool failure_;
  bool inaccurate_;
  bool inconsistent_;
  bool olddata_;
  bool oscillatory_;
  bool outofrange_;
  bool overflow_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_SourceKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_SourceKind) */ {
 public:
  Optional_SourceKind();
  virtual ~Optional_SourceKind();

  Optional_SourceKind(const Optional_SourceKind& from);

  inline Optional_SourceKind& operator=(const Optional_SourceKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_SourceKind(Optional_SourceKind&& from) noexcept
    : Optional_SourceKind() {
    *this = ::std::move(from);
  }

  inline Optional_SourceKind& operator=(Optional_SourceKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_SourceKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_SourceKind* internal_default_instance() {
    return reinterpret_cast<const Optional_SourceKind*>(
               &_Optional_SourceKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Optional_SourceKind* other);
  friend void swap(Optional_SourceKind& a, Optional_SourceKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_SourceKind* New() const final {
    return CreateMaybeMessage<Optional_SourceKind>(nullptr);
  }

  Optional_SourceKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_SourceKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_SourceKind& from);
  void MergeFrom(const Optional_SourceKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_SourceKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.SourceKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::SourceKind value() const;
  void set_value(::commonmodule::SourceKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_SourceKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Quality :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Quality) */ {
 public:
  Quality();
  virtual ~Quality();

  Quality(const Quality& from);

  inline Quality& operator=(const Quality& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quality(Quality&& from) noexcept
    : Quality() {
    *this = ::std::move(from);
  }

  inline Quality& operator=(Quality&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Quality& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quality* internal_default_instance() {
    return reinterpret_cast<const Quality*>(
               &_Quality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Quality* other);
  friend void swap(Quality& a, Quality& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quality* New() const final {
    return CreateMaybeMessage<Quality>(nullptr);
  }

  Quality* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quality>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quality& from);
  void MergeFrom(const Quality& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quality* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.DetailQual detailQual = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_detailqual() const;
  void clear_detailqual();
  static const int kDetailQualFieldNumber = 1;
  const ::commonmodule::DetailQual& detailqual() const;
  ::commonmodule::DetailQual* release_detailqual();
  ::commonmodule::DetailQual* mutable_detailqual();
  void set_allocated_detailqual(::commonmodule::DetailQual* detailqual);

  // .commonmodule.SourceKind source = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_source();
  static const int kSourceFieldNumber = 3;
  ::commonmodule::SourceKind source() const;
  void set_source(::commonmodule::SourceKind value);

  // bool operatorBlocked = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_operatorblocked();
  static const int kOperatorBlockedFieldNumber = 2;
  bool operatorblocked() const;
  void set_operatorblocked(bool value);

  // bool test = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_test();
  static const int kTestFieldNumber = 4;
  bool test() const;
  void set_test(bool value);

  // .commonmodule.ValidityKind validity = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_validity();
  static const int kValidityFieldNumber = 5;
  ::commonmodule::ValidityKind validity() const;
  void set_validity(::commonmodule::ValidityKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Quality)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::DetailQual* detailqual_;
  int source_;
  bool operatorblocked_;
  bool test_;
  int validity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_TimeAccuracyKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_TimeAccuracyKind) */ {
 public:
  Optional_TimeAccuracyKind();
  virtual ~Optional_TimeAccuracyKind();

  Optional_TimeAccuracyKind(const Optional_TimeAccuracyKind& from);

  inline Optional_TimeAccuracyKind& operator=(const Optional_TimeAccuracyKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_TimeAccuracyKind(Optional_TimeAccuracyKind&& from) noexcept
    : Optional_TimeAccuracyKind() {
    *this = ::std::move(from);
  }

  inline Optional_TimeAccuracyKind& operator=(Optional_TimeAccuracyKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_TimeAccuracyKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_TimeAccuracyKind* internal_default_instance() {
    return reinterpret_cast<const Optional_TimeAccuracyKind*>(
               &_Optional_TimeAccuracyKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Optional_TimeAccuracyKind* other);
  friend void swap(Optional_TimeAccuracyKind& a, Optional_TimeAccuracyKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_TimeAccuracyKind* New() const final {
    return CreateMaybeMessage<Optional_TimeAccuracyKind>(nullptr);
  }

  Optional_TimeAccuracyKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_TimeAccuracyKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_TimeAccuracyKind& from);
  void MergeFrom(const Optional_TimeAccuracyKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_TimeAccuracyKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.TimeAccuracyKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::TimeAccuracyKind value() const;
  void set_value(::commonmodule::TimeAccuracyKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_TimeAccuracyKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class TimeQuality :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.TimeQuality) */ {
 public:
  TimeQuality();
  virtual ~TimeQuality();

  TimeQuality(const TimeQuality& from);

  inline TimeQuality& operator=(const TimeQuality& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeQuality(TimeQuality&& from) noexcept
    : TimeQuality() {
    *this = ::std::move(from);
  }

  inline TimeQuality& operator=(TimeQuality&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TimeQuality& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeQuality* internal_default_instance() {
    return reinterpret_cast<const TimeQuality*>(
               &_TimeQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TimeQuality* other);
  friend void swap(TimeQuality& a, TimeQuality& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeQuality* New() const final {
    return CreateMaybeMessage<TimeQuality>(nullptr);
  }

  TimeQuality* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeQuality>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimeQuality& from);
  void MergeFrom(const TimeQuality& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeQuality* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_clockfailure();
  static const int kClockFailureFieldNumber = 1;
  bool clockfailure() const;
  void set_clockfailure(bool value);

  // bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_clocknotsynchronized();
  static const int kClockNotSynchronizedFieldNumber = 2;
  bool clocknotsynchronized() const;
  void set_clocknotsynchronized(bool value);

  // bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_leapsecondsknown();
  static const int kLeapSecondsKnownFieldNumber = 3;
  bool leapsecondsknown() const;
  void set_leapsecondsknown(bool value);

  // .commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_timeaccuracy();
  static const int kTimeAccuracyFieldNumber = 4;
  ::commonmodule::TimeAccuracyKind timeaccuracy() const;
  void set_timeaccuracy(::commonmodule::TimeAccuracyKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.TimeQuality)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool clockfailure_;
  bool clocknotsynchronized_;
  bool leapsecondsknown_;
  int timeaccuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Timestamp :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(nullptr);
  }

  Timestamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.TimeQuality tq = 3;
  bool has_tq() const;
  void clear_tq();
  static const int kTqFieldNumber = 3;
  const ::commonmodule::TimeQuality& tq() const;
  ::commonmodule::TimeQuality* release_tq();
  ::commonmodule::TimeQuality* mutable_tq();
  void set_allocated_tq(::commonmodule::TimeQuality* tq);

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  ::google::protobuf::uint64 seconds() const;
  void set_seconds(::google::protobuf::uint64 value);

  // uint32 fraction = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_fraction();
  static const int kFractionFieldNumber = 1;
  ::google::protobuf::uint32 fraction() const;
  void set_fraction(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:commonmodule.Timestamp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::TimeQuality* tq_;
  ::google::protobuf::uint64 seconds_;
  ::google::protobuf::uint32 fraction_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Unit :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Unit) */ {
 public:
  Unit();
  virtual ~Unit();

  Unit(const Unit& from);

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unit(Unit&& from) noexcept
    : Unit() {
    *this = ::std::move(from);
  }

  inline Unit& operator=(Unit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Unit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unit* internal_default_instance() {
    return reinterpret_cast<const Unit*>(
               &_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Unit* other);
  friend void swap(Unit& a, Unit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unit* New() const final {
    return CreateMaybeMessage<Unit>(nullptr);
  }

  Unit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Unit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Unit& from);
  void MergeFrom(const Unit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  bool has_multiplier() const;
  void clear_multiplier();
  static const int kMultiplierFieldNumber = 1;
  const ::commonmodule::Optional_UnitMultiplierKind& multiplier() const;
  ::commonmodule::Optional_UnitMultiplierKind* release_multiplier();
  ::commonmodule::Optional_UnitMultiplierKind* mutable_multiplier();
  void set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier);

  // .commonmodule.UnitSymbolKind SIUnit = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_siunit();
  static const int kSIUnitFieldNumber = 2;
  ::commonmodule::UnitSymbolKind siunit() const;
  void set_siunit(::commonmodule::UnitSymbolKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Unit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Optional_UnitMultiplierKind* multiplier_;
  int siunit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class MV :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.MV) */ {
 public:
  MV();
  virtual ~MV();

  MV(const MV& from);

  inline MV& operator=(const MV& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MV(MV&& from) noexcept
    : MV() {
    *this = ::std::move(from);
  }

  inline MV& operator=(MV&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MV& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MV* internal_default_instance() {
    return reinterpret_cast<const MV*>(
               &_MV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MV* other);
  friend void swap(MV& a, MV& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MV* New() const final {
    return CreateMaybeMessage<MV>(nullptr);
  }

  MV* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MV>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MV& from);
  void MergeFrom(const MV& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MV* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.AnalogueValue mag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_mag() const;
  void clear_mag();
  static const int kMagFieldNumber = 1;
  const ::commonmodule::AnalogueValue& mag() const;
  ::commonmodule::AnalogueValue* release_mag();
  ::commonmodule::AnalogueValue* mutable_mag();
  void set_allocated_mag(::commonmodule::AnalogueValue* mag);

  // .commonmodule.Quality q = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 2;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.Unit units = 4;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 4;
  const ::commonmodule::Unit& units() const;
  ::commonmodule::Unit* release_units();
  ::commonmodule::Unit* mutable_units();
  void set_allocated_units(::commonmodule::Unit* units);

  // @@protoc_insertion_point(class_scope:commonmodule.MV)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::AnalogueValue* mag_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  ::commonmodule::Unit* units_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class LogicalNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.LogicalNode) */ {
 public:
  LogicalNode();
  virtual ~LogicalNode();

  LogicalNode(const LogicalNode& from);

  inline LogicalNode& operator=(const LogicalNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalNode(LogicalNode&& from) noexcept
    : LogicalNode() {
    *this = ::std::move(from);
  }

  inline LogicalNode& operator=(LogicalNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LogicalNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalNode* internal_default_instance() {
    return reinterpret_cast<const LogicalNode*>(
               &_LogicalNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(LogicalNode* other);
  friend void swap(LogicalNode& a, LogicalNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalNode* New() const final {
    return CreateMaybeMessage<LogicalNode>(nullptr);
  }

  LogicalNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalNode& from);
  void MergeFrom(const LogicalNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.LogicalNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class AnalogStatusGGIO :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.AnalogStatusGGIO) */ {
 public:
  AnalogStatusGGIO();
  virtual ~AnalogStatusGGIO();

  AnalogStatusGGIO(const AnalogStatusGGIO& from);

  inline AnalogStatusGGIO& operator=(const AnalogStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalogStatusGGIO(AnalogStatusGGIO&& from) noexcept
    : AnalogStatusGGIO() {
    *this = ::std::move(from);
  }

  inline AnalogStatusGGIO& operator=(AnalogStatusGGIO&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AnalogStatusGGIO& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalogStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const AnalogStatusGGIO*>(
               &_AnalogStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(AnalogStatusGGIO* other);
  friend void swap(AnalogStatusGGIO& a, AnalogStatusGGIO& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalogStatusGGIO* New() const final {
    return CreateMaybeMessage<AnalogStatusGGIO>(nullptr);
  }

  AnalogStatusGGIO* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalogStatusGGIO>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalogStatusGGIO& from);
  void MergeFrom(const AnalogStatusGGIO& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogStatusGGIO* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.MV AnIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_anin() const;
  void clear_anin();
  static const int kAnInFieldNumber = 2;
  const ::commonmodule::MV& anin() const;
  ::commonmodule::MV* release_anin();
  ::commonmodule::MV* mutable_anin();
  void set_allocated_anin(::commonmodule::MV* anin);

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 3;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);

  // @@protoc_insertion_point(class_scope:commonmodule.AnalogStatusGGIO)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::MV* anin_;
  ::commonmodule::Optional_PhaseCodeKind* phase_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class AnalogueValueCtl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.AnalogueValueCtl) */ {
 public:
  AnalogueValueCtl();
  virtual ~AnalogueValueCtl();

  AnalogueValueCtl(const AnalogueValueCtl& from);

  inline AnalogueValueCtl& operator=(const AnalogueValueCtl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalogueValueCtl(AnalogueValueCtl&& from) noexcept
    : AnalogueValueCtl() {
    *this = ::std::move(from);
  }

  inline AnalogueValueCtl& operator=(AnalogueValueCtl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AnalogueValueCtl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalogueValueCtl* internal_default_instance() {
    return reinterpret_cast<const AnalogueValueCtl*>(
               &_AnalogueValueCtl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(AnalogueValueCtl* other);
  friend void swap(AnalogueValueCtl& a, AnalogueValueCtl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalogueValueCtl* New() const final {
    return CreateMaybeMessage<AnalogueValueCtl>(nullptr);
  }

  AnalogueValueCtl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalogueValueCtl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalogueValueCtl& from);
  void MergeFrom(const AnalogueValueCtl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogueValueCtl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue f = 1;
  bool has_f() const;
  void clear_f();
  static const int kFFieldNumber = 1;
  const ::google::protobuf::FloatValue& f() const;
  ::google::protobuf::FloatValue* release_f();
  ::google::protobuf::FloatValue* mutable_f();
  void set_allocated_f(::google::protobuf::FloatValue* f);

  // .google.protobuf.Int32Value i = 2;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 2;
  const ::google::protobuf::Int32Value& i() const;
  ::google::protobuf::Int32Value* release_i();
  ::google::protobuf::Int32Value* mutable_i();
  void set_allocated_i(::google::protobuf::Int32Value* i);

  // @@protoc_insertion_point(class_scope:commonmodule.AnalogueValueCtl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* f_;
  ::google::protobuf::Int32Value* i_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class NamedObject :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.NamedObject) */ {
 public:
  NamedObject();
  virtual ~NamedObject();

  NamedObject(const NamedObject& from);

  inline NamedObject& operator=(const NamedObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NamedObject(NamedObject&& from) noexcept
    : NamedObject() {
    *this = ::std::move(from);
  }

  inline NamedObject& operator=(NamedObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NamedObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamedObject* internal_default_instance() {
    return reinterpret_cast<const NamedObject*>(
               &_NamedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(NamedObject* other);
  friend void swap(NamedObject& a, NamedObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NamedObject* New() const final {
    return CreateMaybeMessage<NamedObject>(nullptr);
  }

  NamedObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NamedObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NamedObject& from);
  void MergeFrom(const NamedObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue description = 1;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::google::protobuf::StringValue& description() const;
  ::google::protobuf::StringValue* release_description();
  ::google::protobuf::StringValue* mutable_description();
  void set_allocated_description(::google::protobuf::StringValue* description);

  // .google.protobuf.StringValue name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::google::protobuf::StringValue& name() const;
  ::google::protobuf::StringValue* release_name();
  ::google::protobuf::StringValue* mutable_name();
  void set_allocated_name(::google::protobuf::StringValue* name);

  // @@protoc_insertion_point(class_scope:commonmodule.NamedObject)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* description_;
  ::google::protobuf::StringValue* name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ApplicationSystem :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ApplicationSystem) */ {
 public:
  ApplicationSystem();
  virtual ~ApplicationSystem();

  ApplicationSystem(const ApplicationSystem& from);

  inline ApplicationSystem& operator=(const ApplicationSystem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApplicationSystem(ApplicationSystem&& from) noexcept
    : ApplicationSystem() {
    *this = ::std::move(from);
  }

  inline ApplicationSystem& operator=(ApplicationSystem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ApplicationSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplicationSystem* internal_default_instance() {
    return reinterpret_cast<const ApplicationSystem*>(
               &_ApplicationSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ApplicationSystem* other);
  friend void swap(ApplicationSystem& a, ApplicationSystem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApplicationSystem* New() const final {
    return CreateMaybeMessage<ApplicationSystem>(nullptr);
  }

  ApplicationSystem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationSystem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApplicationSystem& from);
  void MergeFrom(const ApplicationSystem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true];
  void clear_mrid();
  static const int kMRIDFieldNumber = 2;
  const ::std::string& mrid() const;
  void set_mrid(const ::std::string& value);
  #if LANG_CXX11
  void set_mrid(::std::string&& value);
  #endif
  void set_mrid(const char* value);
  void set_mrid(const char* value, size_t size);
  ::std::string* mutable_mrid();
  ::std::string* release_mrid();
  void set_allocated_mrid(::std::string* mrid);

  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  bool has_namedobject() const;
  void clear_namedobject();
  static const int kNamedObjectFieldNumber = 1;
  const ::commonmodule::NamedObject& namedobject() const;
  ::commonmodule::NamedObject* release_namedobject();
  ::commonmodule::NamedObject* mutable_namedobject();
  void set_allocated_namedobject(::commonmodule::NamedObject* namedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.ApplicationSystem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mrid_;
  ::commonmodule::NamedObject* namedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ASG :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ASG) */ {
 public:
  ASG();
  virtual ~ASG();

  ASG(const ASG& from);

  inline ASG& operator=(const ASG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ASG(ASG&& from) noexcept
    : ASG() {
    *this = ::std::move(from);
  }

  inline ASG& operator=(ASG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ASG& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ASG* internal_default_instance() {
    return reinterpret_cast<const ASG*>(
               &_ASG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ASG* other);
  friend void swap(ASG& a, ASG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ASG* New() const final {
    return CreateMaybeMessage<ASG>(nullptr);
  }

  ASG* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ASG>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ASG& from);
  void MergeFrom(const ASG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.AnalogueValueCtl setMag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_setmag() const;
  void clear_setmag();
  static const int kSetMagFieldNumber = 1;
  const ::commonmodule::AnalogueValueCtl& setmag() const;
  ::commonmodule::AnalogueValueCtl* release_setmag();
  ::commonmodule::AnalogueValueCtl* mutable_setmag();
  void set_allocated_setmag(::commonmodule::AnalogueValueCtl* setmag);

  // .commonmodule.Unit units = 2;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  const ::commonmodule::Unit& units() const;
  ::commonmodule::Unit* release_units();
  ::commonmodule::Unit* mutable_units();
  void set_allocated_units(::commonmodule::Unit* units);

  // @@protoc_insertion_point(class_scope:commonmodule.ASG)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::AnalogueValueCtl* setmag_;
  ::commonmodule::Unit* units_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class BCR :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.BCR) */ {
 public:
  BCR();
  virtual ~BCR();

  BCR(const BCR& from);

  inline BCR& operator=(const BCR& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BCR(BCR&& from) noexcept
    : BCR() {
    *this = ::std::move(from);
  }

  inline BCR& operator=(BCR&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BCR& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BCR* internal_default_instance() {
    return reinterpret_cast<const BCR*>(
               &_BCR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(BCR* other);
  friend void swap(BCR& a, BCR& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BCR* New() const final {
    return CreateMaybeMessage<BCR>(nullptr);
  }

  BCR* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BCR>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BCR& from);
  void MergeFrom(const BCR& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BCR* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 2;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.Optional_UnitSymbolKind units = 4;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 4;
  const ::commonmodule::Optional_UnitSymbolKind& units() const;
  ::commonmodule::Optional_UnitSymbolKind* release_units();
  ::commonmodule::Optional_UnitSymbolKind* mutable_units();
  void set_allocated_units(::commonmodule::Optional_UnitSymbolKind* units);

  // int64 actVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_actval();
  static const int kActValFieldNumber = 1;
  ::google::protobuf::int64 actval() const;
  void set_actval(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:commonmodule.BCR)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  ::commonmodule::Optional_UnitSymbolKind* units_;
  ::google::protobuf::int64 actval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusSPS :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusSPS) */ {
 public:
  StatusSPS();
  virtual ~StatusSPS();

  StatusSPS(const StatusSPS& from);

  inline StatusSPS& operator=(const StatusSPS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusSPS(StatusSPS&& from) noexcept
    : StatusSPS() {
    *this = ::std::move(from);
  }

  inline StatusSPS& operator=(StatusSPS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusSPS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusSPS* internal_default_instance() {
    return reinterpret_cast<const StatusSPS*>(
               &_StatusSPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(StatusSPS* other);
  friend void swap(StatusSPS& a, StatusSPS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusSPS* New() const final {
    return CreateMaybeMessage<StatusSPS>(nullptr);
  }

  StatusSPS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusSPS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusSPS& from);
  void MergeFrom(const StatusSPS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusSPS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  bool stval() const;
  void set_stval(bool value);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusSPS)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  bool stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class BooleanStatusGGIO :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.BooleanStatusGGIO) */ {
 public:
  BooleanStatusGGIO();
  virtual ~BooleanStatusGGIO();

  BooleanStatusGGIO(const BooleanStatusGGIO& from);

  inline BooleanStatusGGIO& operator=(const BooleanStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BooleanStatusGGIO(BooleanStatusGGIO&& from) noexcept
    : BooleanStatusGGIO() {
    *this = ::std::move(from);
  }

  inline BooleanStatusGGIO& operator=(BooleanStatusGGIO&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BooleanStatusGGIO& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BooleanStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const BooleanStatusGGIO*>(
               &_BooleanStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(BooleanStatusGGIO* other);
  friend void swap(BooleanStatusGGIO& a, BooleanStatusGGIO& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BooleanStatusGGIO* New() const final {
    return CreateMaybeMessage<BooleanStatusGGIO>(nullptr);
  }

  BooleanStatusGGIO* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BooleanStatusGGIO>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BooleanStatusGGIO& from);
  void MergeFrom(const BooleanStatusGGIO& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BooleanStatusGGIO* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.StatusSPS Ind = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ind() const;
  void clear_ind();
  static const int kIndFieldNumber = 2;
  const ::commonmodule::StatusSPS& ind() const;
  ::commonmodule::StatusSPS* release_ind();
  ::commonmodule::StatusSPS* mutable_ind();
  void set_allocated_ind(::commonmodule::StatusSPS* ind);

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 3;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);

  // @@protoc_insertion_point(class_scope:commonmodule.BooleanStatusGGIO)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::StatusSPS* ind_;
  ::commonmodule::Optional_PhaseCodeKind* phase_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class CheckConditions :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.CheckConditions) */ {
 public:
  CheckConditions();
  virtual ~CheckConditions();

  CheckConditions(const CheckConditions& from);

  inline CheckConditions& operator=(const CheckConditions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckConditions(CheckConditions&& from) noexcept
    : CheckConditions() {
    *this = ::std::move(from);
  }

  inline CheckConditions& operator=(CheckConditions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CheckConditions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckConditions* internal_default_instance() {
    return reinterpret_cast<const CheckConditions*>(
               &_CheckConditions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CheckConditions* other);
  friend void swap(CheckConditions& a, CheckConditions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckConditions* New() const final {
    return CreateMaybeMessage<CheckConditions>(nullptr);
  }

  CheckConditions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CheckConditions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CheckConditions& from);
  void MergeFrom(const CheckConditions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckConditions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.BoolValue interlockCheck = 1;
  bool has_interlockcheck() const;
  void clear_interlockcheck();
  static const int kInterlockCheckFieldNumber = 1;
  const ::google::protobuf::BoolValue& interlockcheck() const;
  ::google::protobuf::BoolValue* release_interlockcheck();
  ::google::protobuf::BoolValue* mutable_interlockcheck();
  void set_allocated_interlockcheck(::google::protobuf::BoolValue* interlockcheck);

  // .google.protobuf.BoolValue synchroCheck = 2;
  bool has_synchrocheck() const;
  void clear_synchrocheck();
  static const int kSynchroCheckFieldNumber = 2;
  const ::google::protobuf::BoolValue& synchrocheck() const;
  ::google::protobuf::BoolValue* release_synchrocheck();
  ::google::protobuf::BoolValue* mutable_synchrocheck();
  void set_allocated_synchrocheck(::google::protobuf::BoolValue* synchrocheck);

  // @@protoc_insertion_point(class_scope:commonmodule.CheckConditions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::BoolValue* interlockcheck_;
  ::google::protobuf::BoolValue* synchrocheck_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Vector :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(Vector* other);
  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return CreateMaybeMessage<Vector>(nullptr);
  }

  Vector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.AnalogueValue ang = 1;
  bool has_ang() const;
  void clear_ang();
  static const int kAngFieldNumber = 1;
  const ::commonmodule::AnalogueValue& ang() const;
  ::commonmodule::AnalogueValue* release_ang();
  ::commonmodule::AnalogueValue* mutable_ang();
  void set_allocated_ang(::commonmodule::AnalogueValue* ang);

  // .commonmodule.AnalogueValue mag = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_mag() const;
  void clear_mag();
  static const int kMagFieldNumber = 2;
  const ::commonmodule::AnalogueValue& mag() const;
  ::commonmodule::AnalogueValue* release_mag();
  ::commonmodule::AnalogueValue* mutable_mag();
  void set_allocated_mag(::commonmodule::AnalogueValue* mag);

  // @@protoc_insertion_point(class_scope:commonmodule.Vector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::AnalogueValue* ang_;
  ::commonmodule::AnalogueValue* mag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class CMV :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.CMV) */ {
 public:
  CMV();
  virtual ~CMV();

  CMV(const CMV& from);

  inline CMV& operator=(const CMV& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMV(CMV&& from) noexcept
    : CMV() {
    *this = ::std::move(from);
  }

  inline CMV& operator=(CMV&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMV& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMV* internal_default_instance() {
    return reinterpret_cast<const CMV*>(
               &_CMV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CMV* other);
  friend void swap(CMV& a, CMV& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMV* New() const final {
    return CreateMaybeMessage<CMV>(nullptr);
  }

  CMV* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMV>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMV& from);
  void MergeFrom(const CMV& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMV* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Vector cVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_cval() const;
  void clear_cval();
  static const int kCValFieldNumber = 1;
  const ::commonmodule::Vector& cval() const;
  ::commonmodule::Vector* release_cval();
  ::commonmodule::Vector* mutable_cval();
  void set_allocated_cval(::commonmodule::Vector* cval);

  // .commonmodule.Quality q = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 2;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.Unit units = 4;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 4;
  const ::commonmodule::Unit& units() const;
  ::commonmodule::Unit* release_units();
  ::commonmodule::Unit* mutable_units();
  void set_allocated_units(::commonmodule::Unit* units);

  // @@protoc_insertion_point(class_scope:commonmodule.CMV)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Vector* cval_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  ::commonmodule::Unit* units_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ConductingEquipment :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ConductingEquipment) */ {
 public:
  ConductingEquipment();
  virtual ~ConductingEquipment();

  ConductingEquipment(const ConductingEquipment& from);

  inline ConductingEquipment& operator=(const ConductingEquipment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConductingEquipment(ConductingEquipment&& from) noexcept
    : ConductingEquipment() {
    *this = ::std::move(from);
  }

  inline ConductingEquipment& operator=(ConductingEquipment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConductingEquipment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConductingEquipment* internal_default_instance() {
    return reinterpret_cast<const ConductingEquipment*>(
               &_ConductingEquipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ConductingEquipment* other);
  friend void swap(ConductingEquipment& a, ConductingEquipment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConductingEquipment* New() const final {
    return CreateMaybeMessage<ConductingEquipment>(nullptr);
  }

  ConductingEquipment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConductingEquipment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConductingEquipment& from);
  void MergeFrom(const ConductingEquipment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConductingEquipment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true, (.uml.option_key) = true];
  void clear_mrid();
  static const int kMRIDFieldNumber = 2;
  const ::std::string& mrid() const;
  void set_mrid(const ::std::string& value);
  #if LANG_CXX11
  void set_mrid(::std::string&& value);
  #endif
  void set_mrid(const char* value);
  void set_mrid(const char* value, size_t size);
  ::std::string* mutable_mrid();
  ::std::string* release_mrid();
  void set_allocated_mrid(::std::string* mrid);

  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  bool has_namedobject() const;
  void clear_namedobject();
  static const int kNamedObjectFieldNumber = 1;
  const ::commonmodule::NamedObject& namedobject() const;
  ::commonmodule::NamedObject* release_namedobject();
  ::commonmodule::NamedObject* mutable_namedobject();
  void set_allocated_namedobject(::commonmodule::NamedObject* namedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.ConductingEquipment)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mrid_;
  ::commonmodule::NamedObject* namedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Terminal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Terminal) */ {
 public:
  Terminal();
  virtual ~Terminal();

  Terminal(const Terminal& from);

  inline Terminal& operator=(const Terminal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Terminal(Terminal&& from) noexcept
    : Terminal() {
    *this = ::std::move(from);
  }

  inline Terminal& operator=(Terminal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Terminal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Terminal* internal_default_instance() {
    return reinterpret_cast<const Terminal*>(
               &_Terminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(Terminal* other);
  friend void swap(Terminal& a, Terminal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Terminal* New() const final {
    return CreateMaybeMessage<Terminal>(nullptr);
  }

  Terminal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Terminal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Terminal& from);
  void MergeFrom(const Terminal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Terminal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ACDCTerminal aCDCTerminal = 1 [(.uml.option_parent_message) = true];
  bool has_acdcterminal() const;
  void clear_acdcterminal();
  static const int kACDCTerminalFieldNumber = 1;
  const ::commonmodule::ACDCTerminal& acdcterminal() const;
  ::commonmodule::ACDCTerminal* release_acdcterminal();
  ::commonmodule::ACDCTerminal* mutable_acdcterminal();
  void set_allocated_acdcterminal(::commonmodule::ACDCTerminal* acdcterminal);

  // .commonmodule.Optional_PhaseCodeKind phases = 2;
  bool has_phases() const;
  void clear_phases();
  static const int kPhasesFieldNumber = 2;
  const ::commonmodule::Optional_PhaseCodeKind& phases() const;
  ::commonmodule::Optional_PhaseCodeKind* release_phases();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phases();
  void set_allocated_phases(::commonmodule::Optional_PhaseCodeKind* phases);

  // @@protoc_insertion_point(class_scope:commonmodule.Terminal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ACDCTerminal* acdcterminal_;
  ::commonmodule::Optional_PhaseCodeKind* phases_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ConductingEquipmentTerminalReading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ConductingEquipmentTerminalReading) */ {
 public:
  ConductingEquipmentTerminalReading();
  virtual ~ConductingEquipmentTerminalReading();

  ConductingEquipmentTerminalReading(const ConductingEquipmentTerminalReading& from);

  inline ConductingEquipmentTerminalReading& operator=(const ConductingEquipmentTerminalReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConductingEquipmentTerminalReading(ConductingEquipmentTerminalReading&& from) noexcept
    : ConductingEquipmentTerminalReading() {
    *this = ::std::move(from);
  }

  inline ConductingEquipmentTerminalReading& operator=(ConductingEquipmentTerminalReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConductingEquipmentTerminalReading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConductingEquipmentTerminalReading* internal_default_instance() {
    return reinterpret_cast<const ConductingEquipmentTerminalReading*>(
               &_ConductingEquipmentTerminalReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ConductingEquipmentTerminalReading* other);
  friend void swap(ConductingEquipmentTerminalReading& a, ConductingEquipmentTerminalReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConductingEquipmentTerminalReading* New() const final {
    return CreateMaybeMessage<ConductingEquipmentTerminalReading>(nullptr);
  }

  ConductingEquipmentTerminalReading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConductingEquipmentTerminalReading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConductingEquipmentTerminalReading& from);
  void MergeFrom(const ConductingEquipmentTerminalReading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConductingEquipmentTerminalReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Terminal terminal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_terminal() const;
  void clear_terminal();
  static const int kTerminalFieldNumber = 1;
  const ::commonmodule::Terminal& terminal() const;
  ::commonmodule::Terminal* release_terminal();
  ::commonmodule::Terminal* mutable_terminal();
  void set_allocated_terminal(::commonmodule::Terminal* terminal);

  // @@protoc_insertion_point(class_scope:commonmodule.ConductingEquipmentTerminalReading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Terminal* terminal_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlDPC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlDPC) */ {
 public:
  ControlDPC();
  virtual ~ControlDPC();

  ControlDPC(const ControlDPC& from);

  inline ControlDPC& operator=(const ControlDPC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlDPC(ControlDPC&& from) noexcept
    : ControlDPC() {
    *this = ::std::move(from);
  }

  inline ControlDPC& operator=(ControlDPC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlDPC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlDPC* internal_default_instance() {
    return reinterpret_cast<const ControlDPC*>(
               &_ControlDPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(ControlDPC* other);
  friend void swap(ControlDPC& a, ControlDPC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlDPC* New() const final {
    return CreateMaybeMessage<ControlDPC>(nullptr);
  }

  ControlDPC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlDPC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlDPC& from);
  void MergeFrom(const ControlDPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlDPC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval();
  static const int kCtlValFieldNumber = 1;
  bool ctlval() const;
  void set_ctlval(bool value);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlDPC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool ctlval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlTimestamp :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlTimestamp) */ {
 public:
  ControlTimestamp();
  virtual ~ControlTimestamp();

  ControlTimestamp(const ControlTimestamp& from);

  inline ControlTimestamp& operator=(const ControlTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlTimestamp(ControlTimestamp&& from) noexcept
    : ControlTimestamp() {
    *this = ::std::move(from);
  }

  inline ControlTimestamp& operator=(ControlTimestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlTimestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlTimestamp* internal_default_instance() {
    return reinterpret_cast<const ControlTimestamp*>(
               &_ControlTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ControlTimestamp* other);
  friend void swap(ControlTimestamp& a, ControlTimestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlTimestamp* New() const final {
    return CreateMaybeMessage<ControlTimestamp>(nullptr);
  }

  ControlTimestamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlTimestamp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlTimestamp& from);
  void MergeFrom(const ControlTimestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlTimestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  ::google::protobuf::uint64 seconds() const;
  void set_seconds(::google::protobuf::uint64 value);

  // uint32 fraction = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_fraction();
  static const int kFractionFieldNumber = 1;
  ::google::protobuf::uint32 fraction() const;
  void set_fraction(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlTimestamp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 seconds_;
  ::google::protobuf::uint32 fraction_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_ScheduleParameterKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_ScheduleParameterKind) */ {
 public:
  Optional_ScheduleParameterKind();
  virtual ~Optional_ScheduleParameterKind();

  Optional_ScheduleParameterKind(const Optional_ScheduleParameterKind& from);

  inline Optional_ScheduleParameterKind& operator=(const Optional_ScheduleParameterKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_ScheduleParameterKind(Optional_ScheduleParameterKind&& from) noexcept
    : Optional_ScheduleParameterKind() {
    *this = ::std::move(from);
  }

  inline Optional_ScheduleParameterKind& operator=(Optional_ScheduleParameterKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_ScheduleParameterKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_ScheduleParameterKind* internal_default_instance() {
    return reinterpret_cast<const Optional_ScheduleParameterKind*>(
               &_Optional_ScheduleParameterKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(Optional_ScheduleParameterKind* other);
  friend void swap(Optional_ScheduleParameterKind& a, Optional_ScheduleParameterKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_ScheduleParameterKind* New() const final {
    return CreateMaybeMessage<Optional_ScheduleParameterKind>(nullptr);
  }

  Optional_ScheduleParameterKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_ScheduleParameterKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_ScheduleParameterKind& from);
  void MergeFrom(const Optional_ScheduleParameterKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_ScheduleParameterKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ScheduleParameterKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::ScheduleParameterKind value() const;
  void set_value(::commonmodule::ScheduleParameterKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_ScheduleParameterKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENG_ScheduleParameter :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_ScheduleParameter) */ {
 public:
  ENG_ScheduleParameter();
  virtual ~ENG_ScheduleParameter();

  ENG_ScheduleParameter(const ENG_ScheduleParameter& from);

  inline ENG_ScheduleParameter& operator=(const ENG_ScheduleParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENG_ScheduleParameter(ENG_ScheduleParameter&& from) noexcept
    : ENG_ScheduleParameter() {
    *this = ::std::move(from);
  }

  inline ENG_ScheduleParameter& operator=(ENG_ScheduleParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENG_ScheduleParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENG_ScheduleParameter* internal_default_instance() {
    return reinterpret_cast<const ENG_ScheduleParameter*>(
               &_ENG_ScheduleParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ENG_ScheduleParameter* other);
  friend void swap(ENG_ScheduleParameter& a, ENG_ScheduleParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENG_ScheduleParameter* New() const final {
    return CreateMaybeMessage<ENG_ScheduleParameter>(nullptr);
  }

  ENG_ScheduleParameter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENG_ScheduleParameter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENG_ScheduleParameter& from);
  void MergeFrom(const ENG_ScheduleParameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_ScheduleParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ScheduleParameterKind scheduleParameterType = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_scheduleparametertype();
  static const int kScheduleParameterTypeFieldNumber = 1;
  ::commonmodule::ScheduleParameterKind scheduleparametertype() const;
  void set_scheduleparametertype(::commonmodule::ScheduleParameterKind value);

  // float value = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENG_ScheduleParameter)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int scheduleparametertype_;
  float value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class SchedulePoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.SchedulePoint) */ {
 public:
  SchedulePoint();
  virtual ~SchedulePoint();

  SchedulePoint(const SchedulePoint& from);

  inline SchedulePoint& operator=(const SchedulePoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SchedulePoint(SchedulePoint&& from) noexcept
    : SchedulePoint() {
    *this = ::std::move(from);
  }

  inline SchedulePoint& operator=(SchedulePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SchedulePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedulePoint* internal_default_instance() {
    return reinterpret_cast<const SchedulePoint*>(
               &_SchedulePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(SchedulePoint* other);
  friend void swap(SchedulePoint& a, SchedulePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SchedulePoint* New() const final {
    return CreateMaybeMessage<SchedulePoint>(nullptr);
  }

  SchedulePoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SchedulePoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SchedulePoint& from);
  void MergeFrom(const SchedulePoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedulePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int scheduleparameter_size() const;
  void clear_scheduleparameter();
  static const int kScheduleParameterFieldNumber = 1;
  ::commonmodule::ENG_ScheduleParameter* mutable_scheduleparameter(int index);
  ::google::protobuf::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >*
      mutable_scheduleparameter();
  const ::commonmodule::ENG_ScheduleParameter& scheduleparameter(int index) const;
  ::commonmodule::ENG_ScheduleParameter* add_scheduleparameter();
  const ::google::protobuf::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >&
      scheduleparameter() const;

  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 2;
  const ::commonmodule::ControlTimestamp& starttime() const;
  ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);

  // @@protoc_insertion_point(class_scope:commonmodule.SchedulePoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter > scheduleparameter_;
  ::commonmodule::ControlTimestamp* starttime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ScheduleCSG :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ScheduleCSG) */ {
 public:
  ScheduleCSG();
  virtual ~ScheduleCSG();

  ScheduleCSG(const ScheduleCSG& from);

  inline ScheduleCSG& operator=(const ScheduleCSG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScheduleCSG(ScheduleCSG&& from) noexcept
    : ScheduleCSG() {
    *this = ::std::move(from);
  }

  inline ScheduleCSG& operator=(ScheduleCSG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ScheduleCSG& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScheduleCSG* internal_default_instance() {
    return reinterpret_cast<const ScheduleCSG*>(
               &_ScheduleCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(ScheduleCSG* other);
  friend void swap(ScheduleCSG& a, ScheduleCSG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScheduleCSG* New() const final {
    return CreateMaybeMessage<ScheduleCSG>(nullptr);
  }

  ScheduleCSG* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScheduleCSG>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScheduleCSG& from);
  void MergeFrom(const ScheduleCSG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleCSG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .commonmodule.SchedulePoint schPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int schpts_size() const;
  void clear_schpts();
  static const int kSchPtsFieldNumber = 1;
  ::commonmodule::SchedulePoint* mutable_schpts(int index);
  ::google::protobuf::RepeatedPtrField< ::commonmodule::SchedulePoint >*
      mutable_schpts();
  const ::commonmodule::SchedulePoint& schpts(int index) const;
  ::commonmodule::SchedulePoint* add_schpts();
  const ::google::protobuf::RepeatedPtrField< ::commonmodule::SchedulePoint >&
      schpts() const;

  // @@protoc_insertion_point(class_scope:commonmodule.ScheduleCSG)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::commonmodule::SchedulePoint > schpts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlScheduleFSCH :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlScheduleFSCH) */ {
 public:
  ControlScheduleFSCH();
  virtual ~ControlScheduleFSCH();

  ControlScheduleFSCH(const ControlScheduleFSCH& from);

  inline ControlScheduleFSCH& operator=(const ControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlScheduleFSCH(ControlScheduleFSCH&& from) noexcept
    : ControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline ControlScheduleFSCH& operator=(ControlScheduleFSCH&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlScheduleFSCH& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const ControlScheduleFSCH*>(
               &_ControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(ControlScheduleFSCH* other);
  friend void swap(ControlScheduleFSCH& a, ControlScheduleFSCH& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlScheduleFSCH* New() const final {
    return CreateMaybeMessage<ControlScheduleFSCH>(nullptr);
  }

  ControlScheduleFSCH* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlScheduleFSCH>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlScheduleFSCH& from);
  void MergeFrom(const ControlScheduleFSCH& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlScheduleFSCH* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valacsg() const;
  void clear_valacsg();
  static const int kValACSGFieldNumber = 1;
  const ::commonmodule::ScheduleCSG& valacsg() const;
  ::commonmodule::ScheduleCSG* release_valacsg();
  ::commonmodule::ScheduleCSG* mutable_valacsg();
  void set_allocated_valacsg(::commonmodule::ScheduleCSG* valacsg);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlScheduleFSCH)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ScheduleCSG* valacsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class LogicalNodeForControl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.LogicalNodeForControl) */ {
 public:
  LogicalNodeForControl();
  virtual ~LogicalNodeForControl();

  LogicalNodeForControl(const LogicalNodeForControl& from);

  inline LogicalNodeForControl& operator=(const LogicalNodeForControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalNodeForControl(LogicalNodeForControl&& from) noexcept
    : LogicalNodeForControl() {
    *this = ::std::move(from);
  }

  inline LogicalNodeForControl& operator=(LogicalNodeForControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LogicalNodeForControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalNodeForControl* internal_default_instance() {
    return reinterpret_cast<const LogicalNodeForControl*>(
               &_LogicalNodeForControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(LogicalNodeForControl* other);
  friend void swap(LogicalNodeForControl& a, LogicalNodeForControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalNodeForControl* New() const final {
    return CreateMaybeMessage<LogicalNodeForControl>(nullptr);
  }

  LogicalNodeForControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalNodeForControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalNodeForControl& from);
  void MergeFrom(const LogicalNodeForControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalNodeForControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // @@protoc_insertion_point(class_scope:commonmodule.LogicalNodeForControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlFSCC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlFSCC) */ {
 public:
  ControlFSCC();
  virtual ~ControlFSCC();

  ControlFSCC(const ControlFSCC& from);

  inline ControlFSCC& operator=(const ControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlFSCC(ControlFSCC&& from) noexcept
    : ControlFSCC() {
    *this = ::std::move(from);
  }

  inline ControlFSCC& operator=(ControlFSCC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlFSCC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlFSCC* internal_default_instance() {
    return reinterpret_cast<const ControlFSCC*>(
               &_ControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(ControlFSCC* other);
  friend void swap(ControlFSCC& a, ControlFSCC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlFSCC* New() const final {
    return CreateMaybeMessage<ControlFSCC>(nullptr);
  }

  ControlFSCC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlFSCC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlFSCC& from);
  void MergeFrom(const ControlFSCC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlFSCC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol();
  static const int kLogicalNodeForControlFieldNumber = 1;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);

  // .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;
  bool has_controlschedulefsch() const;
  void clear_controlschedulefsch();
  static const int kControlScheduleFSCHFieldNumber = 2;
  const ::commonmodule::ControlScheduleFSCH& controlschedulefsch() const;
  ::commonmodule::ControlScheduleFSCH* release_controlschedulefsch();
  ::commonmodule::ControlScheduleFSCH* mutable_controlschedulefsch();
  void set_allocated_controlschedulefsch(::commonmodule::ControlScheduleFSCH* controlschedulefsch);

  // .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;
  bool has_islandcontrolschedulefsch() const;
  void clear_islandcontrolschedulefsch();
  static const int kIslandControlScheduleFSCHFieldNumber = 3;
  const ::commonmodule::ControlScheduleFSCH& islandcontrolschedulefsch() const;
  ::commonmodule::ControlScheduleFSCH* release_islandcontrolschedulefsch();
  ::commonmodule::ControlScheduleFSCH* mutable_islandcontrolschedulefsch();
  void set_allocated_islandcontrolschedulefsch(::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlFSCC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
  ::commonmodule::ControlScheduleFSCH* controlschedulefsch_;
  ::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlING :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlING) */ {
 public:
  ControlING();
  virtual ~ControlING();

  ControlING(const ControlING& from);

  inline ControlING& operator=(const ControlING& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlING(ControlING&& from) noexcept
    : ControlING() {
    *this = ::std::move(from);
  }

  inline ControlING& operator=(ControlING&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlING& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlING* internal_default_instance() {
    return reinterpret_cast<const ControlING*>(
               &_ControlING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(ControlING* other);
  friend void swap(ControlING& a, ControlING& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlING* New() const final {
    return CreateMaybeMessage<ControlING>(nullptr);
  }

  ControlING* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlING>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlING& from);
  void MergeFrom(const ControlING& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlING* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Unit units = 2;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  const ::commonmodule::Unit& units() const;
  ::commonmodule::Unit* release_units();
  ::commonmodule::Unit* mutable_units();
  void set_allocated_units(::commonmodule::Unit* units);

  // int32 setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval();
  static const int kSetValFieldNumber = 1;
  ::google::protobuf::int32 setval() const;
  void set_setval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlING)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Unit* units_;
  ::google::protobuf::int32 setval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlISC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlISC) */ {
 public:
  ControlISC();
  virtual ~ControlISC();

  ControlISC(const ControlISC& from);

  inline ControlISC& operator=(const ControlISC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlISC(ControlISC&& from) noexcept
    : ControlISC() {
    *this = ::std::move(from);
  }

  inline ControlISC& operator=(ControlISC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlISC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlISC* internal_default_instance() {
    return reinterpret_cast<const ControlISC*>(
               &_ControlISC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(ControlISC* other);
  friend void swap(ControlISC& a, ControlISC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlISC* New() const final {
    return CreateMaybeMessage<ControlISC>(nullptr);
  }

  ControlISC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlISC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlISC& from);
  void MergeFrom(const ControlISC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlISC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval();
  static const int kCtlValFieldNumber = 1;
  ::google::protobuf::int32 ctlval() const;
  void set_ctlval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlISC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ctlval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class MessageInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.MessageInfo) */ {
 public:
  MessageInfo();
  virtual ~MessageInfo();

  MessageInfo(const MessageInfo& from);

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageInfo(MessageInfo&& from) noexcept
    : MessageInfo() {
    *this = ::std::move(from);
  }

  inline MessageInfo& operator=(MessageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageInfo* internal_default_instance() {
    return reinterpret_cast<const MessageInfo*>(
               &_MessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(MessageInfo* other);
  friend void swap(MessageInfo& a, MessageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageInfo* New() const final {
    return CreateMaybeMessage<MessageInfo>(nullptr);
  }

  MessageInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageInfo& from);
  void MergeFrom(const MessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // .commonmodule.Timestamp messageTimeStamp = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_messagetimestamp() const;
  void clear_messagetimestamp();
  static const int kMessageTimeStampFieldNumber = 2;
  const ::commonmodule::Timestamp& messagetimestamp() const;
  ::commonmodule::Timestamp* release_messagetimestamp();
  ::commonmodule::Timestamp* mutable_messagetimestamp();
  void set_allocated_messagetimestamp(::commonmodule::Timestamp* messagetimestamp);

  // @@protoc_insertion_point(class_scope:commonmodule.MessageInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  ::commonmodule::Timestamp* messagetimestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlMessageInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlMessageInfo) */ {
 public:
  ControlMessageInfo();
  virtual ~ControlMessageInfo();

  ControlMessageInfo(const ControlMessageInfo& from);

  inline ControlMessageInfo& operator=(const ControlMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlMessageInfo(ControlMessageInfo&& from) noexcept
    : ControlMessageInfo() {
    *this = ::std::move(from);
  }

  inline ControlMessageInfo& operator=(ControlMessageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlMessageInfo* internal_default_instance() {
    return reinterpret_cast<const ControlMessageInfo*>(
               &_ControlMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(ControlMessageInfo* other);
  friend void swap(ControlMessageInfo& a, ControlMessageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlMessageInfo* New() const final {
    return CreateMaybeMessage<ControlMessageInfo>(nullptr);
  }

  ControlMessageInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlMessageInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlMessageInfo& from);
  void MergeFrom(const ControlMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  void clear_messageinfo();
  static const int kMessageInfoFieldNumber = 1;
  const ::commonmodule::MessageInfo& messageinfo() const;
  ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlMessageInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::MessageInfo* messageinfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlSPC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlSPC) */ {
 public:
  ControlSPC();
  virtual ~ControlSPC();

  ControlSPC(const ControlSPC& from);

  inline ControlSPC& operator=(const ControlSPC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlSPC(ControlSPC&& from) noexcept
    : ControlSPC() {
    *this = ::std::move(from);
  }

  inline ControlSPC& operator=(ControlSPC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlSPC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlSPC* internal_default_instance() {
    return reinterpret_cast<const ControlSPC*>(
               &_ControlSPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(ControlSPC* other);
  friend void swap(ControlSPC& a, ControlSPC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlSPC* New() const final {
    return CreateMaybeMessage<ControlSPC>(nullptr);
  }

  ControlSPC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlSPC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlSPC& from);
  void MergeFrom(const ControlSPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlSPC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval();
  static const int kCtlValFieldNumber = 1;
  bool ctlval() const;
  void set_ctlval(bool value);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlSPC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool ctlval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ControlValue :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlValue) */ {
 public:
  ControlValue();
  virtual ~ControlValue();

  ControlValue(const ControlValue& from);

  inline ControlValue& operator=(const ControlValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlValue(ControlValue&& from) noexcept
    : ControlValue() {
    *this = ::std::move(from);
  }

  inline ControlValue& operator=(ControlValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ControlValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlValue* internal_default_instance() {
    return reinterpret_cast<const ControlValue*>(
               &_ControlValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(ControlValue* other);
  friend void swap(ControlValue& a, ControlValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlValue* New() const final {
    return CreateMaybeMessage<ControlValue>(nullptr);
  }

  ControlValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ControlValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ControlValue& from);
  void MergeFrom(const ControlValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // .google.protobuf.BoolValue modBlk = 2;
  bool has_modblk() const;
  void clear_modblk();
  static const int kModBlkFieldNumber = 2;
  const ::google::protobuf::BoolValue& modblk() const;
  ::google::protobuf::BoolValue* release_modblk();
  ::google::protobuf::BoolValue* mutable_modblk();
  void set_allocated_modblk(::google::protobuf::BoolValue* modblk);

  // @@protoc_insertion_point(class_scope:commonmodule.ControlValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  ::google::protobuf::BoolValue* modblk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class DateTimeInterval :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.DateTimeInterval) */ {
 public:
  DateTimeInterval();
  virtual ~DateTimeInterval();

  DateTimeInterval(const DateTimeInterval& from);

  inline DateTimeInterval& operator=(const DateTimeInterval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DateTimeInterval(DateTimeInterval&& from) noexcept
    : DateTimeInterval() {
    *this = ::std::move(from);
  }

  inline DateTimeInterval& operator=(DateTimeInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DateTimeInterval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DateTimeInterval* internal_default_instance() {
    return reinterpret_cast<const DateTimeInterval*>(
               &_DateTimeInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(DateTimeInterval* other);
  friend void swap(DateTimeInterval& a, DateTimeInterval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DateTimeInterval* New() const final {
    return CreateMaybeMessage<DateTimeInterval>(nullptr);
  }

  DateTimeInterval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DateTimeInterval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DateTimeInterval& from);
  void MergeFrom(const DateTimeInterval& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DateTimeInterval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int64Value end = 1;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 1;
  const ::google::protobuf::Int64Value& end() const;
  ::google::protobuf::Int64Value* release_end();
  ::google::protobuf::Int64Value* mutable_end();
  void set_allocated_end(::google::protobuf::Int64Value* end);

  // .google.protobuf.Int64Value start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::google::protobuf::Int64Value& start() const;
  ::google::protobuf::Int64Value* release_start();
  ::google::protobuf::Int64Value* mutable_start();
  void set_allocated_start(::google::protobuf::Int64Value* start);

  // @@protoc_insertion_point(class_scope:commonmodule.DateTimeInterval)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int64Value* end_;
  ::google::protobuf::Int64Value* start_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class DEL :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.DEL) */ {
 public:
  DEL();
  virtual ~DEL();

  DEL(const DEL& from);

  inline DEL& operator=(const DEL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DEL(DEL&& from) noexcept
    : DEL() {
    *this = ::std::move(from);
  }

  inline DEL& operator=(DEL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DEL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DEL* internal_default_instance() {
    return reinterpret_cast<const DEL*>(
               &_DEL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(DEL* other);
  friend void swap(DEL& a, DEL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DEL* New() const final {
    return CreateMaybeMessage<DEL>(nullptr);
  }

  DEL* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DEL>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DEL& from);
  void MergeFrom(const DEL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DEL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.CMV phsAB = 1;
  bool has_phsab() const;
  void clear_phsab();
  static const int kPhsABFieldNumber = 1;
  const ::commonmodule::CMV& phsab() const;
  ::commonmodule::CMV* release_phsab();
  ::commonmodule::CMV* mutable_phsab();
  void set_allocated_phsab(::commonmodule::CMV* phsab);

  // .commonmodule.CMV phsBC = 2;
  bool has_phsbc() const;
  void clear_phsbc();
  static const int kPhsBCFieldNumber = 2;
  const ::commonmodule::CMV& phsbc() const;
  ::commonmodule::CMV* release_phsbc();
  ::commonmodule::CMV* mutable_phsbc();
  void set_allocated_phsbc(::commonmodule::CMV* phsbc);

  // .commonmodule.CMV phsCA = 3;
  bool has_phsca() const;
  void clear_phsca();
  static const int kPhsCAFieldNumber = 3;
  const ::commonmodule::CMV& phsca() const;
  ::commonmodule::CMV* release_phsca();
  ::commonmodule::CMV* mutable_phsca();
  void set_allocated_phsca(::commonmodule::CMV* phsca);

  // @@protoc_insertion_point(class_scope:commonmodule.DEL)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::CMV* phsab_;
  ::commonmodule::CMV* phsbc_;
  ::commonmodule::CMV* phsca_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class EnergyConsumer :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.EnergyConsumer) */ {
 public:
  EnergyConsumer();
  virtual ~EnergyConsumer();

  EnergyConsumer(const EnergyConsumer& from);

  inline EnergyConsumer& operator=(const EnergyConsumer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnergyConsumer(EnergyConsumer&& from) noexcept
    : EnergyConsumer() {
    *this = ::std::move(from);
  }

  inline EnergyConsumer& operator=(EnergyConsumer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EnergyConsumer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnergyConsumer* internal_default_instance() {
    return reinterpret_cast<const EnergyConsumer*>(
               &_EnergyConsumer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(EnergyConsumer* other);
  friend void swap(EnergyConsumer& a, EnergyConsumer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnergyConsumer* New() const final {
    return CreateMaybeMessage<EnergyConsumer>(nullptr);
  }

  EnergyConsumer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnergyConsumer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnergyConsumer& from);
  void MergeFrom(const EnergyConsumer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnergyConsumer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment();
  static const int kConductingEquipmentFieldNumber = 1;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);

  // .google.protobuf.StringValue operatingLimit = 2;
  bool has_operatinglimit() const;
  void clear_operatinglimit();
  static const int kOperatingLimitFieldNumber = 2;
  const ::google::protobuf::StringValue& operatinglimit() const;
  ::google::protobuf::StringValue* release_operatinglimit();
  ::google::protobuf::StringValue* mutable_operatinglimit();
  void set_allocated_operatinglimit(::google::protobuf::StringValue* operatinglimit);

  // @@protoc_insertion_point(class_scope:commonmodule.EnergyConsumer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipment* conductingequipment_;
  ::google::protobuf::StringValue* operatinglimit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_CalcMethodKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_CalcMethodKind) */ {
 public:
  Optional_CalcMethodKind();
  virtual ~Optional_CalcMethodKind();

  Optional_CalcMethodKind(const Optional_CalcMethodKind& from);

  inline Optional_CalcMethodKind& operator=(const Optional_CalcMethodKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_CalcMethodKind(Optional_CalcMethodKind&& from) noexcept
    : Optional_CalcMethodKind() {
    *this = ::std::move(from);
  }

  inline Optional_CalcMethodKind& operator=(Optional_CalcMethodKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_CalcMethodKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_CalcMethodKind* internal_default_instance() {
    return reinterpret_cast<const Optional_CalcMethodKind*>(
               &_Optional_CalcMethodKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(Optional_CalcMethodKind* other);
  friend void swap(Optional_CalcMethodKind& a, Optional_CalcMethodKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_CalcMethodKind* New() const final {
    return CreateMaybeMessage<Optional_CalcMethodKind>(nullptr);
  }

  Optional_CalcMethodKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_CalcMethodKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_CalcMethodKind& from);
  void MergeFrom(const Optional_CalcMethodKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_CalcMethodKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.CalcMethodKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::CalcMethodKind value() const;
  void set_value(::commonmodule::CalcMethodKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_CalcMethodKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENG_CalcMethodKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_CalcMethodKind) */ {
 public:
  ENG_CalcMethodKind();
  virtual ~ENG_CalcMethodKind();

  ENG_CalcMethodKind(const ENG_CalcMethodKind& from);

  inline ENG_CalcMethodKind& operator=(const ENG_CalcMethodKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENG_CalcMethodKind(ENG_CalcMethodKind&& from) noexcept
    : ENG_CalcMethodKind() {
    *this = ::std::move(from);
  }

  inline ENG_CalcMethodKind& operator=(ENG_CalcMethodKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENG_CalcMethodKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENG_CalcMethodKind* internal_default_instance() {
    return reinterpret_cast<const ENG_CalcMethodKind*>(
               &_ENG_CalcMethodKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(ENG_CalcMethodKind* other);
  friend void swap(ENG_CalcMethodKind& a, ENG_CalcMethodKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENG_CalcMethodKind* New() const final {
    return CreateMaybeMessage<ENG_CalcMethodKind>(nullptr);
  }

  ENG_CalcMethodKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENG_CalcMethodKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENG_CalcMethodKind& from);
  void MergeFrom(const ENG_CalcMethodKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_CalcMethodKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.CalcMethodKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval();
  static const int kSetValFieldNumber = 1;
  ::commonmodule::CalcMethodKind setval() const;
  void set_setval(::commonmodule::CalcMethodKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENG_CalcMethodKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int setval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_GridConnectModeKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_GridConnectModeKind) */ {
 public:
  Optional_GridConnectModeKind();
  virtual ~Optional_GridConnectModeKind();

  Optional_GridConnectModeKind(const Optional_GridConnectModeKind& from);

  inline Optional_GridConnectModeKind& operator=(const Optional_GridConnectModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_GridConnectModeKind(Optional_GridConnectModeKind&& from) noexcept
    : Optional_GridConnectModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_GridConnectModeKind& operator=(Optional_GridConnectModeKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_GridConnectModeKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_GridConnectModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_GridConnectModeKind*>(
               &_Optional_GridConnectModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(Optional_GridConnectModeKind* other);
  friend void swap(Optional_GridConnectModeKind& a, Optional_GridConnectModeKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_GridConnectModeKind* New() const final {
    return CreateMaybeMessage<Optional_GridConnectModeKind>(nullptr);
  }

  Optional_GridConnectModeKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_GridConnectModeKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_GridConnectModeKind& from);
  void MergeFrom(const Optional_GridConnectModeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_GridConnectModeKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.GridConnectModeKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::GridConnectModeKind value() const;
  void set_value(::commonmodule::GridConnectModeKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_GridConnectModeKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENG_GridConnectModeKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_GridConnectModeKind) */ {
 public:
  ENG_GridConnectModeKind();
  virtual ~ENG_GridConnectModeKind();

  ENG_GridConnectModeKind(const ENG_GridConnectModeKind& from);

  inline ENG_GridConnectModeKind& operator=(const ENG_GridConnectModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENG_GridConnectModeKind(ENG_GridConnectModeKind&& from) noexcept
    : ENG_GridConnectModeKind() {
    *this = ::std::move(from);
  }

  inline ENG_GridConnectModeKind& operator=(ENG_GridConnectModeKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENG_GridConnectModeKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENG_GridConnectModeKind* internal_default_instance() {
    return reinterpret_cast<const ENG_GridConnectModeKind*>(
               &_ENG_GridConnectModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(ENG_GridConnectModeKind* other);
  friend void swap(ENG_GridConnectModeKind& a, ENG_GridConnectModeKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENG_GridConnectModeKind* New() const final {
    return CreateMaybeMessage<ENG_GridConnectModeKind>(nullptr);
  }

  ENG_GridConnectModeKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENG_GridConnectModeKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENG_GridConnectModeKind& from);
  void MergeFrom(const ENG_GridConnectModeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_GridConnectModeKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue setValExtension = 2;
  bool has_setvalextension() const;
  void clear_setvalextension();
  static const int kSetValExtensionFieldNumber = 2;
  const ::google::protobuf::StringValue& setvalextension() const;
  ::google::protobuf::StringValue* release_setvalextension();
  ::google::protobuf::StringValue* mutable_setvalextension();
  void set_allocated_setvalextension(::google::protobuf::StringValue* setvalextension);

  // .commonmodule.GridConnectModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval();
  static const int kSetValFieldNumber = 1;
  ::commonmodule::GridConnectModeKind setval() const;
  void set_setval(::commonmodule::GridConnectModeKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENG_GridConnectModeKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* setvalextension_;
  int setval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_PFSignKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_PFSignKind) */ {
 public:
  Optional_PFSignKind();
  virtual ~Optional_PFSignKind();

  Optional_PFSignKind(const Optional_PFSignKind& from);

  inline Optional_PFSignKind& operator=(const Optional_PFSignKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_PFSignKind(Optional_PFSignKind&& from) noexcept
    : Optional_PFSignKind() {
    *this = ::std::move(from);
  }

  inline Optional_PFSignKind& operator=(Optional_PFSignKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_PFSignKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_PFSignKind* internal_default_instance() {
    return reinterpret_cast<const Optional_PFSignKind*>(
               &_Optional_PFSignKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(Optional_PFSignKind* other);
  friend void swap(Optional_PFSignKind& a, Optional_PFSignKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_PFSignKind* New() const final {
    return CreateMaybeMessage<Optional_PFSignKind>(nullptr);
  }

  Optional_PFSignKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_PFSignKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_PFSignKind& from);
  void MergeFrom(const Optional_PFSignKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_PFSignKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.PFSignKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::PFSignKind value() const;
  void set_value(::commonmodule::PFSignKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_PFSignKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENG_PFSignKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_PFSignKind) */ {
 public:
  ENG_PFSignKind();
  virtual ~ENG_PFSignKind();

  ENG_PFSignKind(const ENG_PFSignKind& from);

  inline ENG_PFSignKind& operator=(const ENG_PFSignKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENG_PFSignKind(ENG_PFSignKind&& from) noexcept
    : ENG_PFSignKind() {
    *this = ::std::move(from);
  }

  inline ENG_PFSignKind& operator=(ENG_PFSignKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENG_PFSignKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENG_PFSignKind* internal_default_instance() {
    return reinterpret_cast<const ENG_PFSignKind*>(
               &_ENG_PFSignKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(ENG_PFSignKind* other);
  friend void swap(ENG_PFSignKind& a, ENG_PFSignKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENG_PFSignKind* New() const final {
    return CreateMaybeMessage<ENG_PFSignKind>(nullptr);
  }

  ENG_PFSignKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENG_PFSignKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENG_PFSignKind& from);
  void MergeFrom(const ENG_PFSignKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_PFSignKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.PFSignKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval();
  static const int kSetValFieldNumber = 1;
  ::commonmodule::PFSignKind setval() const;
  void set_setval(::commonmodule::PFSignKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENG_PFSignKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int setval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_BehaviourModeKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_BehaviourModeKind) */ {
 public:
  Optional_BehaviourModeKind();
  virtual ~Optional_BehaviourModeKind();

  Optional_BehaviourModeKind(const Optional_BehaviourModeKind& from);

  inline Optional_BehaviourModeKind& operator=(const Optional_BehaviourModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_BehaviourModeKind(Optional_BehaviourModeKind&& from) noexcept
    : Optional_BehaviourModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_BehaviourModeKind& operator=(Optional_BehaviourModeKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_BehaviourModeKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_BehaviourModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_BehaviourModeKind*>(
               &_Optional_BehaviourModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(Optional_BehaviourModeKind* other);
  friend void swap(Optional_BehaviourModeKind& a, Optional_BehaviourModeKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_BehaviourModeKind* New() const final {
    return CreateMaybeMessage<Optional_BehaviourModeKind>(nullptr);
  }

  Optional_BehaviourModeKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_BehaviourModeKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_BehaviourModeKind& from);
  void MergeFrom(const Optional_BehaviourModeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_BehaviourModeKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.BehaviourModeKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::BehaviourModeKind value() const;
  void set_value(::commonmodule::BehaviourModeKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_BehaviourModeKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENS_BehaviourModeKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_BehaviourModeKind) */ {
 public:
  ENS_BehaviourModeKind();
  virtual ~ENS_BehaviourModeKind();

  ENS_BehaviourModeKind(const ENS_BehaviourModeKind& from);

  inline ENS_BehaviourModeKind& operator=(const ENS_BehaviourModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENS_BehaviourModeKind(ENS_BehaviourModeKind&& from) noexcept
    : ENS_BehaviourModeKind() {
    *this = ::std::move(from);
  }

  inline ENS_BehaviourModeKind& operator=(ENS_BehaviourModeKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENS_BehaviourModeKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENS_BehaviourModeKind* internal_default_instance() {
    return reinterpret_cast<const ENS_BehaviourModeKind*>(
               &_ENS_BehaviourModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(ENS_BehaviourModeKind* other);
  friend void swap(ENS_BehaviourModeKind& a, ENS_BehaviourModeKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENS_BehaviourModeKind* New() const final {
    return CreateMaybeMessage<ENS_BehaviourModeKind>(nullptr);
  }

  ENS_BehaviourModeKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENS_BehaviourModeKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENS_BehaviourModeKind& from);
  void MergeFrom(const ENS_BehaviourModeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_BehaviourModeKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.BehaviourModeKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  ::commonmodule::BehaviourModeKind stval() const;
  void set_stval(::commonmodule::BehaviourModeKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENS_BehaviourModeKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  int stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_DERGeneratorStateKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_DERGeneratorStateKind) */ {
 public:
  Optional_DERGeneratorStateKind();
  virtual ~Optional_DERGeneratorStateKind();

  Optional_DERGeneratorStateKind(const Optional_DERGeneratorStateKind& from);

  inline Optional_DERGeneratorStateKind& operator=(const Optional_DERGeneratorStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_DERGeneratorStateKind(Optional_DERGeneratorStateKind&& from) noexcept
    : Optional_DERGeneratorStateKind() {
    *this = ::std::move(from);
  }

  inline Optional_DERGeneratorStateKind& operator=(Optional_DERGeneratorStateKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_DERGeneratorStateKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_DERGeneratorStateKind* internal_default_instance() {
    return reinterpret_cast<const Optional_DERGeneratorStateKind*>(
               &_Optional_DERGeneratorStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(Optional_DERGeneratorStateKind* other);
  friend void swap(Optional_DERGeneratorStateKind& a, Optional_DERGeneratorStateKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_DERGeneratorStateKind* New() const final {
    return CreateMaybeMessage<Optional_DERGeneratorStateKind>(nullptr);
  }

  Optional_DERGeneratorStateKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_DERGeneratorStateKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_DERGeneratorStateKind& from);
  void MergeFrom(const Optional_DERGeneratorStateKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_DERGeneratorStateKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.DERGeneratorStateKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::DERGeneratorStateKind value() const;
  void set_value(::commonmodule::DERGeneratorStateKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_DERGeneratorStateKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENS_DERGeneratorStateKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_DERGeneratorStateKind) */ {
 public:
  ENS_DERGeneratorStateKind();
  virtual ~ENS_DERGeneratorStateKind();

  ENS_DERGeneratorStateKind(const ENS_DERGeneratorStateKind& from);

  inline ENS_DERGeneratorStateKind& operator=(const ENS_DERGeneratorStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENS_DERGeneratorStateKind(ENS_DERGeneratorStateKind&& from) noexcept
    : ENS_DERGeneratorStateKind() {
    *this = ::std::move(from);
  }

  inline ENS_DERGeneratorStateKind& operator=(ENS_DERGeneratorStateKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENS_DERGeneratorStateKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENS_DERGeneratorStateKind* internal_default_instance() {
    return reinterpret_cast<const ENS_DERGeneratorStateKind*>(
               &_ENS_DERGeneratorStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(ENS_DERGeneratorStateKind* other);
  friend void swap(ENS_DERGeneratorStateKind& a, ENS_DERGeneratorStateKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENS_DERGeneratorStateKind* New() const final {
    return CreateMaybeMessage<ENS_DERGeneratorStateKind>(nullptr);
  }

  ENS_DERGeneratorStateKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENS_DERGeneratorStateKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENS_DERGeneratorStateKind& from);
  void MergeFrom(const ENS_DERGeneratorStateKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_DERGeneratorStateKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.DERGeneratorStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  ::commonmodule::DERGeneratorStateKind stval() const;
  void set_stval(::commonmodule::DERGeneratorStateKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENS_DERGeneratorStateKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  int stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_DynamicTestKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_DynamicTestKind) */ {
 public:
  Optional_DynamicTestKind();
  virtual ~Optional_DynamicTestKind();

  Optional_DynamicTestKind(const Optional_DynamicTestKind& from);

  inline Optional_DynamicTestKind& operator=(const Optional_DynamicTestKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_DynamicTestKind(Optional_DynamicTestKind&& from) noexcept
    : Optional_DynamicTestKind() {
    *this = ::std::move(from);
  }

  inline Optional_DynamicTestKind& operator=(Optional_DynamicTestKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_DynamicTestKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_DynamicTestKind* internal_default_instance() {
    return reinterpret_cast<const Optional_DynamicTestKind*>(
               &_Optional_DynamicTestKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(Optional_DynamicTestKind* other);
  friend void swap(Optional_DynamicTestKind& a, Optional_DynamicTestKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_DynamicTestKind* New() const final {
    return CreateMaybeMessage<Optional_DynamicTestKind>(nullptr);
  }

  Optional_DynamicTestKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_DynamicTestKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_DynamicTestKind& from);
  void MergeFrom(const Optional_DynamicTestKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_DynamicTestKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.DynamicTestKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::DynamicTestKind value() const;
  void set_value(::commonmodule::DynamicTestKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_DynamicTestKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENS_DynamicTestKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_DynamicTestKind) */ {
 public:
  ENS_DynamicTestKind();
  virtual ~ENS_DynamicTestKind();

  ENS_DynamicTestKind(const ENS_DynamicTestKind& from);

  inline ENS_DynamicTestKind& operator=(const ENS_DynamicTestKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENS_DynamicTestKind(ENS_DynamicTestKind&& from) noexcept
    : ENS_DynamicTestKind() {
    *this = ::std::move(from);
  }

  inline ENS_DynamicTestKind& operator=(ENS_DynamicTestKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENS_DynamicTestKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENS_DynamicTestKind* internal_default_instance() {
    return reinterpret_cast<const ENS_DynamicTestKind*>(
               &_ENS_DynamicTestKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(ENS_DynamicTestKind* other);
  friend void swap(ENS_DynamicTestKind& a, ENS_DynamicTestKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENS_DynamicTestKind* New() const final {
    return CreateMaybeMessage<ENS_DynamicTestKind>(nullptr);
  }

  ENS_DynamicTestKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENS_DynamicTestKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENS_DynamicTestKind& from);
  void MergeFrom(const ENS_DynamicTestKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_DynamicTestKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.DynamicTestKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  ::commonmodule::DynamicTestKind stval() const;
  void set_stval(::commonmodule::DynamicTestKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENS_DynamicTestKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  int stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENS_GridConnectModeKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_GridConnectModeKind) */ {
 public:
  ENS_GridConnectModeKind();
  virtual ~ENS_GridConnectModeKind();

  ENS_GridConnectModeKind(const ENS_GridConnectModeKind& from);

  inline ENS_GridConnectModeKind& operator=(const ENS_GridConnectModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENS_GridConnectModeKind(ENS_GridConnectModeKind&& from) noexcept
    : ENS_GridConnectModeKind() {
    *this = ::std::move(from);
  }

  inline ENS_GridConnectModeKind& operator=(ENS_GridConnectModeKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENS_GridConnectModeKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENS_GridConnectModeKind* internal_default_instance() {
    return reinterpret_cast<const ENS_GridConnectModeKind*>(
               &_ENS_GridConnectModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(ENS_GridConnectModeKind* other);
  friend void swap(ENS_GridConnectModeKind& a, ENS_GridConnectModeKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENS_GridConnectModeKind* New() const final {
    return CreateMaybeMessage<ENS_GridConnectModeKind>(nullptr);
  }

  ENS_GridConnectModeKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENS_GridConnectModeKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENS_GridConnectModeKind& from);
  void MergeFrom(const ENS_GridConnectModeKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_GridConnectModeKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string stValExtension = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stvalextension();
  static const int kStValExtensionFieldNumber = 2;
  const ::std::string& stvalextension() const;
  void set_stvalextension(const ::std::string& value);
  #if LANG_CXX11
  void set_stvalextension(::std::string&& value);
  #endif
  void set_stvalextension(const char* value);
  void set_stvalextension(const char* value, size_t size);
  ::std::string* mutable_stvalextension();
  ::std::string* release_stvalextension();
  void set_allocated_stvalextension(::std::string* stvalextension);

  // .commonmodule.GridConnectModeKind stVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 1;
  ::commonmodule::GridConnectModeKind stval() const;
  void set_stval(::commonmodule::GridConnectModeKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENS_GridConnectModeKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr stvalextension_;
  int stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_HealthKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_HealthKind) */ {
 public:
  Optional_HealthKind();
  virtual ~Optional_HealthKind();

  Optional_HealthKind(const Optional_HealthKind& from);

  inline Optional_HealthKind& operator=(const Optional_HealthKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_HealthKind(Optional_HealthKind&& from) noexcept
    : Optional_HealthKind() {
    *this = ::std::move(from);
  }

  inline Optional_HealthKind& operator=(Optional_HealthKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_HealthKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_HealthKind* internal_default_instance() {
    return reinterpret_cast<const Optional_HealthKind*>(
               &_Optional_HealthKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(Optional_HealthKind* other);
  friend void swap(Optional_HealthKind& a, Optional_HealthKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_HealthKind* New() const final {
    return CreateMaybeMessage<Optional_HealthKind>(nullptr);
  }

  Optional_HealthKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_HealthKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_HealthKind& from);
  void MergeFrom(const Optional_HealthKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_HealthKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.HealthKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::HealthKind value() const;
  void set_value(::commonmodule::HealthKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_HealthKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ENS_HealthKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_HealthKind) */ {
 public:
  ENS_HealthKind();
  virtual ~ENS_HealthKind();

  ENS_HealthKind(const ENS_HealthKind& from);

  inline ENS_HealthKind& operator=(const ENS_HealthKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ENS_HealthKind(ENS_HealthKind&& from) noexcept
    : ENS_HealthKind() {
    *this = ::std::move(from);
  }

  inline ENS_HealthKind& operator=(ENS_HealthKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ENS_HealthKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ENS_HealthKind* internal_default_instance() {
    return reinterpret_cast<const ENS_HealthKind*>(
               &_ENS_HealthKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(ENS_HealthKind* other);
  friend void swap(ENS_HealthKind& a, ENS_HealthKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ENS_HealthKind* New() const final {
    return CreateMaybeMessage<ENS_HealthKind>(nullptr);
  }

  ENS_HealthKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ENS_HealthKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ENS_HealthKind& from);
  void MergeFrom(const ENS_HealthKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_HealthKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue d = 1;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 1;
  const ::google::protobuf::StringValue& d() const;
  ::google::protobuf::StringValue* release_d();
  ::google::protobuf::StringValue* mutable_d();
  void set_allocated_d(::google::protobuf::StringValue* d);

  // .commonmodule.HealthKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  ::commonmodule::HealthKind stval() const;
  void set_stval(::commonmodule::HealthKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.ENS_HealthKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::StringValue* d_;
  int stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ESS :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ESS) */ {
 public:
  ESS();
  virtual ~ESS();

  ESS(const ESS& from);

  inline ESS& operator=(const ESS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESS(ESS&& from) noexcept
    : ESS() {
    *this = ::std::move(from);
  }

  inline ESS& operator=(ESS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESS* internal_default_instance() {
    return reinterpret_cast<const ESS*>(
               &_ESS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(ESS* other);
  friend void swap(ESS& a, ESS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESS* New() const final {
    return CreateMaybeMessage<ESS>(nullptr);
  }

  ESS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESS& from);
  void MergeFrom(const ESS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment();
  static const int kConductingEquipmentFieldNumber = 1;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);

  // @@protoc_insertion_point(class_scope:commonmodule.ESS)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipment* conductingequipment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class EventMessageInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.EventMessageInfo) */ {
 public:
  EventMessageInfo();
  virtual ~EventMessageInfo();

  EventMessageInfo(const EventMessageInfo& from);

  inline EventMessageInfo& operator=(const EventMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventMessageInfo(EventMessageInfo&& from) noexcept
    : EventMessageInfo() {
    *this = ::std::move(from);
  }

  inline EventMessageInfo& operator=(EventMessageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EventMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventMessageInfo* internal_default_instance() {
    return reinterpret_cast<const EventMessageInfo*>(
               &_EventMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(EventMessageInfo* other);
  friend void swap(EventMessageInfo& a, EventMessageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventMessageInfo* New() const final {
    return CreateMaybeMessage<EventMessageInfo>(nullptr);
  }

  EventMessageInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventMessageInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventMessageInfo& from);
  void MergeFrom(const EventMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventMessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  void clear_messageinfo();
  static const int kMessageInfoFieldNumber = 1;
  const ::commonmodule::MessageInfo& messageinfo() const;
  ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);

  // @@protoc_insertion_point(class_scope:commonmodule.EventMessageInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::MessageInfo* messageinfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class EventValue :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.EventValue) */ {
 public:
  EventValue();
  virtual ~EventValue();

  EventValue(const EventValue& from);

  inline EventValue& operator=(const EventValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventValue(EventValue&& from) noexcept
    : EventValue() {
    *this = ::std::move(from);
  }

  inline EventValue& operator=(EventValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EventValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventValue* internal_default_instance() {
    return reinterpret_cast<const EventValue*>(
               &_EventValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(EventValue* other);
  friend void swap(EventValue& a, EventValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventValue* New() const final {
    return CreateMaybeMessage<EventValue>(nullptr);
  }

  EventValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventValue& from);
  void MergeFrom(const EventValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.EventValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ForecastValueSource :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ForecastValueSource) */ {
 public:
  ForecastValueSource();
  virtual ~ForecastValueSource();

  ForecastValueSource(const ForecastValueSource& from);

  inline ForecastValueSource& operator=(const ForecastValueSource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ForecastValueSource(ForecastValueSource&& from) noexcept
    : ForecastValueSource() {
    *this = ::std::move(from);
  }

  inline ForecastValueSource& operator=(ForecastValueSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ForecastValueSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForecastValueSource* internal_default_instance() {
    return reinterpret_cast<const ForecastValueSource*>(
               &_ForecastValueSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(ForecastValueSource* other);
  friend void swap(ForecastValueSource& a, ForecastValueSource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ForecastValueSource* New() const final {
    return CreateMaybeMessage<ForecastValueSource>(nullptr);
  }

  ForecastValueSource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ForecastValueSource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ForecastValueSource& from);
  void MergeFrom(const ForecastValueSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForecastValueSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.ForecastValueSource)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ForecastIED :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ForecastIED) */ {
 public:
  ForecastIED();
  virtual ~ForecastIED();

  ForecastIED(const ForecastIED& from);

  inline ForecastIED& operator=(const ForecastIED& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ForecastIED(ForecastIED&& from) noexcept
    : ForecastIED() {
    *this = ::std::move(from);
  }

  inline ForecastIED& operator=(ForecastIED&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ForecastIED& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForecastIED* internal_default_instance() {
    return reinterpret_cast<const ForecastIED*>(
               &_ForecastIED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(ForecastIED* other);
  friend void swap(ForecastIED& a, ForecastIED& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ForecastIED* New() const final {
    return CreateMaybeMessage<ForecastIED>(nullptr);
  }

  ForecastIED* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ForecastIED>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ForecastIED& from);
  void MergeFrom(const ForecastIED& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForecastIED* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sourceApplicationID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_sourceapplicationid();
  static const int kSourceApplicationIDFieldNumber = 2;
  const ::std::string& sourceapplicationid() const;
  void set_sourceapplicationid(const ::std::string& value);
  #if LANG_CXX11
  void set_sourceapplicationid(::std::string&& value);
  #endif
  void set_sourceapplicationid(const char* value);
  void set_sourceapplicationid(const char* value, size_t size);
  ::std::string* mutable_sourceapplicationid();
  ::std::string* release_sourceapplicationid();
  void set_allocated_sourceapplicationid(::std::string* sourceapplicationid);

  // .commonmodule.ForecastValueSource forecastValueSource = 1 [(.uml.option_parent_message) = true];
  bool has_forecastvaluesource() const;
  void clear_forecastvaluesource();
  static const int kForecastValueSourceFieldNumber = 1;
  const ::commonmodule::ForecastValueSource& forecastvaluesource() const;
  ::commonmodule::ForecastValueSource* release_forecastvaluesource();
  ::commonmodule::ForecastValueSource* mutable_forecastvaluesource();
  void set_allocated_forecastvaluesource(::commonmodule::ForecastValueSource* forecastvaluesource);

  // int64 sourceDateTime = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_sourcedatetime();
  static const int kSourceDateTimeFieldNumber = 3;
  ::google::protobuf::int64 sourcedatetime() const;
  void set_sourcedatetime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:commonmodule.ForecastIED)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sourceapplicationid_;
  ::commonmodule::ForecastValueSource* forecastvaluesource_;
  ::google::protobuf::int64 sourcedatetime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ForecastValue :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ForecastValue) */ {
 public:
  ForecastValue();
  virtual ~ForecastValue();

  ForecastValue(const ForecastValue& from);

  inline ForecastValue& operator=(const ForecastValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ForecastValue(ForecastValue&& from) noexcept
    : ForecastValue() {
    *this = ::std::move(from);
  }

  inline ForecastValue& operator=(ForecastValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ForecastValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForecastValue* internal_default_instance() {
    return reinterpret_cast<const ForecastValue*>(
               &_ForecastValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(ForecastValue* other);
  friend void swap(ForecastValue& a, ForecastValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ForecastValue* New() const final {
    return CreateMaybeMessage<ForecastValue>(nullptr);
  }

  ForecastValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ForecastValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ForecastValue& from);
  void MergeFrom(const ForecastValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForecastValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.ForecastValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class IED :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.IED) */ {
 public:
  IED();
  virtual ~IED();

  IED(const IED& from);

  inline IED& operator=(const IED& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IED(IED&& from) noexcept
    : IED() {
    *this = ::std::move(from);
  }

  inline IED& operator=(IED&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IED& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IED* internal_default_instance() {
    return reinterpret_cast<const IED*>(
               &_IED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(IED* other);
  friend void swap(IED& a, IED& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IED* New() const final {
    return CreateMaybeMessage<IED>(nullptr);
  }

  IED* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IED>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IED& from);
  void MergeFrom(const IED& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IED* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.IED)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusINS :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusINS) */ {
 public:
  StatusINS();
  virtual ~StatusINS();

  StatusINS(const StatusINS& from);

  inline StatusINS& operator=(const StatusINS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusINS(StatusINS&& from) noexcept
    : StatusINS() {
    *this = ::std::move(from);
  }

  inline StatusINS& operator=(StatusINS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusINS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusINS* internal_default_instance() {
    return reinterpret_cast<const StatusINS*>(
               &_StatusINS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(StatusINS* other);
  friend void swap(StatusINS& a, StatusINS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusINS* New() const final {
    return CreateMaybeMessage<StatusINS>(nullptr);
  }

  StatusINS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusINS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusINS& from);
  void MergeFrom(const StatusINS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusINS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.Unit units = 4;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 4;
  const ::commonmodule::Unit& units() const;
  ::commonmodule::Unit* release_units();
  ::commonmodule::Unit* mutable_units();
  void set_allocated_units(::commonmodule::Unit* units);

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  ::google::protobuf::int32 stval() const;
  void set_stval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusINS)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  ::commonmodule::Unit* units_;
  ::google::protobuf::int32 stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class IntegerStatusGGIO :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.IntegerStatusGGIO) */ {
 public:
  IntegerStatusGGIO();
  virtual ~IntegerStatusGGIO();

  IntegerStatusGGIO(const IntegerStatusGGIO& from);

  inline IntegerStatusGGIO& operator=(const IntegerStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntegerStatusGGIO(IntegerStatusGGIO&& from) noexcept
    : IntegerStatusGGIO() {
    *this = ::std::move(from);
  }

  inline IntegerStatusGGIO& operator=(IntegerStatusGGIO&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IntegerStatusGGIO& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntegerStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const IntegerStatusGGIO*>(
               &_IntegerStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(IntegerStatusGGIO* other);
  friend void swap(IntegerStatusGGIO& a, IntegerStatusGGIO& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntegerStatusGGIO* New() const final {
    return CreateMaybeMessage<IntegerStatusGGIO>(nullptr);
  }

  IntegerStatusGGIO* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntegerStatusGGIO>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntegerStatusGGIO& from);
  void MergeFrom(const IntegerStatusGGIO& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerStatusGGIO* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.StatusINS IntIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_intin() const;
  void clear_intin();
  static const int kIntInFieldNumber = 2;
  const ::commonmodule::StatusINS& intin() const;
  ::commonmodule::StatusINS* release_intin();
  ::commonmodule::StatusINS* mutable_intin();
  void set_allocated_intin(::commonmodule::StatusINS* intin);

  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 3;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);

  // @@protoc_insertion_point(class_scope:commonmodule.IntegerStatusGGIO)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::StatusINS* intin_;
  ::commonmodule::Optional_PhaseCodeKind* phase_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class LogicalNodeForEventAndStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.LogicalNodeForEventAndStatus) */ {
 public:
  LogicalNodeForEventAndStatus();
  virtual ~LogicalNodeForEventAndStatus();

  LogicalNodeForEventAndStatus(const LogicalNodeForEventAndStatus& from);

  inline LogicalNodeForEventAndStatus& operator=(const LogicalNodeForEventAndStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalNodeForEventAndStatus(LogicalNodeForEventAndStatus&& from) noexcept
    : LogicalNodeForEventAndStatus() {
    *this = ::std::move(from);
  }

  inline LogicalNodeForEventAndStatus& operator=(LogicalNodeForEventAndStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LogicalNodeForEventAndStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalNodeForEventAndStatus* internal_default_instance() {
    return reinterpret_cast<const LogicalNodeForEventAndStatus*>(
               &_LogicalNodeForEventAndStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(LogicalNodeForEventAndStatus* other);
  friend void swap(LogicalNodeForEventAndStatus& a, LogicalNodeForEventAndStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalNodeForEventAndStatus* New() const final {
    return CreateMaybeMessage<LogicalNodeForEventAndStatus>(nullptr);
  }

  LogicalNodeForEventAndStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalNodeForEventAndStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalNodeForEventAndStatus& from);
  void MergeFrom(const LogicalNodeForEventAndStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalNodeForEventAndStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.ENS_BehaviourModeKind Beh = 2;
  bool has_beh() const;
  void clear_beh();
  static const int kBehFieldNumber = 2;
  const ::commonmodule::ENS_BehaviourModeKind& beh() const;
  ::commonmodule::ENS_BehaviourModeKind* release_beh();
  ::commonmodule::ENS_BehaviourModeKind* mutable_beh();
  void set_allocated_beh(::commonmodule::ENS_BehaviourModeKind* beh);

  // .commonmodule.ENS_HealthKind EEHealth = 3;
  bool has_eehealth() const;
  void clear_eehealth();
  static const int kEEHealthFieldNumber = 3;
  const ::commonmodule::ENS_HealthKind& eehealth() const;
  ::commonmodule::ENS_HealthKind* release_eehealth();
  ::commonmodule::ENS_HealthKind* mutable_eehealth();
  void set_allocated_eehealth(::commonmodule::ENS_HealthKind* eehealth);

  // @@protoc_insertion_point(class_scope:commonmodule.LogicalNodeForEventAndStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::ENS_BehaviourModeKind* beh_;
  ::commonmodule::ENS_HealthKind* eehealth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class MeasurementValue :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.MeasurementValue) */ {
 public:
  MeasurementValue();
  virtual ~MeasurementValue();

  MeasurementValue(const MeasurementValue& from);

  inline MeasurementValue& operator=(const MeasurementValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeasurementValue(MeasurementValue&& from) noexcept
    : MeasurementValue() {
    *this = ::std::move(from);
  }

  inline MeasurementValue& operator=(MeasurementValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MeasurementValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeasurementValue* internal_default_instance() {
    return reinterpret_cast<const MeasurementValue*>(
               &_MeasurementValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(MeasurementValue* other);
  friend void swap(MeasurementValue& a, MeasurementValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeasurementValue* New() const final {
    return CreateMaybeMessage<MeasurementValue>(nullptr);
  }

  MeasurementValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MeasurementValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MeasurementValue& from);
  void MergeFrom(const MeasurementValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeasurementValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.MeasurementValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Meter :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Meter) */ {
 public:
  Meter();
  virtual ~Meter();

  Meter(const Meter& from);

  inline Meter& operator=(const Meter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Meter(Meter&& from) noexcept
    : Meter() {
    *this = ::std::move(from);
  }

  inline Meter& operator=(Meter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Meter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Meter* internal_default_instance() {
    return reinterpret_cast<const Meter*>(
               &_Meter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(Meter* other);
  friend void swap(Meter& a, Meter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Meter* New() const final {
    return CreateMaybeMessage<Meter>(nullptr);
  }

  Meter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Meter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Meter& from);
  void MergeFrom(const Meter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Meter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment();
  static const int kConductingEquipmentFieldNumber = 1;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);

  // @@protoc_insertion_point(class_scope:commonmodule.Meter)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipment* conductingequipment_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class OptimizationMessageInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.OptimizationMessageInfo) */ {
 public:
  OptimizationMessageInfo();
  virtual ~OptimizationMessageInfo();

  OptimizationMessageInfo(const OptimizationMessageInfo& from);

  inline OptimizationMessageInfo& operator=(const OptimizationMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptimizationMessageInfo(OptimizationMessageInfo&& from) noexcept
    : OptimizationMessageInfo() {
    *this = ::std::move(from);
  }

  inline OptimizationMessageInfo& operator=(OptimizationMessageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OptimizationMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptimizationMessageInfo* internal_default_instance() {
    return reinterpret_cast<const OptimizationMessageInfo*>(
               &_OptimizationMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(OptimizationMessageInfo* other);
  friend void swap(OptimizationMessageInfo& a, OptimizationMessageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptimizationMessageInfo* New() const final {
    return CreateMaybeMessage<OptimizationMessageInfo>(nullptr);
  }

  OptimizationMessageInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptimizationMessageInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptimizationMessageInfo& from);
  void MergeFrom(const OptimizationMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptimizationMessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  void clear_messageinfo();
  static const int kMessageInfoFieldNumber = 1;
  const ::commonmodule::MessageInfo& messageinfo() const;
  ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);

  // @@protoc_insertion_point(class_scope:commonmodule.OptimizationMessageInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::MessageInfo* messageinfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ReadingMMTN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMMTN) */ {
 public:
  ReadingMMTN();
  virtual ~ReadingMMTN();

  ReadingMMTN(const ReadingMMTN& from);

  inline ReadingMMTN& operator=(const ReadingMMTN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadingMMTN(ReadingMMTN&& from) noexcept
    : ReadingMMTN() {
    *this = ::std::move(from);
  }

  inline ReadingMMTN& operator=(ReadingMMTN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReadingMMTN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadingMMTN* internal_default_instance() {
    return reinterpret_cast<const ReadingMMTN*>(
               &_ReadingMMTN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(ReadingMMTN* other);
  friend void swap(ReadingMMTN& a, ReadingMMTN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadingMMTN* New() const final {
    return CreateMaybeMessage<ReadingMMTN>(nullptr);
  }

  ReadingMMTN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadingMMTN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadingMMTN& from);
  void MergeFrom(const ReadingMMTN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMMTN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.BCR DmdVAh = 2;
  bool has_dmdvah() const;
  void clear_dmdvah();
  static const int kDmdVAhFieldNumber = 2;
  const ::commonmodule::BCR& dmdvah() const;
  ::commonmodule::BCR* release_dmdvah();
  ::commonmodule::BCR* mutable_dmdvah();
  void set_allocated_dmdvah(::commonmodule::BCR* dmdvah);

  // .commonmodule.BCR DmdVArh = 3;
  bool has_dmdvarh() const;
  void clear_dmdvarh();
  static const int kDmdVArhFieldNumber = 3;
  const ::commonmodule::BCR& dmdvarh() const;
  ::commonmodule::BCR* release_dmdvarh();
  ::commonmodule::BCR* mutable_dmdvarh();
  void set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh);

  // .commonmodule.BCR DmdWh = 4;
  bool has_dmdwh() const;
  void clear_dmdwh();
  static const int kDmdWhFieldNumber = 4;
  const ::commonmodule::BCR& dmdwh() const;
  ::commonmodule::BCR* release_dmdwh();
  ::commonmodule::BCR* mutable_dmdwh();
  void set_allocated_dmdwh(::commonmodule::BCR* dmdwh);

  // .commonmodule.BCR SupVAh = 5;
  bool has_supvah() const;
  void clear_supvah();
  static const int kSupVAhFieldNumber = 5;
  const ::commonmodule::BCR& supvah() const;
  ::commonmodule::BCR* release_supvah();
  ::commonmodule::BCR* mutable_supvah();
  void set_allocated_supvah(::commonmodule::BCR* supvah);

  // .commonmodule.BCR SupVArh = 6;
  bool has_supvarh() const;
  void clear_supvarh();
  static const int kSupVArhFieldNumber = 6;
  const ::commonmodule::BCR& supvarh() const;
  ::commonmodule::BCR* release_supvarh();
  ::commonmodule::BCR* mutable_supvarh();
  void set_allocated_supvarh(::commonmodule::BCR* supvarh);

  // .commonmodule.BCR SupWh = 7;
  bool has_supwh() const;
  void clear_supwh();
  static const int kSupWhFieldNumber = 7;
  const ::commonmodule::BCR& supwh() const;
  ::commonmodule::BCR* release_supwh();
  ::commonmodule::BCR* mutable_supwh();
  void set_allocated_supwh(::commonmodule::BCR* supwh);

  // .commonmodule.BCR TotVAh = 8;
  bool has_totvah() const;
  void clear_totvah();
  static const int kTotVAhFieldNumber = 8;
  const ::commonmodule::BCR& totvah() const;
  ::commonmodule::BCR* release_totvah();
  ::commonmodule::BCR* mutable_totvah();
  void set_allocated_totvah(::commonmodule::BCR* totvah);

  // .commonmodule.BCR TotVArh = 9;
  bool has_totvarh() const;
  void clear_totvarh();
  static const int kTotVArhFieldNumber = 9;
  const ::commonmodule::BCR& totvarh() const;
  ::commonmodule::BCR* release_totvarh();
  ::commonmodule::BCR* mutable_totvarh();
  void set_allocated_totvarh(::commonmodule::BCR* totvarh);

  // .commonmodule.BCR TotWh = 10;
  bool has_totwh() const;
  void clear_totwh();
  static const int kTotWhFieldNumber = 10;
  const ::commonmodule::BCR& totwh() const;
  ::commonmodule::BCR* release_totwh();
  ::commonmodule::BCR* mutable_totwh();
  void set_allocated_totwh(::commonmodule::BCR* totwh);

  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMMTN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::BCR* dmdvah_;
  ::commonmodule::BCR* dmdvarh_;
  ::commonmodule::BCR* dmdwh_;
  ::commonmodule::BCR* supvah_;
  ::commonmodule::BCR* supvarh_;
  ::commonmodule::BCR* supwh_;
  ::commonmodule::BCR* totvah_;
  ::commonmodule::BCR* totvarh_;
  ::commonmodule::BCR* totwh_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class PhaseMMTN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseMMTN) */ {
 public:
  PhaseMMTN();
  virtual ~PhaseMMTN();

  PhaseMMTN(const PhaseMMTN& from);

  inline PhaseMMTN& operator=(const PhaseMMTN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhaseMMTN(PhaseMMTN&& from) noexcept
    : PhaseMMTN() {
    *this = ::std::move(from);
  }

  inline PhaseMMTN& operator=(PhaseMMTN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PhaseMMTN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhaseMMTN* internal_default_instance() {
    return reinterpret_cast<const PhaseMMTN*>(
               &_PhaseMMTN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(PhaseMMTN* other);
  friend void swap(PhaseMMTN& a, PhaseMMTN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhaseMMTN* New() const final {
    return CreateMaybeMessage<PhaseMMTN>(nullptr);
  }

  PhaseMMTN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PhaseMMTN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PhaseMMTN& from);
  void MergeFrom(const PhaseMMTN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseMMTN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ReadingMMTN phsA = 1;
  bool has_phsa() const;
  void clear_phsa();
  static const int kPhsAFieldNumber = 1;
  const ::commonmodule::ReadingMMTN& phsa() const;
  ::commonmodule::ReadingMMTN* release_phsa();
  ::commonmodule::ReadingMMTN* mutable_phsa();
  void set_allocated_phsa(::commonmodule::ReadingMMTN* phsa);

  // .commonmodule.ReadingMMTN phsAB = 2;
  bool has_phsab() const;
  void clear_phsab();
  static const int kPhsABFieldNumber = 2;
  const ::commonmodule::ReadingMMTN& phsab() const;
  ::commonmodule::ReadingMMTN* release_phsab();
  ::commonmodule::ReadingMMTN* mutable_phsab();
  void set_allocated_phsab(::commonmodule::ReadingMMTN* phsab);

  // .commonmodule.ReadingMMTN phsB = 3;
  bool has_phsb() const;
  void clear_phsb();
  static const int kPhsBFieldNumber = 3;
  const ::commonmodule::ReadingMMTN& phsb() const;
  ::commonmodule::ReadingMMTN* release_phsb();
  ::commonmodule::ReadingMMTN* mutable_phsb();
  void set_allocated_phsb(::commonmodule::ReadingMMTN* phsb);

  // .commonmodule.ReadingMMTN phsBC = 4;
  bool has_phsbc() const;
  void clear_phsbc();
  static const int kPhsBCFieldNumber = 4;
  const ::commonmodule::ReadingMMTN& phsbc() const;
  ::commonmodule::ReadingMMTN* release_phsbc();
  ::commonmodule::ReadingMMTN* mutable_phsbc();
  void set_allocated_phsbc(::commonmodule::ReadingMMTN* phsbc);

  // .commonmodule.ReadingMMTN phsC = 5;
  bool has_phsc() const;
  void clear_phsc();
  static const int kPhsCFieldNumber = 5;
  const ::commonmodule::ReadingMMTN& phsc() const;
  ::commonmodule::ReadingMMTN* release_phsc();
  ::commonmodule::ReadingMMTN* mutable_phsc();
  void set_allocated_phsc(::commonmodule::ReadingMMTN* phsc);

  // .commonmodule.ReadingMMTN phsCA = 6;
  bool has_phsca() const;
  void clear_phsca();
  static const int kPhsCAFieldNumber = 6;
  const ::commonmodule::ReadingMMTN& phsca() const;
  ::commonmodule::ReadingMMTN* release_phsca();
  ::commonmodule::ReadingMMTN* mutable_phsca();
  void set_allocated_phsca(::commonmodule::ReadingMMTN* phsca);

  // @@protoc_insertion_point(class_scope:commonmodule.PhaseMMTN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ReadingMMTN* phsa_;
  ::commonmodule::ReadingMMTN* phsab_;
  ::commonmodule::ReadingMMTN* phsb_;
  ::commonmodule::ReadingMMTN* phsbc_;
  ::commonmodule::ReadingMMTN* phsc_;
  ::commonmodule::ReadingMMTN* phsca_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class RampRate :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.RampRate) */ {
 public:
  RampRate();
  virtual ~RampRate();

  RampRate(const RampRate& from);

  inline RampRate& operator=(const RampRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RampRate(RampRate&& from) noexcept
    : RampRate() {
    *this = ::std::move(from);
  }

  inline RampRate& operator=(RampRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RampRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RampRate* internal_default_instance() {
    return reinterpret_cast<const RampRate*>(
               &_RampRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(RampRate* other);
  friend void swap(RampRate& a, RampRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RampRate* New() const final {
    return CreateMaybeMessage<RampRate>(nullptr);
  }

  RampRate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RampRate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RampRate& from);
  void MergeFrom(const RampRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RampRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;
  bool has_negativereactivepowerkvarpermin() const;
  void clear_negativereactivepowerkvarpermin();
  static const int kNegativeReactivePowerKVArPerMinFieldNumber = 1;
  const ::google::protobuf::FloatValue& negativereactivepowerkvarpermin() const;
  ::google::protobuf::FloatValue* release_negativereactivepowerkvarpermin();
  ::google::protobuf::FloatValue* mutable_negativereactivepowerkvarpermin();
  void set_allocated_negativereactivepowerkvarpermin(::google::protobuf::FloatValue* negativereactivepowerkvarpermin);

  // .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;
  bool has_negativerealpowerkwpermin() const;
  void clear_negativerealpowerkwpermin();
  static const int kNegativeRealPowerKWPerMinFieldNumber = 2;
  const ::google::protobuf::FloatValue& negativerealpowerkwpermin() const;
  ::google::protobuf::FloatValue* release_negativerealpowerkwpermin();
  ::google::protobuf::FloatValue* mutable_negativerealpowerkwpermin();
  void set_allocated_negativerealpowerkwpermin(::google::protobuf::FloatValue* negativerealpowerkwpermin);

  // .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;
  bool has_positivereactivepowerkvarpermin() const;
  void clear_positivereactivepowerkvarpermin();
  static const int kPositiveReactivePowerKVArPerMinFieldNumber = 3;
  const ::google::protobuf::FloatValue& positivereactivepowerkvarpermin() const;
  ::google::protobuf::FloatValue* release_positivereactivepowerkvarpermin();
  ::google::protobuf::FloatValue* mutable_positivereactivepowerkvarpermin();
  void set_allocated_positivereactivepowerkvarpermin(::google::protobuf::FloatValue* positivereactivepowerkvarpermin);

  // .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;
  bool has_positiverealpowerkwpermin() const;
  void clear_positiverealpowerkwpermin();
  static const int kPositiveRealPowerKWPerMinFieldNumber = 4;
  const ::google::protobuf::FloatValue& positiverealpowerkwpermin() const;
  ::google::protobuf::FloatValue* release_positiverealpowerkwpermin();
  ::google::protobuf::FloatValue* mutable_positiverealpowerkwpermin();
  void set_allocated_positiverealpowerkwpermin(::google::protobuf::FloatValue* positiverealpowerkwpermin);

  // @@protoc_insertion_point(class_scope:commonmodule.RampRate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* negativereactivepowerkvarpermin_;
  ::google::protobuf::FloatValue* negativerealpowerkwpermin_;
  ::google::protobuf::FloatValue* positivereactivepowerkvarpermin_;
  ::google::protobuf::FloatValue* positiverealpowerkwpermin_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ReadingMessageInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMessageInfo) */ {
 public:
  ReadingMessageInfo();
  virtual ~ReadingMessageInfo();

  ReadingMessageInfo(const ReadingMessageInfo& from);

  inline ReadingMessageInfo& operator=(const ReadingMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadingMessageInfo(ReadingMessageInfo&& from) noexcept
    : ReadingMessageInfo() {
    *this = ::std::move(from);
  }

  inline ReadingMessageInfo& operator=(ReadingMessageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReadingMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadingMessageInfo* internal_default_instance() {
    return reinterpret_cast<const ReadingMessageInfo*>(
               &_ReadingMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(ReadingMessageInfo* other);
  friend void swap(ReadingMessageInfo& a, ReadingMessageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadingMessageInfo* New() const final {
    return CreateMaybeMessage<ReadingMessageInfo>(nullptr);
  }

  ReadingMessageInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadingMessageInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadingMessageInfo& from);
  void MergeFrom(const ReadingMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  void clear_messageinfo();
  static const int kMessageInfoFieldNumber = 1;
  const ::commonmodule::MessageInfo& messageinfo() const;
  ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);

  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMessageInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::MessageInfo* messageinfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ReadingMMTR :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMMTR) */ {
 public:
  ReadingMMTR();
  virtual ~ReadingMMTR();

  ReadingMMTR(const ReadingMMTR& from);

  inline ReadingMMTR& operator=(const ReadingMMTR& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadingMMTR(ReadingMMTR&& from) noexcept
    : ReadingMMTR() {
    *this = ::std::move(from);
  }

  inline ReadingMMTR& operator=(ReadingMMTR&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReadingMMTR& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadingMMTR* internal_default_instance() {
    return reinterpret_cast<const ReadingMMTR*>(
               &_ReadingMMTR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(ReadingMMTR* other);
  friend void swap(ReadingMMTR& a, ReadingMMTR& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadingMMTR* New() const final {
    return CreateMaybeMessage<ReadingMMTR>(nullptr);
  }

  ReadingMMTR* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadingMMTR>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadingMMTR& from);
  void MergeFrom(const ReadingMMTR& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMMTR* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.BCR DmdVAh = 2;
  bool has_dmdvah() const;
  void clear_dmdvah();
  static const int kDmdVAhFieldNumber = 2;
  const ::commonmodule::BCR& dmdvah() const;
  ::commonmodule::BCR* release_dmdvah();
  ::commonmodule::BCR* mutable_dmdvah();
  void set_allocated_dmdvah(::commonmodule::BCR* dmdvah);

  // .commonmodule.BCR DmdVArh = 3;
  bool has_dmdvarh() const;
  void clear_dmdvarh();
  static const int kDmdVArhFieldNumber = 3;
  const ::commonmodule::BCR& dmdvarh() const;
  ::commonmodule::BCR* release_dmdvarh();
  ::commonmodule::BCR* mutable_dmdvarh();
  void set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh);

  // .commonmodule.BCR DmdWh = 4;
  bool has_dmdwh() const;
  void clear_dmdwh();
  static const int kDmdWhFieldNumber = 4;
  const ::commonmodule::BCR& dmdwh() const;
  ::commonmodule::BCR* release_dmdwh();
  ::commonmodule::BCR* mutable_dmdwh();
  void set_allocated_dmdwh(::commonmodule::BCR* dmdwh);

  // .commonmodule.BCR SupVAh = 5;
  bool has_supvah() const;
  void clear_supvah();
  static const int kSupVAhFieldNumber = 5;
  const ::commonmodule::BCR& supvah() const;
  ::commonmodule::BCR* release_supvah();
  ::commonmodule::BCR* mutable_supvah();
  void set_allocated_supvah(::commonmodule::BCR* supvah);

  // .commonmodule.BCR SupVArh = 6;
  bool has_supvarh() const;
  void clear_supvarh();
  static const int kSupVArhFieldNumber = 6;
  const ::commonmodule::BCR& supvarh() const;
  ::commonmodule::BCR* release_supvarh();
  ::commonmodule::BCR* mutable_supvarh();
  void set_allocated_supvarh(::commonmodule::BCR* supvarh);

  // .commonmodule.BCR SupWh = 7;
  bool has_supwh() const;
  void clear_supwh();
  static const int kSupWhFieldNumber = 7;
  const ::commonmodule::BCR& supwh() const;
  ::commonmodule::BCR* release_supwh();
  ::commonmodule::BCR* mutable_supwh();
  void set_allocated_supwh(::commonmodule::BCR* supwh);

  // .commonmodule.BCR TotVAh = 8;
  bool has_totvah() const;
  void clear_totvah();
  static const int kTotVAhFieldNumber = 8;
  const ::commonmodule::BCR& totvah() const;
  ::commonmodule::BCR* release_totvah();
  ::commonmodule::BCR* mutable_totvah();
  void set_allocated_totvah(::commonmodule::BCR* totvah);

  // .commonmodule.BCR TotVArh = 9;
  bool has_totvarh() const;
  void clear_totvarh();
  static const int kTotVArhFieldNumber = 9;
  const ::commonmodule::BCR& totvarh() const;
  ::commonmodule::BCR* release_totvarh();
  ::commonmodule::BCR* mutable_totvarh();
  void set_allocated_totvarh(::commonmodule::BCR* totvarh);

  // .commonmodule.BCR TotWh = 10;
  bool has_totwh() const;
  void clear_totwh();
  static const int kTotWhFieldNumber = 10;
  const ::commonmodule::BCR& totwh() const;
  ::commonmodule::BCR* release_totwh();
  ::commonmodule::BCR* mutable_totwh();
  void set_allocated_totwh(::commonmodule::BCR* totwh);

  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMMTR)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::BCR* dmdvah_;
  ::commonmodule::BCR* dmdvarh_;
  ::commonmodule::BCR* dmdwh_;
  ::commonmodule::BCR* supvah_;
  ::commonmodule::BCR* supvarh_;
  ::commonmodule::BCR* supwh_;
  ::commonmodule::BCR* totvah_;
  ::commonmodule::BCR* totvarh_;
  ::commonmodule::BCR* totwh_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class WYE :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.WYE) */ {
 public:
  WYE();
  virtual ~WYE();

  WYE(const WYE& from);

  inline WYE& operator=(const WYE& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WYE(WYE&& from) noexcept
    : WYE() {
    *this = ::std::move(from);
  }

  inline WYE& operator=(WYE&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WYE& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WYE* internal_default_instance() {
    return reinterpret_cast<const WYE*>(
               &_WYE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(WYE* other);
  friend void swap(WYE& a, WYE& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WYE* New() const final {
    return CreateMaybeMessage<WYE>(nullptr);
  }

  WYE* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WYE>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WYE& from);
  void MergeFrom(const WYE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WYE* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.CMV net = 1;
  bool has_net() const;
  void clear_net();
  static const int kNetFieldNumber = 1;
  const ::commonmodule::CMV& net() const;
  ::commonmodule::CMV* release_net();
  ::commonmodule::CMV* mutable_net();
  void set_allocated_net(::commonmodule::CMV* net);

  // .commonmodule.CMV neut = 2;
  bool has_neut() const;
  void clear_neut();
  static const int kNeutFieldNumber = 2;
  const ::commonmodule::CMV& neut() const;
  ::commonmodule::CMV* release_neut();
  ::commonmodule::CMV* mutable_neut();
  void set_allocated_neut(::commonmodule::CMV* neut);

  // .commonmodule.CMV phsA = 3;
  bool has_phsa() const;
  void clear_phsa();
  static const int kPhsAFieldNumber = 3;
  const ::commonmodule::CMV& phsa() const;
  ::commonmodule::CMV* release_phsa();
  ::commonmodule::CMV* mutable_phsa();
  void set_allocated_phsa(::commonmodule::CMV* phsa);

  // .commonmodule.CMV phsB = 4;
  bool has_phsb() const;
  void clear_phsb();
  static const int kPhsBFieldNumber = 4;
  const ::commonmodule::CMV& phsb() const;
  ::commonmodule::CMV* release_phsb();
  ::commonmodule::CMV* mutable_phsb();
  void set_allocated_phsb(::commonmodule::CMV* phsb);

  // .commonmodule.CMV phsC = 5;
  bool has_phsc() const;
  void clear_phsc();
  static const int kPhsCFieldNumber = 5;
  const ::commonmodule::CMV& phsc() const;
  ::commonmodule::CMV* release_phsc();
  ::commonmodule::CMV* mutable_phsc();
  void set_allocated_phsc(::commonmodule::CMV* phsc);

  // @@protoc_insertion_point(class_scope:commonmodule.WYE)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::CMV* net_;
  ::commonmodule::CMV* neut_;
  ::commonmodule::CMV* phsa_;
  ::commonmodule::CMV* phsb_;
  ::commonmodule::CMV* phsc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class ReadingMMXU :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMMXU) */ {
 public:
  ReadingMMXU();
  virtual ~ReadingMMXU();

  ReadingMMXU(const ReadingMMXU& from);

  inline ReadingMMXU& operator=(const ReadingMMXU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadingMMXU(ReadingMMXU&& from) noexcept
    : ReadingMMXU() {
    *this = ::std::move(from);
  }

  inline ReadingMMXU& operator=(ReadingMMXU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReadingMMXU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadingMMXU* internal_default_instance() {
    return reinterpret_cast<const ReadingMMXU*>(
               &_ReadingMMXU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(ReadingMMXU* other);
  friend void swap(ReadingMMXU& a, ReadingMMXU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadingMMXU* New() const final {
    return CreateMaybeMessage<ReadingMMXU>(nullptr);
  }

  ReadingMMXU* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadingMMXU>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadingMMXU& from);
  void MergeFrom(const ReadingMMXU& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMMXU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.WYE A = 2;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 2;
  const ::commonmodule::WYE& a() const;
  ::commonmodule::WYE* release_a();
  ::commonmodule::WYE* mutable_a();
  void set_allocated_a(::commonmodule::WYE* a);

  // .commonmodule.ENG_CalcMethodKind ClcMth = 3;
  bool has_clcmth() const;
  void clear_clcmth();
  static const int kClcMthFieldNumber = 3;
  const ::commonmodule::ENG_CalcMethodKind& clcmth() const;
  ::commonmodule::ENG_CalcMethodKind* release_clcmth();
  ::commonmodule::ENG_CalcMethodKind* mutable_clcmth();
  void set_allocated_clcmth(::commonmodule::ENG_CalcMethodKind* clcmth);

  // .commonmodule.MV Hz = 4;
  bool has_hz() const;
  void clear_hz();
  static const int kHzFieldNumber = 4;
  const ::commonmodule::MV& hz() const;
  ::commonmodule::MV* release_hz();
  ::commonmodule::MV* mutable_hz();
  void set_allocated_hz(::commonmodule::MV* hz);

  // .commonmodule.WYE PF = 5;
  bool has_pf() const;
  void clear_pf();
  static const int kPFFieldNumber = 5;
  const ::commonmodule::WYE& pf() const;
  ::commonmodule::WYE* release_pf();
  ::commonmodule::WYE* mutable_pf();
  void set_allocated_pf(::commonmodule::WYE* pf);

  // .commonmodule.ENG_PFSignKind PFSign = 6;
  bool has_pfsign() const;
  void clear_pfsign();
  static const int kPFSignFieldNumber = 6;
  const ::commonmodule::ENG_PFSignKind& pfsign() const;
  ::commonmodule::ENG_PFSignKind* release_pfsign();
  ::commonmodule::ENG_PFSignKind* mutable_pfsign();
  void set_allocated_pfsign(::commonmodule::ENG_PFSignKind* pfsign);

  // .commonmodule.WYE PhV = 7;
  bool has_phv() const;
  void clear_phv();
  static const int kPhVFieldNumber = 7;
  const ::commonmodule::WYE& phv() const;
  ::commonmodule::WYE* release_phv();
  ::commonmodule::WYE* mutable_phv();
  void set_allocated_phv(::commonmodule::WYE* phv);

  // .commonmodule.DEL PPV = 8;
  bool has_ppv() const;
  void clear_ppv();
  static const int kPPVFieldNumber = 8;
  const ::commonmodule::DEL& ppv() const;
  ::commonmodule::DEL* release_ppv();
  ::commonmodule::DEL* mutable_ppv();
  void set_allocated_ppv(::commonmodule::DEL* ppv);

  // .commonmodule.WYE VA = 9;
  bool has_va() const;
  void clear_va();
  static const int kVAFieldNumber = 9;
  const ::commonmodule::WYE& va() const;
  ::commonmodule::WYE* release_va();
  ::commonmodule::WYE* mutable_va();
  void set_allocated_va(::commonmodule::WYE* va);

  // .commonmodule.WYE VAr = 10;
  bool has_var() const;
  void clear_var();
  static const int kVArFieldNumber = 10;
  const ::commonmodule::WYE& var() const;
  ::commonmodule::WYE* release_var();
  ::commonmodule::WYE* mutable_var();
  void set_allocated_var(::commonmodule::WYE* var);

  // .commonmodule.WYE W = 11;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 11;
  const ::commonmodule::WYE& w() const;
  ::commonmodule::WYE* release_w();
  ::commonmodule::WYE* mutable_w();
  void set_allocated_w(::commonmodule::WYE* w);

  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMMXU)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::WYE* a_;
  ::commonmodule::ENG_CalcMethodKind* clcmth_;
  ::commonmodule::MV* hz_;
  ::commonmodule::WYE* pf_;
  ::commonmodule::ENG_PFSignKind* pfsign_;
  ::commonmodule::WYE* phv_;
  ::commonmodule::DEL* ppv_;
  ::commonmodule::WYE* va_;
  ::commonmodule::WYE* var_;
  ::commonmodule::WYE* w_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_DbPosKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_DbPosKind) */ {
 public:
  Optional_DbPosKind();
  virtual ~Optional_DbPosKind();

  Optional_DbPosKind(const Optional_DbPosKind& from);

  inline Optional_DbPosKind& operator=(const Optional_DbPosKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_DbPosKind(Optional_DbPosKind&& from) noexcept
    : Optional_DbPosKind() {
    *this = ::std::move(from);
  }

  inline Optional_DbPosKind& operator=(Optional_DbPosKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_DbPosKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_DbPosKind* internal_default_instance() {
    return reinterpret_cast<const Optional_DbPosKind*>(
               &_Optional_DbPosKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(Optional_DbPosKind* other);
  friend void swap(Optional_DbPosKind& a, Optional_DbPosKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_DbPosKind* New() const final {
    return CreateMaybeMessage<Optional_DbPosKind>(nullptr);
  }

  Optional_DbPosKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_DbPosKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_DbPosKind& from);
  void MergeFrom(const Optional_DbPosKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_DbPosKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.DbPosKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::DbPosKind value() const;
  void set_value(::commonmodule::DbPosKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_DbPosKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusDPS :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusDPS) */ {
 public:
  StatusDPS();
  virtual ~StatusDPS();

  StatusDPS(const StatusDPS& from);

  inline StatusDPS& operator=(const StatusDPS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusDPS(StatusDPS&& from) noexcept
    : StatusDPS() {
    *this = ::std::move(from);
  }

  inline StatusDPS& operator=(StatusDPS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusDPS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusDPS* internal_default_instance() {
    return reinterpret_cast<const StatusDPS*>(
               &_StatusDPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(StatusDPS* other);
  friend void swap(StatusDPS& a, StatusDPS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusDPS* New() const final {
    return CreateMaybeMessage<StatusDPS>(nullptr);
  }

  StatusDPS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusDPS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusDPS& from);
  void MergeFrom(const StatusDPS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusDPS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // .commonmodule.DbPosKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  ::commonmodule::DbPosKind stval() const;
  void set_stval(::commonmodule::DbPosKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusDPS)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  int stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusAndEventXCBR :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusAndEventXCBR) */ {
 public:
  StatusAndEventXCBR();
  virtual ~StatusAndEventXCBR();

  StatusAndEventXCBR(const StatusAndEventXCBR& from);

  inline StatusAndEventXCBR& operator=(const StatusAndEventXCBR& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusAndEventXCBR(StatusAndEventXCBR&& from) noexcept
    : StatusAndEventXCBR() {
    *this = ::std::move(from);
  }

  inline StatusAndEventXCBR& operator=(StatusAndEventXCBR&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusAndEventXCBR& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusAndEventXCBR* internal_default_instance() {
    return reinterpret_cast<const StatusAndEventXCBR*>(
               &_StatusAndEventXCBR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(StatusAndEventXCBR* other);
  friend void swap(StatusAndEventXCBR& a, StatusAndEventXCBR& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusAndEventXCBR* New() const final {
    return CreateMaybeMessage<StatusAndEventXCBR>(nullptr);
  }

  StatusAndEventXCBR* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusAndEventXCBR>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusAndEventXCBR& from);
  void MergeFrom(const StatusAndEventXCBR& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusAndEventXCBR* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  void clear_dynamictest();
  static const int kDynamicTestFieldNumber = 2;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);

  // .commonmodule.StatusDPS Pos = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  const ::commonmodule::StatusDPS& pos() const;
  ::commonmodule::StatusDPS* release_pos();
  ::commonmodule::StatusDPS* mutable_pos();
  void set_allocated_pos(::commonmodule::StatusDPS* pos);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusAndEventXCBR)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::ENS_DynamicTestKind* dynamictest_;
  ::commonmodule::StatusDPS* pos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusISC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusISC) */ {
 public:
  StatusISC();
  virtual ~StatusISC();

  StatusISC(const StatusISC& from);

  inline StatusISC& operator=(const StatusISC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusISC(StatusISC&& from) noexcept
    : StatusISC() {
    *this = ::std::move(from);
  }

  inline StatusISC& operator=(StatusISC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusISC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusISC* internal_default_instance() {
    return reinterpret_cast<const StatusISC*>(
               &_StatusISC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  void Swap(StatusISC* other);
  friend void swap(StatusISC& a, StatusISC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusISC* New() const final {
    return CreateMaybeMessage<StatusISC>(nullptr);
  }

  StatusISC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusISC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusISC& from);
  void MergeFrom(const StatusISC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusISC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  ::google::protobuf::int32 stval() const;
  void set_stval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusISC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  ::google::protobuf::int32 stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusMessageInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusMessageInfo) */ {
 public:
  StatusMessageInfo();
  virtual ~StatusMessageInfo();

  StatusMessageInfo(const StatusMessageInfo& from);

  inline StatusMessageInfo& operator=(const StatusMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusMessageInfo(StatusMessageInfo&& from) noexcept
    : StatusMessageInfo() {
    *this = ::std::move(from);
  }

  inline StatusMessageInfo& operator=(StatusMessageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusMessageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusMessageInfo* internal_default_instance() {
    return reinterpret_cast<const StatusMessageInfo*>(
               &_StatusMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  void Swap(StatusMessageInfo* other);
  friend void swap(StatusMessageInfo& a, StatusMessageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusMessageInfo* New() const final {
    return CreateMaybeMessage<StatusMessageInfo>(nullptr);
  }

  StatusMessageInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusMessageInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusMessageInfo& from);
  void MergeFrom(const StatusMessageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusMessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  void clear_messageinfo();
  static const int kMessageInfoFieldNumber = 1;
  const ::commonmodule::MessageInfo& messageinfo() const;
  ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusMessageInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::MessageInfo* messageinfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusSPC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusSPC) */ {
 public:
  StatusSPC();
  virtual ~StatusSPC();

  StatusSPC(const StatusSPC& from);

  inline StatusSPC& operator=(const StatusSPC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusSPC(StatusSPC&& from) noexcept
    : StatusSPC() {
    *this = ::std::move(from);
  }

  inline StatusSPC& operator=(StatusSPC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusSPC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusSPC* internal_default_instance() {
    return reinterpret_cast<const StatusSPC*>(
               &_StatusSPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  void Swap(StatusSPC* other);
  friend void swap(StatusSPC& a, StatusSPC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusSPC* New() const final {
    return CreateMaybeMessage<StatusSPC>(nullptr);
  }

  StatusSPC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusSPC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusSPC& from);
  void MergeFrom(const StatusSPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusSPC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  bool stval() const;
  void set_stval(bool value);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusSPC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  bool stval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StatusValue :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusValue) */ {
 public:
  StatusValue();
  virtual ~StatusValue();

  StatusValue(const StatusValue& from);

  inline StatusValue& operator=(const StatusValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatusValue(StatusValue&& from) noexcept
    : StatusValue() {
    *this = ::std::move(from);
  }

  inline StatusValue& operator=(StatusValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StatusValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusValue* internal_default_instance() {
    return reinterpret_cast<const StatusValue*>(
               &_StatusValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  void Swap(StatusValue* other);
  friend void swap(StatusValue& a, StatusValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatusValue* New() const final {
    return CreateMaybeMessage<StatusValue>(nullptr);
  }

  StatusValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatusValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatusValue& from);
  void MergeFrom(const StatusValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  void clear_identifiedobject();
  static const int kIdentifiedObjectFieldNumber = 1;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);

  // @@protoc_insertion_point(class_scope:commonmodule.StatusValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::IdentifiedObject* identifiedobject_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class VSS :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.VSS) */ {
 public:
  VSS();
  virtual ~VSS();

  VSS(const VSS& from);

  inline VSS& operator=(const VSS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VSS(VSS&& from) noexcept
    : VSS() {
    *this = ::std::move(from);
  }

  inline VSS& operator=(VSS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VSS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VSS* internal_default_instance() {
    return reinterpret_cast<const VSS*>(
               &_VSS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  void Swap(VSS* other);
  friend void swap(VSS& a, VSS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VSS* New() const final {
    return CreateMaybeMessage<VSS>(nullptr);
  }

  VSS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VSS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VSS& from);
  void MergeFrom(const VSS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval();
  static const int kStValFieldNumber = 2;
  const ::std::string& stval() const;
  void set_stval(const ::std::string& value);
  #if LANG_CXX11
  void set_stval(::std::string&& value);
  #endif
  void set_stval(const char* value);
  void set_stval(const char* value, size_t size);
  ::std::string* mutable_stval();
  ::std::string* release_stval();
  void set_allocated_stval(::std::string* stval);

  // .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::commonmodule::Quality& q() const;
  ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);

  // .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::commonmodule::Timestamp& t() const;
  ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);

  // @@protoc_insertion_point(class_scope:commonmodule.VSS)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr stval_;
  ::commonmodule::Quality* q_;
  ::commonmodule::Timestamp* t_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class StringStatusGGIO :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.StringStatusGGIO) */ {
 public:
  StringStatusGGIO();
  virtual ~StringStatusGGIO();

  StringStatusGGIO(const StringStatusGGIO& from);

  inline StringStatusGGIO& operator=(const StringStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringStatusGGIO(StringStatusGGIO&& from) noexcept
    : StringStatusGGIO() {
    *this = ::std::move(from);
  }

  inline StringStatusGGIO& operator=(StringStatusGGIO&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StringStatusGGIO& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const StringStatusGGIO*>(
               &_StringStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  void Swap(StringStatusGGIO* other);
  friend void swap(StringStatusGGIO& a, StringStatusGGIO& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringStatusGGIO* New() const final {
    return CreateMaybeMessage<StringStatusGGIO>(nullptr);
  }

  StringStatusGGIO* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringStatusGGIO>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringStatusGGIO& from);
  void MergeFrom(const StringStatusGGIO& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringStatusGGIO* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode();
  static const int kLogicalNodeFieldNumber = 1;
  const ::commonmodule::LogicalNode& logicalnode() const;
  ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);

  // .commonmodule.Optional_PhaseCodeKind Phase = 2;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 2;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);

  // .commonmodule.VSS StrIn = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_strin() const;
  void clear_strin();
  static const int kStrInFieldNumber = 3;
  const ::commonmodule::VSS& strin() const;
  ::commonmodule::VSS* release_strin();
  ::commonmodule::VSS* mutable_strin();
  void set_allocated_strin(::commonmodule::VSS* strin);

  // @@protoc_insertion_point(class_scope:commonmodule.StringStatusGGIO)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNode* logicalnode_;
  ::commonmodule::Optional_PhaseCodeKind* phase_;
  ::commonmodule::VSS* strin_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchPoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.SwitchPoint) */ {
 public:
  SwitchPoint();
  virtual ~SwitchPoint();

  SwitchPoint(const SwitchPoint& from);

  inline SwitchPoint& operator=(const SwitchPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchPoint(SwitchPoint&& from) noexcept
    : SwitchPoint() {
    *this = ::std::move(from);
  }

  inline SwitchPoint& operator=(SwitchPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchPoint* internal_default_instance() {
    return reinterpret_cast<const SwitchPoint*>(
               &_SwitchPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  void Swap(SwitchPoint* other);
  friend void swap(SwitchPoint& a, SwitchPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchPoint* New() const final {
    return CreateMaybeMessage<SwitchPoint>(nullptr);
  }

  SwitchPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchPoint& from);
  void MergeFrom(const SwitchPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlDPC Pos = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  const ::commonmodule::ControlDPC& pos() const;
  ::commonmodule::ControlDPC* release_pos();
  ::commonmodule::ControlDPC* mutable_pos();
  void set_allocated_pos(::commonmodule::ControlDPC* pos);

  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 2;
  const ::commonmodule::ControlTimestamp& starttime() const;
  ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);

  // @@protoc_insertion_point(class_scope:commonmodule.SwitchPoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlDPC* pos_;
  ::commonmodule::ControlTimestamp* starttime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchCSG :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.SwitchCSG) */ {
 public:
  SwitchCSG();
  virtual ~SwitchCSG();

  SwitchCSG(const SwitchCSG& from);

  inline SwitchCSG& operator=(const SwitchCSG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchCSG(SwitchCSG&& from) noexcept
    : SwitchCSG() {
    *this = ::std::move(from);
  }

  inline SwitchCSG& operator=(SwitchCSG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchCSG& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchCSG* internal_default_instance() {
    return reinterpret_cast<const SwitchCSG*>(
               &_SwitchCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  void Swap(SwitchCSG* other);
  friend void swap(SwitchCSG& a, SwitchCSG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchCSG* New() const final {
    return CreateMaybeMessage<SwitchCSG>(nullptr);
  }

  SwitchCSG* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchCSG>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchCSG& from);
  void MergeFrom(const SwitchCSG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchCSG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .commonmodule.SwitchPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  void clear_crvpts();
  static const int kCrvPtsFieldNumber = 1;
  ::commonmodule::SwitchPoint* mutable_crvpts(int index);
  ::google::protobuf::RepeatedPtrField< ::commonmodule::SwitchPoint >*
      mutable_crvpts();
  const ::commonmodule::SwitchPoint& crvpts(int index) const;
  ::commonmodule::SwitchPoint* add_crvpts();
  const ::google::protobuf::RepeatedPtrField< ::commonmodule::SwitchPoint >&
      crvpts() const;

  // @@protoc_insertion_point(class_scope:commonmodule.SwitchCSG)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::commonmodule::SwitchPoint > crvpts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class SwitchControlScheduleFSCH :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.SwitchControlScheduleFSCH) */ {
 public:
  SwitchControlScheduleFSCH();
  virtual ~SwitchControlScheduleFSCH();

  SwitchControlScheduleFSCH(const SwitchControlScheduleFSCH& from);

  inline SwitchControlScheduleFSCH& operator=(const SwitchControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchControlScheduleFSCH(SwitchControlScheduleFSCH&& from) noexcept
    : SwitchControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline SwitchControlScheduleFSCH& operator=(SwitchControlScheduleFSCH&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SwitchControlScheduleFSCH& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const SwitchControlScheduleFSCH*>(
               &_SwitchControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  void Swap(SwitchControlScheduleFSCH* other);
  friend void swap(SwitchControlScheduleFSCH& a, SwitchControlScheduleFSCH& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchControlScheduleFSCH* New() const final {
    return CreateMaybeMessage<SwitchControlScheduleFSCH>(nullptr);
  }

  SwitchControlScheduleFSCH* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchControlScheduleFSCH>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchControlScheduleFSCH& from);
  void MergeFrom(const SwitchControlScheduleFSCH& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchControlScheduleFSCH* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.SwitchCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  void clear_valdcsg();
  static const int kValDCSGFieldNumber = 1;
  const ::commonmodule::SwitchCSG& valdcsg() const;
  ::commonmodule::SwitchCSG* release_valdcsg();
  ::commonmodule::SwitchCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::commonmodule::SwitchCSG* valdcsg);

  // @@protoc_insertion_point(class_scope:commonmodule.SwitchControlScheduleFSCH)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::SwitchCSG* valdcsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// -------------------------------------------------------------------

class Optional_StateKind :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_StateKind) */ {
 public:
  Optional_StateKind();
  virtual ~Optional_StateKind();

  Optional_StateKind(const Optional_StateKind& from);

  inline Optional_StateKind& operator=(const Optional_StateKind& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optional_StateKind(Optional_StateKind&& from) noexcept
    : Optional_StateKind() {
    *this = ::std::move(from);
  }

  inline Optional_StateKind& operator=(Optional_StateKind&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Optional_StateKind& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optional_StateKind* internal_default_instance() {
    return reinterpret_cast<const Optional_StateKind*>(
               &_Optional_StateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  void Swap(Optional_StateKind* other);
  friend void swap(Optional_StateKind& a, Optional_StateKind& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optional_StateKind* New() const final {
    return CreateMaybeMessage<Optional_StateKind>(nullptr);
  }

  Optional_StateKind* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optional_StateKind>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optional_StateKind& from);
  void MergeFrom(const Optional_StateKind& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_StateKind* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StateKind value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::commonmodule::StateKind value() const;
  void set_value(::commonmodule::StateKind value);

  // @@protoc_insertion_point(class_scope:commonmodule.Optional_StateKind)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IdentifiedObject

// .google.protobuf.StringValue description = 1;
inline bool IdentifiedObject::has_description() const {
  return this != internal_default_instance() && description_ != nullptr;
}
inline const ::google::protobuf::StringValue& IdentifiedObject::description() const {
  const ::google::protobuf::StringValue* p = description_;
  // @@protoc_insertion_point(field_get:commonmodule.IdentifiedObject.description)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* IdentifiedObject::release_description() {
  // @@protoc_insertion_point(field_release:commonmodule.IdentifiedObject.description)
  
  ::google::protobuf::StringValue* temp = description_;
  description_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* IdentifiedObject::mutable_description() {
  
  if (description_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.IdentifiedObject.description)
  return description_;
}
inline void IdentifiedObject::set_allocated_description(::google::protobuf::StringValue* description) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(description_);
  }
  if (description) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(description)->GetArena();
    if (message_arena != submessage_arena) {
      description = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    
  } else {
    
  }
  description_ = description;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IdentifiedObject.description)
}

// .google.protobuf.StringValue mRID = 2 [(.uml.option_uuid) = true];
inline bool IdentifiedObject::has_mrid() const {
  return this != internal_default_instance() && mrid_ != nullptr;
}
inline const ::google::protobuf::StringValue& IdentifiedObject::mrid() const {
  const ::google::protobuf::StringValue* p = mrid_;
  // @@protoc_insertion_point(field_get:commonmodule.IdentifiedObject.mRID)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* IdentifiedObject::release_mrid() {
  // @@protoc_insertion_point(field_release:commonmodule.IdentifiedObject.mRID)
  
  ::google::protobuf::StringValue* temp = mrid_;
  mrid_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* IdentifiedObject::mutable_mrid() {
  
  if (mrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    mrid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.IdentifiedObject.mRID)
  return mrid_;
}
inline void IdentifiedObject::set_allocated_mrid(::google::protobuf::StringValue* mrid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mrid_);
  }
  if (mrid) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(mrid)->GetArena();
    if (message_arena != submessage_arena) {
      mrid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mrid, submessage_arena);
    }
    
  } else {
    
  }
  mrid_ = mrid;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IdentifiedObject.mRID)
}

// .google.protobuf.StringValue name = 3;
inline bool IdentifiedObject::has_name() const {
  return this != internal_default_instance() && name_ != nullptr;
}
inline const ::google::protobuf::StringValue& IdentifiedObject::name() const {
  const ::google::protobuf::StringValue* p = name_;
  // @@protoc_insertion_point(field_get:commonmodule.IdentifiedObject.name)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* IdentifiedObject::release_name() {
  // @@protoc_insertion_point(field_release:commonmodule.IdentifiedObject.name)
  
  ::google::protobuf::StringValue* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* IdentifiedObject::mutable_name() {
  
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.IdentifiedObject.name)
  return name_;
}
inline void IdentifiedObject::set_allocated_name(::google::protobuf::StringValue* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(name_);
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(name)->GetArena();
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IdentifiedObject.name)
}

// -------------------------------------------------------------------

// ACDCTerminal

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ACDCTerminal::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void ACDCTerminal::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ACDCTerminal::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.ACDCTerminal.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* ACDCTerminal::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ACDCTerminal.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ACDCTerminal::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ACDCTerminal.identifiedObject)
  return identifiedobject_;
}
inline void ACDCTerminal::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACDCTerminal.identifiedObject)
}

// .google.protobuf.BoolValue connected = 2;
inline bool ACDCTerminal::has_connected() const {
  return this != internal_default_instance() && connected_ != nullptr;
}
inline const ::google::protobuf::BoolValue& ACDCTerminal::connected() const {
  const ::google::protobuf::BoolValue* p = connected_;
  // @@protoc_insertion_point(field_get:commonmodule.ACDCTerminal.connected)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ACDCTerminal::release_connected() {
  // @@protoc_insertion_point(field_release:commonmodule.ACDCTerminal.connected)
  
  ::google::protobuf::BoolValue* temp = connected_;
  connected_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* ACDCTerminal::mutable_connected() {
  
  if (connected_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    connected_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ACDCTerminal.connected)
  return connected_;
}
inline void ACDCTerminal::set_allocated_connected(::google::protobuf::BoolValue* connected) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(connected_);
  }
  if (connected) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(connected)->GetArena();
    if (message_arena != submessage_arena) {
      connected = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connected, submessage_arena);
    }
    
  } else {
    
  }
  connected_ = connected;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACDCTerminal.connected)
}

// .google.protobuf.Int32Value sequenceNumber = 3;
inline bool ACDCTerminal::has_sequencenumber() const {
  return this != internal_default_instance() && sequencenumber_ != nullptr;
}
inline const ::google::protobuf::Int32Value& ACDCTerminal::sequencenumber() const {
  const ::google::protobuf::Int32Value* p = sequencenumber_;
  // @@protoc_insertion_point(field_get:commonmodule.ACDCTerminal.sequenceNumber)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* ACDCTerminal::release_sequencenumber() {
  // @@protoc_insertion_point(field_release:commonmodule.ACDCTerminal.sequenceNumber)
  
  ::google::protobuf::Int32Value* temp = sequencenumber_;
  sequencenumber_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* ACDCTerminal::mutable_sequencenumber() {
  
  if (sequencenumber_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    sequencenumber_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ACDCTerminal.sequenceNumber)
  return sequencenumber_;
}
inline void ACDCTerminal::set_allocated_sequencenumber(::google::protobuf::Int32Value* sequencenumber) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sequencenumber_);
  }
  if (sequencenumber) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(sequencenumber)->GetArena();
    if (message_arena != submessage_arena) {
      sequencenumber = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sequencenumber, submessage_arena);
    }
    
  } else {
    
  }
  sequencenumber_ = sequencenumber;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACDCTerminal.sequenceNumber)
}

// -------------------------------------------------------------------

// Optional_UnitSymbolKind

// .commonmodule.UnitSymbolKind value = 1;
inline void Optional_UnitSymbolKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::UnitSymbolKind Optional_UnitSymbolKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_UnitSymbolKind.value)
  return static_cast< ::commonmodule::UnitSymbolKind >(value_);
}
inline void Optional_UnitSymbolKind::set_value(::commonmodule::UnitSymbolKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_UnitSymbolKind.value)
}

// -------------------------------------------------------------------

// Optional_UnitMultiplierKind

// .commonmodule.UnitMultiplierKind value = 1;
inline void Optional_UnitMultiplierKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::UnitMultiplierKind Optional_UnitMultiplierKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_UnitMultiplierKind.value)
  return static_cast< ::commonmodule::UnitMultiplierKind >(value_);
}
inline void Optional_UnitMultiplierKind::set_value(::commonmodule::UnitMultiplierKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_UnitMultiplierKind.value)
}

// -------------------------------------------------------------------

// ActivePower

// .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
inline bool ActivePower::has_multiplier() const {
  return this != internal_default_instance() && multiplier_ != nullptr;
}
inline void ActivePower::clear_multiplier() {
  if (GetArenaNoVirtual() == nullptr && multiplier_ != nullptr) {
    delete multiplier_;
  }
  multiplier_ = nullptr;
}
inline const ::commonmodule::Optional_UnitMultiplierKind& ActivePower::multiplier() const {
  const ::commonmodule::Optional_UnitMultiplierKind* p = multiplier_;
  // @@protoc_insertion_point(field_get:commonmodule.ActivePower.multiplier)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_UnitMultiplierKind*>(
      &::commonmodule::_Optional_UnitMultiplierKind_default_instance_);
}
inline ::commonmodule::Optional_UnitMultiplierKind* ActivePower::release_multiplier() {
  // @@protoc_insertion_point(field_release:commonmodule.ActivePower.multiplier)
  
  ::commonmodule::Optional_UnitMultiplierKind* temp = multiplier_;
  multiplier_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_UnitMultiplierKind* ActivePower::mutable_multiplier() {
  
  if (multiplier_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_UnitMultiplierKind>(GetArenaNoVirtual());
    multiplier_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ActivePower.multiplier)
  return multiplier_;
}
inline void ActivePower::set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multiplier_;
  }
  if (multiplier) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multiplier = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multiplier, submessage_arena);
    }
    
  } else {
    
  }
  multiplier_ = multiplier;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ActivePower.multiplier)
}

// .commonmodule.Optional_UnitSymbolKind unit = 2;
inline bool ActivePower::has_unit() const {
  return this != internal_default_instance() && unit_ != nullptr;
}
inline void ActivePower::clear_unit() {
  if (GetArenaNoVirtual() == nullptr && unit_ != nullptr) {
    delete unit_;
  }
  unit_ = nullptr;
}
inline const ::commonmodule::Optional_UnitSymbolKind& ActivePower::unit() const {
  const ::commonmodule::Optional_UnitSymbolKind* p = unit_;
  // @@protoc_insertion_point(field_get:commonmodule.ActivePower.unit)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_UnitSymbolKind*>(
      &::commonmodule::_Optional_UnitSymbolKind_default_instance_);
}
inline ::commonmodule::Optional_UnitSymbolKind* ActivePower::release_unit() {
  // @@protoc_insertion_point(field_release:commonmodule.ActivePower.unit)
  
  ::commonmodule::Optional_UnitSymbolKind* temp = unit_;
  unit_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_UnitSymbolKind* ActivePower::mutable_unit() {
  
  if (unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_UnitSymbolKind>(GetArenaNoVirtual());
    unit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ActivePower.unit)
  return unit_;
}
inline void ActivePower::set_allocated_unit(::commonmodule::Optional_UnitSymbolKind* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete unit_;
  }
  if (unit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ActivePower.unit)
}

// .google.protobuf.FloatValue value = 3;
inline bool ActivePower::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::google::protobuf::FloatValue& ActivePower::value() const {
  const ::google::protobuf::FloatValue* p = value_;
  // @@protoc_insertion_point(field_get:commonmodule.ActivePower.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* ActivePower::release_value() {
  // @@protoc_insertion_point(field_release:commonmodule.ActivePower.value)
  
  ::google::protobuf::FloatValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ActivePower::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ActivePower.value)
  return value_;
}
inline void ActivePower::set_allocated_value(::google::protobuf::FloatValue* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ActivePower.value)
}

// -------------------------------------------------------------------

// Optional_PhaseCodeKind

// .commonmodule.PhaseCodeKind value = 1;
inline void Optional_PhaseCodeKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::PhaseCodeKind Optional_PhaseCodeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_PhaseCodeKind.value)
  return static_cast< ::commonmodule::PhaseCodeKind >(value_);
}
inline void Optional_PhaseCodeKind::set_value(::commonmodule::PhaseCodeKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_PhaseCodeKind.value)
}

// -------------------------------------------------------------------

// AnalogueValue

// .google.protobuf.FloatValue f = 1;
inline bool AnalogueValue::has_f() const {
  return this != internal_default_instance() && f_ != nullptr;
}
inline const ::google::protobuf::FloatValue& AnalogueValue::f() const {
  const ::google::protobuf::FloatValue* p = f_;
  // @@protoc_insertion_point(field_get:commonmodule.AnalogueValue.f)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* AnalogueValue::release_f() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogueValue.f)
  
  ::google::protobuf::FloatValue* temp = f_;
  f_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* AnalogueValue::mutable_f() {
  
  if (f_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    f_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogueValue.f)
  return f_;
}
inline void AnalogueValue::set_allocated_f(::google::protobuf::FloatValue* f) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(f_);
  }
  if (f) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(f)->GetArena();
    if (message_arena != submessage_arena) {
      f = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, f, submessage_arena);
    }
    
  } else {
    
  }
  f_ = f;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogueValue.f)
}

// .google.protobuf.Int32Value i = 2;
inline bool AnalogueValue::has_i() const {
  return this != internal_default_instance() && i_ != nullptr;
}
inline const ::google::protobuf::Int32Value& AnalogueValue::i() const {
  const ::google::protobuf::Int32Value* p = i_;
  // @@protoc_insertion_point(field_get:commonmodule.AnalogueValue.i)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* AnalogueValue::release_i() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogueValue.i)
  
  ::google::protobuf::Int32Value* temp = i_;
  i_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* AnalogueValue::mutable_i() {
  
  if (i_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    i_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogueValue.i)
  return i_;
}
inline void AnalogueValue::set_allocated_i(::google::protobuf::Int32Value* i) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(i_);
  }
  if (i) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(i)->GetArena();
    if (message_arena != submessage_arena) {
      i = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, i, submessage_arena);
    }
    
  } else {
    
  }
  i_ = i;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogueValue.i)
}

// -------------------------------------------------------------------

// Optional_ValidityKind

// .commonmodule.ValidityKind value = 1;
inline void Optional_ValidityKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::ValidityKind Optional_ValidityKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_ValidityKind.value)
  return static_cast< ::commonmodule::ValidityKind >(value_);
}
inline void Optional_ValidityKind::set_value(::commonmodule::ValidityKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_ValidityKind.value)
}

// -------------------------------------------------------------------

// DetailQual

// bool badReference = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_badreference() {
  badreference_ = false;
}
inline bool DetailQual::badreference() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.badReference)
  return badreference_;
}
inline void DetailQual::set_badreference(bool value) {
  
  badreference_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.badReference)
}

// bool failure = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_failure() {
  failure_ = false;
}
inline bool DetailQual::failure() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.failure)
  return failure_;
}
inline void DetailQual::set_failure(bool value) {
  
  failure_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.failure)
}

// bool inaccurate = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_inaccurate() {
  inaccurate_ = false;
}
inline bool DetailQual::inaccurate() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.inaccurate)
  return inaccurate_;
}
inline void DetailQual::set_inaccurate(bool value) {
  
  inaccurate_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.inaccurate)
}

// bool inconsistent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_inconsistent() {
  inconsistent_ = false;
}
inline bool DetailQual::inconsistent() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.inconsistent)
  return inconsistent_;
}
inline void DetailQual::set_inconsistent(bool value) {
  
  inconsistent_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.inconsistent)
}

// bool oldData = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_olddata() {
  olddata_ = false;
}
inline bool DetailQual::olddata() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.oldData)
  return olddata_;
}
inline void DetailQual::set_olddata(bool value) {
  
  olddata_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.oldData)
}

// bool oscillatory = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_oscillatory() {
  oscillatory_ = false;
}
inline bool DetailQual::oscillatory() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.oscillatory)
  return oscillatory_;
}
inline void DetailQual::set_oscillatory(bool value) {
  
  oscillatory_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.oscillatory)
}

// bool outOfRange = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_outofrange() {
  outofrange_ = false;
}
inline bool DetailQual::outofrange() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.outOfRange)
  return outofrange_;
}
inline void DetailQual::set_outofrange(bool value) {
  
  outofrange_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.outOfRange)
}

// bool overflow = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_overflow() {
  overflow_ = false;
}
inline bool DetailQual::overflow() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.overflow)
  return overflow_;
}
inline void DetailQual::set_overflow(bool value) {
  
  overflow_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.overflow)
}

// -------------------------------------------------------------------

// Optional_SourceKind

// .commonmodule.SourceKind value = 1;
inline void Optional_SourceKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::SourceKind Optional_SourceKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_SourceKind.value)
  return static_cast< ::commonmodule::SourceKind >(value_);
}
inline void Optional_SourceKind::set_value(::commonmodule::SourceKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_SourceKind.value)
}

// -------------------------------------------------------------------

// Quality

// .commonmodule.DetailQual detailQual = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool Quality::has_detailqual() const {
  return this != internal_default_instance() && detailqual_ != nullptr;
}
inline void Quality::clear_detailqual() {
  if (GetArenaNoVirtual() == nullptr && detailqual_ != nullptr) {
    delete detailqual_;
  }
  detailqual_ = nullptr;
}
inline const ::commonmodule::DetailQual& Quality::detailqual() const {
  const ::commonmodule::DetailQual* p = detailqual_;
  // @@protoc_insertion_point(field_get:commonmodule.Quality.detailQual)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::DetailQual*>(
      &::commonmodule::_DetailQual_default_instance_);
}
inline ::commonmodule::DetailQual* Quality::release_detailqual() {
  // @@protoc_insertion_point(field_release:commonmodule.Quality.detailQual)
  
  ::commonmodule::DetailQual* temp = detailqual_;
  detailqual_ = nullptr;
  return temp;
}
inline ::commonmodule::DetailQual* Quality::mutable_detailqual() {
  
  if (detailqual_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::DetailQual>(GetArenaNoVirtual());
    detailqual_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Quality.detailQual)
  return detailqual_;
}
inline void Quality::set_allocated_detailqual(::commonmodule::DetailQual* detailqual) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete detailqual_;
  }
  if (detailqual) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      detailqual = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detailqual, submessage_arena);
    }
    
  } else {
    
  }
  detailqual_ = detailqual;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Quality.detailQual)
}

// bool operatorBlocked = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_operatorblocked() {
  operatorblocked_ = false;
}
inline bool Quality::operatorblocked() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.operatorBlocked)
  return operatorblocked_;
}
inline void Quality::set_operatorblocked(bool value) {
  
  operatorblocked_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Quality.operatorBlocked)
}

// .commonmodule.SourceKind source = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_source() {
  source_ = 0;
}
inline ::commonmodule::SourceKind Quality::source() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.source)
  return static_cast< ::commonmodule::SourceKind >(source_);
}
inline void Quality::set_source(::commonmodule::SourceKind value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Quality.source)
}

// bool test = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_test() {
  test_ = false;
}
inline bool Quality::test() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.test)
  return test_;
}
inline void Quality::set_test(bool value) {
  
  test_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Quality.test)
}

// .commonmodule.ValidityKind validity = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_validity() {
  validity_ = 0;
}
inline ::commonmodule::ValidityKind Quality::validity() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.validity)
  return static_cast< ::commonmodule::ValidityKind >(validity_);
}
inline void Quality::set_validity(::commonmodule::ValidityKind value) {
  
  validity_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Quality.validity)
}

// -------------------------------------------------------------------

// Optional_TimeAccuracyKind

// .commonmodule.TimeAccuracyKind value = 1;
inline void Optional_TimeAccuracyKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::TimeAccuracyKind Optional_TimeAccuracyKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_TimeAccuracyKind.value)
  return static_cast< ::commonmodule::TimeAccuracyKind >(value_);
}
inline void Optional_TimeAccuracyKind::set_value(::commonmodule::TimeAccuracyKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_TimeAccuracyKind.value)
}

// -------------------------------------------------------------------

// TimeQuality

// bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_clockfailure() {
  clockfailure_ = false;
}
inline bool TimeQuality::clockfailure() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.clockFailure)
  return clockfailure_;
}
inline void TimeQuality::set_clockfailure(bool value) {
  
  clockfailure_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.clockFailure)
}

// bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_clocknotsynchronized() {
  clocknotsynchronized_ = false;
}
inline bool TimeQuality::clocknotsynchronized() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.clockNotSynchronized)
  return clocknotsynchronized_;
}
inline void TimeQuality::set_clocknotsynchronized(bool value) {
  
  clocknotsynchronized_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.clockNotSynchronized)
}

// bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_leapsecondsknown() {
  leapsecondsknown_ = false;
}
inline bool TimeQuality::leapsecondsknown() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.leapSecondsKnown)
  return leapsecondsknown_;
}
inline void TimeQuality::set_leapsecondsknown(bool value) {
  
  leapsecondsknown_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.leapSecondsKnown)
}

// .commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_timeaccuracy() {
  timeaccuracy_ = 0;
}
inline ::commonmodule::TimeAccuracyKind TimeQuality::timeaccuracy() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.timeAccuracy)
  return static_cast< ::commonmodule::TimeAccuracyKind >(timeaccuracy_);
}
inline void TimeQuality::set_timeaccuracy(::commonmodule::TimeAccuracyKind value) {
  
  timeaccuracy_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.timeAccuracy)
}

// -------------------------------------------------------------------

// Timestamp

// uint32 fraction = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Timestamp::clear_fraction() {
  fraction_ = 0u;
}
inline ::google::protobuf::uint32 Timestamp::fraction() const {
  // @@protoc_insertion_point(field_get:commonmodule.Timestamp.fraction)
  return fraction_;
}
inline void Timestamp::set_fraction(::google::protobuf::uint32 value) {
  
  fraction_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Timestamp.fraction)
}

// uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Timestamp::clear_seconds() {
  seconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.Timestamp.seconds)
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::uint64 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Timestamp.seconds)
}

// .commonmodule.TimeQuality tq = 3;
inline bool Timestamp::has_tq() const {
  return this != internal_default_instance() && tq_ != nullptr;
}
inline void Timestamp::clear_tq() {
  if (GetArenaNoVirtual() == nullptr && tq_ != nullptr) {
    delete tq_;
  }
  tq_ = nullptr;
}
inline const ::commonmodule::TimeQuality& Timestamp::tq() const {
  const ::commonmodule::TimeQuality* p = tq_;
  // @@protoc_insertion_point(field_get:commonmodule.Timestamp.tq)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::TimeQuality*>(
      &::commonmodule::_TimeQuality_default_instance_);
}
inline ::commonmodule::TimeQuality* Timestamp::release_tq() {
  // @@protoc_insertion_point(field_release:commonmodule.Timestamp.tq)
  
  ::commonmodule::TimeQuality* temp = tq_;
  tq_ = nullptr;
  return temp;
}
inline ::commonmodule::TimeQuality* Timestamp::mutable_tq() {
  
  if (tq_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TimeQuality>(GetArenaNoVirtual());
    tq_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Timestamp.tq)
  return tq_;
}
inline void Timestamp::set_allocated_tq(::commonmodule::TimeQuality* tq) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tq_;
  }
  if (tq) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tq = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tq, submessage_arena);
    }
    
  } else {
    
  }
  tq_ = tq;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Timestamp.tq)
}

// -------------------------------------------------------------------

// Unit

// .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
inline bool Unit::has_multiplier() const {
  return this != internal_default_instance() && multiplier_ != nullptr;
}
inline void Unit::clear_multiplier() {
  if (GetArenaNoVirtual() == nullptr && multiplier_ != nullptr) {
    delete multiplier_;
  }
  multiplier_ = nullptr;
}
inline const ::commonmodule::Optional_UnitMultiplierKind& Unit::multiplier() const {
  const ::commonmodule::Optional_UnitMultiplierKind* p = multiplier_;
  // @@protoc_insertion_point(field_get:commonmodule.Unit.multiplier)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_UnitMultiplierKind*>(
      &::commonmodule::_Optional_UnitMultiplierKind_default_instance_);
}
inline ::commonmodule::Optional_UnitMultiplierKind* Unit::release_multiplier() {
  // @@protoc_insertion_point(field_release:commonmodule.Unit.multiplier)
  
  ::commonmodule::Optional_UnitMultiplierKind* temp = multiplier_;
  multiplier_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_UnitMultiplierKind* Unit::mutable_multiplier() {
  
  if (multiplier_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_UnitMultiplierKind>(GetArenaNoVirtual());
    multiplier_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Unit.multiplier)
  return multiplier_;
}
inline void Unit::set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multiplier_;
  }
  if (multiplier) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multiplier = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multiplier, submessage_arena);
    }
    
  } else {
    
  }
  multiplier_ = multiplier;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Unit.multiplier)
}

// .commonmodule.UnitSymbolKind SIUnit = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Unit::clear_siunit() {
  siunit_ = 0;
}
inline ::commonmodule::UnitSymbolKind Unit::siunit() const {
  // @@protoc_insertion_point(field_get:commonmodule.Unit.SIUnit)
  return static_cast< ::commonmodule::UnitSymbolKind >(siunit_);
}
inline void Unit::set_siunit(::commonmodule::UnitSymbolKind value) {
  
  siunit_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Unit.SIUnit)
}

// -------------------------------------------------------------------

// MV

// .commonmodule.AnalogueValue mag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool MV::has_mag() const {
  return this != internal_default_instance() && mag_ != nullptr;
}
inline void MV::clear_mag() {
  if (GetArenaNoVirtual() == nullptr && mag_ != nullptr) {
    delete mag_;
  }
  mag_ = nullptr;
}
inline const ::commonmodule::AnalogueValue& MV::mag() const {
  const ::commonmodule::AnalogueValue* p = mag_;
  // @@protoc_insertion_point(field_get:commonmodule.MV.mag)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::AnalogueValue*>(
      &::commonmodule::_AnalogueValue_default_instance_);
}
inline ::commonmodule::AnalogueValue* MV::release_mag() {
  // @@protoc_insertion_point(field_release:commonmodule.MV.mag)
  
  ::commonmodule::AnalogueValue* temp = mag_;
  mag_ = nullptr;
  return temp;
}
inline ::commonmodule::AnalogueValue* MV::mutable_mag() {
  
  if (mag_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::AnalogueValue>(GetArenaNoVirtual());
    mag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.MV.mag)
  return mag_;
}
inline void MV::set_allocated_mag(::commonmodule::AnalogueValue* mag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete mag_;
  }
  if (mag) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mag, submessage_arena);
    }
    
  } else {
    
  }
  mag_ = mag;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MV.mag)
}

// .commonmodule.Quality q = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool MV::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void MV::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& MV::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.MV.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* MV::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.MV.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* MV::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.MV.q)
  return q_;
}
inline void MV::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MV.q)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool MV::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void MV::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& MV::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.MV.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* MV::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.MV.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* MV::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.MV.t)
  return t_;
}
inline void MV::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MV.t)
}

// .commonmodule.Unit units = 4;
inline bool MV::has_units() const {
  return this != internal_default_instance() && units_ != nullptr;
}
inline void MV::clear_units() {
  if (GetArenaNoVirtual() == nullptr && units_ != nullptr) {
    delete units_;
  }
  units_ = nullptr;
}
inline const ::commonmodule::Unit& MV::units() const {
  const ::commonmodule::Unit* p = units_;
  // @@protoc_insertion_point(field_get:commonmodule.MV.units)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Unit*>(
      &::commonmodule::_Unit_default_instance_);
}
inline ::commonmodule::Unit* MV::release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.MV.units)
  
  ::commonmodule::Unit* temp = units_;
  units_ = nullptr;
  return temp;
}
inline ::commonmodule::Unit* MV::mutable_units() {
  
  if (units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Unit>(GetArenaNoVirtual());
    units_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.MV.units)
  return units_;
}
inline void MV::set_allocated_units(::commonmodule::Unit* units) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete units_;
  }
  if (units) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      units = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }
    
  } else {
    
  }
  units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MV.units)
}

// -------------------------------------------------------------------

// LogicalNode

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool LogicalNode::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void LogicalNode::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& LogicalNode::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNode.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* LogicalNode::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNode.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* LogicalNode::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNode.identifiedObject)
  return identifiedobject_;
}
inline void LogicalNode::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNode.identifiedObject)
}

// -------------------------------------------------------------------

// AnalogStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool AnalogStatusGGIO::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void AnalogStatusGGIO::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& AnalogStatusGGIO::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.AnalogStatusGGIO.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* AnalogStatusGGIO::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* AnalogStatusGGIO::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogStatusGGIO.logicalNode)
  return logicalnode_;
}
inline void AnalogStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogStatusGGIO.logicalNode)
}

// .commonmodule.MV AnIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool AnalogStatusGGIO::has_anin() const {
  return this != internal_default_instance() && anin_ != nullptr;
}
inline void AnalogStatusGGIO::clear_anin() {
  if (GetArenaNoVirtual() == nullptr && anin_ != nullptr) {
    delete anin_;
  }
  anin_ = nullptr;
}
inline const ::commonmodule::MV& AnalogStatusGGIO::anin() const {
  const ::commonmodule::MV* p = anin_;
  // @@protoc_insertion_point(field_get:commonmodule.AnalogStatusGGIO.AnIn)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MV*>(
      &::commonmodule::_MV_default_instance_);
}
inline ::commonmodule::MV* AnalogStatusGGIO::release_anin() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogStatusGGIO.AnIn)
  
  ::commonmodule::MV* temp = anin_;
  anin_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* AnalogStatusGGIO::mutable_anin() {
  
  if (anin_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaNoVirtual());
    anin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogStatusGGIO.AnIn)
  return anin_;
}
inline void AnalogStatusGGIO::set_allocated_anin(::commonmodule::MV* anin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anin_;
  }
  if (anin) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, anin, submessage_arena);
    }
    
  } else {
    
  }
  anin_ = anin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogStatusGGIO.AnIn)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 3;
inline bool AnalogStatusGGIO::has_phase() const {
  return this != internal_default_instance() && phase_ != nullptr;
}
inline void AnalogStatusGGIO::clear_phase() {
  if (GetArenaNoVirtual() == nullptr && phase_ != nullptr) {
    delete phase_;
  }
  phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& AnalogStatusGGIO::phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = phase_;
  // @@protoc_insertion_point(field_get:commonmodule.AnalogStatusGGIO.Phase)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind*>(
      &::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline ::commonmodule::Optional_PhaseCodeKind* AnalogStatusGGIO::release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = phase_;
  phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* AnalogStatusGGIO::mutable_phase() {
  
  if (phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaNoVirtual());
    phase_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogStatusGGIO.Phase)
  return phase_;
}
inline void AnalogStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phase_;
  }
  if (phase) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phase = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }
    
  } else {
    
  }
  phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogStatusGGIO.Phase)
}

// -------------------------------------------------------------------

// AnalogueValueCtl

// .google.protobuf.FloatValue f = 1;
inline bool AnalogueValueCtl::has_f() const {
  return this != internal_default_instance() && f_ != nullptr;
}
inline const ::google::protobuf::FloatValue& AnalogueValueCtl::f() const {
  const ::google::protobuf::FloatValue* p = f_;
  // @@protoc_insertion_point(field_get:commonmodule.AnalogueValueCtl.f)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* AnalogueValueCtl::release_f() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogueValueCtl.f)
  
  ::google::protobuf::FloatValue* temp = f_;
  f_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* AnalogueValueCtl::mutable_f() {
  
  if (f_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    f_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogueValueCtl.f)
  return f_;
}
inline void AnalogueValueCtl::set_allocated_f(::google::protobuf::FloatValue* f) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(f_);
  }
  if (f) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(f)->GetArena();
    if (message_arena != submessage_arena) {
      f = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, f, submessage_arena);
    }
    
  } else {
    
  }
  f_ = f;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogueValueCtl.f)
}

// .google.protobuf.Int32Value i = 2;
inline bool AnalogueValueCtl::has_i() const {
  return this != internal_default_instance() && i_ != nullptr;
}
inline const ::google::protobuf::Int32Value& AnalogueValueCtl::i() const {
  const ::google::protobuf::Int32Value* p = i_;
  // @@protoc_insertion_point(field_get:commonmodule.AnalogueValueCtl.i)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* AnalogueValueCtl::release_i() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogueValueCtl.i)
  
  ::google::protobuf::Int32Value* temp = i_;
  i_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* AnalogueValueCtl::mutable_i() {
  
  if (i_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    i_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogueValueCtl.i)
  return i_;
}
inline void AnalogueValueCtl::set_allocated_i(::google::protobuf::Int32Value* i) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(i_);
  }
  if (i) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(i)->GetArena();
    if (message_arena != submessage_arena) {
      i = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, i, submessage_arena);
    }
    
  } else {
    
  }
  i_ = i;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogueValueCtl.i)
}

// -------------------------------------------------------------------

// NamedObject

// .google.protobuf.StringValue description = 1;
inline bool NamedObject::has_description() const {
  return this != internal_default_instance() && description_ != nullptr;
}
inline const ::google::protobuf::StringValue& NamedObject::description() const {
  const ::google::protobuf::StringValue* p = description_;
  // @@protoc_insertion_point(field_get:commonmodule.NamedObject.description)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* NamedObject::release_description() {
  // @@protoc_insertion_point(field_release:commonmodule.NamedObject.description)
  
  ::google::protobuf::StringValue* temp = description_;
  description_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* NamedObject::mutable_description() {
  
  if (description_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.NamedObject.description)
  return description_;
}
inline void NamedObject::set_allocated_description(::google::protobuf::StringValue* description) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(description_);
  }
  if (description) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(description)->GetArena();
    if (message_arena != submessage_arena) {
      description = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    
  } else {
    
  }
  description_ = description;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NamedObject.description)
}

// .google.protobuf.StringValue name = 2;
inline bool NamedObject::has_name() const {
  return this != internal_default_instance() && name_ != nullptr;
}
inline const ::google::protobuf::StringValue& NamedObject::name() const {
  const ::google::protobuf::StringValue* p = name_;
  // @@protoc_insertion_point(field_get:commonmodule.NamedObject.name)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* NamedObject::release_name() {
  // @@protoc_insertion_point(field_release:commonmodule.NamedObject.name)
  
  ::google::protobuf::StringValue* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* NamedObject::mutable_name() {
  
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.NamedObject.name)
  return name_;
}
inline void NamedObject::set_allocated_name(::google::protobuf::StringValue* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(name_);
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(name)->GetArena();
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NamedObject.name)
}

// -------------------------------------------------------------------

// ApplicationSystem

// .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
inline bool ApplicationSystem::has_namedobject() const {
  return this != internal_default_instance() && namedobject_ != nullptr;
}
inline void ApplicationSystem::clear_namedobject() {
  if (GetArenaNoVirtual() == nullptr && namedobject_ != nullptr) {
    delete namedobject_;
  }
  namedobject_ = nullptr;
}
inline const ::commonmodule::NamedObject& ApplicationSystem::namedobject() const {
  const ::commonmodule::NamedObject* p = namedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.ApplicationSystem.namedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::NamedObject*>(
      &::commonmodule::_NamedObject_default_instance_);
}
inline ::commonmodule::NamedObject* ApplicationSystem::release_namedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ApplicationSystem.namedObject)
  
  ::commonmodule::NamedObject* temp = namedobject_;
  namedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::NamedObject* ApplicationSystem::mutable_namedobject() {
  
  if (namedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::NamedObject>(GetArenaNoVirtual());
    namedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ApplicationSystem.namedObject)
  return namedobject_;
}
inline void ApplicationSystem::set_allocated_namedobject(::commonmodule::NamedObject* namedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete namedobject_;
  }
  if (namedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      namedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, namedobject, submessage_arena);
    }
    
  } else {
    
  }
  namedobject_ = namedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ApplicationSystem.namedObject)
}

// string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true];
inline void ApplicationSystem::clear_mrid() {
  mrid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ApplicationSystem::mrid() const {
  // @@protoc_insertion_point(field_get:commonmodule.ApplicationSystem.mRID)
  return mrid_.GetNoArena();
}
inline void ApplicationSystem::set_mrid(const ::std::string& value) {
  
  mrid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:commonmodule.ApplicationSystem.mRID)
}
#if LANG_CXX11
inline void ApplicationSystem::set_mrid(::std::string&& value) {
  
  mrid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:commonmodule.ApplicationSystem.mRID)
}
#endif
inline void ApplicationSystem::set_mrid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mrid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:commonmodule.ApplicationSystem.mRID)
}
inline void ApplicationSystem::set_mrid(const char* value, size_t size) {
  
  mrid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:commonmodule.ApplicationSystem.mRID)
}
inline ::std::string* ApplicationSystem::mutable_mrid() {
  
  // @@protoc_insertion_point(field_mutable:commonmodule.ApplicationSystem.mRID)
  return mrid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplicationSystem::release_mrid() {
  // @@protoc_insertion_point(field_release:commonmodule.ApplicationSystem.mRID)
  
  return mrid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplicationSystem::set_allocated_mrid(::std::string* mrid) {
  if (mrid != nullptr) {
    
  } else {
    
  }
  mrid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mrid);
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ApplicationSystem.mRID)
}

// -------------------------------------------------------------------

// ASG

// .commonmodule.AnalogueValueCtl setMag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ASG::has_setmag() const {
  return this != internal_default_instance() && setmag_ != nullptr;
}
inline void ASG::clear_setmag() {
  if (GetArenaNoVirtual() == nullptr && setmag_ != nullptr) {
    delete setmag_;
  }
  setmag_ = nullptr;
}
inline const ::commonmodule::AnalogueValueCtl& ASG::setmag() const {
  const ::commonmodule::AnalogueValueCtl* p = setmag_;
  // @@protoc_insertion_point(field_get:commonmodule.ASG.setMag)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::AnalogueValueCtl*>(
      &::commonmodule::_AnalogueValueCtl_default_instance_);
}
inline ::commonmodule::AnalogueValueCtl* ASG::release_setmag() {
  // @@protoc_insertion_point(field_release:commonmodule.ASG.setMag)
  
  ::commonmodule::AnalogueValueCtl* temp = setmag_;
  setmag_ = nullptr;
  return temp;
}
inline ::commonmodule::AnalogueValueCtl* ASG::mutable_setmag() {
  
  if (setmag_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::AnalogueValueCtl>(GetArenaNoVirtual());
    setmag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ASG.setMag)
  return setmag_;
}
inline void ASG::set_allocated_setmag(::commonmodule::AnalogueValueCtl* setmag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete setmag_;
  }
  if (setmag) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      setmag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, setmag, submessage_arena);
    }
    
  } else {
    
  }
  setmag_ = setmag;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ASG.setMag)
}

// .commonmodule.Unit units = 2;
inline bool ASG::has_units() const {
  return this != internal_default_instance() && units_ != nullptr;
}
inline void ASG::clear_units() {
  if (GetArenaNoVirtual() == nullptr && units_ != nullptr) {
    delete units_;
  }
  units_ = nullptr;
}
inline const ::commonmodule::Unit& ASG::units() const {
  const ::commonmodule::Unit* p = units_;
  // @@protoc_insertion_point(field_get:commonmodule.ASG.units)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Unit*>(
      &::commonmodule::_Unit_default_instance_);
}
inline ::commonmodule::Unit* ASG::release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.ASG.units)
  
  ::commonmodule::Unit* temp = units_;
  units_ = nullptr;
  return temp;
}
inline ::commonmodule::Unit* ASG::mutable_units() {
  
  if (units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Unit>(GetArenaNoVirtual());
    units_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ASG.units)
  return units_;
}
inline void ASG::set_allocated_units(::commonmodule::Unit* units) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete units_;
  }
  if (units) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      units = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }
    
  } else {
    
  }
  units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ASG.units)
}

// -------------------------------------------------------------------

// BCR

// int64 actVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void BCR::clear_actval() {
  actval_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BCR::actval() const {
  // @@protoc_insertion_point(field_get:commonmodule.BCR.actVal)
  return actval_;
}
inline void BCR::set_actval(::google::protobuf::int64 value) {
  
  actval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.BCR.actVal)
}

// .commonmodule.Quality q = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BCR::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void BCR::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& BCR::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.BCR.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* BCR::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.BCR.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* BCR::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.BCR.q)
  return q_;
}
inline void BCR::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BCR.q)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BCR::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void BCR::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& BCR::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.BCR.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* BCR::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.BCR.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* BCR::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.BCR.t)
  return t_;
}
inline void BCR::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BCR.t)
}

// .commonmodule.Optional_UnitSymbolKind units = 4;
inline bool BCR::has_units() const {
  return this != internal_default_instance() && units_ != nullptr;
}
inline void BCR::clear_units() {
  if (GetArenaNoVirtual() == nullptr && units_ != nullptr) {
    delete units_;
  }
  units_ = nullptr;
}
inline const ::commonmodule::Optional_UnitSymbolKind& BCR::units() const {
  const ::commonmodule::Optional_UnitSymbolKind* p = units_;
  // @@protoc_insertion_point(field_get:commonmodule.BCR.units)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_UnitSymbolKind*>(
      &::commonmodule::_Optional_UnitSymbolKind_default_instance_);
}
inline ::commonmodule::Optional_UnitSymbolKind* BCR::release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.BCR.units)
  
  ::commonmodule::Optional_UnitSymbolKind* temp = units_;
  units_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_UnitSymbolKind* BCR::mutable_units() {
  
  if (units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_UnitSymbolKind>(GetArenaNoVirtual());
    units_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.BCR.units)
  return units_;
}
inline void BCR::set_allocated_units(::commonmodule::Optional_UnitSymbolKind* units) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete units_;
  }
  if (units) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      units = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }
    
  } else {
    
  }
  units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BCR.units)
}

// -------------------------------------------------------------------

// StatusSPS

// .commonmodule.Quality q = 1;
inline bool StatusSPS::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void StatusSPS::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusSPS::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPS.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* StatusSPS::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusSPS.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusSPS::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusSPS.q)
  return q_;
}
inline void StatusSPS::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusSPS.q)
}

// bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusSPS::clear_stval() {
  stval_ = false;
}
inline bool StatusSPS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPS.stVal)
  return stval_;
}
inline void StatusSPS::set_stval(bool value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.StatusSPS.stVal)
}

// .commonmodule.Timestamp t = 3;
inline bool StatusSPS::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void StatusSPS::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusSPS::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPS.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* StatusSPS::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusSPS.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusSPS::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusSPS.t)
  return t_;
}
inline void StatusSPS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusSPS.t)
}

// -------------------------------------------------------------------

// BooleanStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool BooleanStatusGGIO::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void BooleanStatusGGIO::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& BooleanStatusGGIO::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.BooleanStatusGGIO.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* BooleanStatusGGIO::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.BooleanStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* BooleanStatusGGIO::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.BooleanStatusGGIO.logicalNode)
  return logicalnode_;
}
inline void BooleanStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BooleanStatusGGIO.logicalNode)
}

// .commonmodule.StatusSPS Ind = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BooleanStatusGGIO::has_ind() const {
  return this != internal_default_instance() && ind_ != nullptr;
}
inline void BooleanStatusGGIO::clear_ind() {
  if (GetArenaNoVirtual() == nullptr && ind_ != nullptr) {
    delete ind_;
  }
  ind_ = nullptr;
}
inline const ::commonmodule::StatusSPS& BooleanStatusGGIO::ind() const {
  const ::commonmodule::StatusSPS* p = ind_;
  // @@protoc_insertion_point(field_get:commonmodule.BooleanStatusGGIO.Ind)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* BooleanStatusGGIO::release_ind() {
  // @@protoc_insertion_point(field_release:commonmodule.BooleanStatusGGIO.Ind)
  
  ::commonmodule::StatusSPS* temp = ind_;
  ind_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* BooleanStatusGGIO::mutable_ind() {
  
  if (ind_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    ind_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.BooleanStatusGGIO.Ind)
  return ind_;
}
inline void BooleanStatusGGIO::set_allocated_ind(::commonmodule::StatusSPS* ind) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ind_;
  }
  if (ind) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ind = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ind, submessage_arena);
    }
    
  } else {
    
  }
  ind_ = ind;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BooleanStatusGGIO.Ind)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 3;
inline bool BooleanStatusGGIO::has_phase() const {
  return this != internal_default_instance() && phase_ != nullptr;
}
inline void BooleanStatusGGIO::clear_phase() {
  if (GetArenaNoVirtual() == nullptr && phase_ != nullptr) {
    delete phase_;
  }
  phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& BooleanStatusGGIO::phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = phase_;
  // @@protoc_insertion_point(field_get:commonmodule.BooleanStatusGGIO.Phase)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind*>(
      &::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline ::commonmodule::Optional_PhaseCodeKind* BooleanStatusGGIO::release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.BooleanStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = phase_;
  phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* BooleanStatusGGIO::mutable_phase() {
  
  if (phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaNoVirtual());
    phase_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.BooleanStatusGGIO.Phase)
  return phase_;
}
inline void BooleanStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phase_;
  }
  if (phase) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phase = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }
    
  } else {
    
  }
  phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BooleanStatusGGIO.Phase)
}

// -------------------------------------------------------------------

// CheckConditions

// .google.protobuf.BoolValue interlockCheck = 1;
inline bool CheckConditions::has_interlockcheck() const {
  return this != internal_default_instance() && interlockcheck_ != nullptr;
}
inline const ::google::protobuf::BoolValue& CheckConditions::interlockcheck() const {
  const ::google::protobuf::BoolValue* p = interlockcheck_;
  // @@protoc_insertion_point(field_get:commonmodule.CheckConditions.interlockCheck)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* CheckConditions::release_interlockcheck() {
  // @@protoc_insertion_point(field_release:commonmodule.CheckConditions.interlockCheck)
  
  ::google::protobuf::BoolValue* temp = interlockcheck_;
  interlockcheck_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* CheckConditions::mutable_interlockcheck() {
  
  if (interlockcheck_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    interlockcheck_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.CheckConditions.interlockCheck)
  return interlockcheck_;
}
inline void CheckConditions::set_allocated_interlockcheck(::google::protobuf::BoolValue* interlockcheck) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(interlockcheck_);
  }
  if (interlockcheck) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(interlockcheck)->GetArena();
    if (message_arena != submessage_arena) {
      interlockcheck = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interlockcheck, submessage_arena);
    }
    
  } else {
    
  }
  interlockcheck_ = interlockcheck;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CheckConditions.interlockCheck)
}

// .google.protobuf.BoolValue synchroCheck = 2;
inline bool CheckConditions::has_synchrocheck() const {
  return this != internal_default_instance() && synchrocheck_ != nullptr;
}
inline const ::google::protobuf::BoolValue& CheckConditions::synchrocheck() const {
  const ::google::protobuf::BoolValue* p = synchrocheck_;
  // @@protoc_insertion_point(field_get:commonmodule.CheckConditions.synchroCheck)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* CheckConditions::release_synchrocheck() {
  // @@protoc_insertion_point(field_release:commonmodule.CheckConditions.synchroCheck)
  
  ::google::protobuf::BoolValue* temp = synchrocheck_;
  synchrocheck_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* CheckConditions::mutable_synchrocheck() {
  
  if (synchrocheck_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    synchrocheck_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.CheckConditions.synchroCheck)
  return synchrocheck_;
}
inline void CheckConditions::set_allocated_synchrocheck(::google::protobuf::BoolValue* synchrocheck) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(synchrocheck_);
  }
  if (synchrocheck) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(synchrocheck)->GetArena();
    if (message_arena != submessage_arena) {
      synchrocheck = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, synchrocheck, submessage_arena);
    }
    
  } else {
    
  }
  synchrocheck_ = synchrocheck;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CheckConditions.synchroCheck)
}

// -------------------------------------------------------------------

// Vector

// .commonmodule.AnalogueValue ang = 1;
inline bool Vector::has_ang() const {
  return this != internal_default_instance() && ang_ != nullptr;
}
inline void Vector::clear_ang() {
  if (GetArenaNoVirtual() == nullptr && ang_ != nullptr) {
    delete ang_;
  }
  ang_ = nullptr;
}
inline const ::commonmodule::AnalogueValue& Vector::ang() const {
  const ::commonmodule::AnalogueValue* p = ang_;
  // @@protoc_insertion_point(field_get:commonmodule.Vector.ang)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::AnalogueValue*>(
      &::commonmodule::_AnalogueValue_default_instance_);
}
inline ::commonmodule::AnalogueValue* Vector::release_ang() {
  // @@protoc_insertion_point(field_release:commonmodule.Vector.ang)
  
  ::commonmodule::AnalogueValue* temp = ang_;
  ang_ = nullptr;
  return temp;
}
inline ::commonmodule::AnalogueValue* Vector::mutable_ang() {
  
  if (ang_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::AnalogueValue>(GetArenaNoVirtual());
    ang_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Vector.ang)
  return ang_;
}
inline void Vector::set_allocated_ang(::commonmodule::AnalogueValue* ang) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ang_;
  }
  if (ang) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ang = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ang, submessage_arena);
    }
    
  } else {
    
  }
  ang_ = ang;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Vector.ang)
}

// .commonmodule.AnalogueValue mag = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool Vector::has_mag() const {
  return this != internal_default_instance() && mag_ != nullptr;
}
inline void Vector::clear_mag() {
  if (GetArenaNoVirtual() == nullptr && mag_ != nullptr) {
    delete mag_;
  }
  mag_ = nullptr;
}
inline const ::commonmodule::AnalogueValue& Vector::mag() const {
  const ::commonmodule::AnalogueValue* p = mag_;
  // @@protoc_insertion_point(field_get:commonmodule.Vector.mag)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::AnalogueValue*>(
      &::commonmodule::_AnalogueValue_default_instance_);
}
inline ::commonmodule::AnalogueValue* Vector::release_mag() {
  // @@protoc_insertion_point(field_release:commonmodule.Vector.mag)
  
  ::commonmodule::AnalogueValue* temp = mag_;
  mag_ = nullptr;
  return temp;
}
inline ::commonmodule::AnalogueValue* Vector::mutable_mag() {
  
  if (mag_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::AnalogueValue>(GetArenaNoVirtual());
    mag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Vector.mag)
  return mag_;
}
inline void Vector::set_allocated_mag(::commonmodule::AnalogueValue* mag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete mag_;
  }
  if (mag) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mag, submessage_arena);
    }
    
  } else {
    
  }
  mag_ = mag;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Vector.mag)
}

// -------------------------------------------------------------------

// CMV

// .commonmodule.Vector cVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CMV::has_cval() const {
  return this != internal_default_instance() && cval_ != nullptr;
}
inline void CMV::clear_cval() {
  if (GetArenaNoVirtual() == nullptr && cval_ != nullptr) {
    delete cval_;
  }
  cval_ = nullptr;
}
inline const ::commonmodule::Vector& CMV::cval() const {
  const ::commonmodule::Vector* p = cval_;
  // @@protoc_insertion_point(field_get:commonmodule.CMV.cVal)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Vector*>(
      &::commonmodule::_Vector_default_instance_);
}
inline ::commonmodule::Vector* CMV::release_cval() {
  // @@protoc_insertion_point(field_release:commonmodule.CMV.cVal)
  
  ::commonmodule::Vector* temp = cval_;
  cval_ = nullptr;
  return temp;
}
inline ::commonmodule::Vector* CMV::mutable_cval() {
  
  if (cval_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Vector>(GetArenaNoVirtual());
    cval_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.CMV.cVal)
  return cval_;
}
inline void CMV::set_allocated_cval(::commonmodule::Vector* cval) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cval_;
  }
  if (cval) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cval = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cval, submessage_arena);
    }
    
  } else {
    
  }
  cval_ = cval;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CMV.cVal)
}

// .commonmodule.Quality q = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CMV::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void CMV::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& CMV::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.CMV.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* CMV::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.CMV.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* CMV::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.CMV.q)
  return q_;
}
inline void CMV::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CMV.q)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CMV::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void CMV::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& CMV::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.CMV.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* CMV::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.CMV.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* CMV::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.CMV.t)
  return t_;
}
inline void CMV::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CMV.t)
}

// .commonmodule.Unit units = 4;
inline bool CMV::has_units() const {
  return this != internal_default_instance() && units_ != nullptr;
}
inline void CMV::clear_units() {
  if (GetArenaNoVirtual() == nullptr && units_ != nullptr) {
    delete units_;
  }
  units_ = nullptr;
}
inline const ::commonmodule::Unit& CMV::units() const {
  const ::commonmodule::Unit* p = units_;
  // @@protoc_insertion_point(field_get:commonmodule.CMV.units)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Unit*>(
      &::commonmodule::_Unit_default_instance_);
}
inline ::commonmodule::Unit* CMV::release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.CMV.units)
  
  ::commonmodule::Unit* temp = units_;
  units_ = nullptr;
  return temp;
}
inline ::commonmodule::Unit* CMV::mutable_units() {
  
  if (units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Unit>(GetArenaNoVirtual());
    units_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.CMV.units)
  return units_;
}
inline void CMV::set_allocated_units(::commonmodule::Unit* units) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete units_;
  }
  if (units) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      units = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }
    
  } else {
    
  }
  units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CMV.units)
}

// -------------------------------------------------------------------

// ConductingEquipment

// .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
inline bool ConductingEquipment::has_namedobject() const {
  return this != internal_default_instance() && namedobject_ != nullptr;
}
inline void ConductingEquipment::clear_namedobject() {
  if (GetArenaNoVirtual() == nullptr && namedobject_ != nullptr) {
    delete namedobject_;
  }
  namedobject_ = nullptr;
}
inline const ::commonmodule::NamedObject& ConductingEquipment::namedobject() const {
  const ::commonmodule::NamedObject* p = namedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.ConductingEquipment.namedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::NamedObject*>(
      &::commonmodule::_NamedObject_default_instance_);
}
inline ::commonmodule::NamedObject* ConductingEquipment::release_namedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ConductingEquipment.namedObject)
  
  ::commonmodule::NamedObject* temp = namedobject_;
  namedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::NamedObject* ConductingEquipment::mutable_namedobject() {
  
  if (namedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::NamedObject>(GetArenaNoVirtual());
    namedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ConductingEquipment.namedObject)
  return namedobject_;
}
inline void ConductingEquipment::set_allocated_namedobject(::commonmodule::NamedObject* namedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete namedobject_;
  }
  if (namedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      namedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, namedobject, submessage_arena);
    }
    
  } else {
    
  }
  namedobject_ = namedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ConductingEquipment.namedObject)
}

// string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true, (.uml.option_key) = true];
inline void ConductingEquipment::clear_mrid() {
  mrid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConductingEquipment::mrid() const {
  // @@protoc_insertion_point(field_get:commonmodule.ConductingEquipment.mRID)
  return mrid_.GetNoArena();
}
inline void ConductingEquipment::set_mrid(const ::std::string& value) {
  
  mrid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:commonmodule.ConductingEquipment.mRID)
}
#if LANG_CXX11
inline void ConductingEquipment::set_mrid(::std::string&& value) {
  
  mrid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:commonmodule.ConductingEquipment.mRID)
}
#endif
inline void ConductingEquipment::set_mrid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mrid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:commonmodule.ConductingEquipment.mRID)
}
inline void ConductingEquipment::set_mrid(const char* value, size_t size) {
  
  mrid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:commonmodule.ConductingEquipment.mRID)
}
inline ::std::string* ConductingEquipment::mutable_mrid() {
  
  // @@protoc_insertion_point(field_mutable:commonmodule.ConductingEquipment.mRID)
  return mrid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConductingEquipment::release_mrid() {
  // @@protoc_insertion_point(field_release:commonmodule.ConductingEquipment.mRID)
  
  return mrid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConductingEquipment::set_allocated_mrid(::std::string* mrid) {
  if (mrid != nullptr) {
    
  } else {
    
  }
  mrid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mrid);
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ConductingEquipment.mRID)
}

// -------------------------------------------------------------------

// Terminal

// .commonmodule.ACDCTerminal aCDCTerminal = 1 [(.uml.option_parent_message) = true];
inline bool Terminal::has_acdcterminal() const {
  return this != internal_default_instance() && acdcterminal_ != nullptr;
}
inline void Terminal::clear_acdcterminal() {
  if (GetArenaNoVirtual() == nullptr && acdcterminal_ != nullptr) {
    delete acdcterminal_;
  }
  acdcterminal_ = nullptr;
}
inline const ::commonmodule::ACDCTerminal& Terminal::acdcterminal() const {
  const ::commonmodule::ACDCTerminal* p = acdcterminal_;
  // @@protoc_insertion_point(field_get:commonmodule.Terminal.aCDCTerminal)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ACDCTerminal*>(
      &::commonmodule::_ACDCTerminal_default_instance_);
}
inline ::commonmodule::ACDCTerminal* Terminal::release_acdcterminal() {
  // @@protoc_insertion_point(field_release:commonmodule.Terminal.aCDCTerminal)
  
  ::commonmodule::ACDCTerminal* temp = acdcterminal_;
  acdcterminal_ = nullptr;
  return temp;
}
inline ::commonmodule::ACDCTerminal* Terminal::mutable_acdcterminal() {
  
  if (acdcterminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ACDCTerminal>(GetArenaNoVirtual());
    acdcterminal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Terminal.aCDCTerminal)
  return acdcterminal_;
}
inline void Terminal::set_allocated_acdcterminal(::commonmodule::ACDCTerminal* acdcterminal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete acdcterminal_;
  }
  if (acdcterminal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      acdcterminal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acdcterminal, submessage_arena);
    }
    
  } else {
    
  }
  acdcterminal_ = acdcterminal;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Terminal.aCDCTerminal)
}

// .commonmodule.Optional_PhaseCodeKind phases = 2;
inline bool Terminal::has_phases() const {
  return this != internal_default_instance() && phases_ != nullptr;
}
inline void Terminal::clear_phases() {
  if (GetArenaNoVirtual() == nullptr && phases_ != nullptr) {
    delete phases_;
  }
  phases_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& Terminal::phases() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = phases_;
  // @@protoc_insertion_point(field_get:commonmodule.Terminal.phases)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind*>(
      &::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline ::commonmodule::Optional_PhaseCodeKind* Terminal::release_phases() {
  // @@protoc_insertion_point(field_release:commonmodule.Terminal.phases)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = phases_;
  phases_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* Terminal::mutable_phases() {
  
  if (phases_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaNoVirtual());
    phases_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Terminal.phases)
  return phases_;
}
inline void Terminal::set_allocated_phases(::commonmodule::Optional_PhaseCodeKind* phases) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phases_;
  }
  if (phases) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phases = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phases, submessage_arena);
    }
    
  } else {
    
  }
  phases_ = phases;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Terminal.phases)
}

// -------------------------------------------------------------------

// ConductingEquipmentTerminalReading

// .commonmodule.Terminal terminal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ConductingEquipmentTerminalReading::has_terminal() const {
  return this != internal_default_instance() && terminal_ != nullptr;
}
inline void ConductingEquipmentTerminalReading::clear_terminal() {
  if (GetArenaNoVirtual() == nullptr && terminal_ != nullptr) {
    delete terminal_;
  }
  terminal_ = nullptr;
}
inline const ::commonmodule::Terminal& ConductingEquipmentTerminalReading::terminal() const {
  const ::commonmodule::Terminal* p = terminal_;
  // @@protoc_insertion_point(field_get:commonmodule.ConductingEquipmentTerminalReading.terminal)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Terminal*>(
      &::commonmodule::_Terminal_default_instance_);
}
inline ::commonmodule::Terminal* ConductingEquipmentTerminalReading::release_terminal() {
  // @@protoc_insertion_point(field_release:commonmodule.ConductingEquipmentTerminalReading.terminal)
  
  ::commonmodule::Terminal* temp = terminal_;
  terminal_ = nullptr;
  return temp;
}
inline ::commonmodule::Terminal* ConductingEquipmentTerminalReading::mutable_terminal() {
  
  if (terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Terminal>(GetArenaNoVirtual());
    terminal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ConductingEquipmentTerminalReading.terminal)
  return terminal_;
}
inline void ConductingEquipmentTerminalReading::set_allocated_terminal(::commonmodule::Terminal* terminal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete terminal_;
  }
  if (terminal) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      terminal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    
  } else {
    
  }
  terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ConductingEquipmentTerminalReading.terminal)
}

// -------------------------------------------------------------------

// ControlDPC

// bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlDPC::clear_ctlval() {
  ctlval_ = false;
}
inline bool ControlDPC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlDPC.ctlVal)
  return ctlval_;
}
inline void ControlDPC::set_ctlval(bool value) {
  
  ctlval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ControlDPC.ctlVal)
}

// -------------------------------------------------------------------

// ControlTimestamp

// uint32 fraction = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlTimestamp::clear_fraction() {
  fraction_ = 0u;
}
inline ::google::protobuf::uint32 ControlTimestamp::fraction() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlTimestamp.fraction)
  return fraction_;
}
inline void ControlTimestamp::set_fraction(::google::protobuf::uint32 value) {
  
  fraction_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ControlTimestamp.fraction)
}

// uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlTimestamp::clear_seconds() {
  seconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ControlTimestamp::seconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlTimestamp.seconds)
  return seconds_;
}
inline void ControlTimestamp::set_seconds(::google::protobuf::uint64 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ControlTimestamp.seconds)
}

// -------------------------------------------------------------------

// Optional_ScheduleParameterKind

// .commonmodule.ScheduleParameterKind value = 1;
inline void Optional_ScheduleParameterKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::ScheduleParameterKind Optional_ScheduleParameterKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_ScheduleParameterKind.value)
  return static_cast< ::commonmodule::ScheduleParameterKind >(value_);
}
inline void Optional_ScheduleParameterKind::set_value(::commonmodule::ScheduleParameterKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_ScheduleParameterKind.value)
}

// -------------------------------------------------------------------

// ENG_ScheduleParameter

// .commonmodule.ScheduleParameterKind scheduleParameterType = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_ScheduleParameter::clear_scheduleparametertype() {
  scheduleparametertype_ = 0;
}
inline ::commonmodule::ScheduleParameterKind ENG_ScheduleParameter::scheduleparametertype() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_ScheduleParameter.scheduleParameterType)
  return static_cast< ::commonmodule::ScheduleParameterKind >(scheduleparametertype_);
}
inline void ENG_ScheduleParameter::set_scheduleparametertype(::commonmodule::ScheduleParameterKind value) {
  
  scheduleparametertype_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENG_ScheduleParameter.scheduleParameterType)
}

// float value = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_ScheduleParameter::clear_value() {
  value_ = 0;
}
inline float ENG_ScheduleParameter::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_ScheduleParameter.value)
  return value_;
}
inline void ENG_ScheduleParameter::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENG_ScheduleParameter.value)
}

// -------------------------------------------------------------------

// SchedulePoint

// repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int SchedulePoint::scheduleparameter_size() const {
  return scheduleparameter_.size();
}
inline void SchedulePoint::clear_scheduleparameter() {
  scheduleparameter_.Clear();
}
inline ::commonmodule::ENG_ScheduleParameter* SchedulePoint::mutable_scheduleparameter(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.SchedulePoint.scheduleParameter)
  return scheduleparameter_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >*
SchedulePoint::mutable_scheduleparameter() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.SchedulePoint.scheduleParameter)
  return &scheduleparameter_;
}
inline const ::commonmodule::ENG_ScheduleParameter& SchedulePoint::scheduleparameter(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.SchedulePoint.scheduleParameter)
  return scheduleparameter_.Get(index);
}
inline ::commonmodule::ENG_ScheduleParameter* SchedulePoint::add_scheduleparameter() {
  // @@protoc_insertion_point(field_add:commonmodule.SchedulePoint.scheduleParameter)
  return scheduleparameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >&
SchedulePoint::scheduleparameter() const {
  // @@protoc_insertion_point(field_list:commonmodule.SchedulePoint.scheduleParameter)
  return scheduleparameter_;
}

// .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SchedulePoint::has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline void SchedulePoint::clear_starttime() {
  if (GetArenaNoVirtual() == nullptr && starttime_ != nullptr) {
    delete starttime_;
  }
  starttime_ = nullptr;
}
inline const ::commonmodule::ControlTimestamp& SchedulePoint::starttime() const {
  const ::commonmodule::ControlTimestamp* p = starttime_;
  // @@protoc_insertion_point(field_get:commonmodule.SchedulePoint.startTime)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlTimestamp*>(
      &::commonmodule::_ControlTimestamp_default_instance_);
}
inline ::commonmodule::ControlTimestamp* SchedulePoint::release_starttime() {
  // @@protoc_insertion_point(field_release:commonmodule.SchedulePoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* SchedulePoint::mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaNoVirtual());
    starttime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.SchedulePoint.startTime)
  return starttime_;
}
inline void SchedulePoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete starttime_;
  }
  if (starttime) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starttime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SchedulePoint.startTime)
}

// -------------------------------------------------------------------

// ScheduleCSG

// repeated .commonmodule.SchedulePoint schPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int ScheduleCSG::schpts_size() const {
  return schpts_.size();
}
inline void ScheduleCSG::clear_schpts() {
  schpts_.Clear();
}
inline ::commonmodule::SchedulePoint* ScheduleCSG::mutable_schpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.ScheduleCSG.schPts)
  return schpts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::commonmodule::SchedulePoint >*
ScheduleCSG::mutable_schpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.ScheduleCSG.schPts)
  return &schpts_;
}
inline const ::commonmodule::SchedulePoint& ScheduleCSG::schpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.ScheduleCSG.schPts)
  return schpts_.Get(index);
}
inline ::commonmodule::SchedulePoint* ScheduleCSG::add_schpts() {
  // @@protoc_insertion_point(field_add:commonmodule.ScheduleCSG.schPts)
  return schpts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::commonmodule::SchedulePoint >&
ScheduleCSG::schpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.ScheduleCSG.schPts)
  return schpts_;
}

// -------------------------------------------------------------------

// ControlScheduleFSCH

// .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ControlScheduleFSCH::has_valacsg() const {
  return this != internal_default_instance() && valacsg_ != nullptr;
}
inline void ControlScheduleFSCH::clear_valacsg() {
  if (GetArenaNoVirtual() == nullptr && valacsg_ != nullptr) {
    delete valacsg_;
  }
  valacsg_ = nullptr;
}
inline const ::commonmodule::ScheduleCSG& ControlScheduleFSCH::valacsg() const {
  const ::commonmodule::ScheduleCSG* p = valacsg_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlScheduleFSCH.ValACSG)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ScheduleCSG*>(
      &::commonmodule::_ScheduleCSG_default_instance_);
}
inline ::commonmodule::ScheduleCSG* ControlScheduleFSCH::release_valacsg() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlScheduleFSCH.ValACSG)
  
  ::commonmodule::ScheduleCSG* temp = valacsg_;
  valacsg_ = nullptr;
  return temp;
}
inline ::commonmodule::ScheduleCSG* ControlScheduleFSCH::mutable_valacsg() {
  
  if (valacsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ScheduleCSG>(GetArenaNoVirtual());
    valacsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlScheduleFSCH.ValACSG)
  return valacsg_;
}
inline void ControlScheduleFSCH::set_allocated_valacsg(::commonmodule::ScheduleCSG* valacsg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete valacsg_;
  }
  if (valacsg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      valacsg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, valacsg, submessage_arena);
    }
    
  } else {
    
  }
  valacsg_ = valacsg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlScheduleFSCH.ValACSG)
}

// -------------------------------------------------------------------

// LogicalNodeForControl

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool LogicalNodeForControl::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void LogicalNodeForControl::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& LogicalNodeForControl::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForControl.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* LogicalNodeForControl::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForControl.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* LogicalNodeForControl::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForControl.logicalNode)
  return logicalnode_;
}
inline void LogicalNodeForControl::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForControl.logicalNode)
}

// -------------------------------------------------------------------

// ControlFSCC

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool ControlFSCC::has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && logicalnodeforcontrol_ != nullptr;
}
inline void ControlFSCC::clear_logicalnodeforcontrol() {
  if (GetArenaNoVirtual() == nullptr && logicalnodeforcontrol_ != nullptr) {
    delete logicalnodeforcontrol_;
  }
  logicalnodeforcontrol_ = nullptr;
}
inline const ::commonmodule::LogicalNodeForControl& ControlFSCC::logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = logicalnodeforcontrol_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlFSCC.logicalNodeForControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForControl*>(
      &::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline ::commonmodule::LogicalNodeForControl* ControlFSCC::release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlFSCC.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = logicalnodeforcontrol_;
  logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* ControlFSCC::mutable_logicalnodeforcontrol() {
  
  if (logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaNoVirtual());
    logicalnodeforcontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlFSCC.logicalNodeForControl)
  return logicalnodeforcontrol_;
}
inline void ControlFSCC::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnodeforcontrol_;
  }
  if (logicalnodeforcontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlFSCC.logicalNodeForControl)
}

// .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;
inline bool ControlFSCC::has_controlschedulefsch() const {
  return this != internal_default_instance() && controlschedulefsch_ != nullptr;
}
inline void ControlFSCC::clear_controlschedulefsch() {
  if (GetArenaNoVirtual() == nullptr && controlschedulefsch_ != nullptr) {
    delete controlschedulefsch_;
  }
  controlschedulefsch_ = nullptr;
}
inline const ::commonmodule::ControlScheduleFSCH& ControlFSCC::controlschedulefsch() const {
  const ::commonmodule::ControlScheduleFSCH* p = controlschedulefsch_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlFSCC.controlScheduleFSCH)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlScheduleFSCH*>(
      &::commonmodule::_ControlScheduleFSCH_default_instance_);
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::release_controlschedulefsch() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlFSCC.controlScheduleFSCH)
  
  ::commonmodule::ControlScheduleFSCH* temp = controlschedulefsch_;
  controlschedulefsch_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::mutable_controlschedulefsch() {
  
  if (controlschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlScheduleFSCH>(GetArenaNoVirtual());
    controlschedulefsch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlFSCC.controlScheduleFSCH)
  return controlschedulefsch_;
}
inline void ControlFSCC::set_allocated_controlschedulefsch(::commonmodule::ControlScheduleFSCH* controlschedulefsch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete controlschedulefsch_;
  }
  if (controlschedulefsch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlschedulefsch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlschedulefsch, submessage_arena);
    }
    
  } else {
    
  }
  controlschedulefsch_ = controlschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlFSCC.controlScheduleFSCH)
}

// .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;
inline bool ControlFSCC::has_islandcontrolschedulefsch() const {
  return this != internal_default_instance() && islandcontrolschedulefsch_ != nullptr;
}
inline void ControlFSCC::clear_islandcontrolschedulefsch() {
  if (GetArenaNoVirtual() == nullptr && islandcontrolschedulefsch_ != nullptr) {
    delete islandcontrolschedulefsch_;
  }
  islandcontrolschedulefsch_ = nullptr;
}
inline const ::commonmodule::ControlScheduleFSCH& ControlFSCC::islandcontrolschedulefsch() const {
  const ::commonmodule::ControlScheduleFSCH* p = islandcontrolschedulefsch_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlFSCC.islandControlScheduleFSCH)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlScheduleFSCH*>(
      &::commonmodule::_ControlScheduleFSCH_default_instance_);
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::release_islandcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlFSCC.islandControlScheduleFSCH)
  
  ::commonmodule::ControlScheduleFSCH* temp = islandcontrolschedulefsch_;
  islandcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::mutable_islandcontrolschedulefsch() {
  
  if (islandcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlScheduleFSCH>(GetArenaNoVirtual());
    islandcontrolschedulefsch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlFSCC.islandControlScheduleFSCH)
  return islandcontrolschedulefsch_;
}
inline void ControlFSCC::set_allocated_islandcontrolschedulefsch(::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete islandcontrolschedulefsch_;
  }
  if (islandcontrolschedulefsch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      islandcontrolschedulefsch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, islandcontrolschedulefsch, submessage_arena);
    }
    
  } else {
    
  }
  islandcontrolschedulefsch_ = islandcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlFSCC.islandControlScheduleFSCH)
}

// -------------------------------------------------------------------

// ControlING

// int32 setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlING::clear_setval() {
  setval_ = 0;
}
inline ::google::protobuf::int32 ControlING::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlING.setVal)
  return setval_;
}
inline void ControlING::set_setval(::google::protobuf::int32 value) {
  
  setval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ControlING.setVal)
}

// .commonmodule.Unit units = 2;
inline bool ControlING::has_units() const {
  return this != internal_default_instance() && units_ != nullptr;
}
inline void ControlING::clear_units() {
  if (GetArenaNoVirtual() == nullptr && units_ != nullptr) {
    delete units_;
  }
  units_ = nullptr;
}
inline const ::commonmodule::Unit& ControlING::units() const {
  const ::commonmodule::Unit* p = units_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlING.units)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Unit*>(
      &::commonmodule::_Unit_default_instance_);
}
inline ::commonmodule::Unit* ControlING::release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlING.units)
  
  ::commonmodule::Unit* temp = units_;
  units_ = nullptr;
  return temp;
}
inline ::commonmodule::Unit* ControlING::mutable_units() {
  
  if (units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Unit>(GetArenaNoVirtual());
    units_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlING.units)
  return units_;
}
inline void ControlING::set_allocated_units(::commonmodule::Unit* units) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete units_;
  }
  if (units) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      units = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }
    
  } else {
    
  }
  units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlING.units)
}

// -------------------------------------------------------------------

// ControlISC

// int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlISC::clear_ctlval() {
  ctlval_ = 0;
}
inline ::google::protobuf::int32 ControlISC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlISC.ctlVal)
  return ctlval_;
}
inline void ControlISC::set_ctlval(::google::protobuf::int32 value) {
  
  ctlval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ControlISC.ctlVal)
}

// -------------------------------------------------------------------

// MessageInfo

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool MessageInfo::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void MessageInfo::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& MessageInfo::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.MessageInfo.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* MessageInfo::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.MessageInfo.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* MessageInfo::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.MessageInfo.identifiedObject)
  return identifiedobject_;
}
inline void MessageInfo::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MessageInfo.identifiedObject)
}

// .commonmodule.Timestamp messageTimeStamp = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool MessageInfo::has_messagetimestamp() const {
  return this != internal_default_instance() && messagetimestamp_ != nullptr;
}
inline void MessageInfo::clear_messagetimestamp() {
  if (GetArenaNoVirtual() == nullptr && messagetimestamp_ != nullptr) {
    delete messagetimestamp_;
  }
  messagetimestamp_ = nullptr;
}
inline const ::commonmodule::Timestamp& MessageInfo::messagetimestamp() const {
  const ::commonmodule::Timestamp* p = messagetimestamp_;
  // @@protoc_insertion_point(field_get:commonmodule.MessageInfo.messageTimeStamp)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* MessageInfo::release_messagetimestamp() {
  // @@protoc_insertion_point(field_release:commonmodule.MessageInfo.messageTimeStamp)
  
  ::commonmodule::Timestamp* temp = messagetimestamp_;
  messagetimestamp_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* MessageInfo::mutable_messagetimestamp() {
  
  if (messagetimestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    messagetimestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.MessageInfo.messageTimeStamp)
  return messagetimestamp_;
}
inline void MessageInfo::set_allocated_messagetimestamp(::commonmodule::Timestamp* messagetimestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete messagetimestamp_;
  }
  if (messagetimestamp) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      messagetimestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messagetimestamp, submessage_arena);
    }
    
  } else {
    
  }
  messagetimestamp_ = messagetimestamp;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MessageInfo.messageTimeStamp)
}

// -------------------------------------------------------------------

// ControlMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ControlMessageInfo::has_messageinfo() const {
  return this != internal_default_instance() && messageinfo_ != nullptr;
}
inline void ControlMessageInfo::clear_messageinfo() {
  if (GetArenaNoVirtual() == nullptr && messageinfo_ != nullptr) {
    delete messageinfo_;
  }
  messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& ControlMessageInfo::messageinfo() const {
  const ::commonmodule::MessageInfo* p = messageinfo_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlMessageInfo.messageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MessageInfo*>(
      &::commonmodule::_MessageInfo_default_instance_);
}
inline ::commonmodule::MessageInfo* ControlMessageInfo::release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = messageinfo_;
  messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* ControlMessageInfo::mutable_messageinfo() {
  
  if (messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaNoVirtual());
    messageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlMessageInfo.messageInfo)
  return messageinfo_;
}
inline void ControlMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete messageinfo_;
  }
  if (messageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      messageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }
    
  } else {
    
  }
  messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// ControlSPC

// bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlSPC::clear_ctlval() {
  ctlval_ = false;
}
inline bool ControlSPC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlSPC.ctlVal)
  return ctlval_;
}
inline void ControlSPC::set_ctlval(bool value) {
  
  ctlval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ControlSPC.ctlVal)
}

// -------------------------------------------------------------------

// ControlValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ControlValue::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void ControlValue::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ControlValue::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlValue.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* ControlValue::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ControlValue::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlValue.identifiedObject)
  return identifiedobject_;
}
inline void ControlValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlValue.identifiedObject)
}

// .google.protobuf.BoolValue modBlk = 2;
inline bool ControlValue::has_modblk() const {
  return this != internal_default_instance() && modblk_ != nullptr;
}
inline const ::google::protobuf::BoolValue& ControlValue::modblk() const {
  const ::google::protobuf::BoolValue* p = modblk_;
  // @@protoc_insertion_point(field_get:commonmodule.ControlValue.modBlk)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* ControlValue::release_modblk() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlValue.modBlk)
  
  ::google::protobuf::BoolValue* temp = modblk_;
  modblk_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* ControlValue::mutable_modblk() {
  
  if (modblk_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    modblk_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlValue.modBlk)
  return modblk_;
}
inline void ControlValue::set_allocated_modblk(::google::protobuf::BoolValue* modblk) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(modblk_);
  }
  if (modblk) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(modblk)->GetArena();
    if (message_arena != submessage_arena) {
      modblk = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, modblk, submessage_arena);
    }
    
  } else {
    
  }
  modblk_ = modblk;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlValue.modBlk)
}

// -------------------------------------------------------------------

// DateTimeInterval

// .google.protobuf.Int64Value end = 1;
inline bool DateTimeInterval::has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline const ::google::protobuf::Int64Value& DateTimeInterval::end() const {
  const ::google::protobuf::Int64Value* p = end_;
  // @@protoc_insertion_point(field_get:commonmodule.DateTimeInterval.end)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* DateTimeInterval::release_end() {
  // @@protoc_insertion_point(field_release:commonmodule.DateTimeInterval.end)
  
  ::google::protobuf::Int64Value* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* DateTimeInterval::mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.DateTimeInterval.end)
  return end_;
}
inline void DateTimeInterval::set_allocated_end(::google::protobuf::Int64Value* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_);
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(end)->GetArena();
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DateTimeInterval.end)
}

// .google.protobuf.Int64Value start = 2;
inline bool DateTimeInterval::has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline const ::google::protobuf::Int64Value& DateTimeInterval::start() const {
  const ::google::protobuf::Int64Value* p = start_;
  // @@protoc_insertion_point(field_get:commonmodule.DateTimeInterval.start)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* DateTimeInterval::release_start() {
  // @@protoc_insertion_point(field_release:commonmodule.DateTimeInterval.start)
  
  ::google::protobuf::Int64Value* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* DateTimeInterval::mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.DateTimeInterval.start)
  return start_;
}
inline void DateTimeInterval::set_allocated_start(::google::protobuf::Int64Value* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_);
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(start)->GetArena();
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DateTimeInterval.start)
}

// -------------------------------------------------------------------

// DEL

// .commonmodule.CMV phsAB = 1;
inline bool DEL::has_phsab() const {
  return this != internal_default_instance() && phsab_ != nullptr;
}
inline void DEL::clear_phsab() {
  if (GetArenaNoVirtual() == nullptr && phsab_ != nullptr) {
    delete phsab_;
  }
  phsab_ = nullptr;
}
inline const ::commonmodule::CMV& DEL::phsab() const {
  const ::commonmodule::CMV* p = phsab_;
  // @@protoc_insertion_point(field_get:commonmodule.DEL.phsAB)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* DEL::release_phsab() {
  // @@protoc_insertion_point(field_release:commonmodule.DEL.phsAB)
  
  ::commonmodule::CMV* temp = phsab_;
  phsab_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* DEL::mutable_phsab() {
  
  if (phsab_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    phsab_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.DEL.phsAB)
  return phsab_;
}
inline void DEL::set_allocated_phsab(::commonmodule::CMV* phsab) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsab_;
  }
  if (phsab) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsab = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsab, submessage_arena);
    }
    
  } else {
    
  }
  phsab_ = phsab;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DEL.phsAB)
}

// .commonmodule.CMV phsBC = 2;
inline bool DEL::has_phsbc() const {
  return this != internal_default_instance() && phsbc_ != nullptr;
}
inline void DEL::clear_phsbc() {
  if (GetArenaNoVirtual() == nullptr && phsbc_ != nullptr) {
    delete phsbc_;
  }
  phsbc_ = nullptr;
}
inline const ::commonmodule::CMV& DEL::phsbc() const {
  const ::commonmodule::CMV* p = phsbc_;
  // @@protoc_insertion_point(field_get:commonmodule.DEL.phsBC)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* DEL::release_phsbc() {
  // @@protoc_insertion_point(field_release:commonmodule.DEL.phsBC)
  
  ::commonmodule::CMV* temp = phsbc_;
  phsbc_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* DEL::mutable_phsbc() {
  
  if (phsbc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    phsbc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.DEL.phsBC)
  return phsbc_;
}
inline void DEL::set_allocated_phsbc(::commonmodule::CMV* phsbc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsbc_;
  }
  if (phsbc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsbc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsbc, submessage_arena);
    }
    
  } else {
    
  }
  phsbc_ = phsbc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DEL.phsBC)
}

// .commonmodule.CMV phsCA = 3;
inline bool DEL::has_phsca() const {
  return this != internal_default_instance() && phsca_ != nullptr;
}
inline void DEL::clear_phsca() {
  if (GetArenaNoVirtual() == nullptr && phsca_ != nullptr) {
    delete phsca_;
  }
  phsca_ = nullptr;
}
inline const ::commonmodule::CMV& DEL::phsca() const {
  const ::commonmodule::CMV* p = phsca_;
  // @@protoc_insertion_point(field_get:commonmodule.DEL.phsCA)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* DEL::release_phsca() {
  // @@protoc_insertion_point(field_release:commonmodule.DEL.phsCA)
  
  ::commonmodule::CMV* temp = phsca_;
  phsca_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* DEL::mutable_phsca() {
  
  if (phsca_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    phsca_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.DEL.phsCA)
  return phsca_;
}
inline void DEL::set_allocated_phsca(::commonmodule::CMV* phsca) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsca_;
  }
  if (phsca) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsca = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsca, submessage_arena);
    }
    
  } else {
    
  }
  phsca_ = phsca;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DEL.phsCA)
}

// -------------------------------------------------------------------

// EnergyConsumer

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool EnergyConsumer::has_conductingequipment() const {
  return this != internal_default_instance() && conductingequipment_ != nullptr;
}
inline void EnergyConsumer::clear_conductingequipment() {
  if (GetArenaNoVirtual() == nullptr && conductingequipment_ != nullptr) {
    delete conductingequipment_;
  }
  conductingequipment_ = nullptr;
}
inline const ::commonmodule::ConductingEquipment& EnergyConsumer::conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = conductingequipment_;
  // @@protoc_insertion_point(field_get:commonmodule.EnergyConsumer.conductingEquipment)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipment*>(
      &::commonmodule::_ConductingEquipment_default_instance_);
}
inline ::commonmodule::ConductingEquipment* EnergyConsumer::release_conductingequipment() {
  // @@protoc_insertion_point(field_release:commonmodule.EnergyConsumer.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = conductingequipment_;
  conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* EnergyConsumer::mutable_conductingequipment() {
  
  if (conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaNoVirtual());
    conductingequipment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.EnergyConsumer.conductingEquipment)
  return conductingequipment_;
}
inline void EnergyConsumer::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete conductingequipment_;
  }
  if (conductingequipment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EnergyConsumer.conductingEquipment)
}

// .google.protobuf.StringValue operatingLimit = 2;
inline bool EnergyConsumer::has_operatinglimit() const {
  return this != internal_default_instance() && operatinglimit_ != nullptr;
}
inline const ::google::protobuf::StringValue& EnergyConsumer::operatinglimit() const {
  const ::google::protobuf::StringValue* p = operatinglimit_;
  // @@protoc_insertion_point(field_get:commonmodule.EnergyConsumer.operatingLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* EnergyConsumer::release_operatinglimit() {
  // @@protoc_insertion_point(field_release:commonmodule.EnergyConsumer.operatingLimit)
  
  ::google::protobuf::StringValue* temp = operatinglimit_;
  operatinglimit_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* EnergyConsumer::mutable_operatinglimit() {
  
  if (operatinglimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    operatinglimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.EnergyConsumer.operatingLimit)
  return operatinglimit_;
}
inline void EnergyConsumer::set_allocated_operatinglimit(::google::protobuf::StringValue* operatinglimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(operatinglimit_);
  }
  if (operatinglimit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(operatinglimit)->GetArena();
    if (message_arena != submessage_arena) {
      operatinglimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operatinglimit, submessage_arena);
    }
    
  } else {
    
  }
  operatinglimit_ = operatinglimit;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EnergyConsumer.operatingLimit)
}

// -------------------------------------------------------------------

// Optional_CalcMethodKind

// .commonmodule.CalcMethodKind value = 1;
inline void Optional_CalcMethodKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::CalcMethodKind Optional_CalcMethodKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_CalcMethodKind.value)
  return static_cast< ::commonmodule::CalcMethodKind >(value_);
}
inline void Optional_CalcMethodKind::set_value(::commonmodule::CalcMethodKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_CalcMethodKind.value)
}

// -------------------------------------------------------------------

// ENG_CalcMethodKind

// .commonmodule.CalcMethodKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_CalcMethodKind::clear_setval() {
  setval_ = 0;
}
inline ::commonmodule::CalcMethodKind ENG_CalcMethodKind::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_CalcMethodKind.setVal)
  return static_cast< ::commonmodule::CalcMethodKind >(setval_);
}
inline void ENG_CalcMethodKind::set_setval(::commonmodule::CalcMethodKind value) {
  
  setval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENG_CalcMethodKind.setVal)
}

// -------------------------------------------------------------------

// Optional_GridConnectModeKind

// .commonmodule.GridConnectModeKind value = 1;
inline void Optional_GridConnectModeKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::GridConnectModeKind Optional_GridConnectModeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_GridConnectModeKind.value)
  return static_cast< ::commonmodule::GridConnectModeKind >(value_);
}
inline void Optional_GridConnectModeKind::set_value(::commonmodule::GridConnectModeKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_GridConnectModeKind.value)
}

// -------------------------------------------------------------------

// ENG_GridConnectModeKind

// .commonmodule.GridConnectModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_GridConnectModeKind::clear_setval() {
  setval_ = 0;
}
inline ::commonmodule::GridConnectModeKind ENG_GridConnectModeKind::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_GridConnectModeKind.setVal)
  return static_cast< ::commonmodule::GridConnectModeKind >(setval_);
}
inline void ENG_GridConnectModeKind::set_setval(::commonmodule::GridConnectModeKind value) {
  
  setval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENG_GridConnectModeKind.setVal)
}

// .google.protobuf.StringValue setValExtension = 2;
inline bool ENG_GridConnectModeKind::has_setvalextension() const {
  return this != internal_default_instance() && setvalextension_ != nullptr;
}
inline const ::google::protobuf::StringValue& ENG_GridConnectModeKind::setvalextension() const {
  const ::google::protobuf::StringValue* p = setvalextension_;
  // @@protoc_insertion_point(field_get:commonmodule.ENG_GridConnectModeKind.setValExtension)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* ENG_GridConnectModeKind::release_setvalextension() {
  // @@protoc_insertion_point(field_release:commonmodule.ENG_GridConnectModeKind.setValExtension)
  
  ::google::protobuf::StringValue* temp = setvalextension_;
  setvalextension_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* ENG_GridConnectModeKind::mutable_setvalextension() {
  
  if (setvalextension_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    setvalextension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENG_GridConnectModeKind.setValExtension)
  return setvalextension_;
}
inline void ENG_GridConnectModeKind::set_allocated_setvalextension(::google::protobuf::StringValue* setvalextension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(setvalextension_);
  }
  if (setvalextension) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(setvalextension)->GetArena();
    if (message_arena != submessage_arena) {
      setvalextension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, setvalextension, submessage_arena);
    }
    
  } else {
    
  }
  setvalextension_ = setvalextension;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENG_GridConnectModeKind.setValExtension)
}

// -------------------------------------------------------------------

// Optional_PFSignKind

// .commonmodule.PFSignKind value = 1;
inline void Optional_PFSignKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::PFSignKind Optional_PFSignKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_PFSignKind.value)
  return static_cast< ::commonmodule::PFSignKind >(value_);
}
inline void Optional_PFSignKind::set_value(::commonmodule::PFSignKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_PFSignKind.value)
}

// -------------------------------------------------------------------

// ENG_PFSignKind

// .commonmodule.PFSignKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_PFSignKind::clear_setval() {
  setval_ = 0;
}
inline ::commonmodule::PFSignKind ENG_PFSignKind::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_PFSignKind.setVal)
  return static_cast< ::commonmodule::PFSignKind >(setval_);
}
inline void ENG_PFSignKind::set_setval(::commonmodule::PFSignKind value) {
  
  setval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENG_PFSignKind.setVal)
}

// -------------------------------------------------------------------

// Optional_BehaviourModeKind

// .commonmodule.BehaviourModeKind value = 1;
inline void Optional_BehaviourModeKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::BehaviourModeKind Optional_BehaviourModeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_BehaviourModeKind.value)
  return static_cast< ::commonmodule::BehaviourModeKind >(value_);
}
inline void Optional_BehaviourModeKind::set_value(::commonmodule::BehaviourModeKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_BehaviourModeKind.value)
}

// -------------------------------------------------------------------

// ENS_BehaviourModeKind

// .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ENS_BehaviourModeKind::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void ENS_BehaviourModeKind::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& ENS_BehaviourModeKind::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.ENS_BehaviourModeKind.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* ENS_BehaviourModeKind::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_BehaviourModeKind.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* ENS_BehaviourModeKind::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_BehaviourModeKind.q)
  return q_;
}
inline void ENS_BehaviourModeKind::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_BehaviourModeKind.q)
}

// .commonmodule.BehaviourModeKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_BehaviourModeKind::clear_stval() {
  stval_ = 0;
}
inline ::commonmodule::BehaviourModeKind ENS_BehaviourModeKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_BehaviourModeKind.stVal)
  return static_cast< ::commonmodule::BehaviourModeKind >(stval_);
}
inline void ENS_BehaviourModeKind::set_stval(::commonmodule::BehaviourModeKind value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENS_BehaviourModeKind.stVal)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ENS_BehaviourModeKind::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void ENS_BehaviourModeKind::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& ENS_BehaviourModeKind::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.ENS_BehaviourModeKind.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* ENS_BehaviourModeKind::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_BehaviourModeKind.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* ENS_BehaviourModeKind::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_BehaviourModeKind.t)
  return t_;
}
inline void ENS_BehaviourModeKind::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_BehaviourModeKind.t)
}

// -------------------------------------------------------------------

// Optional_DERGeneratorStateKind

// .commonmodule.DERGeneratorStateKind value = 1;
inline void Optional_DERGeneratorStateKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::DERGeneratorStateKind Optional_DERGeneratorStateKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_DERGeneratorStateKind.value)
  return static_cast< ::commonmodule::DERGeneratorStateKind >(value_);
}
inline void Optional_DERGeneratorStateKind::set_value(::commonmodule::DERGeneratorStateKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_DERGeneratorStateKind.value)
}

// -------------------------------------------------------------------

// ENS_DERGeneratorStateKind

// .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ENS_DERGeneratorStateKind::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void ENS_DERGeneratorStateKind::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& ENS_DERGeneratorStateKind::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DERGeneratorStateKind.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* ENS_DERGeneratorStateKind::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DERGeneratorStateKind.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* ENS_DERGeneratorStateKind::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DERGeneratorStateKind.q)
  return q_;
}
inline void ENS_DERGeneratorStateKind::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DERGeneratorStateKind.q)
}

// .commonmodule.DERGeneratorStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_DERGeneratorStateKind::clear_stval() {
  stval_ = 0;
}
inline ::commonmodule::DERGeneratorStateKind ENS_DERGeneratorStateKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DERGeneratorStateKind.stVal)
  return static_cast< ::commonmodule::DERGeneratorStateKind >(stval_);
}
inline void ENS_DERGeneratorStateKind::set_stval(::commonmodule::DERGeneratorStateKind value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENS_DERGeneratorStateKind.stVal)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ENS_DERGeneratorStateKind::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void ENS_DERGeneratorStateKind::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& ENS_DERGeneratorStateKind::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DERGeneratorStateKind.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* ENS_DERGeneratorStateKind::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DERGeneratorStateKind.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* ENS_DERGeneratorStateKind::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DERGeneratorStateKind.t)
  return t_;
}
inline void ENS_DERGeneratorStateKind::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DERGeneratorStateKind.t)
}

// -------------------------------------------------------------------

// Optional_DynamicTestKind

// .commonmodule.DynamicTestKind value = 1;
inline void Optional_DynamicTestKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::DynamicTestKind Optional_DynamicTestKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_DynamicTestKind.value)
  return static_cast< ::commonmodule::DynamicTestKind >(value_);
}
inline void Optional_DynamicTestKind::set_value(::commonmodule::DynamicTestKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_DynamicTestKind.value)
}

// -------------------------------------------------------------------

// ENS_DynamicTestKind

// .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ENS_DynamicTestKind::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void ENS_DynamicTestKind::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& ENS_DynamicTestKind::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DynamicTestKind.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* ENS_DynamicTestKind::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DynamicTestKind.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* ENS_DynamicTestKind::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DynamicTestKind.q)
  return q_;
}
inline void ENS_DynamicTestKind::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DynamicTestKind.q)
}

// .commonmodule.DynamicTestKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_DynamicTestKind::clear_stval() {
  stval_ = 0;
}
inline ::commonmodule::DynamicTestKind ENS_DynamicTestKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DynamicTestKind.stVal)
  return static_cast< ::commonmodule::DynamicTestKind >(stval_);
}
inline void ENS_DynamicTestKind::set_stval(::commonmodule::DynamicTestKind value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENS_DynamicTestKind.stVal)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ENS_DynamicTestKind::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void ENS_DynamicTestKind::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& ENS_DynamicTestKind::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DynamicTestKind.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* ENS_DynamicTestKind::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DynamicTestKind.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* ENS_DynamicTestKind::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DynamicTestKind.t)
  return t_;
}
inline void ENS_DynamicTestKind::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DynamicTestKind.t)
}

// -------------------------------------------------------------------

// ENS_GridConnectModeKind

// .commonmodule.GridConnectModeKind stVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_GridConnectModeKind::clear_stval() {
  stval_ = 0;
}
inline ::commonmodule::GridConnectModeKind ENS_GridConnectModeKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_GridConnectModeKind.stVal)
  return static_cast< ::commonmodule::GridConnectModeKind >(stval_);
}
inline void ENS_GridConnectModeKind::set_stval(::commonmodule::GridConnectModeKind value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENS_GridConnectModeKind.stVal)
}

// string stValExtension = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_GridConnectModeKind::clear_stvalextension() {
  stvalextension_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENS_GridConnectModeKind::stvalextension() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_GridConnectModeKind.stValExtension)
  return stvalextension_.GetNoArena();
}
inline void ENS_GridConnectModeKind::set_stvalextension(const ::std::string& value) {
  
  stvalextension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:commonmodule.ENS_GridConnectModeKind.stValExtension)
}
#if LANG_CXX11
inline void ENS_GridConnectModeKind::set_stvalextension(::std::string&& value) {
  
  stvalextension_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:commonmodule.ENS_GridConnectModeKind.stValExtension)
}
#endif
inline void ENS_GridConnectModeKind::set_stvalextension(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stvalextension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:commonmodule.ENS_GridConnectModeKind.stValExtension)
}
inline void ENS_GridConnectModeKind::set_stvalextension(const char* value, size_t size) {
  
  stvalextension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:commonmodule.ENS_GridConnectModeKind.stValExtension)
}
inline ::std::string* ENS_GridConnectModeKind::mutable_stvalextension() {
  
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_GridConnectModeKind.stValExtension)
  return stvalextension_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENS_GridConnectModeKind::release_stvalextension() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_GridConnectModeKind.stValExtension)
  
  return stvalextension_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENS_GridConnectModeKind::set_allocated_stvalextension(::std::string* stvalextension) {
  if (stvalextension != nullptr) {
    
  } else {
    
  }
  stvalextension_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stvalextension);
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_GridConnectModeKind.stValExtension)
}

// -------------------------------------------------------------------

// Optional_HealthKind

// .commonmodule.HealthKind value = 1;
inline void Optional_HealthKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::HealthKind Optional_HealthKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_HealthKind.value)
  return static_cast< ::commonmodule::HealthKind >(value_);
}
inline void Optional_HealthKind::set_value(::commonmodule::HealthKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_HealthKind.value)
}

// -------------------------------------------------------------------

// ENS_HealthKind

// .google.protobuf.StringValue d = 1;
inline bool ENS_HealthKind::has_d() const {
  return this != internal_default_instance() && d_ != nullptr;
}
inline const ::google::protobuf::StringValue& ENS_HealthKind::d() const {
  const ::google::protobuf::StringValue* p = d_;
  // @@protoc_insertion_point(field_get:commonmodule.ENS_HealthKind.d)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* ENS_HealthKind::release_d() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_HealthKind.d)
  
  ::google::protobuf::StringValue* temp = d_;
  d_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* ENS_HealthKind::mutable_d() {
  
  if (d_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    d_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_HealthKind.d)
  return d_;
}
inline void ENS_HealthKind::set_allocated_d(::google::protobuf::StringValue* d) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(d_);
  }
  if (d) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(d)->GetArena();
    if (message_arena != submessage_arena) {
      d = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, d, submessage_arena);
    }
    
  } else {
    
  }
  d_ = d;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_HealthKind.d)
}

// .commonmodule.HealthKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_HealthKind::clear_stval() {
  stval_ = 0;
}
inline ::commonmodule::HealthKind ENS_HealthKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_HealthKind.stVal)
  return static_cast< ::commonmodule::HealthKind >(stval_);
}
inline void ENS_HealthKind::set_stval(::commonmodule::HealthKind value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ENS_HealthKind.stVal)
}

// -------------------------------------------------------------------

// ESS

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool ESS::has_conductingequipment() const {
  return this != internal_default_instance() && conductingequipment_ != nullptr;
}
inline void ESS::clear_conductingequipment() {
  if (GetArenaNoVirtual() == nullptr && conductingequipment_ != nullptr) {
    delete conductingequipment_;
  }
  conductingequipment_ = nullptr;
}
inline const ::commonmodule::ConductingEquipment& ESS::conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = conductingequipment_;
  // @@protoc_insertion_point(field_get:commonmodule.ESS.conductingEquipment)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipment*>(
      &::commonmodule::_ConductingEquipment_default_instance_);
}
inline ::commonmodule::ConductingEquipment* ESS::release_conductingequipment() {
  // @@protoc_insertion_point(field_release:commonmodule.ESS.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = conductingequipment_;
  conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* ESS::mutable_conductingequipment() {
  
  if (conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaNoVirtual());
    conductingequipment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ESS.conductingEquipment)
  return conductingequipment_;
}
inline void ESS::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete conductingequipment_;
  }
  if (conductingequipment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ESS.conductingEquipment)
}

// -------------------------------------------------------------------

// EventMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EventMessageInfo::has_messageinfo() const {
  return this != internal_default_instance() && messageinfo_ != nullptr;
}
inline void EventMessageInfo::clear_messageinfo() {
  if (GetArenaNoVirtual() == nullptr && messageinfo_ != nullptr) {
    delete messageinfo_;
  }
  messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& EventMessageInfo::messageinfo() const {
  const ::commonmodule::MessageInfo* p = messageinfo_;
  // @@protoc_insertion_point(field_get:commonmodule.EventMessageInfo.messageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MessageInfo*>(
      &::commonmodule::_MessageInfo_default_instance_);
}
inline ::commonmodule::MessageInfo* EventMessageInfo::release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.EventMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = messageinfo_;
  messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* EventMessageInfo::mutable_messageinfo() {
  
  if (messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaNoVirtual());
    messageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.EventMessageInfo.messageInfo)
  return messageinfo_;
}
inline void EventMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete messageinfo_;
  }
  if (messageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      messageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }
    
  } else {
    
  }
  messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EventMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// EventValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool EventValue::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void EventValue::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& EventValue::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.EventValue.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* EventValue::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.EventValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* EventValue::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.EventValue.identifiedObject)
  return identifiedobject_;
}
inline void EventValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EventValue.identifiedObject)
}

// -------------------------------------------------------------------

// ForecastValueSource

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ForecastValueSource::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void ForecastValueSource::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ForecastValueSource::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.ForecastValueSource.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* ForecastValueSource::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastValueSource.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ForecastValueSource::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastValueSource.identifiedObject)
  return identifiedobject_;
}
inline void ForecastValueSource::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastValueSource.identifiedObject)
}

// -------------------------------------------------------------------

// ForecastIED

// .commonmodule.ForecastValueSource forecastValueSource = 1 [(.uml.option_parent_message) = true];
inline bool ForecastIED::has_forecastvaluesource() const {
  return this != internal_default_instance() && forecastvaluesource_ != nullptr;
}
inline void ForecastIED::clear_forecastvaluesource() {
  if (GetArenaNoVirtual() == nullptr && forecastvaluesource_ != nullptr) {
    delete forecastvaluesource_;
  }
  forecastvaluesource_ = nullptr;
}
inline const ::commonmodule::ForecastValueSource& ForecastIED::forecastvaluesource() const {
  const ::commonmodule::ForecastValueSource* p = forecastvaluesource_;
  // @@protoc_insertion_point(field_get:commonmodule.ForecastIED.forecastValueSource)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ForecastValueSource*>(
      &::commonmodule::_ForecastValueSource_default_instance_);
}
inline ::commonmodule::ForecastValueSource* ForecastIED::release_forecastvaluesource() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastIED.forecastValueSource)
  
  ::commonmodule::ForecastValueSource* temp = forecastvaluesource_;
  forecastvaluesource_ = nullptr;
  return temp;
}
inline ::commonmodule::ForecastValueSource* ForecastIED::mutable_forecastvaluesource() {
  
  if (forecastvaluesource_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ForecastValueSource>(GetArenaNoVirtual());
    forecastvaluesource_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastIED.forecastValueSource)
  return forecastvaluesource_;
}
inline void ForecastIED::set_allocated_forecastvaluesource(::commonmodule::ForecastValueSource* forecastvaluesource) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete forecastvaluesource_;
  }
  if (forecastvaluesource) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      forecastvaluesource = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, forecastvaluesource, submessage_arena);
    }
    
  } else {
    
  }
  forecastvaluesource_ = forecastvaluesource;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastIED.forecastValueSource)
}

// string sourceApplicationID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ForecastIED::clear_sourceapplicationid() {
  sourceapplicationid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ForecastIED::sourceapplicationid() const {
  // @@protoc_insertion_point(field_get:commonmodule.ForecastIED.sourceApplicationID)
  return sourceapplicationid_.GetNoArena();
}
inline void ForecastIED::set_sourceapplicationid(const ::std::string& value) {
  
  sourceapplicationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:commonmodule.ForecastIED.sourceApplicationID)
}
#if LANG_CXX11
inline void ForecastIED::set_sourceapplicationid(::std::string&& value) {
  
  sourceapplicationid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:commonmodule.ForecastIED.sourceApplicationID)
}
#endif
inline void ForecastIED::set_sourceapplicationid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sourceapplicationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:commonmodule.ForecastIED.sourceApplicationID)
}
inline void ForecastIED::set_sourceapplicationid(const char* value, size_t size) {
  
  sourceapplicationid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:commonmodule.ForecastIED.sourceApplicationID)
}
inline ::std::string* ForecastIED::mutable_sourceapplicationid() {
  
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastIED.sourceApplicationID)
  return sourceapplicationid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ForecastIED::release_sourceapplicationid() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastIED.sourceApplicationID)
  
  return sourceapplicationid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ForecastIED::set_allocated_sourceapplicationid(::std::string* sourceapplicationid) {
  if (sourceapplicationid != nullptr) {
    
  } else {
    
  }
  sourceapplicationid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourceapplicationid);
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastIED.sourceApplicationID)
}

// int64 sourceDateTime = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ForecastIED::clear_sourcedatetime() {
  sourcedatetime_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ForecastIED::sourcedatetime() const {
  // @@protoc_insertion_point(field_get:commonmodule.ForecastIED.sourceDateTime)
  return sourcedatetime_;
}
inline void ForecastIED::set_sourcedatetime(::google::protobuf::int64 value) {
  
  sourcedatetime_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.ForecastIED.sourceDateTime)
}

// -------------------------------------------------------------------

// ForecastValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ForecastValue::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void ForecastValue::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ForecastValue::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.ForecastValue.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* ForecastValue::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ForecastValue::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastValue.identifiedObject)
  return identifiedobject_;
}
inline void ForecastValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastValue.identifiedObject)
}

// -------------------------------------------------------------------

// IED

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool IED::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void IED::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& IED::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.IED.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* IED::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.IED.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* IED::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.IED.identifiedObject)
  return identifiedobject_;
}
inline void IED::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IED.identifiedObject)
}

// -------------------------------------------------------------------

// StatusINS

// .commonmodule.Quality q = 1;
inline bool StatusINS::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void StatusINS::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusINS::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusINS.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* StatusINS::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusINS.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusINS::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusINS.q)
  return q_;
}
inline void StatusINS::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusINS.q)
}

// int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusINS::clear_stval() {
  stval_ = 0;
}
inline ::google::protobuf::int32 StatusINS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusINS.stVal)
  return stval_;
}
inline void StatusINS::set_stval(::google::protobuf::int32 value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.StatusINS.stVal)
}

// .commonmodule.Timestamp t = 3;
inline bool StatusINS::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void StatusINS::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusINS::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusINS.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* StatusINS::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusINS.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusINS::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusINS.t)
  return t_;
}
inline void StatusINS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusINS.t)
}

// .commonmodule.Unit units = 4;
inline bool StatusINS::has_units() const {
  return this != internal_default_instance() && units_ != nullptr;
}
inline void StatusINS::clear_units() {
  if (GetArenaNoVirtual() == nullptr && units_ != nullptr) {
    delete units_;
  }
  units_ = nullptr;
}
inline const ::commonmodule::Unit& StatusINS::units() const {
  const ::commonmodule::Unit* p = units_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusINS.units)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Unit*>(
      &::commonmodule::_Unit_default_instance_);
}
inline ::commonmodule::Unit* StatusINS::release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusINS.units)
  
  ::commonmodule::Unit* temp = units_;
  units_ = nullptr;
  return temp;
}
inline ::commonmodule::Unit* StatusINS::mutable_units() {
  
  if (units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Unit>(GetArenaNoVirtual());
    units_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusINS.units)
  return units_;
}
inline void StatusINS::set_allocated_units(::commonmodule::Unit* units) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete units_;
  }
  if (units) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      units = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }
    
  } else {
    
  }
  units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusINS.units)
}

// -------------------------------------------------------------------

// IntegerStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool IntegerStatusGGIO::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void IntegerStatusGGIO::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& IntegerStatusGGIO::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.IntegerStatusGGIO.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* IntegerStatusGGIO::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.IntegerStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* IntegerStatusGGIO::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.IntegerStatusGGIO.logicalNode)
  return logicalnode_;
}
inline void IntegerStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IntegerStatusGGIO.logicalNode)
}

// .commonmodule.StatusINS IntIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool IntegerStatusGGIO::has_intin() const {
  return this != internal_default_instance() && intin_ != nullptr;
}
inline void IntegerStatusGGIO::clear_intin() {
  if (GetArenaNoVirtual() == nullptr && intin_ != nullptr) {
    delete intin_;
  }
  intin_ = nullptr;
}
inline const ::commonmodule::StatusINS& IntegerStatusGGIO::intin() const {
  const ::commonmodule::StatusINS* p = intin_;
  // @@protoc_insertion_point(field_get:commonmodule.IntegerStatusGGIO.IntIn)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusINS*>(
      &::commonmodule::_StatusINS_default_instance_);
}
inline ::commonmodule::StatusINS* IntegerStatusGGIO::release_intin() {
  // @@protoc_insertion_point(field_release:commonmodule.IntegerStatusGGIO.IntIn)
  
  ::commonmodule::StatusINS* temp = intin_;
  intin_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINS* IntegerStatusGGIO::mutable_intin() {
  
  if (intin_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINS>(GetArenaNoVirtual());
    intin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.IntegerStatusGGIO.IntIn)
  return intin_;
}
inline void IntegerStatusGGIO::set_allocated_intin(::commonmodule::StatusINS* intin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete intin_;
  }
  if (intin) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      intin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intin, submessage_arena);
    }
    
  } else {
    
  }
  intin_ = intin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IntegerStatusGGIO.IntIn)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 3;
inline bool IntegerStatusGGIO::has_phase() const {
  return this != internal_default_instance() && phase_ != nullptr;
}
inline void IntegerStatusGGIO::clear_phase() {
  if (GetArenaNoVirtual() == nullptr && phase_ != nullptr) {
    delete phase_;
  }
  phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& IntegerStatusGGIO::phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = phase_;
  // @@protoc_insertion_point(field_get:commonmodule.IntegerStatusGGIO.Phase)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind*>(
      &::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline ::commonmodule::Optional_PhaseCodeKind* IntegerStatusGGIO::release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.IntegerStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = phase_;
  phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* IntegerStatusGGIO::mutable_phase() {
  
  if (phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaNoVirtual());
    phase_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.IntegerStatusGGIO.Phase)
  return phase_;
}
inline void IntegerStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phase_;
  }
  if (phase) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phase = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }
    
  } else {
    
  }
  phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IntegerStatusGGIO.Phase)
}

// -------------------------------------------------------------------

// LogicalNodeForEventAndStatus

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool LogicalNodeForEventAndStatus::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void LogicalNodeForEventAndStatus::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& LogicalNodeForEventAndStatus::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* LogicalNodeForEventAndStatus::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* LogicalNodeForEventAndStatus::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
  return logicalnode_;
}
inline void LogicalNodeForEventAndStatus::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
}

// .commonmodule.ENS_BehaviourModeKind Beh = 2;
inline bool LogicalNodeForEventAndStatus::has_beh() const {
  return this != internal_default_instance() && beh_ != nullptr;
}
inline void LogicalNodeForEventAndStatus::clear_beh() {
  if (GetArenaNoVirtual() == nullptr && beh_ != nullptr) {
    delete beh_;
  }
  beh_ = nullptr;
}
inline const ::commonmodule::ENS_BehaviourModeKind& LogicalNodeForEventAndStatus::beh() const {
  const ::commonmodule::ENS_BehaviourModeKind* p = beh_;
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.Beh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_BehaviourModeKind*>(
      &::commonmodule::_ENS_BehaviourModeKind_default_instance_);
}
inline ::commonmodule::ENS_BehaviourModeKind* LogicalNodeForEventAndStatus::release_beh() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.Beh)
  
  ::commonmodule::ENS_BehaviourModeKind* temp = beh_;
  beh_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_BehaviourModeKind* LogicalNodeForEventAndStatus::mutable_beh() {
  
  if (beh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_BehaviourModeKind>(GetArenaNoVirtual());
    beh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.Beh)
  return beh_;
}
inline void LogicalNodeForEventAndStatus::set_allocated_beh(::commonmodule::ENS_BehaviourModeKind* beh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete beh_;
  }
  if (beh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      beh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, beh, submessage_arena);
    }
    
  } else {
    
  }
  beh_ = beh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.Beh)
}

// .commonmodule.ENS_HealthKind EEHealth = 3;
inline bool LogicalNodeForEventAndStatus::has_eehealth() const {
  return this != internal_default_instance() && eehealth_ != nullptr;
}
inline void LogicalNodeForEventAndStatus::clear_eehealth() {
  if (GetArenaNoVirtual() == nullptr && eehealth_ != nullptr) {
    delete eehealth_;
  }
  eehealth_ = nullptr;
}
inline const ::commonmodule::ENS_HealthKind& LogicalNodeForEventAndStatus::eehealth() const {
  const ::commonmodule::ENS_HealthKind* p = eehealth_;
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_HealthKind*>(
      &::commonmodule::_ENS_HealthKind_default_instance_);
}
inline ::commonmodule::ENS_HealthKind* LogicalNodeForEventAndStatus::release_eehealth() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
  
  ::commonmodule::ENS_HealthKind* temp = eehealth_;
  eehealth_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_HealthKind* LogicalNodeForEventAndStatus::mutable_eehealth() {
  
  if (eehealth_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_HealthKind>(GetArenaNoVirtual());
    eehealth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
  return eehealth_;
}
inline void LogicalNodeForEventAndStatus::set_allocated_eehealth(::commonmodule::ENS_HealthKind* eehealth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete eehealth_;
  }
  if (eehealth) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eehealth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eehealth, submessage_arena);
    }
    
  } else {
    
  }
  eehealth_ = eehealth;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
}

// -------------------------------------------------------------------

// MeasurementValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool MeasurementValue::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void MeasurementValue::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& MeasurementValue::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.MeasurementValue.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* MeasurementValue::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.MeasurementValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* MeasurementValue::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.MeasurementValue.identifiedObject)
  return identifiedobject_;
}
inline void MeasurementValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MeasurementValue.identifiedObject)
}

// -------------------------------------------------------------------

// Meter

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool Meter::has_conductingequipment() const {
  return this != internal_default_instance() && conductingequipment_ != nullptr;
}
inline void Meter::clear_conductingequipment() {
  if (GetArenaNoVirtual() == nullptr && conductingequipment_ != nullptr) {
    delete conductingequipment_;
  }
  conductingequipment_ = nullptr;
}
inline const ::commonmodule::ConductingEquipment& Meter::conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = conductingequipment_;
  // @@protoc_insertion_point(field_get:commonmodule.Meter.conductingEquipment)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipment*>(
      &::commonmodule::_ConductingEquipment_default_instance_);
}
inline ::commonmodule::ConductingEquipment* Meter::release_conductingequipment() {
  // @@protoc_insertion_point(field_release:commonmodule.Meter.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = conductingequipment_;
  conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* Meter::mutable_conductingequipment() {
  
  if (conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaNoVirtual());
    conductingequipment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.Meter.conductingEquipment)
  return conductingequipment_;
}
inline void Meter::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete conductingequipment_;
  }
  if (conductingequipment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Meter.conductingEquipment)
}

// -------------------------------------------------------------------

// OptimizationMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool OptimizationMessageInfo::has_messageinfo() const {
  return this != internal_default_instance() && messageinfo_ != nullptr;
}
inline void OptimizationMessageInfo::clear_messageinfo() {
  if (GetArenaNoVirtual() == nullptr && messageinfo_ != nullptr) {
    delete messageinfo_;
  }
  messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& OptimizationMessageInfo::messageinfo() const {
  const ::commonmodule::MessageInfo* p = messageinfo_;
  // @@protoc_insertion_point(field_get:commonmodule.OptimizationMessageInfo.messageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MessageInfo*>(
      &::commonmodule::_MessageInfo_default_instance_);
}
inline ::commonmodule::MessageInfo* OptimizationMessageInfo::release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.OptimizationMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = messageinfo_;
  messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* OptimizationMessageInfo::mutable_messageinfo() {
  
  if (messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaNoVirtual());
    messageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.OptimizationMessageInfo.messageInfo)
  return messageinfo_;
}
inline void OptimizationMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete messageinfo_;
  }
  if (messageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      messageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }
    
  } else {
    
  }
  messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OptimizationMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// ReadingMMTN

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMMTN::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void ReadingMMTN::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& ReadingMMTN::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* ReadingMMTN::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMTN::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.logicalNode)
  return logicalnode_;
}
inline void ReadingMMTN::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.logicalNode)
}

// .commonmodule.BCR DmdVAh = 2;
inline bool ReadingMMTN::has_dmdvah() const {
  return this != internal_default_instance() && dmdvah_ != nullptr;
}
inline void ReadingMMTN::clear_dmdvah() {
  if (GetArenaNoVirtual() == nullptr && dmdvah_ != nullptr) {
    delete dmdvah_;
  }
  dmdvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::dmdvah() const {
  const ::commonmodule::BCR* p = dmdvah_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.DmdVAh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_dmdvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.DmdVAh)
  
  ::commonmodule::BCR* temp = dmdvah_;
  dmdvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_dmdvah() {
  
  if (dmdvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    dmdvah_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.DmdVAh)
  return dmdvah_;
}
inline void ReadingMMTN::set_allocated_dmdvah(::commonmodule::BCR* dmdvah) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dmdvah_;
  }
  if (dmdvah) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dmdvah = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dmdvah, submessage_arena);
    }
    
  } else {
    
  }
  dmdvah_ = dmdvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.DmdVAh)
}

// .commonmodule.BCR DmdVArh = 3;
inline bool ReadingMMTN::has_dmdvarh() const {
  return this != internal_default_instance() && dmdvarh_ != nullptr;
}
inline void ReadingMMTN::clear_dmdvarh() {
  if (GetArenaNoVirtual() == nullptr && dmdvarh_ != nullptr) {
    delete dmdvarh_;
  }
  dmdvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::dmdvarh() const {
  const ::commonmodule::BCR* p = dmdvarh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.DmdVArh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_dmdvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.DmdVArh)
  
  ::commonmodule::BCR* temp = dmdvarh_;
  dmdvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_dmdvarh() {
  
  if (dmdvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    dmdvarh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.DmdVArh)
  return dmdvarh_;
}
inline void ReadingMMTN::set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dmdvarh_;
  }
  if (dmdvarh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dmdvarh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dmdvarh, submessage_arena);
    }
    
  } else {
    
  }
  dmdvarh_ = dmdvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.DmdVArh)
}

// .commonmodule.BCR DmdWh = 4;
inline bool ReadingMMTN::has_dmdwh() const {
  return this != internal_default_instance() && dmdwh_ != nullptr;
}
inline void ReadingMMTN::clear_dmdwh() {
  if (GetArenaNoVirtual() == nullptr && dmdwh_ != nullptr) {
    delete dmdwh_;
  }
  dmdwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::dmdwh() const {
  const ::commonmodule::BCR* p = dmdwh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.DmdWh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_dmdwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.DmdWh)
  
  ::commonmodule::BCR* temp = dmdwh_;
  dmdwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_dmdwh() {
  
  if (dmdwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    dmdwh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.DmdWh)
  return dmdwh_;
}
inline void ReadingMMTN::set_allocated_dmdwh(::commonmodule::BCR* dmdwh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dmdwh_;
  }
  if (dmdwh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dmdwh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dmdwh, submessage_arena);
    }
    
  } else {
    
  }
  dmdwh_ = dmdwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.DmdWh)
}

// .commonmodule.BCR SupVAh = 5;
inline bool ReadingMMTN::has_supvah() const {
  return this != internal_default_instance() && supvah_ != nullptr;
}
inline void ReadingMMTN::clear_supvah() {
  if (GetArenaNoVirtual() == nullptr && supvah_ != nullptr) {
    delete supvah_;
  }
  supvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::supvah() const {
  const ::commonmodule::BCR* p = supvah_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.SupVAh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_supvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.SupVAh)
  
  ::commonmodule::BCR* temp = supvah_;
  supvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_supvah() {
  
  if (supvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    supvah_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.SupVAh)
  return supvah_;
}
inline void ReadingMMTN::set_allocated_supvah(::commonmodule::BCR* supvah) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete supvah_;
  }
  if (supvah) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      supvah = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supvah, submessage_arena);
    }
    
  } else {
    
  }
  supvah_ = supvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.SupVAh)
}

// .commonmodule.BCR SupVArh = 6;
inline bool ReadingMMTN::has_supvarh() const {
  return this != internal_default_instance() && supvarh_ != nullptr;
}
inline void ReadingMMTN::clear_supvarh() {
  if (GetArenaNoVirtual() == nullptr && supvarh_ != nullptr) {
    delete supvarh_;
  }
  supvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::supvarh() const {
  const ::commonmodule::BCR* p = supvarh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.SupVArh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_supvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.SupVArh)
  
  ::commonmodule::BCR* temp = supvarh_;
  supvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_supvarh() {
  
  if (supvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    supvarh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.SupVArh)
  return supvarh_;
}
inline void ReadingMMTN::set_allocated_supvarh(::commonmodule::BCR* supvarh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete supvarh_;
  }
  if (supvarh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      supvarh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supvarh, submessage_arena);
    }
    
  } else {
    
  }
  supvarh_ = supvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.SupVArh)
}

// .commonmodule.BCR SupWh = 7;
inline bool ReadingMMTN::has_supwh() const {
  return this != internal_default_instance() && supwh_ != nullptr;
}
inline void ReadingMMTN::clear_supwh() {
  if (GetArenaNoVirtual() == nullptr && supwh_ != nullptr) {
    delete supwh_;
  }
  supwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::supwh() const {
  const ::commonmodule::BCR* p = supwh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.SupWh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_supwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.SupWh)
  
  ::commonmodule::BCR* temp = supwh_;
  supwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_supwh() {
  
  if (supwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    supwh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.SupWh)
  return supwh_;
}
inline void ReadingMMTN::set_allocated_supwh(::commonmodule::BCR* supwh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete supwh_;
  }
  if (supwh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      supwh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supwh, submessage_arena);
    }
    
  } else {
    
  }
  supwh_ = supwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.SupWh)
}

// .commonmodule.BCR TotVAh = 8;
inline bool ReadingMMTN::has_totvah() const {
  return this != internal_default_instance() && totvah_ != nullptr;
}
inline void ReadingMMTN::clear_totvah() {
  if (GetArenaNoVirtual() == nullptr && totvah_ != nullptr) {
    delete totvah_;
  }
  totvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::totvah() const {
  const ::commonmodule::BCR* p = totvah_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.TotVAh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_totvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.TotVAh)
  
  ::commonmodule::BCR* temp = totvah_;
  totvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_totvah() {
  
  if (totvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    totvah_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.TotVAh)
  return totvah_;
}
inline void ReadingMMTN::set_allocated_totvah(::commonmodule::BCR* totvah) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete totvah_;
  }
  if (totvah) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      totvah = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totvah, submessage_arena);
    }
    
  } else {
    
  }
  totvah_ = totvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.TotVAh)
}

// .commonmodule.BCR TotVArh = 9;
inline bool ReadingMMTN::has_totvarh() const {
  return this != internal_default_instance() && totvarh_ != nullptr;
}
inline void ReadingMMTN::clear_totvarh() {
  if (GetArenaNoVirtual() == nullptr && totvarh_ != nullptr) {
    delete totvarh_;
  }
  totvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::totvarh() const {
  const ::commonmodule::BCR* p = totvarh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.TotVArh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_totvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.TotVArh)
  
  ::commonmodule::BCR* temp = totvarh_;
  totvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_totvarh() {
  
  if (totvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    totvarh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.TotVArh)
  return totvarh_;
}
inline void ReadingMMTN::set_allocated_totvarh(::commonmodule::BCR* totvarh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete totvarh_;
  }
  if (totvarh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      totvarh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totvarh, submessage_arena);
    }
    
  } else {
    
  }
  totvarh_ = totvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.TotVArh)
}

// .commonmodule.BCR TotWh = 10;
inline bool ReadingMMTN::has_totwh() const {
  return this != internal_default_instance() && totwh_ != nullptr;
}
inline void ReadingMMTN::clear_totwh() {
  if (GetArenaNoVirtual() == nullptr && totwh_ != nullptr) {
    delete totwh_;
  }
  totwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::totwh() const {
  const ::commonmodule::BCR* p = totwh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.TotWh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTN::release_totwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.TotWh)
  
  ::commonmodule::BCR* temp = totwh_;
  totwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_totwh() {
  
  if (totwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    totwh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.TotWh)
  return totwh_;
}
inline void ReadingMMTN::set_allocated_totwh(::commonmodule::BCR* totwh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete totwh_;
  }
  if (totwh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      totwh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totwh, submessage_arena);
    }
    
  } else {
    
  }
  totwh_ = totwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.TotWh)
}

// -------------------------------------------------------------------

// PhaseMMTN

// .commonmodule.ReadingMMTN phsA = 1;
inline bool PhaseMMTN::has_phsa() const {
  return this != internal_default_instance() && phsa_ != nullptr;
}
inline void PhaseMMTN::clear_phsa() {
  if (GetArenaNoVirtual() == nullptr && phsa_ != nullptr) {
    delete phsa_;
  }
  phsa_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsa() const {
  const ::commonmodule::ReadingMMTN* p = phsa_;
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsA)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTN*>(
      &::commonmodule::_ReadingMMTN_default_instance_);
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsA)
  
  ::commonmodule::ReadingMMTN* temp = phsa_;
  phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsa() {
  
  if (phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaNoVirtual());
    phsa_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsA)
  return phsa_;
}
inline void PhaseMMTN::set_allocated_phsa(::commonmodule::ReadingMMTN* phsa) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsa_;
  }
  if (phsa) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsa = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }
    
  } else {
    
  }
  phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsA)
}

// .commonmodule.ReadingMMTN phsAB = 2;
inline bool PhaseMMTN::has_phsab() const {
  return this != internal_default_instance() && phsab_ != nullptr;
}
inline void PhaseMMTN::clear_phsab() {
  if (GetArenaNoVirtual() == nullptr && phsab_ != nullptr) {
    delete phsab_;
  }
  phsab_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsab() const {
  const ::commonmodule::ReadingMMTN* p = phsab_;
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsAB)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTN*>(
      &::commonmodule::_ReadingMMTN_default_instance_);
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsab() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsAB)
  
  ::commonmodule::ReadingMMTN* temp = phsab_;
  phsab_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsab() {
  
  if (phsab_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaNoVirtual());
    phsab_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsAB)
  return phsab_;
}
inline void PhaseMMTN::set_allocated_phsab(::commonmodule::ReadingMMTN* phsab) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsab_;
  }
  if (phsab) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsab = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsab, submessage_arena);
    }
    
  } else {
    
  }
  phsab_ = phsab;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsAB)
}

// .commonmodule.ReadingMMTN phsB = 3;
inline bool PhaseMMTN::has_phsb() const {
  return this != internal_default_instance() && phsb_ != nullptr;
}
inline void PhaseMMTN::clear_phsb() {
  if (GetArenaNoVirtual() == nullptr && phsb_ != nullptr) {
    delete phsb_;
  }
  phsb_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsb() const {
  const ::commonmodule::ReadingMMTN* p = phsb_;
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsB)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTN*>(
      &::commonmodule::_ReadingMMTN_default_instance_);
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsB)
  
  ::commonmodule::ReadingMMTN* temp = phsb_;
  phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsb() {
  
  if (phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaNoVirtual());
    phsb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsB)
  return phsb_;
}
inline void PhaseMMTN::set_allocated_phsb(::commonmodule::ReadingMMTN* phsb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsb_;
  }
  if (phsb) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }
    
  } else {
    
  }
  phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsB)
}

// .commonmodule.ReadingMMTN phsBC = 4;
inline bool PhaseMMTN::has_phsbc() const {
  return this != internal_default_instance() && phsbc_ != nullptr;
}
inline void PhaseMMTN::clear_phsbc() {
  if (GetArenaNoVirtual() == nullptr && phsbc_ != nullptr) {
    delete phsbc_;
  }
  phsbc_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsbc() const {
  const ::commonmodule::ReadingMMTN* p = phsbc_;
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsBC)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTN*>(
      &::commonmodule::_ReadingMMTN_default_instance_);
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsbc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsBC)
  
  ::commonmodule::ReadingMMTN* temp = phsbc_;
  phsbc_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsbc() {
  
  if (phsbc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaNoVirtual());
    phsbc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsBC)
  return phsbc_;
}
inline void PhaseMMTN::set_allocated_phsbc(::commonmodule::ReadingMMTN* phsbc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsbc_;
  }
  if (phsbc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsbc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsbc, submessage_arena);
    }
    
  } else {
    
  }
  phsbc_ = phsbc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsBC)
}

// .commonmodule.ReadingMMTN phsC = 5;
inline bool PhaseMMTN::has_phsc() const {
  return this != internal_default_instance() && phsc_ != nullptr;
}
inline void PhaseMMTN::clear_phsc() {
  if (GetArenaNoVirtual() == nullptr && phsc_ != nullptr) {
    delete phsc_;
  }
  phsc_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsc() const {
  const ::commonmodule::ReadingMMTN* p = phsc_;
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsC)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTN*>(
      &::commonmodule::_ReadingMMTN_default_instance_);
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsC)
  
  ::commonmodule::ReadingMMTN* temp = phsc_;
  phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsc() {
  
  if (phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaNoVirtual());
    phsc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsC)
  return phsc_;
}
inline void PhaseMMTN::set_allocated_phsc(::commonmodule::ReadingMMTN* phsc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsc_;
  }
  if (phsc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }
    
  } else {
    
  }
  phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsC)
}

// .commonmodule.ReadingMMTN phsCA = 6;
inline bool PhaseMMTN::has_phsca() const {
  return this != internal_default_instance() && phsca_ != nullptr;
}
inline void PhaseMMTN::clear_phsca() {
  if (GetArenaNoVirtual() == nullptr && phsca_ != nullptr) {
    delete phsca_;
  }
  phsca_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsca() const {
  const ::commonmodule::ReadingMMTN* p = phsca_;
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsCA)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTN*>(
      &::commonmodule::_ReadingMMTN_default_instance_);
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsca() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsCA)
  
  ::commonmodule::ReadingMMTN* temp = phsca_;
  phsca_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsca() {
  
  if (phsca_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaNoVirtual());
    phsca_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsCA)
  return phsca_;
}
inline void PhaseMMTN::set_allocated_phsca(::commonmodule::ReadingMMTN* phsca) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsca_;
  }
  if (phsca) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsca = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsca, submessage_arena);
    }
    
  } else {
    
  }
  phsca_ = phsca;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsCA)
}

// -------------------------------------------------------------------

// RampRate

// .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;
inline bool RampRate::has_negativereactivepowerkvarpermin() const {
  return this != internal_default_instance() && negativereactivepowerkvarpermin_ != nullptr;
}
inline const ::google::protobuf::FloatValue& RampRate::negativereactivepowerkvarpermin() const {
  const ::google::protobuf::FloatValue* p = negativereactivepowerkvarpermin_;
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* RampRate::release_negativereactivepowerkvarpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
  
  ::google::protobuf::FloatValue* temp = negativereactivepowerkvarpermin_;
  negativereactivepowerkvarpermin_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* RampRate::mutable_negativereactivepowerkvarpermin() {
  
  if (negativereactivepowerkvarpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    negativereactivepowerkvarpermin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
  return negativereactivepowerkvarpermin_;
}
inline void RampRate::set_allocated_negativereactivepowerkvarpermin(::google::protobuf::FloatValue* negativereactivepowerkvarpermin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(negativereactivepowerkvarpermin_);
  }
  if (negativereactivepowerkvarpermin) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(negativereactivepowerkvarpermin)->GetArena();
    if (message_arena != submessage_arena) {
      negativereactivepowerkvarpermin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, negativereactivepowerkvarpermin, submessage_arena);
    }
    
  } else {
    
  }
  negativereactivepowerkvarpermin_ = negativereactivepowerkvarpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
}

// .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;
inline bool RampRate::has_negativerealpowerkwpermin() const {
  return this != internal_default_instance() && negativerealpowerkwpermin_ != nullptr;
}
inline const ::google::protobuf::FloatValue& RampRate::negativerealpowerkwpermin() const {
  const ::google::protobuf::FloatValue* p = negativerealpowerkwpermin_;
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.negativeRealPowerKWPerMin)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* RampRate::release_negativerealpowerkwpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.negativeRealPowerKWPerMin)
  
  ::google::protobuf::FloatValue* temp = negativerealpowerkwpermin_;
  negativerealpowerkwpermin_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* RampRate::mutable_negativerealpowerkwpermin() {
  
  if (negativerealpowerkwpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    negativerealpowerkwpermin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.negativeRealPowerKWPerMin)
  return negativerealpowerkwpermin_;
}
inline void RampRate::set_allocated_negativerealpowerkwpermin(::google::protobuf::FloatValue* negativerealpowerkwpermin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(negativerealpowerkwpermin_);
  }
  if (negativerealpowerkwpermin) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(negativerealpowerkwpermin)->GetArena();
    if (message_arena != submessage_arena) {
      negativerealpowerkwpermin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, negativerealpowerkwpermin, submessage_arena);
    }
    
  } else {
    
  }
  negativerealpowerkwpermin_ = negativerealpowerkwpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.negativeRealPowerKWPerMin)
}

// .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;
inline bool RampRate::has_positivereactivepowerkvarpermin() const {
  return this != internal_default_instance() && positivereactivepowerkvarpermin_ != nullptr;
}
inline const ::google::protobuf::FloatValue& RampRate::positivereactivepowerkvarpermin() const {
  const ::google::protobuf::FloatValue* p = positivereactivepowerkvarpermin_;
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* RampRate::release_positivereactivepowerkvarpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
  
  ::google::protobuf::FloatValue* temp = positivereactivepowerkvarpermin_;
  positivereactivepowerkvarpermin_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* RampRate::mutable_positivereactivepowerkvarpermin() {
  
  if (positivereactivepowerkvarpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    positivereactivepowerkvarpermin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
  return positivereactivepowerkvarpermin_;
}
inline void RampRate::set_allocated_positivereactivepowerkvarpermin(::google::protobuf::FloatValue* positivereactivepowerkvarpermin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(positivereactivepowerkvarpermin_);
  }
  if (positivereactivepowerkvarpermin) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(positivereactivepowerkvarpermin)->GetArena();
    if (message_arena != submessage_arena) {
      positivereactivepowerkvarpermin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, positivereactivepowerkvarpermin, submessage_arena);
    }
    
  } else {
    
  }
  positivereactivepowerkvarpermin_ = positivereactivepowerkvarpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
}

// .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;
inline bool RampRate::has_positiverealpowerkwpermin() const {
  return this != internal_default_instance() && positiverealpowerkwpermin_ != nullptr;
}
inline const ::google::protobuf::FloatValue& RampRate::positiverealpowerkwpermin() const {
  const ::google::protobuf::FloatValue* p = positiverealpowerkwpermin_;
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.positiveRealPowerKWPerMin)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* RampRate::release_positiverealpowerkwpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.positiveRealPowerKWPerMin)
  
  ::google::protobuf::FloatValue* temp = positiverealpowerkwpermin_;
  positiverealpowerkwpermin_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* RampRate::mutable_positiverealpowerkwpermin() {
  
  if (positiverealpowerkwpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    positiverealpowerkwpermin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.positiveRealPowerKWPerMin)
  return positiverealpowerkwpermin_;
}
inline void RampRate::set_allocated_positiverealpowerkwpermin(::google::protobuf::FloatValue* positiverealpowerkwpermin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(positiverealpowerkwpermin_);
  }
  if (positiverealpowerkwpermin) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(positiverealpowerkwpermin)->GetArena();
    if (message_arena != submessage_arena) {
      positiverealpowerkwpermin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, positiverealpowerkwpermin, submessage_arena);
    }
    
  } else {
    
  }
  positiverealpowerkwpermin_ = positiverealpowerkwpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.positiveRealPowerKWPerMin)
}

// -------------------------------------------------------------------

// ReadingMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMessageInfo::has_messageinfo() const {
  return this != internal_default_instance() && messageinfo_ != nullptr;
}
inline void ReadingMessageInfo::clear_messageinfo() {
  if (GetArenaNoVirtual() == nullptr && messageinfo_ != nullptr) {
    delete messageinfo_;
  }
  messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& ReadingMessageInfo::messageinfo() const {
  const ::commonmodule::MessageInfo* p = messageinfo_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMessageInfo.messageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MessageInfo*>(
      &::commonmodule::_MessageInfo_default_instance_);
}
inline ::commonmodule::MessageInfo* ReadingMessageInfo::release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = messageinfo_;
  messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* ReadingMessageInfo::mutable_messageinfo() {
  
  if (messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaNoVirtual());
    messageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMessageInfo.messageInfo)
  return messageinfo_;
}
inline void ReadingMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete messageinfo_;
  }
  if (messageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      messageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }
    
  } else {
    
  }
  messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// ReadingMMTR

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMMTR::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void ReadingMMTR::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& ReadingMMTR::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* ReadingMMTR::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMTR::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.logicalNode)
  return logicalnode_;
}
inline void ReadingMMTR::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.logicalNode)
}

// .commonmodule.BCR DmdVAh = 2;
inline bool ReadingMMTR::has_dmdvah() const {
  return this != internal_default_instance() && dmdvah_ != nullptr;
}
inline void ReadingMMTR::clear_dmdvah() {
  if (GetArenaNoVirtual() == nullptr && dmdvah_ != nullptr) {
    delete dmdvah_;
  }
  dmdvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::dmdvah() const {
  const ::commonmodule::BCR* p = dmdvah_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.DmdVAh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_dmdvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.DmdVAh)
  
  ::commonmodule::BCR* temp = dmdvah_;
  dmdvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_dmdvah() {
  
  if (dmdvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    dmdvah_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.DmdVAh)
  return dmdvah_;
}
inline void ReadingMMTR::set_allocated_dmdvah(::commonmodule::BCR* dmdvah) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dmdvah_;
  }
  if (dmdvah) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dmdvah = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dmdvah, submessage_arena);
    }
    
  } else {
    
  }
  dmdvah_ = dmdvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.DmdVAh)
}

// .commonmodule.BCR DmdVArh = 3;
inline bool ReadingMMTR::has_dmdvarh() const {
  return this != internal_default_instance() && dmdvarh_ != nullptr;
}
inline void ReadingMMTR::clear_dmdvarh() {
  if (GetArenaNoVirtual() == nullptr && dmdvarh_ != nullptr) {
    delete dmdvarh_;
  }
  dmdvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::dmdvarh() const {
  const ::commonmodule::BCR* p = dmdvarh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.DmdVArh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_dmdvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.DmdVArh)
  
  ::commonmodule::BCR* temp = dmdvarh_;
  dmdvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_dmdvarh() {
  
  if (dmdvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    dmdvarh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.DmdVArh)
  return dmdvarh_;
}
inline void ReadingMMTR::set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dmdvarh_;
  }
  if (dmdvarh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dmdvarh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dmdvarh, submessage_arena);
    }
    
  } else {
    
  }
  dmdvarh_ = dmdvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.DmdVArh)
}

// .commonmodule.BCR DmdWh = 4;
inline bool ReadingMMTR::has_dmdwh() const {
  return this != internal_default_instance() && dmdwh_ != nullptr;
}
inline void ReadingMMTR::clear_dmdwh() {
  if (GetArenaNoVirtual() == nullptr && dmdwh_ != nullptr) {
    delete dmdwh_;
  }
  dmdwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::dmdwh() const {
  const ::commonmodule::BCR* p = dmdwh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.DmdWh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_dmdwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.DmdWh)
  
  ::commonmodule::BCR* temp = dmdwh_;
  dmdwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_dmdwh() {
  
  if (dmdwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    dmdwh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.DmdWh)
  return dmdwh_;
}
inline void ReadingMMTR::set_allocated_dmdwh(::commonmodule::BCR* dmdwh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dmdwh_;
  }
  if (dmdwh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dmdwh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dmdwh, submessage_arena);
    }
    
  } else {
    
  }
  dmdwh_ = dmdwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.DmdWh)
}

// .commonmodule.BCR SupVAh = 5;
inline bool ReadingMMTR::has_supvah() const {
  return this != internal_default_instance() && supvah_ != nullptr;
}
inline void ReadingMMTR::clear_supvah() {
  if (GetArenaNoVirtual() == nullptr && supvah_ != nullptr) {
    delete supvah_;
  }
  supvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::supvah() const {
  const ::commonmodule::BCR* p = supvah_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.SupVAh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_supvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.SupVAh)
  
  ::commonmodule::BCR* temp = supvah_;
  supvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_supvah() {
  
  if (supvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    supvah_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.SupVAh)
  return supvah_;
}
inline void ReadingMMTR::set_allocated_supvah(::commonmodule::BCR* supvah) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete supvah_;
  }
  if (supvah) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      supvah = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supvah, submessage_arena);
    }
    
  } else {
    
  }
  supvah_ = supvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.SupVAh)
}

// .commonmodule.BCR SupVArh = 6;
inline bool ReadingMMTR::has_supvarh() const {
  return this != internal_default_instance() && supvarh_ != nullptr;
}
inline void ReadingMMTR::clear_supvarh() {
  if (GetArenaNoVirtual() == nullptr && supvarh_ != nullptr) {
    delete supvarh_;
  }
  supvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::supvarh() const {
  const ::commonmodule::BCR* p = supvarh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.SupVArh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_supvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.SupVArh)
  
  ::commonmodule::BCR* temp = supvarh_;
  supvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_supvarh() {
  
  if (supvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    supvarh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.SupVArh)
  return supvarh_;
}
inline void ReadingMMTR::set_allocated_supvarh(::commonmodule::BCR* supvarh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete supvarh_;
  }
  if (supvarh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      supvarh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supvarh, submessage_arena);
    }
    
  } else {
    
  }
  supvarh_ = supvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.SupVArh)
}

// .commonmodule.BCR SupWh = 7;
inline bool ReadingMMTR::has_supwh() const {
  return this != internal_default_instance() && supwh_ != nullptr;
}
inline void ReadingMMTR::clear_supwh() {
  if (GetArenaNoVirtual() == nullptr && supwh_ != nullptr) {
    delete supwh_;
  }
  supwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::supwh() const {
  const ::commonmodule::BCR* p = supwh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.SupWh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_supwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.SupWh)
  
  ::commonmodule::BCR* temp = supwh_;
  supwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_supwh() {
  
  if (supwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    supwh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.SupWh)
  return supwh_;
}
inline void ReadingMMTR::set_allocated_supwh(::commonmodule::BCR* supwh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete supwh_;
  }
  if (supwh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      supwh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, supwh, submessage_arena);
    }
    
  } else {
    
  }
  supwh_ = supwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.SupWh)
}

// .commonmodule.BCR TotVAh = 8;
inline bool ReadingMMTR::has_totvah() const {
  return this != internal_default_instance() && totvah_ != nullptr;
}
inline void ReadingMMTR::clear_totvah() {
  if (GetArenaNoVirtual() == nullptr && totvah_ != nullptr) {
    delete totvah_;
  }
  totvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::totvah() const {
  const ::commonmodule::BCR* p = totvah_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.TotVAh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_totvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.TotVAh)
  
  ::commonmodule::BCR* temp = totvah_;
  totvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_totvah() {
  
  if (totvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    totvah_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.TotVAh)
  return totvah_;
}
inline void ReadingMMTR::set_allocated_totvah(::commonmodule::BCR* totvah) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete totvah_;
  }
  if (totvah) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      totvah = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totvah, submessage_arena);
    }
    
  } else {
    
  }
  totvah_ = totvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.TotVAh)
}

// .commonmodule.BCR TotVArh = 9;
inline bool ReadingMMTR::has_totvarh() const {
  return this != internal_default_instance() && totvarh_ != nullptr;
}
inline void ReadingMMTR::clear_totvarh() {
  if (GetArenaNoVirtual() == nullptr && totvarh_ != nullptr) {
    delete totvarh_;
  }
  totvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::totvarh() const {
  const ::commonmodule::BCR* p = totvarh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.TotVArh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_totvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.TotVArh)
  
  ::commonmodule::BCR* temp = totvarh_;
  totvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_totvarh() {
  
  if (totvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    totvarh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.TotVArh)
  return totvarh_;
}
inline void ReadingMMTR::set_allocated_totvarh(::commonmodule::BCR* totvarh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete totvarh_;
  }
  if (totvarh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      totvarh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totvarh, submessage_arena);
    }
    
  } else {
    
  }
  totvarh_ = totvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.TotVArh)
}

// .commonmodule.BCR TotWh = 10;
inline bool ReadingMMTR::has_totwh() const {
  return this != internal_default_instance() && totwh_ != nullptr;
}
inline void ReadingMMTR::clear_totwh() {
  if (GetArenaNoVirtual() == nullptr && totwh_ != nullptr) {
    delete totwh_;
  }
  totwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::totwh() const {
  const ::commonmodule::BCR* p = totwh_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.TotWh)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::BCR*>(
      &::commonmodule::_BCR_default_instance_);
}
inline ::commonmodule::BCR* ReadingMMTR::release_totwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.TotWh)
  
  ::commonmodule::BCR* temp = totwh_;
  totwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_totwh() {
  
  if (totwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaNoVirtual());
    totwh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.TotWh)
  return totwh_;
}
inline void ReadingMMTR::set_allocated_totwh(::commonmodule::BCR* totwh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete totwh_;
  }
  if (totwh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      totwh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totwh, submessage_arena);
    }
    
  } else {
    
  }
  totwh_ = totwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.TotWh)
}

// -------------------------------------------------------------------

// WYE

// .commonmodule.CMV net = 1;
inline bool WYE::has_net() const {
  return this != internal_default_instance() && net_ != nullptr;
}
inline void WYE::clear_net() {
  if (GetArenaNoVirtual() == nullptr && net_ != nullptr) {
    delete net_;
  }
  net_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::net() const {
  const ::commonmodule::CMV* p = net_;
  // @@protoc_insertion_point(field_get:commonmodule.WYE.net)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* WYE::release_net() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.net)
  
  ::commonmodule::CMV* temp = net_;
  net_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::mutable_net() {
  
  if (net_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    net_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.net)
  return net_;
}
inline void WYE::set_allocated_net(::commonmodule::CMV* net) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete net_;
  }
  if (net) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      net = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, net, submessage_arena);
    }
    
  } else {
    
  }
  net_ = net;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.net)
}

// .commonmodule.CMV neut = 2;
inline bool WYE::has_neut() const {
  return this != internal_default_instance() && neut_ != nullptr;
}
inline void WYE::clear_neut() {
  if (GetArenaNoVirtual() == nullptr && neut_ != nullptr) {
    delete neut_;
  }
  neut_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::neut() const {
  const ::commonmodule::CMV* p = neut_;
  // @@protoc_insertion_point(field_get:commonmodule.WYE.neut)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* WYE::release_neut() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.neut)
  
  ::commonmodule::CMV* temp = neut_;
  neut_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::mutable_neut() {
  
  if (neut_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    neut_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.neut)
  return neut_;
}
inline void WYE::set_allocated_neut(::commonmodule::CMV* neut) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete neut_;
  }
  if (neut) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      neut = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, neut, submessage_arena);
    }
    
  } else {
    
  }
  neut_ = neut;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.neut)
}

// .commonmodule.CMV phsA = 3;
inline bool WYE::has_phsa() const {
  return this != internal_default_instance() && phsa_ != nullptr;
}
inline void WYE::clear_phsa() {
  if (GetArenaNoVirtual() == nullptr && phsa_ != nullptr) {
    delete phsa_;
  }
  phsa_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::phsa() const {
  const ::commonmodule::CMV* p = phsa_;
  // @@protoc_insertion_point(field_get:commonmodule.WYE.phsA)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* WYE::release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.phsA)
  
  ::commonmodule::CMV* temp = phsa_;
  phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::mutable_phsa() {
  
  if (phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    phsa_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.phsA)
  return phsa_;
}
inline void WYE::set_allocated_phsa(::commonmodule::CMV* phsa) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsa_;
  }
  if (phsa) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsa = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }
    
  } else {
    
  }
  phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.phsA)
}

// .commonmodule.CMV phsB = 4;
inline bool WYE::has_phsb() const {
  return this != internal_default_instance() && phsb_ != nullptr;
}
inline void WYE::clear_phsb() {
  if (GetArenaNoVirtual() == nullptr && phsb_ != nullptr) {
    delete phsb_;
  }
  phsb_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::phsb() const {
  const ::commonmodule::CMV* p = phsb_;
  // @@protoc_insertion_point(field_get:commonmodule.WYE.phsB)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* WYE::release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.phsB)
  
  ::commonmodule::CMV* temp = phsb_;
  phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::mutable_phsb() {
  
  if (phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    phsb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.phsB)
  return phsb_;
}
inline void WYE::set_allocated_phsb(::commonmodule::CMV* phsb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsb_;
  }
  if (phsb) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }
    
  } else {
    
  }
  phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.phsB)
}

// .commonmodule.CMV phsC = 5;
inline bool WYE::has_phsc() const {
  return this != internal_default_instance() && phsc_ != nullptr;
}
inline void WYE::clear_phsc() {
  if (GetArenaNoVirtual() == nullptr && phsc_ != nullptr) {
    delete phsc_;
  }
  phsc_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::phsc() const {
  const ::commonmodule::CMV* p = phsc_;
  // @@protoc_insertion_point(field_get:commonmodule.WYE.phsC)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CMV*>(
      &::commonmodule::_CMV_default_instance_);
}
inline ::commonmodule::CMV* WYE::release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.phsC)
  
  ::commonmodule::CMV* temp = phsc_;
  phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::mutable_phsc() {
  
  if (phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaNoVirtual());
    phsc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.phsC)
  return phsc_;
}
inline void WYE::set_allocated_phsc(::commonmodule::CMV* phsc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phsc_;
  }
  if (phsc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phsc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }
    
  } else {
    
  }
  phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.phsC)
}

// -------------------------------------------------------------------

// ReadingMMXU

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMMXU::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void ReadingMMXU::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& ReadingMMXU::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* ReadingMMXU::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMXU::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.logicalNode)
  return logicalnode_;
}
inline void ReadingMMXU::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.logicalNode)
}

// .commonmodule.WYE A = 2;
inline bool ReadingMMXU::has_a() const {
  return this != internal_default_instance() && a_ != nullptr;
}
inline void ReadingMMXU::clear_a() {
  if (GetArenaNoVirtual() == nullptr && a_ != nullptr) {
    delete a_;
  }
  a_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::a() const {
  const ::commonmodule::WYE* p = a_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.A)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::WYE*>(
      &::commonmodule::_WYE_default_instance_);
}
inline ::commonmodule::WYE* ReadingMMXU::release_a() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.A)
  
  ::commonmodule::WYE* temp = a_;
  a_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_a() {
  
  if (a_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaNoVirtual());
    a_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.A)
  return a_;
}
inline void ReadingMMXU::set_allocated_a(::commonmodule::WYE* a) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete a_;
  }
  if (a) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      a = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    
  } else {
    
  }
  a_ = a;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.A)
}

// .commonmodule.ENG_CalcMethodKind ClcMth = 3;
inline bool ReadingMMXU::has_clcmth() const {
  return this != internal_default_instance() && clcmth_ != nullptr;
}
inline void ReadingMMXU::clear_clcmth() {
  if (GetArenaNoVirtual() == nullptr && clcmth_ != nullptr) {
    delete clcmth_;
  }
  clcmth_ = nullptr;
}
inline const ::commonmodule::ENG_CalcMethodKind& ReadingMMXU::clcmth() const {
  const ::commonmodule::ENG_CalcMethodKind* p = clcmth_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.ClcMth)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_CalcMethodKind*>(
      &::commonmodule::_ENG_CalcMethodKind_default_instance_);
}
inline ::commonmodule::ENG_CalcMethodKind* ReadingMMXU::release_clcmth() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.ClcMth)
  
  ::commonmodule::ENG_CalcMethodKind* temp = clcmth_;
  clcmth_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_CalcMethodKind* ReadingMMXU::mutable_clcmth() {
  
  if (clcmth_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_CalcMethodKind>(GetArenaNoVirtual());
    clcmth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.ClcMth)
  return clcmth_;
}
inline void ReadingMMXU::set_allocated_clcmth(::commonmodule::ENG_CalcMethodKind* clcmth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete clcmth_;
  }
  if (clcmth) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      clcmth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clcmth, submessage_arena);
    }
    
  } else {
    
  }
  clcmth_ = clcmth;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.ClcMth)
}

// .commonmodule.MV Hz = 4;
inline bool ReadingMMXU::has_hz() const {
  return this != internal_default_instance() && hz_ != nullptr;
}
inline void ReadingMMXU::clear_hz() {
  if (GetArenaNoVirtual() == nullptr && hz_ != nullptr) {
    delete hz_;
  }
  hz_ = nullptr;
}
inline const ::commonmodule::MV& ReadingMMXU::hz() const {
  const ::commonmodule::MV* p = hz_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.Hz)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MV*>(
      &::commonmodule::_MV_default_instance_);
}
inline ::commonmodule::MV* ReadingMMXU::release_hz() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.Hz)
  
  ::commonmodule::MV* temp = hz_;
  hz_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* ReadingMMXU::mutable_hz() {
  
  if (hz_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaNoVirtual());
    hz_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.Hz)
  return hz_;
}
inline void ReadingMMXU::set_allocated_hz(::commonmodule::MV* hz) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hz_;
  }
  if (hz) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hz = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hz, submessage_arena);
    }
    
  } else {
    
  }
  hz_ = hz;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.Hz)
}

// .commonmodule.WYE PF = 5;
inline bool ReadingMMXU::has_pf() const {
  return this != internal_default_instance() && pf_ != nullptr;
}
inline void ReadingMMXU::clear_pf() {
  if (GetArenaNoVirtual() == nullptr && pf_ != nullptr) {
    delete pf_;
  }
  pf_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::pf() const {
  const ::commonmodule::WYE* p = pf_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PF)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::WYE*>(
      &::commonmodule::_WYE_default_instance_);
}
inline ::commonmodule::WYE* ReadingMMXU::release_pf() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PF)
  
  ::commonmodule::WYE* temp = pf_;
  pf_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_pf() {
  
  if (pf_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaNoVirtual());
    pf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PF)
  return pf_;
}
inline void ReadingMMXU::set_allocated_pf(::commonmodule::WYE* pf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pf_;
  }
  if (pf) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pf, submessage_arena);
    }
    
  } else {
    
  }
  pf_ = pf;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PF)
}

// .commonmodule.ENG_PFSignKind PFSign = 6;
inline bool ReadingMMXU::has_pfsign() const {
  return this != internal_default_instance() && pfsign_ != nullptr;
}
inline void ReadingMMXU::clear_pfsign() {
  if (GetArenaNoVirtual() == nullptr && pfsign_ != nullptr) {
    delete pfsign_;
  }
  pfsign_ = nullptr;
}
inline const ::commonmodule::ENG_PFSignKind& ReadingMMXU::pfsign() const {
  const ::commonmodule::ENG_PFSignKind* p = pfsign_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PFSign)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_PFSignKind*>(
      &::commonmodule::_ENG_PFSignKind_default_instance_);
}
inline ::commonmodule::ENG_PFSignKind* ReadingMMXU::release_pfsign() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PFSign)
  
  ::commonmodule::ENG_PFSignKind* temp = pfsign_;
  pfsign_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_PFSignKind* ReadingMMXU::mutable_pfsign() {
  
  if (pfsign_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_PFSignKind>(GetArenaNoVirtual());
    pfsign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PFSign)
  return pfsign_;
}
inline void ReadingMMXU::set_allocated_pfsign(::commonmodule::ENG_PFSignKind* pfsign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pfsign_;
  }
  if (pfsign) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pfsign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pfsign, submessage_arena);
    }
    
  } else {
    
  }
  pfsign_ = pfsign;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PFSign)
}

// .commonmodule.WYE PhV = 7;
inline bool ReadingMMXU::has_phv() const {
  return this != internal_default_instance() && phv_ != nullptr;
}
inline void ReadingMMXU::clear_phv() {
  if (GetArenaNoVirtual() == nullptr && phv_ != nullptr) {
    delete phv_;
  }
  phv_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::phv() const {
  const ::commonmodule::WYE* p = phv_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PhV)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::WYE*>(
      &::commonmodule::_WYE_default_instance_);
}
inline ::commonmodule::WYE* ReadingMMXU::release_phv() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PhV)
  
  ::commonmodule::WYE* temp = phv_;
  phv_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_phv() {
  
  if (phv_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaNoVirtual());
    phv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PhV)
  return phv_;
}
inline void ReadingMMXU::set_allocated_phv(::commonmodule::WYE* phv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phv_;
  }
  if (phv) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phv, submessage_arena);
    }
    
  } else {
    
  }
  phv_ = phv;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PhV)
}

// .commonmodule.DEL PPV = 8;
inline bool ReadingMMXU::has_ppv() const {
  return this != internal_default_instance() && ppv_ != nullptr;
}
inline void ReadingMMXU::clear_ppv() {
  if (GetArenaNoVirtual() == nullptr && ppv_ != nullptr) {
    delete ppv_;
  }
  ppv_ = nullptr;
}
inline const ::commonmodule::DEL& ReadingMMXU::ppv() const {
  const ::commonmodule::DEL* p = ppv_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PPV)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::DEL*>(
      &::commonmodule::_DEL_default_instance_);
}
inline ::commonmodule::DEL* ReadingMMXU::release_ppv() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PPV)
  
  ::commonmodule::DEL* temp = ppv_;
  ppv_ = nullptr;
  return temp;
}
inline ::commonmodule::DEL* ReadingMMXU::mutable_ppv() {
  
  if (ppv_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::DEL>(GetArenaNoVirtual());
    ppv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PPV)
  return ppv_;
}
inline void ReadingMMXU::set_allocated_ppv(::commonmodule::DEL* ppv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ppv_;
  }
  if (ppv) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ppv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ppv, submessage_arena);
    }
    
  } else {
    
  }
  ppv_ = ppv;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PPV)
}

// .commonmodule.WYE VA = 9;
inline bool ReadingMMXU::has_va() const {
  return this != internal_default_instance() && va_ != nullptr;
}
inline void ReadingMMXU::clear_va() {
  if (GetArenaNoVirtual() == nullptr && va_ != nullptr) {
    delete va_;
  }
  va_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::va() const {
  const ::commonmodule::WYE* p = va_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.VA)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::WYE*>(
      &::commonmodule::_WYE_default_instance_);
}
inline ::commonmodule::WYE* ReadingMMXU::release_va() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.VA)
  
  ::commonmodule::WYE* temp = va_;
  va_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_va() {
  
  if (va_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaNoVirtual());
    va_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.VA)
  return va_;
}
inline void ReadingMMXU::set_allocated_va(::commonmodule::WYE* va) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete va_;
  }
  if (va) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      va = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, va, submessage_arena);
    }
    
  } else {
    
  }
  va_ = va;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.VA)
}

// .commonmodule.WYE VAr = 10;
inline bool ReadingMMXU::has_var() const {
  return this != internal_default_instance() && var_ != nullptr;
}
inline void ReadingMMXU::clear_var() {
  if (GetArenaNoVirtual() == nullptr && var_ != nullptr) {
    delete var_;
  }
  var_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::var() const {
  const ::commonmodule::WYE* p = var_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.VAr)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::WYE*>(
      &::commonmodule::_WYE_default_instance_);
}
inline ::commonmodule::WYE* ReadingMMXU::release_var() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.VAr)
  
  ::commonmodule::WYE* temp = var_;
  var_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_var() {
  
  if (var_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaNoVirtual());
    var_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.VAr)
  return var_;
}
inline void ReadingMMXU::set_allocated_var(::commonmodule::WYE* var) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete var_;
  }
  if (var) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      var = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, var, submessage_arena);
    }
    
  } else {
    
  }
  var_ = var;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.VAr)
}

// .commonmodule.WYE W = 11;
inline bool ReadingMMXU::has_w() const {
  return this != internal_default_instance() && w_ != nullptr;
}
inline void ReadingMMXU::clear_w() {
  if (GetArenaNoVirtual() == nullptr && w_ != nullptr) {
    delete w_;
  }
  w_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::w() const {
  const ::commonmodule::WYE* p = w_;
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.W)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::WYE*>(
      &::commonmodule::_WYE_default_instance_);
}
inline ::commonmodule::WYE* ReadingMMXU::release_w() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.W)
  
  ::commonmodule::WYE* temp = w_;
  w_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_w() {
  
  if (w_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaNoVirtual());
    w_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.W)
  return w_;
}
inline void ReadingMMXU::set_allocated_w(::commonmodule::WYE* w) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete w_;
  }
  if (w) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      w = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, w, submessage_arena);
    }
    
  } else {
    
  }
  w_ = w;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.W)
}

// -------------------------------------------------------------------

// Optional_DbPosKind

// .commonmodule.DbPosKind value = 1;
inline void Optional_DbPosKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::DbPosKind Optional_DbPosKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_DbPosKind.value)
  return static_cast< ::commonmodule::DbPosKind >(value_);
}
inline void Optional_DbPosKind::set_value(::commonmodule::DbPosKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_DbPosKind.value)
}

// -------------------------------------------------------------------

// StatusDPS

// .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool StatusDPS::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void StatusDPS::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusDPS::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusDPS.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* StatusDPS::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusDPS.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusDPS::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusDPS.q)
  return q_;
}
inline void StatusDPS::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusDPS.q)
}

// .commonmodule.DbPosKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusDPS::clear_stval() {
  stval_ = 0;
}
inline ::commonmodule::DbPosKind StatusDPS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusDPS.stVal)
  return static_cast< ::commonmodule::DbPosKind >(stval_);
}
inline void StatusDPS::set_stval(::commonmodule::DbPosKind value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.StatusDPS.stVal)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool StatusDPS::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void StatusDPS::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusDPS::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusDPS.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* StatusDPS::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusDPS.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusDPS::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusDPS.t)
  return t_;
}
inline void StatusDPS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusDPS.t)
}

// -------------------------------------------------------------------

// StatusAndEventXCBR

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool StatusAndEventXCBR::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline void StatusAndEventXCBR::clear_logicalnodeforeventandstatus() {
  if (GetArenaNoVirtual() == nullptr && logicalnodeforeventandstatus_ != nullptr) {
    delete logicalnodeforeventandstatus_;
  }
  logicalnodeforeventandstatus_ = nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& StatusAndEventXCBR::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* StatusAndEventXCBR::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* StatusAndEventXCBR::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void StatusAndEventXCBR::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnodeforeventandstatus_;
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool StatusAndEventXCBR::has_dynamictest() const {
  return this != internal_default_instance() && dynamictest_ != nullptr;
}
inline void StatusAndEventXCBR::clear_dynamictest() {
  if (GetArenaNoVirtual() == nullptr && dynamictest_ != nullptr) {
    delete dynamictest_;
  }
  dynamictest_ = nullptr;
}
inline const ::commonmodule::ENS_DynamicTestKind& StatusAndEventXCBR::dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = dynamictest_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.DynamicTest)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind*>(
      &::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline ::commonmodule::ENS_DynamicTestKind* StatusAndEventXCBR::release_dynamictest() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = dynamictest_;
  dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* StatusAndEventXCBR::mutable_dynamictest() {
  
  if (dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaNoVirtual());
    dynamictest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.DynamicTest)
  return dynamictest_;
}
inline void StatusAndEventXCBR::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamictest_;
  }
  if (dynamictest) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamictest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }
    
  } else {
    
  }
  dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.DynamicTest)
}

// .commonmodule.StatusDPS Pos = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool StatusAndEventXCBR::has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline void StatusAndEventXCBR::clear_pos() {
  if (GetArenaNoVirtual() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::commonmodule::StatusDPS& StatusAndEventXCBR::pos() const {
  const ::commonmodule::StatusDPS* p = pos_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.Pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusDPS*>(
      &::commonmodule::_StatusDPS_default_instance_);
}
inline ::commonmodule::StatusDPS* StatusAndEventXCBR::release_pos() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.Pos)
  
  ::commonmodule::StatusDPS* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* StatusAndEventXCBR::mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.Pos)
  return pos_;
}
inline void StatusAndEventXCBR::set_allocated_pos(::commonmodule::StatusDPS* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.Pos)
}

// -------------------------------------------------------------------

// StatusISC

// .commonmodule.Quality q = 1;
inline bool StatusISC::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void StatusISC::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusISC::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusISC.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* StatusISC::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusISC.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusISC::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusISC.q)
  return q_;
}
inline void StatusISC::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusISC.q)
}

// int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusISC::clear_stval() {
  stval_ = 0;
}
inline ::google::protobuf::int32 StatusISC::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusISC.stVal)
  return stval_;
}
inline void StatusISC::set_stval(::google::protobuf::int32 value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.StatusISC.stVal)
}

// .commonmodule.Timestamp t = 3;
inline bool StatusISC::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void StatusISC::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusISC::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusISC.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* StatusISC::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusISC.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusISC::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusISC.t)
  return t_;
}
inline void StatusISC::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusISC.t)
}

// -------------------------------------------------------------------

// StatusMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool StatusMessageInfo::has_messageinfo() const {
  return this != internal_default_instance() && messageinfo_ != nullptr;
}
inline void StatusMessageInfo::clear_messageinfo() {
  if (GetArenaNoVirtual() == nullptr && messageinfo_ != nullptr) {
    delete messageinfo_;
  }
  messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& StatusMessageInfo::messageinfo() const {
  const ::commonmodule::MessageInfo* p = messageinfo_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusMessageInfo.messageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MessageInfo*>(
      &::commonmodule::_MessageInfo_default_instance_);
}
inline ::commonmodule::MessageInfo* StatusMessageInfo::release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = messageinfo_;
  messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* StatusMessageInfo::mutable_messageinfo() {
  
  if (messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaNoVirtual());
    messageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusMessageInfo.messageInfo)
  return messageinfo_;
}
inline void StatusMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete messageinfo_;
  }
  if (messageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      messageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }
    
  } else {
    
  }
  messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// StatusSPC

// .commonmodule.Quality q = 1;
inline bool StatusSPC::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void StatusSPC::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusSPC::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPC.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* StatusSPC::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusSPC.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusSPC::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusSPC.q)
  return q_;
}
inline void StatusSPC::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusSPC.q)
}

// bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusSPC::clear_stval() {
  stval_ = false;
}
inline bool StatusSPC::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPC.stVal)
  return stval_;
}
inline void StatusSPC::set_stval(bool value) {
  
  stval_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.StatusSPC.stVal)
}

// .commonmodule.Timestamp t = 3;
inline bool StatusSPC::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void StatusSPC::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusSPC::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPC.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* StatusSPC::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusSPC.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusSPC::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusSPC.t)
  return t_;
}
inline void StatusSPC::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusSPC.t)
}

// -------------------------------------------------------------------

// StatusValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool StatusValue::has_identifiedobject() const {
  return this != internal_default_instance() && identifiedobject_ != nullptr;
}
inline void StatusValue::clear_identifiedobject() {
  if (GetArenaNoVirtual() == nullptr && identifiedobject_ != nullptr) {
    delete identifiedobject_;
  }
  identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& StatusValue::identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = identifiedobject_;
  // @@protoc_insertion_point(field_get:commonmodule.StatusValue.identifiedObject)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IdentifiedObject*>(
      &::commonmodule::_IdentifiedObject_default_instance_);
}
inline ::commonmodule::IdentifiedObject* StatusValue::release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = identifiedobject_;
  identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* StatusValue::mutable_identifiedobject() {
  
  if (identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaNoVirtual());
    identifiedobject_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusValue.identifiedObject)
  return identifiedobject_;
}
inline void StatusValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifiedobject_;
  }
  if (identifiedobject) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifiedobject = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }
    
  } else {
    
  }
  identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusValue.identifiedObject)
}

// -------------------------------------------------------------------

// VSS

// .commonmodule.Quality q = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool VSS::has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline void VSS::clear_q() {
  if (GetArenaNoVirtual() == nullptr && q_ != nullptr) {
    delete q_;
  }
  q_ = nullptr;
}
inline const ::commonmodule::Quality& VSS::q() const {
  const ::commonmodule::Quality* p = q_;
  // @@protoc_insertion_point(field_get:commonmodule.VSS.q)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Quality*>(
      &::commonmodule::_Quality_default_instance_);
}
inline ::commonmodule::Quality* VSS::release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.VSS.q)
  
  ::commonmodule::Quality* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* VSS::mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaNoVirtual());
    q_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.VSS.q)
  return q_;
}
inline void VSS::set_allocated_q(::commonmodule::Quality* q) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete q_;
  }
  if (q) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      q = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VSS.q)
}

// string stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VSS::clear_stval() {
  stval_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VSS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.VSS.stVal)
  return stval_.GetNoArena();
}
inline void VSS::set_stval(const ::std::string& value) {
  
  stval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:commonmodule.VSS.stVal)
}
#if LANG_CXX11
inline void VSS::set_stval(::std::string&& value) {
  
  stval_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:commonmodule.VSS.stVal)
}
#endif
inline void VSS::set_stval(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:commonmodule.VSS.stVal)
}
inline void VSS::set_stval(const char* value, size_t size) {
  
  stval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:commonmodule.VSS.stVal)
}
inline ::std::string* VSS::mutable_stval() {
  
  // @@protoc_insertion_point(field_mutable:commonmodule.VSS.stVal)
  return stval_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VSS::release_stval() {
  // @@protoc_insertion_point(field_release:commonmodule.VSS.stVal)
  
  return stval_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VSS::set_allocated_stval(::std::string* stval) {
  if (stval != nullptr) {
    
  } else {
    
  }
  stval_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stval);
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VSS.stVal)
}

// .commonmodule.Timestamp t = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool VSS::has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline void VSS::clear_t() {
  if (GetArenaNoVirtual() == nullptr && t_ != nullptr) {
    delete t_;
  }
  t_ = nullptr;
}
inline const ::commonmodule::Timestamp& VSS::t() const {
  const ::commonmodule::Timestamp* p = t_;
  // @@protoc_insertion_point(field_get:commonmodule.VSS.t)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Timestamp*>(
      &::commonmodule::_Timestamp_default_instance_);
}
inline ::commonmodule::Timestamp* VSS::release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.VSS.t)
  
  ::commonmodule::Timestamp* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* VSS::mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaNoVirtual());
    t_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.VSS.t)
  return t_;
}
inline void VSS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VSS.t)
}

// -------------------------------------------------------------------

// StringStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool StringStatusGGIO::has_logicalnode() const {
  return this != internal_default_instance() && logicalnode_ != nullptr;
}
inline void StringStatusGGIO::clear_logicalnode() {
  if (GetArenaNoVirtual() == nullptr && logicalnode_ != nullptr) {
    delete logicalnode_;
  }
  logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& StringStatusGGIO::logicalnode() const {
  const ::commonmodule::LogicalNode* p = logicalnode_;
  // @@protoc_insertion_point(field_get:commonmodule.StringStatusGGIO.logicalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNode*>(
      &::commonmodule::_LogicalNode_default_instance_);
}
inline ::commonmodule::LogicalNode* StringStatusGGIO::release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.StringStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = logicalnode_;
  logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* StringStatusGGIO::mutable_logicalnode() {
  
  if (logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaNoVirtual());
    logicalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StringStatusGGIO.logicalNode)
  return logicalnode_;
}
inline void StringStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete logicalnode_;
  }
  if (logicalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }
    
  } else {
    
  }
  logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StringStatusGGIO.logicalNode)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 2;
inline bool StringStatusGGIO::has_phase() const {
  return this != internal_default_instance() && phase_ != nullptr;
}
inline void StringStatusGGIO::clear_phase() {
  if (GetArenaNoVirtual() == nullptr && phase_ != nullptr) {
    delete phase_;
  }
  phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& StringStatusGGIO::phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = phase_;
  // @@protoc_insertion_point(field_get:commonmodule.StringStatusGGIO.Phase)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind*>(
      &::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline ::commonmodule::Optional_PhaseCodeKind* StringStatusGGIO::release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.StringStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = phase_;
  phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* StringStatusGGIO::mutable_phase() {
  
  if (phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaNoVirtual());
    phase_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StringStatusGGIO.Phase)
  return phase_;
}
inline void StringStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phase_;
  }
  if (phase) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phase = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }
    
  } else {
    
  }
  phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StringStatusGGIO.Phase)
}

// .commonmodule.VSS StrIn = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool StringStatusGGIO::has_strin() const {
  return this != internal_default_instance() && strin_ != nullptr;
}
inline void StringStatusGGIO::clear_strin() {
  if (GetArenaNoVirtual() == nullptr && strin_ != nullptr) {
    delete strin_;
  }
  strin_ = nullptr;
}
inline const ::commonmodule::VSS& StringStatusGGIO::strin() const {
  const ::commonmodule::VSS* p = strin_;
  // @@protoc_insertion_point(field_get:commonmodule.StringStatusGGIO.StrIn)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::VSS*>(
      &::commonmodule::_VSS_default_instance_);
}
inline ::commonmodule::VSS* StringStatusGGIO::release_strin() {
  // @@protoc_insertion_point(field_release:commonmodule.StringStatusGGIO.StrIn)
  
  ::commonmodule::VSS* temp = strin_;
  strin_ = nullptr;
  return temp;
}
inline ::commonmodule::VSS* StringStatusGGIO::mutable_strin() {
  
  if (strin_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VSS>(GetArenaNoVirtual());
    strin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.StringStatusGGIO.StrIn)
  return strin_;
}
inline void StringStatusGGIO::set_allocated_strin(::commonmodule::VSS* strin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete strin_;
  }
  if (strin) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      strin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, strin, submessage_arena);
    }
    
  } else {
    
  }
  strin_ = strin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StringStatusGGIO.StrIn)
}

// -------------------------------------------------------------------

// SwitchPoint

// .commonmodule.ControlDPC Pos = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchPoint::has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline void SwitchPoint::clear_pos() {
  if (GetArenaNoVirtual() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::commonmodule::ControlDPC& SwitchPoint::pos() const {
  const ::commonmodule::ControlDPC* p = pos_;
  // @@protoc_insertion_point(field_get:commonmodule.SwitchPoint.Pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* SwitchPoint::release_pos() {
  // @@protoc_insertion_point(field_release:commonmodule.SwitchPoint.Pos)
  
  ::commonmodule::ControlDPC* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SwitchPoint::mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.SwitchPoint.Pos)
  return pos_;
}
inline void SwitchPoint::set_allocated_pos(::commonmodule::ControlDPC* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SwitchPoint.Pos)
}

// .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchPoint::has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline void SwitchPoint::clear_starttime() {
  if (GetArenaNoVirtual() == nullptr && starttime_ != nullptr) {
    delete starttime_;
  }
  starttime_ = nullptr;
}
inline const ::commonmodule::ControlTimestamp& SwitchPoint::starttime() const {
  const ::commonmodule::ControlTimestamp* p = starttime_;
  // @@protoc_insertion_point(field_get:commonmodule.SwitchPoint.startTime)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlTimestamp*>(
      &::commonmodule::_ControlTimestamp_default_instance_);
}
inline ::commonmodule::ControlTimestamp* SwitchPoint::release_starttime() {
  // @@protoc_insertion_point(field_release:commonmodule.SwitchPoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* SwitchPoint::mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaNoVirtual());
    starttime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.SwitchPoint.startTime)
  return starttime_;
}
inline void SwitchPoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete starttime_;
  }
  if (starttime) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starttime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SwitchPoint.startTime)
}

// -------------------------------------------------------------------

// SwitchCSG

// repeated .commonmodule.SwitchPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int SwitchCSG::crvpts_size() const {
  return crvpts_.size();
}
inline void SwitchCSG::clear_crvpts() {
  crvpts_.Clear();
}
inline ::commonmodule::SwitchPoint* SwitchCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.SwitchCSG.crvPts)
  return crvpts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::commonmodule::SwitchPoint >*
SwitchCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.SwitchCSG.crvPts)
  return &crvpts_;
}
inline const ::commonmodule::SwitchPoint& SwitchCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.SwitchCSG.crvPts)
  return crvpts_.Get(index);
}
inline ::commonmodule::SwitchPoint* SwitchCSG::add_crvpts() {
  // @@protoc_insertion_point(field_add:commonmodule.SwitchCSG.crvPts)
  return crvpts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::commonmodule::SwitchPoint >&
SwitchCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.SwitchCSG.crvPts)
  return crvpts_;
}

// -------------------------------------------------------------------

// SwitchControlScheduleFSCH

// .commonmodule.SwitchCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchControlScheduleFSCH::has_valdcsg() const {
  return this != internal_default_instance() && valdcsg_ != nullptr;
}
inline void SwitchControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaNoVirtual() == nullptr && valdcsg_ != nullptr) {
    delete valdcsg_;
  }
  valdcsg_ = nullptr;
}
inline const ::commonmodule::SwitchCSG& SwitchControlScheduleFSCH::valdcsg() const {
  const ::commonmodule::SwitchCSG* p = valdcsg_;
  // @@protoc_insertion_point(field_get:commonmodule.SwitchControlScheduleFSCH.ValDCSG)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::SwitchCSG*>(
      &::commonmodule::_SwitchCSG_default_instance_);
}
inline ::commonmodule::SwitchCSG* SwitchControlScheduleFSCH::release_valdcsg() {
  // @@protoc_insertion_point(field_release:commonmodule.SwitchControlScheduleFSCH.ValDCSG)
  
  ::commonmodule::SwitchCSG* temp = valdcsg_;
  valdcsg_ = nullptr;
  return temp;
}
inline ::commonmodule::SwitchCSG* SwitchControlScheduleFSCH::mutable_valdcsg() {
  
  if (valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::SwitchCSG>(GetArenaNoVirtual());
    valdcsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonmodule.SwitchControlScheduleFSCH.ValDCSG)
  return valdcsg_;
}
inline void SwitchControlScheduleFSCH::set_allocated_valdcsg(::commonmodule::SwitchCSG* valdcsg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete valdcsg_;
  }
  if (valdcsg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      valdcsg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }
    
  } else {
    
  }
  valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SwitchControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// Optional_StateKind

// .commonmodule.StateKind value = 1;
inline void Optional_StateKind::clear_value() {
  value_ = 0;
}
inline ::commonmodule::StateKind Optional_StateKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_StateKind.value)
  return static_cast< ::commonmodule::StateKind >(value_);
}
inline void Optional_StateKind::set_value(::commonmodule::StateKind value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:commonmodule.Optional_StateKind.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commonmodule

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::commonmodule::UnitSymbolKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::UnitSymbolKind>() {
  return ::commonmodule::UnitSymbolKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::UnitMultiplierKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::UnitMultiplierKind>() {
  return ::commonmodule::UnitMultiplierKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::PhaseCodeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::PhaseCodeKind>() {
  return ::commonmodule::PhaseCodeKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::ValidityKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::ValidityKind>() {
  return ::commonmodule::ValidityKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::SourceKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::SourceKind>() {
  return ::commonmodule::SourceKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::TimeAccuracyKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::TimeAccuracyKind>() {
  return ::commonmodule::TimeAccuracyKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::ScheduleParameterKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::ScheduleParameterKind>() {
  return ::commonmodule::ScheduleParameterKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::CalcMethodKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::CalcMethodKind>() {
  return ::commonmodule::CalcMethodKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::GridConnectModeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::GridConnectModeKind>() {
  return ::commonmodule::GridConnectModeKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::PFSignKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::PFSignKind>() {
  return ::commonmodule::PFSignKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::BehaviourModeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::BehaviourModeKind>() {
  return ::commonmodule::BehaviourModeKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::DERGeneratorStateKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::DERGeneratorStateKind>() {
  return ::commonmodule::DERGeneratorStateKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::DynamicTestKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::DynamicTestKind>() {
  return ::commonmodule::DynamicTestKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::HealthKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::HealthKind>() {
  return ::commonmodule::HealthKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::DbPosKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::DbPosKind>() {
  return ::commonmodule::DbPosKind_descriptor();
}
template <> struct is_proto_enum< ::commonmodule::StateKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonmodule::StateKind>() {
  return ::commonmodule::StateKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_commonmodule_2fcommonmodule_2eproto
