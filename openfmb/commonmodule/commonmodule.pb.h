// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commonmodule/commonmodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_commonmodule_2fcommonmodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_commonmodule_2fcommonmodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_commonmodule_2fcommonmodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_commonmodule_2fcommonmodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_commonmodule_2fcommonmodule_2eproto;
namespace commonmodule {
class ACD;
struct ACDDefaultTypeInternal;
extern ACDDefaultTypeInternal _ACD_default_instance_;
class ACDCTerminal;
struct ACDCTerminalDefaultTypeInternal;
extern ACDCTerminalDefaultTypeInternal _ACDCTerminal_default_instance_;
class ASG;
struct ASGDefaultTypeInternal;
extern ASGDefaultTypeInternal _ASG_default_instance_;
class ActivePower;
struct ActivePowerDefaultTypeInternal;
extern ActivePowerDefaultTypeInternal _ActivePower_default_instance_;
class AnalogEventAndStatusGGIO;
struct AnalogEventAndStatusGGIODefaultTypeInternal;
extern AnalogEventAndStatusGGIODefaultTypeInternal _AnalogEventAndStatusGGIO_default_instance_;
class ApplicationSystem;
struct ApplicationSystemDefaultTypeInternal;
extern ApplicationSystemDefaultTypeInternal _ApplicationSystem_default_instance_;
class BCR;
struct BCRDefaultTypeInternal;
extern BCRDefaultTypeInternal _BCR_default_instance_;
class BooleanEventAndStatusGGIO;
struct BooleanEventAndStatusGGIODefaultTypeInternal;
extern BooleanEventAndStatusGGIODefaultTypeInternal _BooleanEventAndStatusGGIO_default_instance_;
class CMV;
struct CMVDefaultTypeInternal;
extern CMVDefaultTypeInternal _CMV_default_instance_;
class CapabilityMessageInfo;
struct CapabilityMessageInfoDefaultTypeInternal;
extern CapabilityMessageInfoDefaultTypeInternal _CapabilityMessageInfo_default_instance_;
class CheckConditions;
struct CheckConditionsDefaultTypeInternal;
extern CheckConditionsDefaultTypeInternal _CheckConditions_default_instance_;
class ClearingTime;
struct ClearingTimeDefaultTypeInternal;
extern ClearingTimeDefaultTypeInternal _ClearingTime_default_instance_;
class ConductingEquipment;
struct ConductingEquipmentDefaultTypeInternal;
extern ConductingEquipmentDefaultTypeInternal _ConductingEquipment_default_instance_;
class ConductingEquipmentTerminalReading;
struct ConductingEquipmentTerminalReadingDefaultTypeInternal;
extern ConductingEquipmentTerminalReadingDefaultTypeInternal _ConductingEquipmentTerminalReading_default_instance_;
class ControlAPC;
struct ControlAPCDefaultTypeInternal;
extern ControlAPCDefaultTypeInternal _ControlAPC_default_instance_;
class ControlDPC;
struct ControlDPCDefaultTypeInternal;
extern ControlDPCDefaultTypeInternal _ControlDPC_default_instance_;
class ControlFSCC;
struct ControlFSCCDefaultTypeInternal;
extern ControlFSCCDefaultTypeInternal _ControlFSCC_default_instance_;
class ControlINC;
struct ControlINCDefaultTypeInternal;
extern ControlINCDefaultTypeInternal _ControlINC_default_instance_;
class ControlING;
struct ControlINGDefaultTypeInternal;
extern ControlINGDefaultTypeInternal _ControlING_default_instance_;
class ControlISC;
struct ControlISCDefaultTypeInternal;
extern ControlISCDefaultTypeInternal _ControlISC_default_instance_;
class ControlMessageInfo;
struct ControlMessageInfoDefaultTypeInternal;
extern ControlMessageInfoDefaultTypeInternal _ControlMessageInfo_default_instance_;
class ControlSPC;
struct ControlSPCDefaultTypeInternal;
extern ControlSPCDefaultTypeInternal _ControlSPC_default_instance_;
class ControlScheduleFSCH;
struct ControlScheduleFSCHDefaultTypeInternal;
extern ControlScheduleFSCHDefaultTypeInternal _ControlScheduleFSCH_default_instance_;
class ControlTimestamp;
struct ControlTimestampDefaultTypeInternal;
extern ControlTimestampDefaultTypeInternal _ControlTimestamp_default_instance_;
class ControlValue;
struct ControlValueDefaultTypeInternal;
extern ControlValueDefaultTypeInternal _ControlValue_default_instance_;
class CumulativeTime;
struct CumulativeTimeDefaultTypeInternal;
extern CumulativeTimeDefaultTypeInternal _CumulativeTime_default_instance_;
class DEL;
struct DELDefaultTypeInternal;
extern DELDefaultTypeInternal _DEL_default_instance_;
class DateTimeInterval;
struct DateTimeIntervalDefaultTypeInternal;
extern DateTimeIntervalDefaultTypeInternal _DateTimeInterval_default_instance_;
class DetailQual;
struct DetailQualDefaultTypeInternal;
extern DetailQualDefaultTypeInternal _DetailQual_default_instance_;
class DiscreteControlXCBR;
struct DiscreteControlXCBRDefaultTypeInternal;
extern DiscreteControlXCBRDefaultTypeInternal _DiscreteControlXCBR_default_instance_;
class ENG_CalcMethodKind;
struct ENG_CalcMethodKindDefaultTypeInternal;
extern ENG_CalcMethodKindDefaultTypeInternal _ENG_CalcMethodKind_default_instance_;
class ENG_GridConnectModeKind;
struct ENG_GridConnectModeKindDefaultTypeInternal;
extern ENG_GridConnectModeKindDefaultTypeInternal _ENG_GridConnectModeKind_default_instance_;
class ENG_PFSignKind;
struct ENG_PFSignKindDefaultTypeInternal;
extern ENG_PFSignKindDefaultTypeInternal _ENG_PFSignKind_default_instance_;
class ENG_ScheduleParameter;
struct ENG_ScheduleParameterDefaultTypeInternal;
extern ENG_ScheduleParameterDefaultTypeInternal _ENG_ScheduleParameter_default_instance_;
class ENS_BehaviourModeKind;
struct ENS_BehaviourModeKindDefaultTypeInternal;
extern ENS_BehaviourModeKindDefaultTypeInternal _ENS_BehaviourModeKind_default_instance_;
class ENS_DERGeneratorStateKind;
struct ENS_DERGeneratorStateKindDefaultTypeInternal;
extern ENS_DERGeneratorStateKindDefaultTypeInternal _ENS_DERGeneratorStateKind_default_instance_;
class ENS_DynamicTestKind;
struct ENS_DynamicTestKindDefaultTypeInternal;
extern ENS_DynamicTestKindDefaultTypeInternal _ENS_DynamicTestKind_default_instance_;
class ENS_GridConnectModeKind;
struct ENS_GridConnectModeKindDefaultTypeInternal;
extern ENS_GridConnectModeKindDefaultTypeInternal _ENS_GridConnectModeKind_default_instance_;
class ENS_HealthKind;
struct ENS_HealthKindDefaultTypeInternal;
extern ENS_HealthKindDefaultTypeInternal _ENS_HealthKind_default_instance_;
class ENS_SwitchingCapabilityKind;
struct ENS_SwitchingCapabilityKindDefaultTypeInternal;
extern ENS_SwitchingCapabilityKindDefaultTypeInternal _ENS_SwitchingCapabilityKind_default_instance_;
class ESS;
struct ESSDefaultTypeInternal;
extern ESSDefaultTypeInternal _ESS_default_instance_;
class EnergyConsumer;
struct EnergyConsumerDefaultTypeInternal;
extern EnergyConsumerDefaultTypeInternal _EnergyConsumer_default_instance_;
class EnterServiceAPC;
struct EnterServiceAPCDefaultTypeInternal;
extern EnterServiceAPCDefaultTypeInternal _EnterServiceAPC_default_instance_;
class EventMessageInfo;
struct EventMessageInfoDefaultTypeInternal;
extern EventMessageInfoDefaultTypeInternal _EventMessageInfo_default_instance_;
class EventValue;
struct EventValueDefaultTypeInternal;
extern EventValueDefaultTypeInternal _EventValue_default_instance_;
class ForecastIED;
struct ForecastIEDDefaultTypeInternal;
extern ForecastIEDDefaultTypeInternal _ForecastIED_default_instance_;
class ForecastValue;
struct ForecastValueDefaultTypeInternal;
extern ForecastValueDefaultTypeInternal _ForecastValue_default_instance_;
class ForecastValueSource;
struct ForecastValueSourceDefaultTypeInternal;
extern ForecastValueSourceDefaultTypeInternal _ForecastValueSource_default_instance_;
class HzWAPC;
struct HzWAPCDefaultTypeInternal;
extern HzWAPCDefaultTypeInternal _HzWAPC_default_instance_;
class HzWPoint;
struct HzWPointDefaultTypeInternal;
extern HzWPointDefaultTypeInternal _HzWPoint_default_instance_;
class IdentifiedObject;
struct IdentifiedObjectDefaultTypeInternal;
extern IdentifiedObjectDefaultTypeInternal _IdentifiedObject_default_instance_;
class IntegerEventAndStatusGGIO;
struct IntegerEventAndStatusGGIODefaultTypeInternal;
extern IntegerEventAndStatusGGIODefaultTypeInternal _IntegerEventAndStatusGGIO_default_instance_;
class LimitWAPC;
struct LimitWAPCDefaultTypeInternal;
extern LimitWAPCDefaultTypeInternal _LimitWAPC_default_instance_;
class LogicalNode;
struct LogicalNodeDefaultTypeInternal;
extern LogicalNodeDefaultTypeInternal _LogicalNode_default_instance_;
class LogicalNodeForControl;
struct LogicalNodeForControlDefaultTypeInternal;
extern LogicalNodeForControlDefaultTypeInternal _LogicalNodeForControl_default_instance_;
class LogicalNodeForEventAndStatus;
struct LogicalNodeForEventAndStatusDefaultTypeInternal;
extern LogicalNodeForEventAndStatusDefaultTypeInternal _LogicalNodeForEventAndStatus_default_instance_;
class MV;
struct MVDefaultTypeInternal;
extern MVDefaultTypeInternal _MV_default_instance_;
class MeasurementValue;
struct MeasurementValueDefaultTypeInternal;
extern MeasurementValueDefaultTypeInternal _MeasurementValue_default_instance_;
class MessageInfo;
struct MessageInfoDefaultTypeInternal;
extern MessageInfoDefaultTypeInternal _MessageInfo_default_instance_;
class Meter;
struct MeterDefaultTypeInternal;
extern MeterDefaultTypeInternal _Meter_default_instance_;
class NamedObject;
struct NamedObjectDefaultTypeInternal;
extern NamedObjectDefaultTypeInternal _NamedObject_default_instance_;
class NameplateValue;
struct NameplateValueDefaultTypeInternal;
extern NameplateValueDefaultTypeInternal _NameplateValue_default_instance_;
class OperationDCTE;
struct OperationDCTEDefaultTypeInternal;
extern OperationDCTEDefaultTypeInternal _OperationDCTE_default_instance_;
class OperationDFPF;
struct OperationDFPFDefaultTypeInternal;
extern OperationDFPFDefaultTypeInternal _OperationDFPF_default_instance_;
class OperationDHFW;
struct OperationDHFWDefaultTypeInternal;
extern OperationDHFWDefaultTypeInternal _OperationDHFW_default_instance_;
class OperationDLFW;
struct OperationDLFWDefaultTypeInternal;
extern OperationDLFWDefaultTypeInternal _OperationDLFW_default_instance_;
class OperationDVAR;
struct OperationDVARDefaultTypeInternal;
extern OperationDVARDefaultTypeInternal _OperationDVAR_default_instance_;
class OperationDVVR;
struct OperationDVVRDefaultTypeInternal;
extern OperationDVVRDefaultTypeInternal _OperationDVVR_default_instance_;
class OperationDVWC;
struct OperationDVWCDefaultTypeInternal;
extern OperationDVWCDefaultTypeInternal _OperationDVWC_default_instance_;
class OperationDWGC;
struct OperationDWGCDefaultTypeInternal;
extern OperationDWGCDefaultTypeInternal _OperationDWGC_default_instance_;
class OperationDWMN;
struct OperationDWMNDefaultTypeInternal;
extern OperationDWMNDefaultTypeInternal _OperationDWMN_default_instance_;
class OperationDWMX;
struct OperationDWMXDefaultTypeInternal;
extern OperationDWMXDefaultTypeInternal _OperationDWMX_default_instance_;
class OperationDWVR;
struct OperationDWVRDefaultTypeInternal;
extern OperationDWVRDefaultTypeInternal _OperationDWVR_default_instance_;
class OptimizationMessageInfo;
struct OptimizationMessageInfoDefaultTypeInternal;
extern OptimizationMessageInfoDefaultTypeInternal _OptimizationMessageInfo_default_instance_;
class Optional_AbnOpCatKind;
struct Optional_AbnOpCatKindDefaultTypeInternal;
extern Optional_AbnOpCatKindDefaultTypeInternal _Optional_AbnOpCatKind_default_instance_;
class Optional_AlrmKind;
struct Optional_AlrmKindDefaultTypeInternal;
extern Optional_AlrmKindDefaultTypeInternal _Optional_AlrmKind_default_instance_;
class Optional_BehaviourModeKind;
struct Optional_BehaviourModeKindDefaultTypeInternal;
extern Optional_BehaviourModeKindDefaultTypeInternal _Optional_BehaviourModeKind_default_instance_;
class Optional_CalcMethodKind;
struct Optional_CalcMethodKindDefaultTypeInternal;
extern Optional_CalcMethodKindDefaultTypeInternal _Optional_CalcMethodKind_default_instance_;
class Optional_ControlModeKind;
struct Optional_ControlModeKindDefaultTypeInternal;
extern Optional_ControlModeKindDefaultTypeInternal _Optional_ControlModeKind_default_instance_;
class Optional_DERGeneratorStateKind;
struct Optional_DERGeneratorStateKindDefaultTypeInternal;
extern Optional_DERGeneratorStateKindDefaultTypeInternal _Optional_DERGeneratorStateKind_default_instance_;
class Optional_DbPosKind;
struct Optional_DbPosKindDefaultTypeInternal;
extern Optional_DbPosKindDefaultTypeInternal _Optional_DbPosKind_default_instance_;
class Optional_DirectionModeKind;
struct Optional_DirectionModeKindDefaultTypeInternal;
extern Optional_DirectionModeKindDefaultTypeInternal _Optional_DirectionModeKind_default_instance_;
class Optional_DynamicTestKind;
struct Optional_DynamicTestKindDefaultTypeInternal;
extern Optional_DynamicTestKindDefaultTypeInternal _Optional_DynamicTestKind_default_instance_;
class Optional_FaultDirectionKind;
struct Optional_FaultDirectionKindDefaultTypeInternal;
extern Optional_FaultDirectionKindDefaultTypeInternal _Optional_FaultDirectionKind_default_instance_;
class Optional_GridConnectModeKind;
struct Optional_GridConnectModeKindDefaultTypeInternal;
extern Optional_GridConnectModeKindDefaultTypeInternal _Optional_GridConnectModeKind_default_instance_;
class Optional_GridConnectionStateKind;
struct Optional_GridConnectionStateKindDefaultTypeInternal;
extern Optional_GridConnectionStateKindDefaultTypeInternal _Optional_GridConnectionStateKind_default_instance_;
class Optional_HealthKind;
struct Optional_HealthKindDefaultTypeInternal;
extern Optional_HealthKindDefaultTypeInternal _Optional_HealthKind_default_instance_;
class Optional_NorOpCatKind;
struct Optional_NorOpCatKindDefaultTypeInternal;
extern Optional_NorOpCatKindDefaultTypeInternal _Optional_NorOpCatKind_default_instance_;
class Optional_OperatingStateKind;
struct Optional_OperatingStateKindDefaultTypeInternal;
extern Optional_OperatingStateKindDefaultTypeInternal _Optional_OperatingStateKind_default_instance_;
class Optional_PFSignKind;
struct Optional_PFSignKindDefaultTypeInternal;
extern Optional_PFSignKindDefaultTypeInternal _Optional_PFSignKind_default_instance_;
class Optional_PhaseCodeKind;
struct Optional_PhaseCodeKindDefaultTypeInternal;
extern Optional_PhaseCodeKindDefaultTypeInternal _Optional_PhaseCodeKind_default_instance_;
class Optional_PhaseFaultDirectionKind;
struct Optional_PhaseFaultDirectionKindDefaultTypeInternal;
extern Optional_PhaseFaultDirectionKindDefaultTypeInternal _Optional_PhaseFaultDirectionKind_default_instance_;
class Optional_ReactivePowerControlKind;
struct Optional_ReactivePowerControlKindDefaultTypeInternal;
extern Optional_ReactivePowerControlKindDefaultTypeInternal _Optional_ReactivePowerControlKind_default_instance_;
class Optional_RealPowerControlKind;
struct Optional_RealPowerControlKindDefaultTypeInternal;
extern Optional_RealPowerControlKindDefaultTypeInternal _Optional_RealPowerControlKind_default_instance_;
class Optional_RecloseActionKind;
struct Optional_RecloseActionKindDefaultTypeInternal;
extern Optional_RecloseActionKindDefaultTypeInternal _Optional_RecloseActionKind_default_instance_;
class Optional_ScheduleParameterKind;
struct Optional_ScheduleParameterKindDefaultTypeInternal;
extern Optional_ScheduleParameterKindDefaultTypeInternal _Optional_ScheduleParameterKind_default_instance_;
class Optional_SourceKind;
struct Optional_SourceKindDefaultTypeInternal;
extern Optional_SourceKindDefaultTypeInternal _Optional_SourceKind_default_instance_;
class Optional_StateKind;
struct Optional_StateKindDefaultTypeInternal;
extern Optional_StateKindDefaultTypeInternal _Optional_StateKind_default_instance_;
class Optional_SwitchingCapabilityKind;
struct Optional_SwitchingCapabilityKindDefaultTypeInternal;
extern Optional_SwitchingCapabilityKindDefaultTypeInternal _Optional_SwitchingCapabilityKind_default_instance_;
class Optional_TimeAccuracyKind;
struct Optional_TimeAccuracyKindDefaultTypeInternal;
extern Optional_TimeAccuracyKindDefaultTypeInternal _Optional_TimeAccuracyKind_default_instance_;
class Optional_UnitMultiplierKind;
struct Optional_UnitMultiplierKindDefaultTypeInternal;
extern Optional_UnitMultiplierKindDefaultTypeInternal _Optional_UnitMultiplierKind_default_instance_;
class Optional_UnitSymbolKind;
struct Optional_UnitSymbolKindDefaultTypeInternal;
extern Optional_UnitSymbolKindDefaultTypeInternal _Optional_UnitSymbolKind_default_instance_;
class Optional_ValidityKind;
struct Optional_ValidityKindDefaultTypeInternal;
extern Optional_ValidityKindDefaultTypeInternal _Optional_ValidityKind_default_instance_;
class Optional_VoltLimitModeKind;
struct Optional_VoltLimitModeKindDefaultTypeInternal;
extern Optional_VoltLimitModeKindDefaultTypeInternal _Optional_VoltLimitModeKind_default_instance_;
class PFSPC;
struct PFSPCDefaultTypeInternal;
extern PFSPCDefaultTypeInternal _PFSPC_default_instance_;
class PMG;
struct PMGDefaultTypeInternal;
extern PMGDefaultTypeInternal _PMG_default_instance_;
class PhaseAPC;
struct PhaseAPCDefaultTypeInternal;
extern PhaseAPCDefaultTypeInternal _PhaseAPC_default_instance_;
class PhaseDPC;
struct PhaseDPCDefaultTypeInternal;
extern PhaseDPCDefaultTypeInternal _PhaseDPC_default_instance_;
class PhaseDPS;
struct PhaseDPSDefaultTypeInternal;
extern PhaseDPSDefaultTypeInternal _PhaseDPS_default_instance_;
class PhaseINS;
struct PhaseINSDefaultTypeInternal;
extern PhaseINSDefaultTypeInternal _PhaseINS_default_instance_;
class PhaseISC;
struct PhaseISCDefaultTypeInternal;
extern PhaseISCDefaultTypeInternal _PhaseISC_default_instance_;
class PhaseMMTN;
struct PhaseMMTNDefaultTypeInternal;
extern PhaseMMTNDefaultTypeInternal _PhaseMMTN_default_instance_;
class PhaseRecloseAction;
struct PhaseRecloseActionDefaultTypeInternal;
extern PhaseRecloseActionDefaultTypeInternal _PhaseRecloseAction_default_instance_;
class PhaseSPC;
struct PhaseSPCDefaultTypeInternal;
extern PhaseSPCDefaultTypeInternal _PhaseSPC_default_instance_;
class PhaseSPS;
struct PhaseSPSDefaultTypeInternal;
extern PhaseSPSDefaultTypeInternal _PhaseSPS_default_instance_;
class Quality;
struct QualityDefaultTypeInternal;
extern QualityDefaultTypeInternal _Quality_default_instance_;
class RampRate;
struct RampRateDefaultTypeInternal;
extern RampRateDefaultTypeInternal _RampRate_default_instance_;
class ReadingMMTN;
struct ReadingMMTNDefaultTypeInternal;
extern ReadingMMTNDefaultTypeInternal _ReadingMMTN_default_instance_;
class ReadingMMTR;
struct ReadingMMTRDefaultTypeInternal;
extern ReadingMMTRDefaultTypeInternal _ReadingMMTR_default_instance_;
class ReadingMMXU;
struct ReadingMMXUDefaultTypeInternal;
extern ReadingMMXUDefaultTypeInternal _ReadingMMXU_default_instance_;
class ReadingMessageInfo;
struct ReadingMessageInfoDefaultTypeInternal;
extern ReadingMessageInfoDefaultTypeInternal _ReadingMessageInfo_default_instance_;
class ScheduleCSG;
struct ScheduleCSGDefaultTypeInternal;
extern ScheduleCSGDefaultTypeInternal _ScheduleCSG_default_instance_;
class SchedulePoint;
struct SchedulePointDefaultTypeInternal;
extern SchedulePointDefaultTypeInternal _SchedulePoint_default_instance_;
class SourceCapabilityConfiguration;
struct SourceCapabilityConfigurationDefaultTypeInternal;
extern SourceCapabilityConfigurationDefaultTypeInternal _SourceCapabilityConfiguration_default_instance_;
class SourceCapabilityRatings;
struct SourceCapabilityRatingsDefaultTypeInternal;
extern SourceCapabilityRatingsDefaultTypeInternal _SourceCapabilityRatings_default_instance_;
class StatusAndEventXCBR;
struct StatusAndEventXCBRDefaultTypeInternal;
extern StatusAndEventXCBRDefaultTypeInternal _StatusAndEventXCBR_default_instance_;
class StatusDPS;
struct StatusDPSDefaultTypeInternal;
extern StatusDPSDefaultTypeInternal _StatusDPS_default_instance_;
class StatusINC;
struct StatusINCDefaultTypeInternal;
extern StatusINCDefaultTypeInternal _StatusINC_default_instance_;
class StatusINS;
struct StatusINSDefaultTypeInternal;
extern StatusINSDefaultTypeInternal _StatusINS_default_instance_;
class StatusISC;
struct StatusISCDefaultTypeInternal;
extern StatusISCDefaultTypeInternal _StatusISC_default_instance_;
class StatusMessageInfo;
struct StatusMessageInfoDefaultTypeInternal;
extern StatusMessageInfoDefaultTypeInternal _StatusMessageInfo_default_instance_;
class StatusSPS;
struct StatusSPSDefaultTypeInternal;
extern StatusSPSDefaultTypeInternal _StatusSPS_default_instance_;
class StatusValue;
struct StatusValueDefaultTypeInternal;
extern StatusValueDefaultTypeInternal _StatusValue_default_instance_;
class StringEventAndStatusGGIO;
struct StringEventAndStatusGGIODefaultTypeInternal;
extern StringEventAndStatusGGIODefaultTypeInternal _StringEventAndStatusGGIO_default_instance_;
class SwitchCSG;
struct SwitchCSGDefaultTypeInternal;
extern SwitchCSGDefaultTypeInternal _SwitchCSG_default_instance_;
class SwitchPoint;
struct SwitchPointDefaultTypeInternal;
extern SwitchPointDefaultTypeInternal _SwitchPoint_default_instance_;
class Terminal;
struct TerminalDefaultTypeInternal;
extern TerminalDefaultTypeInternal _Terminal_default_instance_;
class TimeQuality;
struct TimeQualityDefaultTypeInternal;
extern TimeQualityDefaultTypeInternal _TimeQuality_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TmHzCSG;
struct TmHzCSGDefaultTypeInternal;
extern TmHzCSGDefaultTypeInternal _TmHzCSG_default_instance_;
class TmHzPoint;
struct TmHzPointDefaultTypeInternal;
extern TmHzPointDefaultTypeInternal _TmHzPoint_default_instance_;
class TmVoltCSG;
struct TmVoltCSGDefaultTypeInternal;
extern TmVoltCSGDefaultTypeInternal _TmVoltCSG_default_instance_;
class TmVoltPoint;
struct TmVoltPointDefaultTypeInternal;
extern TmVoltPointDefaultTypeInternal _TmVoltPoint_default_instance_;
class Unit;
struct UnitDefaultTypeInternal;
extern UnitDefaultTypeInternal _Unit_default_instance_;
class VSC;
struct VSCDefaultTypeInternal;
extern VSCDefaultTypeInternal _VSC_default_instance_;
class VSS;
struct VSSDefaultTypeInternal;
extern VSSDefaultTypeInternal _VSS_default_instance_;
class VarSPC;
struct VarSPCDefaultTypeInternal;
extern VarSPCDefaultTypeInternal _VarSPC_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class VoltVarCSG;
struct VoltVarCSGDefaultTypeInternal;
extern VoltVarCSGDefaultTypeInternal _VoltVarCSG_default_instance_;
class VoltVarPoint;
struct VoltVarPointDefaultTypeInternal;
extern VoltVarPointDefaultTypeInternal _VoltVarPoint_default_instance_;
class VoltWCSG;
struct VoltWCSGDefaultTypeInternal;
extern VoltWCSGDefaultTypeInternal _VoltWCSG_default_instance_;
class VoltWPoint;
struct VoltWPointDefaultTypeInternal;
extern VoltWPointDefaultTypeInternal _VoltWPoint_default_instance_;
class WSPC;
struct WSPCDefaultTypeInternal;
extern WSPCDefaultTypeInternal _WSPC_default_instance_;
class WVarCSG;
struct WVarCSGDefaultTypeInternal;
extern WVarCSGDefaultTypeInternal _WVarCSG_default_instance_;
class WVarPoint;
struct WVarPointDefaultTypeInternal;
extern WVarPointDefaultTypeInternal _WVarPoint_default_instance_;
class WYE;
struct WYEDefaultTypeInternal;
extern WYEDefaultTypeInternal _WYE_default_instance_;
}  // namespace commonmodule
PROTOBUF_NAMESPACE_OPEN
template <>
::commonmodule::ACD* Arena::CreateMaybeMessage<::commonmodule::ACD>(Arena*);
template <>
::commonmodule::ACDCTerminal* Arena::CreateMaybeMessage<::commonmodule::ACDCTerminal>(Arena*);
template <>
::commonmodule::ASG* Arena::CreateMaybeMessage<::commonmodule::ASG>(Arena*);
template <>
::commonmodule::ActivePower* Arena::CreateMaybeMessage<::commonmodule::ActivePower>(Arena*);
template <>
::commonmodule::AnalogEventAndStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::AnalogEventAndStatusGGIO>(Arena*);
template <>
::commonmodule::ApplicationSystem* Arena::CreateMaybeMessage<::commonmodule::ApplicationSystem>(Arena*);
template <>
::commonmodule::BCR* Arena::CreateMaybeMessage<::commonmodule::BCR>(Arena*);
template <>
::commonmodule::BooleanEventAndStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::BooleanEventAndStatusGGIO>(Arena*);
template <>
::commonmodule::CMV* Arena::CreateMaybeMessage<::commonmodule::CMV>(Arena*);
template <>
::commonmodule::CapabilityMessageInfo* Arena::CreateMaybeMessage<::commonmodule::CapabilityMessageInfo>(Arena*);
template <>
::commonmodule::CheckConditions* Arena::CreateMaybeMessage<::commonmodule::CheckConditions>(Arena*);
template <>
::commonmodule::ClearingTime* Arena::CreateMaybeMessage<::commonmodule::ClearingTime>(Arena*);
template <>
::commonmodule::ConductingEquipment* Arena::CreateMaybeMessage<::commonmodule::ConductingEquipment>(Arena*);
template <>
::commonmodule::ConductingEquipmentTerminalReading* Arena::CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(Arena*);
template <>
::commonmodule::ControlAPC* Arena::CreateMaybeMessage<::commonmodule::ControlAPC>(Arena*);
template <>
::commonmodule::ControlDPC* Arena::CreateMaybeMessage<::commonmodule::ControlDPC>(Arena*);
template <>
::commonmodule::ControlFSCC* Arena::CreateMaybeMessage<::commonmodule::ControlFSCC>(Arena*);
template <>
::commonmodule::ControlINC* Arena::CreateMaybeMessage<::commonmodule::ControlINC>(Arena*);
template <>
::commonmodule::ControlING* Arena::CreateMaybeMessage<::commonmodule::ControlING>(Arena*);
template <>
::commonmodule::ControlISC* Arena::CreateMaybeMessage<::commonmodule::ControlISC>(Arena*);
template <>
::commonmodule::ControlMessageInfo* Arena::CreateMaybeMessage<::commonmodule::ControlMessageInfo>(Arena*);
template <>
::commonmodule::ControlSPC* Arena::CreateMaybeMessage<::commonmodule::ControlSPC>(Arena*);
template <>
::commonmodule::ControlScheduleFSCH* Arena::CreateMaybeMessage<::commonmodule::ControlScheduleFSCH>(Arena*);
template <>
::commonmodule::ControlTimestamp* Arena::CreateMaybeMessage<::commonmodule::ControlTimestamp>(Arena*);
template <>
::commonmodule::ControlValue* Arena::CreateMaybeMessage<::commonmodule::ControlValue>(Arena*);
template <>
::commonmodule::CumulativeTime* Arena::CreateMaybeMessage<::commonmodule::CumulativeTime>(Arena*);
template <>
::commonmodule::DEL* Arena::CreateMaybeMessage<::commonmodule::DEL>(Arena*);
template <>
::commonmodule::DateTimeInterval* Arena::CreateMaybeMessage<::commonmodule::DateTimeInterval>(Arena*);
template <>
::commonmodule::DetailQual* Arena::CreateMaybeMessage<::commonmodule::DetailQual>(Arena*);
template <>
::commonmodule::DiscreteControlXCBR* Arena::CreateMaybeMessage<::commonmodule::DiscreteControlXCBR>(Arena*);
template <>
::commonmodule::ENG_CalcMethodKind* Arena::CreateMaybeMessage<::commonmodule::ENG_CalcMethodKind>(Arena*);
template <>
::commonmodule::ENG_GridConnectModeKind* Arena::CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(Arena*);
template <>
::commonmodule::ENG_PFSignKind* Arena::CreateMaybeMessage<::commonmodule::ENG_PFSignKind>(Arena*);
template <>
::commonmodule::ENG_ScheduleParameter* Arena::CreateMaybeMessage<::commonmodule::ENG_ScheduleParameter>(Arena*);
template <>
::commonmodule::ENS_BehaviourModeKind* Arena::CreateMaybeMessage<::commonmodule::ENS_BehaviourModeKind>(Arena*);
template <>
::commonmodule::ENS_DERGeneratorStateKind* Arena::CreateMaybeMessage<::commonmodule::ENS_DERGeneratorStateKind>(Arena*);
template <>
::commonmodule::ENS_DynamicTestKind* Arena::CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(Arena*);
template <>
::commonmodule::ENS_GridConnectModeKind* Arena::CreateMaybeMessage<::commonmodule::ENS_GridConnectModeKind>(Arena*);
template <>
::commonmodule::ENS_HealthKind* Arena::CreateMaybeMessage<::commonmodule::ENS_HealthKind>(Arena*);
template <>
::commonmodule::ENS_SwitchingCapabilityKind* Arena::CreateMaybeMessage<::commonmodule::ENS_SwitchingCapabilityKind>(Arena*);
template <>
::commonmodule::ESS* Arena::CreateMaybeMessage<::commonmodule::ESS>(Arena*);
template <>
::commonmodule::EnergyConsumer* Arena::CreateMaybeMessage<::commonmodule::EnergyConsumer>(Arena*);
template <>
::commonmodule::EnterServiceAPC* Arena::CreateMaybeMessage<::commonmodule::EnterServiceAPC>(Arena*);
template <>
::commonmodule::EventMessageInfo* Arena::CreateMaybeMessage<::commonmodule::EventMessageInfo>(Arena*);
template <>
::commonmodule::EventValue* Arena::CreateMaybeMessage<::commonmodule::EventValue>(Arena*);
template <>
::commonmodule::ForecastIED* Arena::CreateMaybeMessage<::commonmodule::ForecastIED>(Arena*);
template <>
::commonmodule::ForecastValue* Arena::CreateMaybeMessage<::commonmodule::ForecastValue>(Arena*);
template <>
::commonmodule::ForecastValueSource* Arena::CreateMaybeMessage<::commonmodule::ForecastValueSource>(Arena*);
template <>
::commonmodule::HzWAPC* Arena::CreateMaybeMessage<::commonmodule::HzWAPC>(Arena*);
template <>
::commonmodule::HzWPoint* Arena::CreateMaybeMessage<::commonmodule::HzWPoint>(Arena*);
template <>
::commonmodule::IdentifiedObject* Arena::CreateMaybeMessage<::commonmodule::IdentifiedObject>(Arena*);
template <>
::commonmodule::IntegerEventAndStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::IntegerEventAndStatusGGIO>(Arena*);
template <>
::commonmodule::LimitWAPC* Arena::CreateMaybeMessage<::commonmodule::LimitWAPC>(Arena*);
template <>
::commonmodule::LogicalNode* Arena::CreateMaybeMessage<::commonmodule::LogicalNode>(Arena*);
template <>
::commonmodule::LogicalNodeForControl* Arena::CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(Arena*);
template <>
::commonmodule::LogicalNodeForEventAndStatus* Arena::CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(Arena*);
template <>
::commonmodule::MV* Arena::CreateMaybeMessage<::commonmodule::MV>(Arena*);
template <>
::commonmodule::MeasurementValue* Arena::CreateMaybeMessage<::commonmodule::MeasurementValue>(Arena*);
template <>
::commonmodule::MessageInfo* Arena::CreateMaybeMessage<::commonmodule::MessageInfo>(Arena*);
template <>
::commonmodule::Meter* Arena::CreateMaybeMessage<::commonmodule::Meter>(Arena*);
template <>
::commonmodule::NamedObject* Arena::CreateMaybeMessage<::commonmodule::NamedObject>(Arena*);
template <>
::commonmodule::NameplateValue* Arena::CreateMaybeMessage<::commonmodule::NameplateValue>(Arena*);
template <>
::commonmodule::OperationDCTE* Arena::CreateMaybeMessage<::commonmodule::OperationDCTE>(Arena*);
template <>
::commonmodule::OperationDFPF* Arena::CreateMaybeMessage<::commonmodule::OperationDFPF>(Arena*);
template <>
::commonmodule::OperationDHFW* Arena::CreateMaybeMessage<::commonmodule::OperationDHFW>(Arena*);
template <>
::commonmodule::OperationDLFW* Arena::CreateMaybeMessage<::commonmodule::OperationDLFW>(Arena*);
template <>
::commonmodule::OperationDVAR* Arena::CreateMaybeMessage<::commonmodule::OperationDVAR>(Arena*);
template <>
::commonmodule::OperationDVVR* Arena::CreateMaybeMessage<::commonmodule::OperationDVVR>(Arena*);
template <>
::commonmodule::OperationDVWC* Arena::CreateMaybeMessage<::commonmodule::OperationDVWC>(Arena*);
template <>
::commonmodule::OperationDWGC* Arena::CreateMaybeMessage<::commonmodule::OperationDWGC>(Arena*);
template <>
::commonmodule::OperationDWMN* Arena::CreateMaybeMessage<::commonmodule::OperationDWMN>(Arena*);
template <>
::commonmodule::OperationDWMX* Arena::CreateMaybeMessage<::commonmodule::OperationDWMX>(Arena*);
template <>
::commonmodule::OperationDWVR* Arena::CreateMaybeMessage<::commonmodule::OperationDWVR>(Arena*);
template <>
::commonmodule::OptimizationMessageInfo* Arena::CreateMaybeMessage<::commonmodule::OptimizationMessageInfo>(Arena*);
template <>
::commonmodule::Optional_AbnOpCatKind* Arena::CreateMaybeMessage<::commonmodule::Optional_AbnOpCatKind>(Arena*);
template <>
::commonmodule::Optional_AlrmKind* Arena::CreateMaybeMessage<::commonmodule::Optional_AlrmKind>(Arena*);
template <>
::commonmodule::Optional_BehaviourModeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_BehaviourModeKind>(Arena*);
template <>
::commonmodule::Optional_CalcMethodKind* Arena::CreateMaybeMessage<::commonmodule::Optional_CalcMethodKind>(Arena*);
template <>
::commonmodule::Optional_ControlModeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_ControlModeKind>(Arena*);
template <>
::commonmodule::Optional_DERGeneratorStateKind* Arena::CreateMaybeMessage<::commonmodule::Optional_DERGeneratorStateKind>(Arena*);
template <>
::commonmodule::Optional_DbPosKind* Arena::CreateMaybeMessage<::commonmodule::Optional_DbPosKind>(Arena*);
template <>
::commonmodule::Optional_DirectionModeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_DirectionModeKind>(Arena*);
template <>
::commonmodule::Optional_DynamicTestKind* Arena::CreateMaybeMessage<::commonmodule::Optional_DynamicTestKind>(Arena*);
template <>
::commonmodule::Optional_FaultDirectionKind* Arena::CreateMaybeMessage<::commonmodule::Optional_FaultDirectionKind>(Arena*);
template <>
::commonmodule::Optional_GridConnectModeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_GridConnectModeKind>(Arena*);
template <>
::commonmodule::Optional_GridConnectionStateKind* Arena::CreateMaybeMessage<::commonmodule::Optional_GridConnectionStateKind>(Arena*);
template <>
::commonmodule::Optional_HealthKind* Arena::CreateMaybeMessage<::commonmodule::Optional_HealthKind>(Arena*);
template <>
::commonmodule::Optional_NorOpCatKind* Arena::CreateMaybeMessage<::commonmodule::Optional_NorOpCatKind>(Arena*);
template <>
::commonmodule::Optional_OperatingStateKind* Arena::CreateMaybeMessage<::commonmodule::Optional_OperatingStateKind>(Arena*);
template <>
::commonmodule::Optional_PFSignKind* Arena::CreateMaybeMessage<::commonmodule::Optional_PFSignKind>(Arena*);
template <>
::commonmodule::Optional_PhaseCodeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(Arena*);
template <>
::commonmodule::Optional_PhaseFaultDirectionKind* Arena::CreateMaybeMessage<::commonmodule::Optional_PhaseFaultDirectionKind>(Arena*);
template <>
::commonmodule::Optional_ReactivePowerControlKind* Arena::CreateMaybeMessage<::commonmodule::Optional_ReactivePowerControlKind>(Arena*);
template <>
::commonmodule::Optional_RealPowerControlKind* Arena::CreateMaybeMessage<::commonmodule::Optional_RealPowerControlKind>(Arena*);
template <>
::commonmodule::Optional_RecloseActionKind* Arena::CreateMaybeMessage<::commonmodule::Optional_RecloseActionKind>(Arena*);
template <>
::commonmodule::Optional_ScheduleParameterKind* Arena::CreateMaybeMessage<::commonmodule::Optional_ScheduleParameterKind>(Arena*);
template <>
::commonmodule::Optional_SourceKind* Arena::CreateMaybeMessage<::commonmodule::Optional_SourceKind>(Arena*);
template <>
::commonmodule::Optional_StateKind* Arena::CreateMaybeMessage<::commonmodule::Optional_StateKind>(Arena*);
template <>
::commonmodule::Optional_SwitchingCapabilityKind* Arena::CreateMaybeMessage<::commonmodule::Optional_SwitchingCapabilityKind>(Arena*);
template <>
::commonmodule::Optional_TimeAccuracyKind* Arena::CreateMaybeMessage<::commonmodule::Optional_TimeAccuracyKind>(Arena*);
template <>
::commonmodule::Optional_UnitMultiplierKind* Arena::CreateMaybeMessage<::commonmodule::Optional_UnitMultiplierKind>(Arena*);
template <>
::commonmodule::Optional_UnitSymbolKind* Arena::CreateMaybeMessage<::commonmodule::Optional_UnitSymbolKind>(Arena*);
template <>
::commonmodule::Optional_ValidityKind* Arena::CreateMaybeMessage<::commonmodule::Optional_ValidityKind>(Arena*);
template <>
::commonmodule::Optional_VoltLimitModeKind* Arena::CreateMaybeMessage<::commonmodule::Optional_VoltLimitModeKind>(Arena*);
template <>
::commonmodule::PFSPC* Arena::CreateMaybeMessage<::commonmodule::PFSPC>(Arena*);
template <>
::commonmodule::PMG* Arena::CreateMaybeMessage<::commonmodule::PMG>(Arena*);
template <>
::commonmodule::PhaseAPC* Arena::CreateMaybeMessage<::commonmodule::PhaseAPC>(Arena*);
template <>
::commonmodule::PhaseDPC* Arena::CreateMaybeMessage<::commonmodule::PhaseDPC>(Arena*);
template <>
::commonmodule::PhaseDPS* Arena::CreateMaybeMessage<::commonmodule::PhaseDPS>(Arena*);
template <>
::commonmodule::PhaseINS* Arena::CreateMaybeMessage<::commonmodule::PhaseINS>(Arena*);
template <>
::commonmodule::PhaseISC* Arena::CreateMaybeMessage<::commonmodule::PhaseISC>(Arena*);
template <>
::commonmodule::PhaseMMTN* Arena::CreateMaybeMessage<::commonmodule::PhaseMMTN>(Arena*);
template <>
::commonmodule::PhaseRecloseAction* Arena::CreateMaybeMessage<::commonmodule::PhaseRecloseAction>(Arena*);
template <>
::commonmodule::PhaseSPC* Arena::CreateMaybeMessage<::commonmodule::PhaseSPC>(Arena*);
template <>
::commonmodule::PhaseSPS* Arena::CreateMaybeMessage<::commonmodule::PhaseSPS>(Arena*);
template <>
::commonmodule::Quality* Arena::CreateMaybeMessage<::commonmodule::Quality>(Arena*);
template <>
::commonmodule::RampRate* Arena::CreateMaybeMessage<::commonmodule::RampRate>(Arena*);
template <>
::commonmodule::ReadingMMTN* Arena::CreateMaybeMessage<::commonmodule::ReadingMMTN>(Arena*);
template <>
::commonmodule::ReadingMMTR* Arena::CreateMaybeMessage<::commonmodule::ReadingMMTR>(Arena*);
template <>
::commonmodule::ReadingMMXU* Arena::CreateMaybeMessage<::commonmodule::ReadingMMXU>(Arena*);
template <>
::commonmodule::ReadingMessageInfo* Arena::CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(Arena*);
template <>
::commonmodule::ScheduleCSG* Arena::CreateMaybeMessage<::commonmodule::ScheduleCSG>(Arena*);
template <>
::commonmodule::SchedulePoint* Arena::CreateMaybeMessage<::commonmodule::SchedulePoint>(Arena*);
template <>
::commonmodule::SourceCapabilityConfiguration* Arena::CreateMaybeMessage<::commonmodule::SourceCapabilityConfiguration>(Arena*);
template <>
::commonmodule::SourceCapabilityRatings* Arena::CreateMaybeMessage<::commonmodule::SourceCapabilityRatings>(Arena*);
template <>
::commonmodule::StatusAndEventXCBR* Arena::CreateMaybeMessage<::commonmodule::StatusAndEventXCBR>(Arena*);
template <>
::commonmodule::StatusDPS* Arena::CreateMaybeMessage<::commonmodule::StatusDPS>(Arena*);
template <>
::commonmodule::StatusINC* Arena::CreateMaybeMessage<::commonmodule::StatusINC>(Arena*);
template <>
::commonmodule::StatusINS* Arena::CreateMaybeMessage<::commonmodule::StatusINS>(Arena*);
template <>
::commonmodule::StatusISC* Arena::CreateMaybeMessage<::commonmodule::StatusISC>(Arena*);
template <>
::commonmodule::StatusMessageInfo* Arena::CreateMaybeMessage<::commonmodule::StatusMessageInfo>(Arena*);
template <>
::commonmodule::StatusSPS* Arena::CreateMaybeMessage<::commonmodule::StatusSPS>(Arena*);
template <>
::commonmodule::StatusValue* Arena::CreateMaybeMessage<::commonmodule::StatusValue>(Arena*);
template <>
::commonmodule::StringEventAndStatusGGIO* Arena::CreateMaybeMessage<::commonmodule::StringEventAndStatusGGIO>(Arena*);
template <>
::commonmodule::SwitchCSG* Arena::CreateMaybeMessage<::commonmodule::SwitchCSG>(Arena*);
template <>
::commonmodule::SwitchPoint* Arena::CreateMaybeMessage<::commonmodule::SwitchPoint>(Arena*);
template <>
::commonmodule::Terminal* Arena::CreateMaybeMessage<::commonmodule::Terminal>(Arena*);
template <>
::commonmodule::TimeQuality* Arena::CreateMaybeMessage<::commonmodule::TimeQuality>(Arena*);
template <>
::commonmodule::Timestamp* Arena::CreateMaybeMessage<::commonmodule::Timestamp>(Arena*);
template <>
::commonmodule::TmHzCSG* Arena::CreateMaybeMessage<::commonmodule::TmHzCSG>(Arena*);
template <>
::commonmodule::TmHzPoint* Arena::CreateMaybeMessage<::commonmodule::TmHzPoint>(Arena*);
template <>
::commonmodule::TmVoltCSG* Arena::CreateMaybeMessage<::commonmodule::TmVoltCSG>(Arena*);
template <>
::commonmodule::TmVoltPoint* Arena::CreateMaybeMessage<::commonmodule::TmVoltPoint>(Arena*);
template <>
::commonmodule::Unit* Arena::CreateMaybeMessage<::commonmodule::Unit>(Arena*);
template <>
::commonmodule::VSC* Arena::CreateMaybeMessage<::commonmodule::VSC>(Arena*);
template <>
::commonmodule::VSS* Arena::CreateMaybeMessage<::commonmodule::VSS>(Arena*);
template <>
::commonmodule::VarSPC* Arena::CreateMaybeMessage<::commonmodule::VarSPC>(Arena*);
template <>
::commonmodule::Vector* Arena::CreateMaybeMessage<::commonmodule::Vector>(Arena*);
template <>
::commonmodule::VoltVarCSG* Arena::CreateMaybeMessage<::commonmodule::VoltVarCSG>(Arena*);
template <>
::commonmodule::VoltVarPoint* Arena::CreateMaybeMessage<::commonmodule::VoltVarPoint>(Arena*);
template <>
::commonmodule::VoltWCSG* Arena::CreateMaybeMessage<::commonmodule::VoltWCSG>(Arena*);
template <>
::commonmodule::VoltWPoint* Arena::CreateMaybeMessage<::commonmodule::VoltWPoint>(Arena*);
template <>
::commonmodule::WSPC* Arena::CreateMaybeMessage<::commonmodule::WSPC>(Arena*);
template <>
::commonmodule::WVarCSG* Arena::CreateMaybeMessage<::commonmodule::WVarCSG>(Arena*);
template <>
::commonmodule::WVarPoint* Arena::CreateMaybeMessage<::commonmodule::WVarPoint>(Arena*);
template <>
::commonmodule::WYE* Arena::CreateMaybeMessage<::commonmodule::WYE>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace commonmodule {
enum FaultDirectionKind : int {
  FaultDirectionKind_UNDEFINED = 0,
  FaultDirectionKind_unknown = 1,
  FaultDirectionKind_forward = 2,
  FaultDirectionKind_backward = 3,
  FaultDirectionKind_both = 4,
  FaultDirectionKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FaultDirectionKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FaultDirectionKind_IsValid(int value);
constexpr FaultDirectionKind FaultDirectionKind_MIN = static_cast<FaultDirectionKind>(0);
constexpr FaultDirectionKind FaultDirectionKind_MAX = static_cast<FaultDirectionKind>(4);
constexpr int FaultDirectionKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FaultDirectionKind_descriptor();
template <typename T>
const std::string& FaultDirectionKind_Name(T value) {
  static_assert(std::is_same<T, FaultDirectionKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FaultDirectionKind_Name().");
  return FaultDirectionKind_Name(static_cast<FaultDirectionKind>(value));
}
template <>
inline const std::string& FaultDirectionKind_Name(FaultDirectionKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FaultDirectionKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool FaultDirectionKind_Parse(absl::string_view name, FaultDirectionKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FaultDirectionKind>(
      FaultDirectionKind_descriptor(), name, value);
}
enum PhaseFaultDirectionKind : int {
  PhaseFaultDirectionKind_UNDEFINED = 0,
  PhaseFaultDirectionKind_unknown = 1,
  PhaseFaultDirectionKind_forward = 2,
  PhaseFaultDirectionKind_backward = 3,
  PhaseFaultDirectionKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PhaseFaultDirectionKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PhaseFaultDirectionKind_IsValid(int value);
constexpr PhaseFaultDirectionKind PhaseFaultDirectionKind_MIN = static_cast<PhaseFaultDirectionKind>(0);
constexpr PhaseFaultDirectionKind PhaseFaultDirectionKind_MAX = static_cast<PhaseFaultDirectionKind>(3);
constexpr int PhaseFaultDirectionKind_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PhaseFaultDirectionKind_descriptor();
template <typename T>
const std::string& PhaseFaultDirectionKind_Name(T value) {
  static_assert(std::is_same<T, PhaseFaultDirectionKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PhaseFaultDirectionKind_Name().");
  return PhaseFaultDirectionKind_Name(static_cast<PhaseFaultDirectionKind>(value));
}
template <>
inline const std::string& PhaseFaultDirectionKind_Name(PhaseFaultDirectionKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PhaseFaultDirectionKind_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PhaseFaultDirectionKind_Parse(absl::string_view name, PhaseFaultDirectionKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhaseFaultDirectionKind>(
      PhaseFaultDirectionKind_descriptor(), name, value);
}
enum UnitSymbolKind : int {
  UnitSymbolKind_none = 0,
  UnitSymbolKind_meter = 2,
  UnitSymbolKind_gram = 3,
  UnitSymbolKind_Amp = 5,
  UnitSymbolKind_deg = 9,
  UnitSymbolKind_rad = 10,
  UnitSymbolKind_degC = 23,
  UnitSymbolKind_Farad = 25,
  UnitSymbolKind_sec = 27,
  UnitSymbolKind_Henry = 28,
  UnitSymbolKind_V = 29,
  UnitSymbolKind_ohm = 30,
  UnitSymbolKind_Joule = 31,
  UnitSymbolKind_Newton = 32,
  UnitSymbolKind_Hz = 33,
  UnitSymbolKind_W = 38,
  UnitSymbolKind_Pa = 39,
  UnitSymbolKind_m2 = 41,
  UnitSymbolKind_Siemens = 53,
  UnitSymbolKind_VA = 61,
  UnitSymbolKind_VAr = 63,
  UnitSymbolKind_wPerVA = 65,
  UnitSymbolKind_VAh = 71,
  UnitSymbolKind_Wh = 72,
  UnitSymbolKind_VArh = 73,
  UnitSymbolKind_hzPerS = 75,
  UnitSymbolKind_wPerS = 81,
  UnitSymbolKind_other = 100,
  UnitSymbolKind_Ah = 106,
  UnitSymbolKind_min = 159,
  UnitSymbolKind_hour = 160,
  UnitSymbolKind_m3 = 166,
  UnitSymbolKind_wPerM2 = 179,
  UnitSymbolKind_degF = 279,
  UnitSymbolKind_mph = 500,
  UnitSymbolKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UnitSymbolKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UnitSymbolKind_IsValid(int value);
constexpr UnitSymbolKind UnitSymbolKind_MIN = static_cast<UnitSymbolKind>(0);
constexpr UnitSymbolKind UnitSymbolKind_MAX = static_cast<UnitSymbolKind>(500);
constexpr int UnitSymbolKind_ARRAYSIZE = 500 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
UnitSymbolKind_descriptor();
template <typename T>
const std::string& UnitSymbolKind_Name(T value) {
  static_assert(std::is_same<T, UnitSymbolKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UnitSymbolKind_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(UnitSymbolKind_descriptor(), value);
}
inline bool UnitSymbolKind_Parse(absl::string_view name, UnitSymbolKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnitSymbolKind>(
      UnitSymbolKind_descriptor(), name, value);
}
enum UnitMultiplierKind : int {
  UnitMultiplierKind_UNDEFINED = 0,
  UnitMultiplierKind_none = 1,
  UnitMultiplierKind_other = 2,
  UnitMultiplierKind_centi = 3,
  UnitMultiplierKind_deci = 4,
  UnitMultiplierKind_Giga = 5,
  UnitMultiplierKind_kilo = 6,
  UnitMultiplierKind_Mega = 7,
  UnitMultiplierKind_micro = 8,
  UnitMultiplierKind_milli = 9,
  UnitMultiplierKind_nano = 10,
  UnitMultiplierKind_pico = 11,
  UnitMultiplierKind_Tera = 12,
  UnitMultiplierKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UnitMultiplierKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UnitMultiplierKind_IsValid(int value);
constexpr UnitMultiplierKind UnitMultiplierKind_MIN = static_cast<UnitMultiplierKind>(0);
constexpr UnitMultiplierKind UnitMultiplierKind_MAX = static_cast<UnitMultiplierKind>(12);
constexpr int UnitMultiplierKind_ARRAYSIZE = 12 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
UnitMultiplierKind_descriptor();
template <typename T>
const std::string& UnitMultiplierKind_Name(T value) {
  static_assert(std::is_same<T, UnitMultiplierKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UnitMultiplierKind_Name().");
  return UnitMultiplierKind_Name(static_cast<UnitMultiplierKind>(value));
}
template <>
inline const std::string& UnitMultiplierKind_Name(UnitMultiplierKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<UnitMultiplierKind_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool UnitMultiplierKind_Parse(absl::string_view name, UnitMultiplierKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnitMultiplierKind>(
      UnitMultiplierKind_descriptor(), name, value);
}
enum PhaseCodeKind : int {
  PhaseCodeKind_none = 0,
  PhaseCodeKind_other = 1,
  PhaseCodeKind_N = 16,
  PhaseCodeKind_C = 32,
  PhaseCodeKind_CN = 33,
  PhaseCodeKind_AC = 40,
  PhaseCodeKind_ACN = 41,
  PhaseCodeKind_B = 64,
  PhaseCodeKind_BN = 65,
  PhaseCodeKind_BC = 66,
  PhaseCodeKind_BCN = 97,
  PhaseCodeKind_A = 128,
  PhaseCodeKind_AN = 129,
  PhaseCodeKind_AB = 132,
  PhaseCodeKind_ABN = 193,
  PhaseCodeKind_ABC = 224,
  PhaseCodeKind_ABCN = 225,
  PhaseCodeKind_s2 = 256,
  PhaseCodeKind_s2N = 257,
  PhaseCodeKind_s1 = 512,
  PhaseCodeKind_s1N = 513,
  PhaseCodeKind_s12 = 768,
  PhaseCodeKind_s12N = 769,
  PhaseCodeKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PhaseCodeKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PhaseCodeKind_IsValid(int value);
constexpr PhaseCodeKind PhaseCodeKind_MIN = static_cast<PhaseCodeKind>(0);
constexpr PhaseCodeKind PhaseCodeKind_MAX = static_cast<PhaseCodeKind>(769);
constexpr int PhaseCodeKind_ARRAYSIZE = 769 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PhaseCodeKind_descriptor();
template <typename T>
const std::string& PhaseCodeKind_Name(T value) {
  static_assert(std::is_same<T, PhaseCodeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PhaseCodeKind_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(PhaseCodeKind_descriptor(), value);
}
inline bool PhaseCodeKind_Parse(absl::string_view name, PhaseCodeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhaseCodeKind>(
      PhaseCodeKind_descriptor(), name, value);
}
enum ValidityKind : int {
  ValidityKind_UNDEFINED = 0,
  ValidityKind_good = 1,
  ValidityKind_invalid = 2,
  ValidityKind_reserved = 3,
  ValidityKind_questionable = 4,
  ValidityKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ValidityKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ValidityKind_IsValid(int value);
constexpr ValidityKind ValidityKind_MIN = static_cast<ValidityKind>(0);
constexpr ValidityKind ValidityKind_MAX = static_cast<ValidityKind>(4);
constexpr int ValidityKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ValidityKind_descriptor();
template <typename T>
const std::string& ValidityKind_Name(T value) {
  static_assert(std::is_same<T, ValidityKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ValidityKind_Name().");
  return ValidityKind_Name(static_cast<ValidityKind>(value));
}
template <>
inline const std::string& ValidityKind_Name(ValidityKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ValidityKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ValidityKind_Parse(absl::string_view name, ValidityKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidityKind>(
      ValidityKind_descriptor(), name, value);
}
enum SourceKind : int {
  SourceKind_UNDEFINED = 0,
  SourceKind_process = 1,
  SourceKind_substituted = 2,
  SourceKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SourceKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SourceKind_IsValid(int value);
constexpr SourceKind SourceKind_MIN = static_cast<SourceKind>(0);
constexpr SourceKind SourceKind_MAX = static_cast<SourceKind>(2);
constexpr int SourceKind_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SourceKind_descriptor();
template <typename T>
const std::string& SourceKind_Name(T value) {
  static_assert(std::is_same<T, SourceKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SourceKind_Name().");
  return SourceKind_Name(static_cast<SourceKind>(value));
}
template <>
inline const std::string& SourceKind_Name(SourceKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SourceKind_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SourceKind_Parse(absl::string_view name, SourceKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SourceKind>(
      SourceKind_descriptor(), name, value);
}
enum TimeAccuracyKind : int {
  TimeAccuracyKind_UNDEFINED = 0,
  TimeAccuracyKind_T0 = 7,
  TimeAccuracyKind_T1 = 10,
  TimeAccuracyKind_T2 = 14,
  TimeAccuracyKind_T3 = 16,
  TimeAccuracyKind_T4 = 18,
  TimeAccuracyKind_T5 = 20,
  TimeAccuracyKind_unspecified = 31,
  TimeAccuracyKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TimeAccuracyKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TimeAccuracyKind_IsValid(int value);
constexpr TimeAccuracyKind TimeAccuracyKind_MIN = static_cast<TimeAccuracyKind>(0);
constexpr TimeAccuracyKind TimeAccuracyKind_MAX = static_cast<TimeAccuracyKind>(31);
constexpr int TimeAccuracyKind_ARRAYSIZE = 31 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TimeAccuracyKind_descriptor();
template <typename T>
const std::string& TimeAccuracyKind_Name(T value) {
  static_assert(std::is_same<T, TimeAccuracyKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TimeAccuracyKind_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(TimeAccuracyKind_descriptor(), value);
}
inline bool TimeAccuracyKind_Parse(absl::string_view name, TimeAccuracyKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeAccuracyKind>(
      TimeAccuracyKind_descriptor(), name, value);
}
enum ScheduleParameterKind : int {
  ScheduleParameterKind_UNDEFINED = 0,
  ScheduleParameterKind_none = 1,
  ScheduleParameterKind_other = 2,
  ScheduleParameterKind_A_net_mag = 3,
  ScheduleParameterKind_A_neut_mag = 4,
  ScheduleParameterKind_A_phsA_mag = 5,
  ScheduleParameterKind_A_phsB_mag = 6,
  ScheduleParameterKind_A_phsC_mag = 7,
  ScheduleParameterKind_Hz_mag = 8,
  ScheduleParameterKind_PF_net_mag = 9,
  ScheduleParameterKind_PF_neut_mag = 10,
  ScheduleParameterKind_PF_phsA_mag = 11,
  ScheduleParameterKind_PF_phsB_mag = 12,
  ScheduleParameterKind_PF_phsC_mag = 13,
  ScheduleParameterKind_PhV_net_ang = 14,
  ScheduleParameterKind_PhV_net_mag = 15,
  ScheduleParameterKind_PhV_neut_ang = 16,
  ScheduleParameterKind_PhV_neut_mag = 17,
  ScheduleParameterKind_PhV_phsA_ang = 18,
  ScheduleParameterKind_PhV_phsA_mag = 19,
  ScheduleParameterKind_PhV_phsB_ang = 20,
  ScheduleParameterKind_PhV_phsB_mag = 21,
  ScheduleParameterKind_PhV_phsC_ang = 22,
  ScheduleParameterKind_PhV_phsC_mag = 23,
  ScheduleParameterKind_PPV_phsAB_ang = 24,
  ScheduleParameterKind_PPV_phsAB_mag = 25,
  ScheduleParameterKind_PPV_phsBC_ang = 26,
  ScheduleParameterKind_PPV_phsBC_mag = 27,
  ScheduleParameterKind_PPV_phsCA_ang = 28,
  ScheduleParameterKind_PPV_phsCA_mag = 29,
  ScheduleParameterKind_VA_net_mag = 30,
  ScheduleParameterKind_VA_neut_mag = 31,
  ScheduleParameterKind_VA_phsA_mag = 32,
  ScheduleParameterKind_VA_phsB_mag = 33,
  ScheduleParameterKind_VA_phsC_mag = 34,
  ScheduleParameterKind_VAr_net_mag = 35,
  ScheduleParameterKind_VAr_neut_mag = 36,
  ScheduleParameterKind_VAr_phsA_mag = 37,
  ScheduleParameterKind_VAr_phsB_mag = 38,
  ScheduleParameterKind_VAr_phsC_mag = 39,
  ScheduleParameterKind_W_net_mag = 40,
  ScheduleParameterKind_W_neut_mag = 41,
  ScheduleParameterKind_W_phsA_mag = 42,
  ScheduleParameterKind_W_phsB_mag = 43,
  ScheduleParameterKind_W_phsC_mag = 44,
  ScheduleParameterKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ScheduleParameterKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ScheduleParameterKind_IsValid(int value);
constexpr ScheduleParameterKind ScheduleParameterKind_MIN = static_cast<ScheduleParameterKind>(0);
constexpr ScheduleParameterKind ScheduleParameterKind_MAX = static_cast<ScheduleParameterKind>(44);
constexpr int ScheduleParameterKind_ARRAYSIZE = 44 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ScheduleParameterKind_descriptor();
template <typename T>
const std::string& ScheduleParameterKind_Name(T value) {
  static_assert(std::is_same<T, ScheduleParameterKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScheduleParameterKind_Name().");
  return ScheduleParameterKind_Name(static_cast<ScheduleParameterKind>(value));
}
template <>
inline const std::string& ScheduleParameterKind_Name(ScheduleParameterKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ScheduleParameterKind_descriptor,
                                                 0, 44>(
      static_cast<int>(value));
}
inline bool ScheduleParameterKind_Parse(absl::string_view name, ScheduleParameterKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScheduleParameterKind>(
      ScheduleParameterKind_descriptor(), name, value);
}
enum CalcMethodKind : int {
  CalcMethodKind_UNDEFINED = 0,
  CalcMethodKind_P_CLASS = 11,
  CalcMethodKind_M_CLASS = 12,
  CalcMethodKind_DIFF = 13,
  CalcMethodKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CalcMethodKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CalcMethodKind_IsValid(int value);
constexpr CalcMethodKind CalcMethodKind_MIN = static_cast<CalcMethodKind>(0);
constexpr CalcMethodKind CalcMethodKind_MAX = static_cast<CalcMethodKind>(13);
constexpr int CalcMethodKind_ARRAYSIZE = 13 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CalcMethodKind_descriptor();
template <typename T>
const std::string& CalcMethodKind_Name(T value) {
  static_assert(std::is_same<T, CalcMethodKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CalcMethodKind_Name().");
  return CalcMethodKind_Name(static_cast<CalcMethodKind>(value));
}
template <>
inline const std::string& CalcMethodKind_Name(CalcMethodKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CalcMethodKind_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool CalcMethodKind_Parse(absl::string_view name, CalcMethodKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CalcMethodKind>(
      CalcMethodKind_descriptor(), name, value);
}
enum GridConnectModeKind : int {
  GridConnectModeKind_UNDEFINED = 0,
  GridConnectModeKind_CSI = 1,
  GridConnectModeKind_VC_VSI = 2,
  GridConnectModeKind_CC_VSI = 3,
  GridConnectModeKind_none = 98,
  GridConnectModeKind_other = 99,
  GridConnectModeKind_VSI_PQ = 2000,
  GridConnectModeKind_VSI_VF = 2001,
  GridConnectModeKind_VSI_ISO = 2002,
  GridConnectModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GridConnectModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GridConnectModeKind_IsValid(int value);
constexpr GridConnectModeKind GridConnectModeKind_MIN = static_cast<GridConnectModeKind>(0);
constexpr GridConnectModeKind GridConnectModeKind_MAX = static_cast<GridConnectModeKind>(2002);
constexpr int GridConnectModeKind_ARRAYSIZE = 2002 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
GridConnectModeKind_descriptor();
template <typename T>
const std::string& GridConnectModeKind_Name(T value) {
  static_assert(std::is_same<T, GridConnectModeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GridConnectModeKind_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(GridConnectModeKind_descriptor(), value);
}
inline bool GridConnectModeKind_Parse(absl::string_view name, GridConnectModeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GridConnectModeKind>(
      GridConnectModeKind_descriptor(), name, value);
}
enum PFSignKind : int {
  PFSignKind_UNDEFINED = 0,
  PFSignKind_IEC = 1,
  PFSignKind_EEI = 2,
  PFSignKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PFSignKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PFSignKind_IsValid(int value);
constexpr PFSignKind PFSignKind_MIN = static_cast<PFSignKind>(0);
constexpr PFSignKind PFSignKind_MAX = static_cast<PFSignKind>(2);
constexpr int PFSignKind_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PFSignKind_descriptor();
template <typename T>
const std::string& PFSignKind_Name(T value) {
  static_assert(std::is_same<T, PFSignKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PFSignKind_Name().");
  return PFSignKind_Name(static_cast<PFSignKind>(value));
}
template <>
inline const std::string& PFSignKind_Name(PFSignKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PFSignKind_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PFSignKind_Parse(absl::string_view name, PFSignKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PFSignKind>(
      PFSignKind_descriptor(), name, value);
}
enum BehaviourModeKind : int {
  BehaviourModeKind_UNDEFINED = 0,
  BehaviourModeKind_on = 1,
  BehaviourModeKind_blocked = 2,
  BehaviourModeKind_test = 3,
  BehaviourModeKind_test_blocked = 4,
  BehaviourModeKind_off = 5,
  BehaviourModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BehaviourModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BehaviourModeKind_IsValid(int value);
constexpr BehaviourModeKind BehaviourModeKind_MIN = static_cast<BehaviourModeKind>(0);
constexpr BehaviourModeKind BehaviourModeKind_MAX = static_cast<BehaviourModeKind>(5);
constexpr int BehaviourModeKind_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
BehaviourModeKind_descriptor();
template <typename T>
const std::string& BehaviourModeKind_Name(T value) {
  static_assert(std::is_same<T, BehaviourModeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BehaviourModeKind_Name().");
  return BehaviourModeKind_Name(static_cast<BehaviourModeKind>(value));
}
template <>
inline const std::string& BehaviourModeKind_Name(BehaviourModeKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<BehaviourModeKind_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool BehaviourModeKind_Parse(absl::string_view name, BehaviourModeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BehaviourModeKind>(
      BehaviourModeKind_descriptor(), name, value);
}
enum DERGeneratorStateKind : int {
  DERGeneratorStateKind_UNDEFINED = 0,
  DERGeneratorStateKind_Not_operating = 1,
  DERGeneratorStateKind_Operating = 2,
  DERGeneratorStateKind_Starting_up = 3,
  DERGeneratorStateKind_Shutting_down = 4,
  DERGeneratorStateKind_At_disconnect_level = 5,
  DERGeneratorStateKind_Ramping_in_power = 6,
  DERGeneratorStateKind_Ramping_in_reactive_power = 7,
  DERGeneratorStateKind_Standby = 8,
  DERGeneratorStateKind_Not_applicable_Unknown = 98,
  DERGeneratorStateKind_Other = 99,
  DERGeneratorStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DERGeneratorStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DERGeneratorStateKind_IsValid(int value);
constexpr DERGeneratorStateKind DERGeneratorStateKind_MIN = static_cast<DERGeneratorStateKind>(0);
constexpr DERGeneratorStateKind DERGeneratorStateKind_MAX = static_cast<DERGeneratorStateKind>(99);
constexpr int DERGeneratorStateKind_ARRAYSIZE = 99 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DERGeneratorStateKind_descriptor();
template <typename T>
const std::string& DERGeneratorStateKind_Name(T value) {
  static_assert(std::is_same<T, DERGeneratorStateKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DERGeneratorStateKind_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(DERGeneratorStateKind_descriptor(), value);
}
inline bool DERGeneratorStateKind_Parse(absl::string_view name, DERGeneratorStateKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DERGeneratorStateKind>(
      DERGeneratorStateKind_descriptor(), name, value);
}
enum DynamicTestKind : int {
  DynamicTestKind_UNDEFINED = 0,
  DynamicTestKind_none = 1,
  DynamicTestKind_testing = 2,
  DynamicTestKind_operating = 3,
  DynamicTestKind_failed = 4,
  DynamicTestKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DynamicTestKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DynamicTestKind_IsValid(int value);
constexpr DynamicTestKind DynamicTestKind_MIN = static_cast<DynamicTestKind>(0);
constexpr DynamicTestKind DynamicTestKind_MAX = static_cast<DynamicTestKind>(4);
constexpr int DynamicTestKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DynamicTestKind_descriptor();
template <typename T>
const std::string& DynamicTestKind_Name(T value) {
  static_assert(std::is_same<T, DynamicTestKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DynamicTestKind_Name().");
  return DynamicTestKind_Name(static_cast<DynamicTestKind>(value));
}
template <>
inline const std::string& DynamicTestKind_Name(DynamicTestKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DynamicTestKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DynamicTestKind_Parse(absl::string_view name, DynamicTestKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DynamicTestKind>(
      DynamicTestKind_descriptor(), name, value);
}
enum HealthKind : int {
  HealthKind_UNDEFINED = 0,
  HealthKind_none = 1,
  HealthKind_OK = 2,
  HealthKind_Warning = 3,
  HealthKind_Alarm = 4,
  HealthKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HealthKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HealthKind_IsValid(int value);
constexpr HealthKind HealthKind_MIN = static_cast<HealthKind>(0);
constexpr HealthKind HealthKind_MAX = static_cast<HealthKind>(4);
constexpr int HealthKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
HealthKind_descriptor();
template <typename T>
const std::string& HealthKind_Name(T value) {
  static_assert(std::is_same<T, HealthKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HealthKind_Name().");
  return HealthKind_Name(static_cast<HealthKind>(value));
}
template <>
inline const std::string& HealthKind_Name(HealthKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<HealthKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool HealthKind_Parse(absl::string_view name, HealthKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HealthKind>(
      HealthKind_descriptor(), name, value);
}
enum SwitchingCapabilityKind : int {
  SwitchingCapabilityKind_UNDEFINED = 0,
  SwitchingCapabilityKind_none = 1,
  SwitchingCapabilityKind_open = 2,
  SwitchingCapabilityKind_close = 3,
  SwitchingCapabilityKind_open_and_close = 4,
  SwitchingCapabilityKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SwitchingCapabilityKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SwitchingCapabilityKind_IsValid(int value);
constexpr SwitchingCapabilityKind SwitchingCapabilityKind_MIN = static_cast<SwitchingCapabilityKind>(0);
constexpr SwitchingCapabilityKind SwitchingCapabilityKind_MAX = static_cast<SwitchingCapabilityKind>(4);
constexpr int SwitchingCapabilityKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SwitchingCapabilityKind_descriptor();
template <typename T>
const std::string& SwitchingCapabilityKind_Name(T value) {
  static_assert(std::is_same<T, SwitchingCapabilityKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SwitchingCapabilityKind_Name().");
  return SwitchingCapabilityKind_Name(static_cast<SwitchingCapabilityKind>(value));
}
template <>
inline const std::string& SwitchingCapabilityKind_Name(SwitchingCapabilityKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SwitchingCapabilityKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SwitchingCapabilityKind_Parse(absl::string_view name, SwitchingCapabilityKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SwitchingCapabilityKind>(
      SwitchingCapabilityKind_descriptor(), name, value);
}
enum DbPosKind : int {
  DbPosKind_UNDEFINED = 0,
  DbPosKind_transient = 1,
  DbPosKind_closed = 2,
  DbPosKind_open = 3,
  DbPosKind_invalid = 4,
  DbPosKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DbPosKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DbPosKind_IsValid(int value);
constexpr DbPosKind DbPosKind_MIN = static_cast<DbPosKind>(0);
constexpr DbPosKind DbPosKind_MAX = static_cast<DbPosKind>(4);
constexpr int DbPosKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DbPosKind_descriptor();
template <typename T>
const std::string& DbPosKind_Name(T value) {
  static_assert(std::is_same<T, DbPosKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DbPosKind_Name().");
  return DbPosKind_Name(static_cast<DbPosKind>(value));
}
template <>
inline const std::string& DbPosKind_Name(DbPosKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DbPosKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DbPosKind_Parse(absl::string_view name, DbPosKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DbPosKind>(
      DbPosKind_descriptor(), name, value);
}
enum RecloseActionKind : int {
  RecloseActionKind_UNDEFINED = 0,
  RecloseActionKind_idle = 1,
  RecloseActionKind_cycling = 2,
  RecloseActionKind_lockout = 3,
  RecloseActionKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RecloseActionKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RecloseActionKind_IsValid(int value);
constexpr RecloseActionKind RecloseActionKind_MIN = static_cast<RecloseActionKind>(0);
constexpr RecloseActionKind RecloseActionKind_MAX = static_cast<RecloseActionKind>(3);
constexpr int RecloseActionKind_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RecloseActionKind_descriptor();
template <typename T>
const std::string& RecloseActionKind_Name(T value) {
  static_assert(std::is_same<T, RecloseActionKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RecloseActionKind_Name().");
  return RecloseActionKind_Name(static_cast<RecloseActionKind>(value));
}
template <>
inline const std::string& RecloseActionKind_Name(RecloseActionKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RecloseActionKind_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RecloseActionKind_Parse(absl::string_view name, RecloseActionKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecloseActionKind>(
      RecloseActionKind_descriptor(), name, value);
}
enum NorOpCatKind : int {
  NorOpCatKind_UNDEFINED = 0,
  NorOpCatKind_A = 1,
  NorOpCatKind_B = 2,
  NorOpCatKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NorOpCatKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NorOpCatKind_IsValid(int value);
constexpr NorOpCatKind NorOpCatKind_MIN = static_cast<NorOpCatKind>(0);
constexpr NorOpCatKind NorOpCatKind_MAX = static_cast<NorOpCatKind>(2);
constexpr int NorOpCatKind_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
NorOpCatKind_descriptor();
template <typename T>
const std::string& NorOpCatKind_Name(T value) {
  static_assert(std::is_same<T, NorOpCatKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NorOpCatKind_Name().");
  return NorOpCatKind_Name(static_cast<NorOpCatKind>(value));
}
template <>
inline const std::string& NorOpCatKind_Name(NorOpCatKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<NorOpCatKind_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NorOpCatKind_Parse(absl::string_view name, NorOpCatKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NorOpCatKind>(
      NorOpCatKind_descriptor(), name, value);
}
enum AbnOpCatKind : int {
  AbnOpCatKind_UNDEFINED = 0,
  AbnOpCatKind_I = 1,
  AbnOpCatKind_II = 2,
  AbnOpCatKind_III = 3,
  AbnOpCatKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AbnOpCatKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AbnOpCatKind_IsValid(int value);
constexpr AbnOpCatKind AbnOpCatKind_MIN = static_cast<AbnOpCatKind>(0);
constexpr AbnOpCatKind AbnOpCatKind_MAX = static_cast<AbnOpCatKind>(3);
constexpr int AbnOpCatKind_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AbnOpCatKind_descriptor();
template <typename T>
const std::string& AbnOpCatKind_Name(T value) {
  static_assert(std::is_same<T, AbnOpCatKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AbnOpCatKind_Name().");
  return AbnOpCatKind_Name(static_cast<AbnOpCatKind>(value));
}
template <>
inline const std::string& AbnOpCatKind_Name(AbnOpCatKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AbnOpCatKind_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AbnOpCatKind_Parse(absl::string_view name, AbnOpCatKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AbnOpCatKind>(
      AbnOpCatKind_descriptor(), name, value);
}
enum AlrmKind : int {
  AlrmKind_ground_fault = 0,
  AlrmKind_dc_over_voltage = 1,
  AlrmKind_ac_disconnect_open = 2,
  AlrmKind_dc_disconnect_open = 3,
  AlrmKind_grid_disconnect = 4,
  AlrmKind_cabinet_open = 5,
  AlrmKind_manual_shutdown = 6,
  AlrmKind_over_temperature = 7,
  AlrmKind_frequency_above_limit = 8,
  AlrmKind_frequency_under_limit = 9,
  AlrmKind_ac_voltage_above_limit = 10,
  AlrmKind_ac_voltage_under_limit = 11,
  AlrmKind_blown_string_fuse_on_input = 12,
  AlrmKind_under_temperature = 13,
  AlrmKind_generic_memory_or_communication_error = 14,
  AlrmKind_hardware_test_failure = 15,
  AlrmKind_manufacturer_alarm = 16,
  AlrmKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AlrmKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AlrmKind_IsValid(int value);
constexpr AlrmKind AlrmKind_MIN = static_cast<AlrmKind>(0);
constexpr AlrmKind AlrmKind_MAX = static_cast<AlrmKind>(16);
constexpr int AlrmKind_ARRAYSIZE = 16 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AlrmKind_descriptor();
template <typename T>
const std::string& AlrmKind_Name(T value) {
  static_assert(std::is_same<T, AlrmKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AlrmKind_Name().");
  return AlrmKind_Name(static_cast<AlrmKind>(value));
}
template <>
inline const std::string& AlrmKind_Name(AlrmKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AlrmKind_descriptor,
                                                 0, 16>(
      static_cast<int>(value));
}
inline bool AlrmKind_Parse(absl::string_view name, AlrmKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlrmKind>(
      AlrmKind_descriptor(), name, value);
}
enum ControlModeKind : int {
  ControlModeKind_UNDEFINED = 0,
  ControlModeKind_auto = 1,
  ControlModeKind_manual = 2,
  ControlModeKind_override = 3,
  ControlModeKind_remote = 4,
  ControlModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControlModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControlModeKind_IsValid(int value);
constexpr ControlModeKind ControlModeKind_MIN = static_cast<ControlModeKind>(0);
constexpr ControlModeKind ControlModeKind_MAX = static_cast<ControlModeKind>(4);
constexpr int ControlModeKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ControlModeKind_descriptor();
template <typename T>
const std::string& ControlModeKind_Name(T value) {
  static_assert(std::is_same<T, ControlModeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ControlModeKind_Name().");
  return ControlModeKind_Name(static_cast<ControlModeKind>(value));
}
template <>
inline const std::string& ControlModeKind_Name(ControlModeKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ControlModeKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ControlModeKind_Parse(absl::string_view name, ControlModeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlModeKind>(
      ControlModeKind_descriptor(), name, value);
}
enum DirectionModeKind : int {
  DirectionModeKind_UNDEFINED = 0,
  DirectionModeKind_locked_forward = 1,
  DirectionModeKind_locked_reverse = 2,
  DirectionModeKind_reverse_idle = 3,
  DirectionModeKind_bidirectional = 4,
  DirectionModeKind_neutral_idle = 5,
  DirectionModeKind_cogeneration = 6,
  DirectionModeKind_reactive_bidirectional = 7,
  DirectionModeKind_bias_bidirectional = 8,
  DirectionModeKind_bias_cogeneration = 9,
  DirectionModeKind_reverse_cogeneration = 10,
  DirectionModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DirectionModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DirectionModeKind_IsValid(int value);
constexpr DirectionModeKind DirectionModeKind_MIN = static_cast<DirectionModeKind>(0);
constexpr DirectionModeKind DirectionModeKind_MAX = static_cast<DirectionModeKind>(10);
constexpr int DirectionModeKind_ARRAYSIZE = 10 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DirectionModeKind_descriptor();
template <typename T>
const std::string& DirectionModeKind_Name(T value) {
  static_assert(std::is_same<T, DirectionModeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DirectionModeKind_Name().");
  return DirectionModeKind_Name(static_cast<DirectionModeKind>(value));
}
template <>
inline const std::string& DirectionModeKind_Name(DirectionModeKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DirectionModeKind_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool DirectionModeKind_Parse(absl::string_view name, DirectionModeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DirectionModeKind>(
      DirectionModeKind_descriptor(), name, value);
}
enum GridConnectionStateKind : int {
  GridConnectionStateKind_disconnected = 0,
  GridConnectionStateKind_connected = 1,
  GridConnectionStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GridConnectionStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GridConnectionStateKind_IsValid(int value);
constexpr GridConnectionStateKind GridConnectionStateKind_MIN = static_cast<GridConnectionStateKind>(0);
constexpr GridConnectionStateKind GridConnectionStateKind_MAX = static_cast<GridConnectionStateKind>(1);
constexpr int GridConnectionStateKind_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
GridConnectionStateKind_descriptor();
template <typename T>
const std::string& GridConnectionStateKind_Name(T value) {
  static_assert(std::is_same<T, GridConnectionStateKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GridConnectionStateKind_Name().");
  return GridConnectionStateKind_Name(static_cast<GridConnectionStateKind>(value));
}
template <>
inline const std::string& GridConnectionStateKind_Name(GridConnectionStateKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<GridConnectionStateKind_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool GridConnectionStateKind_Parse(absl::string_view name, GridConnectionStateKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GridConnectionStateKind>(
      GridConnectionStateKind_descriptor(), name, value);
}
enum OperatingStateKind : int {
  OperatingStateKind_UNDEFINED = 0,
  OperatingStateKind_off = 1,
  OperatingStateKind_disconnected_and_standby = 2,
  OperatingStateKind_disconnected_and_available = 3,
  OperatingStateKind_disconnected_and_authorized = 4,
  OperatingStateKind_starting_and_synchronizing = 5,
  OperatingStateKind_connected_and_idle = 6,
  OperatingStateKind_connected_and_generating = 7,
  OperatingStateKind_connected_and_consuming = 8,
  OperatingStateKind_stopping = 9,
  OperatingStateKind_disconnected_and_blocked = 10,
  OperatingStateKind_disconnected_and_in_maintenance = 11,
  OperatingStateKind_ceased_to_energize = 12,
  OperatingStateKind_failed = 13,
  OperatingStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OperatingStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OperatingStateKind_IsValid(int value);
constexpr OperatingStateKind OperatingStateKind_MIN = static_cast<OperatingStateKind>(0);
constexpr OperatingStateKind OperatingStateKind_MAX = static_cast<OperatingStateKind>(13);
constexpr int OperatingStateKind_ARRAYSIZE = 13 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OperatingStateKind_descriptor();
template <typename T>
const std::string& OperatingStateKind_Name(T value) {
  static_assert(std::is_same<T, OperatingStateKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperatingStateKind_Name().");
  return OperatingStateKind_Name(static_cast<OperatingStateKind>(value));
}
template <>
inline const std::string& OperatingStateKind_Name(OperatingStateKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OperatingStateKind_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool OperatingStateKind_Parse(absl::string_view name, OperatingStateKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperatingStateKind>(
      OperatingStateKind_descriptor(), name, value);
}
enum ReactivePowerControlKind : int {
  ReactivePowerControlKind_UNDEFINED = 0,
  ReactivePowerControlKind_advanced = 1,
  ReactivePowerControlKind_droop = 2,
  ReactivePowerControlKind_voltage = 3,
  ReactivePowerControlKind_reactivePower = 4,
  ReactivePowerControlKind_powerFactor = 5,
  ReactivePowerControlKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ReactivePowerControlKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ReactivePowerControlKind_IsValid(int value);
constexpr ReactivePowerControlKind ReactivePowerControlKind_MIN = static_cast<ReactivePowerControlKind>(0);
constexpr ReactivePowerControlKind ReactivePowerControlKind_MAX = static_cast<ReactivePowerControlKind>(5);
constexpr int ReactivePowerControlKind_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ReactivePowerControlKind_descriptor();
template <typename T>
const std::string& ReactivePowerControlKind_Name(T value) {
  static_assert(std::is_same<T, ReactivePowerControlKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReactivePowerControlKind_Name().");
  return ReactivePowerControlKind_Name(static_cast<ReactivePowerControlKind>(value));
}
template <>
inline const std::string& ReactivePowerControlKind_Name(ReactivePowerControlKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ReactivePowerControlKind_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ReactivePowerControlKind_Parse(absl::string_view name, ReactivePowerControlKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReactivePowerControlKind>(
      ReactivePowerControlKind_descriptor(), name, value);
}
enum RealPowerControlKind : int {
  RealPowerControlKind_UNDEFINED = 0,
  RealPowerControlKind_advanced = 1,
  RealPowerControlKind_droop = 2,
  RealPowerControlKind_isochronous = 3,
  RealPowerControlKind_realPower = 4,
  RealPowerControlKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RealPowerControlKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RealPowerControlKind_IsValid(int value);
constexpr RealPowerControlKind RealPowerControlKind_MIN = static_cast<RealPowerControlKind>(0);
constexpr RealPowerControlKind RealPowerControlKind_MAX = static_cast<RealPowerControlKind>(4);
constexpr int RealPowerControlKind_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RealPowerControlKind_descriptor();
template <typename T>
const std::string& RealPowerControlKind_Name(T value) {
  static_assert(std::is_same<T, RealPowerControlKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RealPowerControlKind_Name().");
  return RealPowerControlKind_Name(static_cast<RealPowerControlKind>(value));
}
template <>
inline const std::string& RealPowerControlKind_Name(RealPowerControlKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RealPowerControlKind_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool RealPowerControlKind_Parse(absl::string_view name, RealPowerControlKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RealPowerControlKind>(
      RealPowerControlKind_descriptor(), name, value);
}
enum StateKind : int {
  StateKind_UNDEFINED = 0,
  StateKind_off = 1,
  StateKind_on = 2,
  StateKind_standby = 3,
  StateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StateKind_IsValid(int value);
constexpr StateKind StateKind_MIN = static_cast<StateKind>(0);
constexpr StateKind StateKind_MAX = static_cast<StateKind>(3);
constexpr int StateKind_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
StateKind_descriptor();
template <typename T>
const std::string& StateKind_Name(T value) {
  static_assert(std::is_same<T, StateKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StateKind_Name().");
  return StateKind_Name(static_cast<StateKind>(value));
}
template <>
inline const std::string& StateKind_Name(StateKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<StateKind_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool StateKind_Parse(absl::string_view name, StateKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateKind>(
      StateKind_descriptor(), name, value);
}
enum VoltLimitModeKind : int {
  VoltLimitModeKind_UNDEFINED = 0,
  VoltLimitModeKind_off = 1,
  VoltLimitModeKind_high_limit_only = 2,
  VoltLimitModeKind_low_limit_only = 3,
  VoltLimitModeKind_high_low_limits = 4,
  VoltLimitModeKind_ivvc_high_limit_only = 5,
  VoltLimitModeKind_ivvc_low_limit_only = 6,
  VoltLimitModeKind_ivvc_high_low_limits = 7,
  VoltLimitModeKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VoltLimitModeKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VoltLimitModeKind_IsValid(int value);
constexpr VoltLimitModeKind VoltLimitModeKind_MIN = static_cast<VoltLimitModeKind>(0);
constexpr VoltLimitModeKind VoltLimitModeKind_MAX = static_cast<VoltLimitModeKind>(7);
constexpr int VoltLimitModeKind_ARRAYSIZE = 7 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
VoltLimitModeKind_descriptor();
template <typename T>
const std::string& VoltLimitModeKind_Name(T value) {
  static_assert(std::is_same<T, VoltLimitModeKind>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VoltLimitModeKind_Name().");
  return VoltLimitModeKind_Name(static_cast<VoltLimitModeKind>(value));
}
template <>
inline const std::string& VoltLimitModeKind_Name(VoltLimitModeKind value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<VoltLimitModeKind_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool VoltLimitModeKind_Parse(absl::string_view name, VoltLimitModeKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VoltLimitModeKind>(
      VoltLimitModeKind_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Optional_FaultDirectionKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_FaultDirectionKind) */ {
 public:
  inline Optional_FaultDirectionKind() : Optional_FaultDirectionKind(nullptr) {}
  ~Optional_FaultDirectionKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_FaultDirectionKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_FaultDirectionKind(const Optional_FaultDirectionKind& from);
  Optional_FaultDirectionKind(Optional_FaultDirectionKind&& from) noexcept
    : Optional_FaultDirectionKind() {
    *this = ::std::move(from);
  }

  inline Optional_FaultDirectionKind& operator=(const Optional_FaultDirectionKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_FaultDirectionKind& operator=(Optional_FaultDirectionKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_FaultDirectionKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_FaultDirectionKind* internal_default_instance() {
    return reinterpret_cast<const Optional_FaultDirectionKind*>(
               &_Optional_FaultDirectionKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Optional_FaultDirectionKind& a, Optional_FaultDirectionKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_FaultDirectionKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_FaultDirectionKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_FaultDirectionKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_FaultDirectionKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_FaultDirectionKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_FaultDirectionKind& from) {
    Optional_FaultDirectionKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_FaultDirectionKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_FaultDirectionKind";
  }
  protected:
  explicit Optional_FaultDirectionKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.FaultDirectionKind value = 1;
  void clear_value() ;
  ::commonmodule::FaultDirectionKind value() const;
  void set_value(::commonmodule::FaultDirectionKind value);

  private:
  ::commonmodule::FaultDirectionKind _internal_value() const;
  void _internal_set_value(::commonmodule::FaultDirectionKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_FaultDirectionKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_PhaseFaultDirectionKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_PhaseFaultDirectionKind) */ {
 public:
  inline Optional_PhaseFaultDirectionKind() : Optional_PhaseFaultDirectionKind(nullptr) {}
  ~Optional_PhaseFaultDirectionKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_PhaseFaultDirectionKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_PhaseFaultDirectionKind(const Optional_PhaseFaultDirectionKind& from);
  Optional_PhaseFaultDirectionKind(Optional_PhaseFaultDirectionKind&& from) noexcept
    : Optional_PhaseFaultDirectionKind() {
    *this = ::std::move(from);
  }

  inline Optional_PhaseFaultDirectionKind& operator=(const Optional_PhaseFaultDirectionKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_PhaseFaultDirectionKind& operator=(Optional_PhaseFaultDirectionKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_PhaseFaultDirectionKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_PhaseFaultDirectionKind* internal_default_instance() {
    return reinterpret_cast<const Optional_PhaseFaultDirectionKind*>(
               &_Optional_PhaseFaultDirectionKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Optional_PhaseFaultDirectionKind& a, Optional_PhaseFaultDirectionKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_PhaseFaultDirectionKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_PhaseFaultDirectionKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_PhaseFaultDirectionKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_PhaseFaultDirectionKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_PhaseFaultDirectionKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_PhaseFaultDirectionKind& from) {
    Optional_PhaseFaultDirectionKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_PhaseFaultDirectionKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_PhaseFaultDirectionKind";
  }
  protected:
  explicit Optional_PhaseFaultDirectionKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.PhaseFaultDirectionKind value = 1;
  void clear_value() ;
  ::commonmodule::PhaseFaultDirectionKind value() const;
  void set_value(::commonmodule::PhaseFaultDirectionKind value);

  private:
  ::commonmodule::PhaseFaultDirectionKind _internal_value() const;
  void _internal_set_value(::commonmodule::PhaseFaultDirectionKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_PhaseFaultDirectionKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ACD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ACD) */ {
 public:
  inline ACD() : ACD(nullptr) {}
  ~ACD() override;
  explicit PROTOBUF_CONSTEXPR ACD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ACD(const ACD& from);
  ACD(ACD&& from) noexcept
    : ACD() {
    *this = ::std::move(from);
  }

  inline ACD& operator=(const ACD& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACD& operator=(ACD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACD& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACD* internal_default_instance() {
    return reinterpret_cast<const ACD*>(
               &_ACD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ACD& a, ACD& b) {
    a.Swap(&b);
  }
  inline void Swap(ACD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACD* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ACD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ACD& from) {
    ACD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ACD";
  }
  protected:
  explicit ACD(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirNeutFieldNumber = 2,
    kDirPhsAFieldNumber = 3,
    kDirPhsBFieldNumber = 4,
    kDirPhsCFieldNumber = 5,
    kNeutFieldNumber = 7,
    kPhsAFieldNumber = 8,
    kPhsBFieldNumber = 9,
    kPhsCFieldNumber = 10,
    kDirGeneralFieldNumber = 1,
    kGeneralFieldNumber = 6,
  };
  // .commonmodule.Optional_PhaseFaultDirectionKind dirNeut = 2;
  bool has_dirneut() const;
  private:
  bool _internal_has_dirneut() const;

  public:
  void clear_dirneut() ;
  const ::commonmodule::Optional_PhaseFaultDirectionKind& dirneut() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseFaultDirectionKind* release_dirneut();
  ::commonmodule::Optional_PhaseFaultDirectionKind* mutable_dirneut();
  void set_allocated_dirneut(::commonmodule::Optional_PhaseFaultDirectionKind* dirneut);
  private:
  const ::commonmodule::Optional_PhaseFaultDirectionKind& _internal_dirneut() const;
  ::commonmodule::Optional_PhaseFaultDirectionKind* _internal_mutable_dirneut();
  public:
  void unsafe_arena_set_allocated_dirneut(
      ::commonmodule::Optional_PhaseFaultDirectionKind* dirneut);
  ::commonmodule::Optional_PhaseFaultDirectionKind* unsafe_arena_release_dirneut();
  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsA = 3;
  bool has_dirphsa() const;
  private:
  bool _internal_has_dirphsa() const;

  public:
  void clear_dirphsa() ;
  const ::commonmodule::Optional_PhaseFaultDirectionKind& dirphsa() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseFaultDirectionKind* release_dirphsa();
  ::commonmodule::Optional_PhaseFaultDirectionKind* mutable_dirphsa();
  void set_allocated_dirphsa(::commonmodule::Optional_PhaseFaultDirectionKind* dirphsa);
  private:
  const ::commonmodule::Optional_PhaseFaultDirectionKind& _internal_dirphsa() const;
  ::commonmodule::Optional_PhaseFaultDirectionKind* _internal_mutable_dirphsa();
  public:
  void unsafe_arena_set_allocated_dirphsa(
      ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsa);
  ::commonmodule::Optional_PhaseFaultDirectionKind* unsafe_arena_release_dirphsa();
  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsB = 4;
  bool has_dirphsb() const;
  private:
  bool _internal_has_dirphsb() const;

  public:
  void clear_dirphsb() ;
  const ::commonmodule::Optional_PhaseFaultDirectionKind& dirphsb() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseFaultDirectionKind* release_dirphsb();
  ::commonmodule::Optional_PhaseFaultDirectionKind* mutable_dirphsb();
  void set_allocated_dirphsb(::commonmodule::Optional_PhaseFaultDirectionKind* dirphsb);
  private:
  const ::commonmodule::Optional_PhaseFaultDirectionKind& _internal_dirphsb() const;
  ::commonmodule::Optional_PhaseFaultDirectionKind* _internal_mutable_dirphsb();
  public:
  void unsafe_arena_set_allocated_dirphsb(
      ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsb);
  ::commonmodule::Optional_PhaseFaultDirectionKind* unsafe_arena_release_dirphsb();
  // .commonmodule.Optional_PhaseFaultDirectionKind dirPhsC = 5;
  bool has_dirphsc() const;
  private:
  bool _internal_has_dirphsc() const;

  public:
  void clear_dirphsc() ;
  const ::commonmodule::Optional_PhaseFaultDirectionKind& dirphsc() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseFaultDirectionKind* release_dirphsc();
  ::commonmodule::Optional_PhaseFaultDirectionKind* mutable_dirphsc();
  void set_allocated_dirphsc(::commonmodule::Optional_PhaseFaultDirectionKind* dirphsc);
  private:
  const ::commonmodule::Optional_PhaseFaultDirectionKind& _internal_dirphsc() const;
  ::commonmodule::Optional_PhaseFaultDirectionKind* _internal_mutable_dirphsc();
  public:
  void unsafe_arena_set_allocated_dirphsc(
      ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsc);
  ::commonmodule::Optional_PhaseFaultDirectionKind* unsafe_arena_release_dirphsc();
  // .google.protobuf.BoolValue neut = 7;
  bool has_neut() const;
  private:
  bool _internal_has_neut() const;

  public:
  void clear_neut() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& neut() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_neut();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_neut();
  void set_allocated_neut(::PROTOBUF_NAMESPACE_ID::BoolValue* neut);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_neut() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_neut();
  public:
  void unsafe_arena_set_allocated_neut(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* neut);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_neut();
  // .google.protobuf.BoolValue phsA = 8;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& phsa() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_phsa();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_phsa();
  void set_allocated_phsa(::PROTOBUF_NAMESPACE_ID::BoolValue* phsa);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_phsa() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* phsa);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_phsa();
  // .google.protobuf.BoolValue phsB = 9;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& phsb() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_phsb();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_phsb();
  void set_allocated_phsb(::PROTOBUF_NAMESPACE_ID::BoolValue* phsb);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_phsb() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* phsb);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_phsb();
  // .google.protobuf.BoolValue phsC = 10;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& phsc() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_phsc();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_phsc();
  void set_allocated_phsc(::PROTOBUF_NAMESPACE_ID::BoolValue* phsc);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_phsc() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* phsc);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_phsc();
  // .commonmodule.FaultDirectionKind dirGeneral = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_dirgeneral() ;
  ::commonmodule::FaultDirectionKind dirgeneral() const;
  void set_dirgeneral(::commonmodule::FaultDirectionKind value);

  private:
  ::commonmodule::FaultDirectionKind _internal_dirgeneral() const;
  void _internal_set_dirgeneral(::commonmodule::FaultDirectionKind value);

  public:
  // bool general = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_general() ;
  bool general() const;
  void set_general(bool value);

  private:
  bool _internal_general() const;
  void _internal_set_general(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ACD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirneut_;
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsa_;
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsb_;
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsc_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* neut_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* phsa_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* phsb_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* phsc_;
    int dirgeneral_;
    bool general_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class IdentifiedObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.IdentifiedObject) */ {
 public:
  inline IdentifiedObject() : IdentifiedObject(nullptr) {}
  ~IdentifiedObject() override;
  explicit PROTOBUF_CONSTEXPR IdentifiedObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdentifiedObject(const IdentifiedObject& from);
  IdentifiedObject(IdentifiedObject&& from) noexcept
    : IdentifiedObject() {
    *this = ::std::move(from);
  }

  inline IdentifiedObject& operator=(const IdentifiedObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdentifiedObject& operator=(IdentifiedObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdentifiedObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdentifiedObject* internal_default_instance() {
    return reinterpret_cast<const IdentifiedObject*>(
               &_IdentifiedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IdentifiedObject& a, IdentifiedObject& b) {
    a.Swap(&b);
  }
  inline void Swap(IdentifiedObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdentifiedObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdentifiedObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdentifiedObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdentifiedObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IdentifiedObject& from) {
    IdentifiedObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdentifiedObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.IdentifiedObject";
  }
  protected:
  explicit IdentifiedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kMRIDFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // .google.protobuf.StringValue description = 1;
  bool has_description() const;
  private:
  bool _internal_has_description() const;

  public:
  void clear_description() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& description() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_description();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_description();
  void set_allocated_description(::PROTOBUF_NAMESPACE_ID::StringValue* description);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_description() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_description();
  public:
  void unsafe_arena_set_allocated_description(
      ::PROTOBUF_NAMESPACE_ID::StringValue* description);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_description();
  // .google.protobuf.StringValue mRID = 2 [(.uml.option_uuid) = true];
  bool has_mrid() const;
  private:
  bool _internal_has_mrid() const;

  public:
  void clear_mrid() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& mrid() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_mrid();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_mrid();
  void set_allocated_mrid(::PROTOBUF_NAMESPACE_ID::StringValue* mrid);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_mrid() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_mrid();
  public:
  void unsafe_arena_set_allocated_mrid(
      ::PROTOBUF_NAMESPACE_ID::StringValue* mrid);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_mrid();
  // .google.protobuf.StringValue name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;

  public:
  void clear_name() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& name() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_name();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_name();
  void set_allocated_name(::PROTOBUF_NAMESPACE_ID::StringValue* name);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_name() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::PROTOBUF_NAMESPACE_ID::StringValue* name);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_name();
  // @@protoc_insertion_point(class_scope:commonmodule.IdentifiedObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::StringValue* description_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* mrid_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ACDCTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ACDCTerminal) */ {
 public:
  inline ACDCTerminal() : ACDCTerminal(nullptr) {}
  ~ACDCTerminal() override;
  explicit PROTOBUF_CONSTEXPR ACDCTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ACDCTerminal(const ACDCTerminal& from);
  ACDCTerminal(ACDCTerminal&& from) noexcept
    : ACDCTerminal() {
    *this = ::std::move(from);
  }

  inline ACDCTerminal& operator=(const ACDCTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACDCTerminal& operator=(ACDCTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACDCTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACDCTerminal* internal_default_instance() {
    return reinterpret_cast<const ACDCTerminal*>(
               &_ACDCTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ACDCTerminal& a, ACDCTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(ACDCTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACDCTerminal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACDCTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACDCTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ACDCTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ACDCTerminal& from) {
    ACDCTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACDCTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ACDCTerminal";
  }
  protected:
  explicit ACDCTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kConnectedFieldNumber = 2,
    kSequenceNumberFieldNumber = 3,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .google.protobuf.BoolValue connected = 2;
  bool has_connected() const;
  private:
  bool _internal_has_connected() const;

  public:
  void clear_connected() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& connected() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_connected();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_connected();
  void set_allocated_connected(::PROTOBUF_NAMESPACE_ID::BoolValue* connected);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_connected() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_connected();
  public:
  void unsafe_arena_set_allocated_connected(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* connected);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_connected();
  // .google.protobuf.Int32Value sequenceNumber = 3;
  bool has_sequencenumber() const;
  private:
  bool _internal_has_sequencenumber() const;

  public:
  void clear_sequencenumber() ;
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& sequencenumber() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int32Value* release_sequencenumber();
  ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_sequencenumber();
  void set_allocated_sequencenumber(::PROTOBUF_NAMESPACE_ID::Int32Value* sequencenumber);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_sequencenumber() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_sequencenumber();
  public:
  void unsafe_arena_set_allocated_sequencenumber(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* sequencenumber);
  ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_sequencenumber();
  // @@protoc_insertion_point(class_scope:commonmodule.ACDCTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* connected_;
    ::PROTOBUF_NAMESPACE_ID::Int32Value* sequencenumber_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_UnitSymbolKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_UnitSymbolKind) */ {
 public:
  inline Optional_UnitSymbolKind() : Optional_UnitSymbolKind(nullptr) {}
  ~Optional_UnitSymbolKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_UnitSymbolKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_UnitSymbolKind(const Optional_UnitSymbolKind& from);
  Optional_UnitSymbolKind(Optional_UnitSymbolKind&& from) noexcept
    : Optional_UnitSymbolKind() {
    *this = ::std::move(from);
  }

  inline Optional_UnitSymbolKind& operator=(const Optional_UnitSymbolKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_UnitSymbolKind& operator=(Optional_UnitSymbolKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_UnitSymbolKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_UnitSymbolKind* internal_default_instance() {
    return reinterpret_cast<const Optional_UnitSymbolKind*>(
               &_Optional_UnitSymbolKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Optional_UnitSymbolKind& a, Optional_UnitSymbolKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_UnitSymbolKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_UnitSymbolKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_UnitSymbolKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_UnitSymbolKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_UnitSymbolKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_UnitSymbolKind& from) {
    Optional_UnitSymbolKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_UnitSymbolKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_UnitSymbolKind";
  }
  protected:
  explicit Optional_UnitSymbolKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.UnitSymbolKind value = 1;
  void clear_value() ;
  ::commonmodule::UnitSymbolKind value() const;
  void set_value(::commonmodule::UnitSymbolKind value);

  private:
  ::commonmodule::UnitSymbolKind _internal_value() const;
  void _internal_set_value(::commonmodule::UnitSymbolKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_UnitSymbolKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_UnitMultiplierKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_UnitMultiplierKind) */ {
 public:
  inline Optional_UnitMultiplierKind() : Optional_UnitMultiplierKind(nullptr) {}
  ~Optional_UnitMultiplierKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_UnitMultiplierKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_UnitMultiplierKind(const Optional_UnitMultiplierKind& from);
  Optional_UnitMultiplierKind(Optional_UnitMultiplierKind&& from) noexcept
    : Optional_UnitMultiplierKind() {
    *this = ::std::move(from);
  }

  inline Optional_UnitMultiplierKind& operator=(const Optional_UnitMultiplierKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_UnitMultiplierKind& operator=(Optional_UnitMultiplierKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_UnitMultiplierKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_UnitMultiplierKind* internal_default_instance() {
    return reinterpret_cast<const Optional_UnitMultiplierKind*>(
               &_Optional_UnitMultiplierKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Optional_UnitMultiplierKind& a, Optional_UnitMultiplierKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_UnitMultiplierKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_UnitMultiplierKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_UnitMultiplierKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_UnitMultiplierKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_UnitMultiplierKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_UnitMultiplierKind& from) {
    Optional_UnitMultiplierKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_UnitMultiplierKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_UnitMultiplierKind";
  }
  protected:
  explicit Optional_UnitMultiplierKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.UnitMultiplierKind value = 1;
  void clear_value() ;
  ::commonmodule::UnitMultiplierKind value() const;
  void set_value(::commonmodule::UnitMultiplierKind value);

  private:
  ::commonmodule::UnitMultiplierKind _internal_value() const;
  void _internal_set_value(::commonmodule::UnitMultiplierKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_UnitMultiplierKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ActivePower final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ActivePower) */ {
 public:
  inline ActivePower() : ActivePower(nullptr) {}
  ~ActivePower() override;
  explicit PROTOBUF_CONSTEXPR ActivePower(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActivePower(const ActivePower& from);
  ActivePower(ActivePower&& from) noexcept
    : ActivePower() {
    *this = ::std::move(from);
  }

  inline ActivePower& operator=(const ActivePower& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivePower& operator=(ActivePower&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivePower& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivePower* internal_default_instance() {
    return reinterpret_cast<const ActivePower*>(
               &_ActivePower_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ActivePower& a, ActivePower& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivePower* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivePower* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivePower* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivePower>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActivePower& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActivePower& from) {
    ActivePower::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivePower* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ActivePower";
  }
  protected:
  explicit ActivePower(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultiplierFieldNumber = 1,
    kUnitFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  bool has_multiplier() const;
  private:
  bool _internal_has_multiplier() const;

  public:
  void clear_multiplier() ;
  const ::commonmodule::Optional_UnitMultiplierKind& multiplier() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_UnitMultiplierKind* release_multiplier();
  ::commonmodule::Optional_UnitMultiplierKind* mutable_multiplier();
  void set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier);
  private:
  const ::commonmodule::Optional_UnitMultiplierKind& _internal_multiplier() const;
  ::commonmodule::Optional_UnitMultiplierKind* _internal_mutable_multiplier();
  public:
  void unsafe_arena_set_allocated_multiplier(
      ::commonmodule::Optional_UnitMultiplierKind* multiplier);
  ::commonmodule::Optional_UnitMultiplierKind* unsafe_arena_release_multiplier();
  // .commonmodule.Optional_UnitSymbolKind unit = 2;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;

  public:
  void clear_unit() ;
  const ::commonmodule::Optional_UnitSymbolKind& unit() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_UnitSymbolKind* release_unit();
  ::commonmodule::Optional_UnitSymbolKind* mutable_unit();
  void set_allocated_unit(::commonmodule::Optional_UnitSymbolKind* unit);
  private:
  const ::commonmodule::Optional_UnitSymbolKind& _internal_unit() const;
  ::commonmodule::Optional_UnitSymbolKind* _internal_mutable_unit();
  public:
  void unsafe_arena_set_allocated_unit(
      ::commonmodule::Optional_UnitSymbolKind* unit);
  ::commonmodule::Optional_UnitSymbolKind* unsafe_arena_release_unit();
  // .google.protobuf.FloatValue value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;

  public:
  void clear_value() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_value();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::FloatValue* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* value);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_value();
  // @@protoc_insertion_point(class_scope:commonmodule.ActivePower)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Optional_UnitMultiplierKind* multiplier_;
    ::commonmodule::Optional_UnitSymbolKind* unit_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_PhaseCodeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_PhaseCodeKind) */ {
 public:
  inline Optional_PhaseCodeKind() : Optional_PhaseCodeKind(nullptr) {}
  ~Optional_PhaseCodeKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_PhaseCodeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_PhaseCodeKind(const Optional_PhaseCodeKind& from);
  Optional_PhaseCodeKind(Optional_PhaseCodeKind&& from) noexcept
    : Optional_PhaseCodeKind() {
    *this = ::std::move(from);
  }

  inline Optional_PhaseCodeKind& operator=(const Optional_PhaseCodeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_PhaseCodeKind& operator=(Optional_PhaseCodeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_PhaseCodeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_PhaseCodeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_PhaseCodeKind*>(
               &_Optional_PhaseCodeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Optional_PhaseCodeKind& a, Optional_PhaseCodeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_PhaseCodeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_PhaseCodeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_PhaseCodeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_PhaseCodeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_PhaseCodeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_PhaseCodeKind& from) {
    Optional_PhaseCodeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_PhaseCodeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_PhaseCodeKind";
  }
  protected:
  explicit Optional_PhaseCodeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.PhaseCodeKind value = 1;
  void clear_value() ;
  ::commonmodule::PhaseCodeKind value() const;
  void set_value(::commonmodule::PhaseCodeKind value);

  private:
  ::commonmodule::PhaseCodeKind _internal_value() const;
  void _internal_set_value(::commonmodule::PhaseCodeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_PhaseCodeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Unit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Unit) */ {
 public:
  inline Unit() : Unit(nullptr) {}
  ~Unit() override;
  explicit PROTOBUF_CONSTEXPR Unit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unit(const Unit& from);
  Unit(Unit&& from) noexcept
    : Unit() {
    *this = ::std::move(from);
  }

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unit& operator=(Unit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unit* internal_default_instance() {
    return reinterpret_cast<const Unit*>(
               &_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Unit& a, Unit& b) {
    a.Swap(&b);
  }
  inline void Swap(Unit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Unit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Unit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Unit& from) {
    Unit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Unit";
  }
  protected:
  explicit Unit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultiplierFieldNumber = 1,
    kSIUnitFieldNumber = 2,
  };
  // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
  bool has_multiplier() const;
  private:
  bool _internal_has_multiplier() const;

  public:
  void clear_multiplier() ;
  const ::commonmodule::Optional_UnitMultiplierKind& multiplier() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_UnitMultiplierKind* release_multiplier();
  ::commonmodule::Optional_UnitMultiplierKind* mutable_multiplier();
  void set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier);
  private:
  const ::commonmodule::Optional_UnitMultiplierKind& _internal_multiplier() const;
  ::commonmodule::Optional_UnitMultiplierKind* _internal_mutable_multiplier();
  public:
  void unsafe_arena_set_allocated_multiplier(
      ::commonmodule::Optional_UnitMultiplierKind* multiplier);
  ::commonmodule::Optional_UnitMultiplierKind* unsafe_arena_release_multiplier();
  // .commonmodule.UnitSymbolKind SIUnit = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_siunit() ;
  ::commonmodule::UnitSymbolKind siunit() const;
  void set_siunit(::commonmodule::UnitSymbolKind value);

  private:
  ::commonmodule::UnitSymbolKind _internal_siunit() const;
  void _internal_set_siunit(::commonmodule::UnitSymbolKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Unit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Optional_UnitMultiplierKind* multiplier_;
    int siunit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_ValidityKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_ValidityKind) */ {
 public:
  inline Optional_ValidityKind() : Optional_ValidityKind(nullptr) {}
  ~Optional_ValidityKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_ValidityKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_ValidityKind(const Optional_ValidityKind& from);
  Optional_ValidityKind(Optional_ValidityKind&& from) noexcept
    : Optional_ValidityKind() {
    *this = ::std::move(from);
  }

  inline Optional_ValidityKind& operator=(const Optional_ValidityKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_ValidityKind& operator=(Optional_ValidityKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_ValidityKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_ValidityKind* internal_default_instance() {
    return reinterpret_cast<const Optional_ValidityKind*>(
               &_Optional_ValidityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Optional_ValidityKind& a, Optional_ValidityKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_ValidityKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_ValidityKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_ValidityKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_ValidityKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_ValidityKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_ValidityKind& from) {
    Optional_ValidityKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_ValidityKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_ValidityKind";
  }
  protected:
  explicit Optional_ValidityKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.ValidityKind value = 1;
  void clear_value() ;
  ::commonmodule::ValidityKind value() const;
  void set_value(::commonmodule::ValidityKind value);

  private:
  ::commonmodule::ValidityKind _internal_value() const;
  void _internal_set_value(::commonmodule::ValidityKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_ValidityKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class DetailQual final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.DetailQual) */ {
 public:
  inline DetailQual() : DetailQual(nullptr) {}
  ~DetailQual() override;
  explicit PROTOBUF_CONSTEXPR DetailQual(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailQual(const DetailQual& from);
  DetailQual(DetailQual&& from) noexcept
    : DetailQual() {
    *this = ::std::move(from);
  }

  inline DetailQual& operator=(const DetailQual& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailQual& operator=(DetailQual&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetailQual& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailQual* internal_default_instance() {
    return reinterpret_cast<const DetailQual*>(
               &_DetailQual_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DetailQual& a, DetailQual& b) {
    a.Swap(&b);
  }
  inline void Swap(DetailQual* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailQual* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailQual* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailQual>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetailQual& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetailQual& from) {
    DetailQual::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailQual* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.DetailQual";
  }
  protected:
  explicit DetailQual(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBadReferenceFieldNumber = 1,
    kFailureFieldNumber = 2,
    kInaccurateFieldNumber = 3,
    kInconsistentFieldNumber = 4,
    kOldDataFieldNumber = 5,
    kOscillatoryFieldNumber = 6,
    kOutOfRangeFieldNumber = 7,
    kOverflowFieldNumber = 8,
  };
  // bool badReference = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_badreference() ;
  bool badreference() const;
  void set_badreference(bool value);

  private:
  bool _internal_badreference() const;
  void _internal_set_badreference(bool value);

  public:
  // bool failure = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_failure() ;
  bool failure() const;
  void set_failure(bool value);

  private:
  bool _internal_failure() const;
  void _internal_set_failure(bool value);

  public:
  // bool inaccurate = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_inaccurate() ;
  bool inaccurate() const;
  void set_inaccurate(bool value);

  private:
  bool _internal_inaccurate() const;
  void _internal_set_inaccurate(bool value);

  public:
  // bool inconsistent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_inconsistent() ;
  bool inconsistent() const;
  void set_inconsistent(bool value);

  private:
  bool _internal_inconsistent() const;
  void _internal_set_inconsistent(bool value);

  public:
  // bool oldData = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_olddata() ;
  bool olddata() const;
  void set_olddata(bool value);

  private:
  bool _internal_olddata() const;
  void _internal_set_olddata(bool value);

  public:
  // bool oscillatory = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_oscillatory() ;
  bool oscillatory() const;
  void set_oscillatory(bool value);

  private:
  bool _internal_oscillatory() const;
  void _internal_set_oscillatory(bool value);

  public:
  // bool outOfRange = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_outofrange() ;
  bool outofrange() const;
  void set_outofrange(bool value);

  private:
  bool _internal_outofrange() const;
  void _internal_set_outofrange(bool value);

  public:
  // bool overflow = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_overflow() ;
  bool overflow() const;
  void set_overflow(bool value);

  private:
  bool _internal_overflow() const;
  void _internal_set_overflow(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.DetailQual)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool badreference_;
    bool failure_;
    bool inaccurate_;
    bool inconsistent_;
    bool olddata_;
    bool oscillatory_;
    bool outofrange_;
    bool overflow_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_SourceKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_SourceKind) */ {
 public:
  inline Optional_SourceKind() : Optional_SourceKind(nullptr) {}
  ~Optional_SourceKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_SourceKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_SourceKind(const Optional_SourceKind& from);
  Optional_SourceKind(Optional_SourceKind&& from) noexcept
    : Optional_SourceKind() {
    *this = ::std::move(from);
  }

  inline Optional_SourceKind& operator=(const Optional_SourceKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_SourceKind& operator=(Optional_SourceKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_SourceKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_SourceKind* internal_default_instance() {
    return reinterpret_cast<const Optional_SourceKind*>(
               &_Optional_SourceKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Optional_SourceKind& a, Optional_SourceKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_SourceKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_SourceKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_SourceKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_SourceKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_SourceKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_SourceKind& from) {
    Optional_SourceKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_SourceKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_SourceKind";
  }
  protected:
  explicit Optional_SourceKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.SourceKind value = 1;
  void clear_value() ;
  ::commonmodule::SourceKind value() const;
  void set_value(::commonmodule::SourceKind value);

  private:
  ::commonmodule::SourceKind _internal_value() const;
  void _internal_set_value(::commonmodule::SourceKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_SourceKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Quality final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Quality) */ {
 public:
  inline Quality() : Quality(nullptr) {}
  ~Quality() override;
  explicit PROTOBUF_CONSTEXPR Quality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quality(const Quality& from);
  Quality(Quality&& from) noexcept
    : Quality() {
    *this = ::std::move(from);
  }

  inline Quality& operator=(const Quality& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quality& operator=(Quality&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quality& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quality* internal_default_instance() {
    return reinterpret_cast<const Quality*>(
               &_Quality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Quality& a, Quality& b) {
    a.Swap(&b);
  }
  inline void Swap(Quality* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quality* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quality>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quality& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quality& from) {
    Quality::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quality* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Quality";
  }
  protected:
  explicit Quality(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailQualFieldNumber = 1,
    kSourceFieldNumber = 3,
    kOperatorBlockedFieldNumber = 2,
    kTestFieldNumber = 4,
    kValidityFieldNumber = 5,
  };
  // .commonmodule.DetailQual detailQual = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_detailqual() const;
  private:
  bool _internal_has_detailqual() const;

  public:
  void clear_detailqual() ;
  const ::commonmodule::DetailQual& detailqual() const;
  PROTOBUF_NODISCARD ::commonmodule::DetailQual* release_detailqual();
  ::commonmodule::DetailQual* mutable_detailqual();
  void set_allocated_detailqual(::commonmodule::DetailQual* detailqual);
  private:
  const ::commonmodule::DetailQual& _internal_detailqual() const;
  ::commonmodule::DetailQual* _internal_mutable_detailqual();
  public:
  void unsafe_arena_set_allocated_detailqual(
      ::commonmodule::DetailQual* detailqual);
  ::commonmodule::DetailQual* unsafe_arena_release_detailqual();
  // .commonmodule.SourceKind source = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_source() ;
  ::commonmodule::SourceKind source() const;
  void set_source(::commonmodule::SourceKind value);

  private:
  ::commonmodule::SourceKind _internal_source() const;
  void _internal_set_source(::commonmodule::SourceKind value);

  public:
  // bool operatorBlocked = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_operatorblocked() ;
  bool operatorblocked() const;
  void set_operatorblocked(bool value);

  private:
  bool _internal_operatorblocked() const;
  void _internal_set_operatorblocked(bool value);

  public:
  // bool test = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_test() ;
  bool test() const;
  void set_test(bool value);

  private:
  bool _internal_test() const;
  void _internal_set_test(bool value);

  public:
  // .commonmodule.ValidityKind validity = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_validity() ;
  ::commonmodule::ValidityKind validity() const;
  void set_validity(::commonmodule::ValidityKind value);

  private:
  ::commonmodule::ValidityKind _internal_validity() const;
  void _internal_set_validity(::commonmodule::ValidityKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Quality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::DetailQual* detailqual_;
    int source_;
    bool operatorblocked_;
    bool test_;
    int validity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_TimeAccuracyKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_TimeAccuracyKind) */ {
 public:
  inline Optional_TimeAccuracyKind() : Optional_TimeAccuracyKind(nullptr) {}
  ~Optional_TimeAccuracyKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_TimeAccuracyKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_TimeAccuracyKind(const Optional_TimeAccuracyKind& from);
  Optional_TimeAccuracyKind(Optional_TimeAccuracyKind&& from) noexcept
    : Optional_TimeAccuracyKind() {
    *this = ::std::move(from);
  }

  inline Optional_TimeAccuracyKind& operator=(const Optional_TimeAccuracyKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_TimeAccuracyKind& operator=(Optional_TimeAccuracyKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_TimeAccuracyKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_TimeAccuracyKind* internal_default_instance() {
    return reinterpret_cast<const Optional_TimeAccuracyKind*>(
               &_Optional_TimeAccuracyKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Optional_TimeAccuracyKind& a, Optional_TimeAccuracyKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_TimeAccuracyKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_TimeAccuracyKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_TimeAccuracyKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_TimeAccuracyKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_TimeAccuracyKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_TimeAccuracyKind& from) {
    Optional_TimeAccuracyKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_TimeAccuracyKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_TimeAccuracyKind";
  }
  protected:
  explicit Optional_TimeAccuracyKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.TimeAccuracyKind value = 1;
  void clear_value() ;
  ::commonmodule::TimeAccuracyKind value() const;
  void set_value(::commonmodule::TimeAccuracyKind value);

  private:
  ::commonmodule::TimeAccuracyKind _internal_value() const;
  void _internal_set_value(::commonmodule::TimeAccuracyKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_TimeAccuracyKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class TimeQuality final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.TimeQuality) */ {
 public:
  inline TimeQuality() : TimeQuality(nullptr) {}
  ~TimeQuality() override;
  explicit PROTOBUF_CONSTEXPR TimeQuality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeQuality(const TimeQuality& from);
  TimeQuality(TimeQuality&& from) noexcept
    : TimeQuality() {
    *this = ::std::move(from);
  }

  inline TimeQuality& operator=(const TimeQuality& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeQuality& operator=(TimeQuality&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeQuality& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeQuality* internal_default_instance() {
    return reinterpret_cast<const TimeQuality*>(
               &_TimeQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TimeQuality& a, TimeQuality& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeQuality* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeQuality* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeQuality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeQuality>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeQuality& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeQuality& from) {
    TimeQuality::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeQuality* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.TimeQuality";
  }
  protected:
  explicit TimeQuality(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClockFailureFieldNumber = 1,
    kClockNotSynchronizedFieldNumber = 2,
    kLeapSecondsKnownFieldNumber = 3,
    kTimeAccuracyFieldNumber = 4,
  };
  // bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_clockfailure() ;
  bool clockfailure() const;
  void set_clockfailure(bool value);

  private:
  bool _internal_clockfailure() const;
  void _internal_set_clockfailure(bool value);

  public:
  // bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_clocknotsynchronized() ;
  bool clocknotsynchronized() const;
  void set_clocknotsynchronized(bool value);

  private:
  bool _internal_clocknotsynchronized() const;
  void _internal_set_clocknotsynchronized(bool value);

  public:
  // bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_leapsecondsknown() ;
  bool leapsecondsknown() const;
  void set_leapsecondsknown(bool value);

  private:
  bool _internal_leapsecondsknown() const;
  void _internal_set_leapsecondsknown(bool value);

  public:
  // .commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_timeaccuracy() ;
  ::commonmodule::TimeAccuracyKind timeaccuracy() const;
  void set_timeaccuracy(::commonmodule::TimeAccuracyKind value);

  private:
  ::commonmodule::TimeAccuracyKind _internal_timeaccuracy() const;
  void _internal_set_timeaccuracy(::commonmodule::TimeAccuracyKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.TimeQuality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool clockfailure_;
    bool clocknotsynchronized_;
    bool leapsecondsknown_;
    int timeaccuracy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Timestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() override;
  explicit PROTOBUF_CONSTEXPR Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Timestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Timestamp& from) {
    Timestamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTqFieldNumber = 3,
    kSecondsFieldNumber = 2,
    kNanosecondsFieldNumber = 4,
  };
  // .commonmodule.TimeQuality tq = 3;
  bool has_tq() const;
  private:
  bool _internal_has_tq() const;

  public:
  void clear_tq() ;
  const ::commonmodule::TimeQuality& tq() const;
  PROTOBUF_NODISCARD ::commonmodule::TimeQuality* release_tq();
  ::commonmodule::TimeQuality* mutable_tq();
  void set_allocated_tq(::commonmodule::TimeQuality* tq);
  private:
  const ::commonmodule::TimeQuality& _internal_tq() const;
  ::commonmodule::TimeQuality* _internal_mutable_tq();
  public:
  void unsafe_arena_set_allocated_tq(
      ::commonmodule::TimeQuality* tq);
  ::commonmodule::TimeQuality* unsafe_arena_release_tq();
  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_seconds() ;
  ::uint64_t seconds() const;
  void set_seconds(::uint64_t value);

  private:
  ::uint64_t _internal_seconds() const;
  void _internal_set_seconds(::uint64_t value);

  public:
  // uint32 nanoseconds = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_nanoseconds() ;
  ::uint32_t nanoseconds() const;
  void set_nanoseconds(::uint32_t value);

  private:
  ::uint32_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::TimeQuality* tq_;
    ::uint64_t seconds_;
    ::uint32_t nanoseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class MV final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.MV) */ {
 public:
  inline MV() : MV(nullptr) {}
  ~MV() override;
  explicit PROTOBUF_CONSTEXPR MV(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MV(const MV& from);
  MV(MV&& from) noexcept
    : MV() {
    *this = ::std::move(from);
  }

  inline MV& operator=(const MV& from) {
    CopyFrom(from);
    return *this;
  }
  inline MV& operator=(MV&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MV& default_instance() {
    return *internal_default_instance();
  }
  static inline const MV* internal_default_instance() {
    return reinterpret_cast<const MV*>(
               &_MV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MV& a, MV& b) {
    a.Swap(&b);
  }
  inline void Swap(MV* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MV* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MV>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MV& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MV& from) {
    MV::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MV* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.MV";
  }
  protected:
  explicit MV(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 2,
    kTFieldNumber = 3,
    kUnitsFieldNumber = 4,
    kMagFieldNumber = 1,
  };
  // .commonmodule.Quality q = 2;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // .commonmodule.Unit units = 4;
  bool has_units() const;
  private:
  bool _internal_has_units() const;

  public:
  void clear_units() ;
  const ::commonmodule::Unit& units() const;
  PROTOBUF_NODISCARD ::commonmodule::Unit* release_units();
  ::commonmodule::Unit* mutable_units();
  void set_allocated_units(::commonmodule::Unit* units);
  private:
  const ::commonmodule::Unit& _internal_units() const;
  ::commonmodule::Unit* _internal_mutable_units();
  public:
  void unsafe_arena_set_allocated_units(
      ::commonmodule::Unit* units);
  ::commonmodule::Unit* unsafe_arena_release_units();
  // double mag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_mag() ;
  double mag() const;
  void set_mag(double value);

  private:
  double _internal_mag() const;
  void _internal_set_mag(double value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.MV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    ::commonmodule::Unit* units_;
    double mag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class LogicalNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.LogicalNode) */ {
 public:
  inline LogicalNode() : LogicalNode(nullptr) {}
  ~LogicalNode() override;
  explicit PROTOBUF_CONSTEXPR LogicalNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicalNode(const LogicalNode& from);
  LogicalNode(LogicalNode&& from) noexcept
    : LogicalNode() {
    *this = ::std::move(from);
  }

  inline LogicalNode& operator=(const LogicalNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalNode& operator=(LogicalNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogicalNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalNode* internal_default_instance() {
    return reinterpret_cast<const LogicalNode*>(
               &_LogicalNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LogicalNode& a, LogicalNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogicalNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogicalNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogicalNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogicalNode& from) {
    LogicalNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.LogicalNode";
  }
  protected:
  explicit LogicalNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // @@protoc_insertion_point(class_scope:commonmodule.LogicalNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class AnalogEventAndStatusGGIO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.AnalogEventAndStatusGGIO) */ {
 public:
  inline AnalogEventAndStatusGGIO() : AnalogEventAndStatusGGIO(nullptr) {}
  ~AnalogEventAndStatusGGIO() override;
  explicit PROTOBUF_CONSTEXPR AnalogEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnalogEventAndStatusGGIO(const AnalogEventAndStatusGGIO& from);
  AnalogEventAndStatusGGIO(AnalogEventAndStatusGGIO&& from) noexcept
    : AnalogEventAndStatusGGIO() {
    *this = ::std::move(from);
  }

  inline AnalogEventAndStatusGGIO& operator=(const AnalogEventAndStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogEventAndStatusGGIO& operator=(AnalogEventAndStatusGGIO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalogEventAndStatusGGIO& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalogEventAndStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const AnalogEventAndStatusGGIO*>(
               &_AnalogEventAndStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AnalogEventAndStatusGGIO& a, AnalogEventAndStatusGGIO& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalogEventAndStatusGGIO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalogEventAndStatusGGIO* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalogEventAndStatusGGIO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalogEventAndStatusGGIO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnalogEventAndStatusGGIO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnalogEventAndStatusGGIO& from) {
    AnalogEventAndStatusGGIO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalogEventAndStatusGGIO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.AnalogEventAndStatusGGIO";
  }
  protected:
  explicit AnalogEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kAnInFieldNumber = 2,
    kPhaseFieldNumber = 3,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.MV AnIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_anin() const;
  private:
  bool _internal_has_anin() const;

  public:
  void clear_anin() ;
  const ::commonmodule::MV& anin() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_anin();
  ::commonmodule::MV* mutable_anin();
  void set_allocated_anin(::commonmodule::MV* anin);
  private:
  const ::commonmodule::MV& _internal_anin() const;
  ::commonmodule::MV* _internal_mutable_anin();
  public:
  void unsafe_arena_set_allocated_anin(
      ::commonmodule::MV* anin);
  ::commonmodule::MV* unsafe_arena_release_anin();
  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;

  public:
  void clear_phase() ;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);
  private:
  const ::commonmodule::Optional_PhaseCodeKind& _internal_phase() const;
  ::commonmodule::Optional_PhaseCodeKind* _internal_mutable_phase();
  public:
  void unsafe_arena_set_allocated_phase(
      ::commonmodule::Optional_PhaseCodeKind* phase);
  ::commonmodule::Optional_PhaseCodeKind* unsafe_arena_release_phase();
  // @@protoc_insertion_point(class_scope:commonmodule.AnalogEventAndStatusGGIO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::MV* anin_;
    ::commonmodule::Optional_PhaseCodeKind* phase_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class NamedObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.NamedObject) */ {
 public:
  inline NamedObject() : NamedObject(nullptr) {}
  ~NamedObject() override;
  explicit PROTOBUF_CONSTEXPR NamedObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedObject(const NamedObject& from);
  NamedObject(NamedObject&& from) noexcept
    : NamedObject() {
    *this = ::std::move(from);
  }

  inline NamedObject& operator=(const NamedObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedObject& operator=(NamedObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedObject* internal_default_instance() {
    return reinterpret_cast<const NamedObject*>(
               &_NamedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(NamedObject& a, NamedObject& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamedObject& from) {
    NamedObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.NamedObject";
  }
  protected:
  explicit NamedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // .google.protobuf.StringValue description = 1;
  bool has_description() const;
  private:
  bool _internal_has_description() const;

  public:
  void clear_description() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& description() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_description();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_description();
  void set_allocated_description(::PROTOBUF_NAMESPACE_ID::StringValue* description);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_description() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_description();
  public:
  void unsafe_arena_set_allocated_description(
      ::PROTOBUF_NAMESPACE_ID::StringValue* description);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_description();
  // .google.protobuf.StringValue name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;

  public:
  void clear_name() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& name() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_name();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_name();
  void set_allocated_name(::PROTOBUF_NAMESPACE_ID::StringValue* name);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_name() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::PROTOBUF_NAMESPACE_ID::StringValue* name);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_name();
  // @@protoc_insertion_point(class_scope:commonmodule.NamedObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::StringValue* description_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ApplicationSystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ApplicationSystem) */ {
 public:
  inline ApplicationSystem() : ApplicationSystem(nullptr) {}
  ~ApplicationSystem() override;
  explicit PROTOBUF_CONSTEXPR ApplicationSystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationSystem(const ApplicationSystem& from);
  ApplicationSystem(ApplicationSystem&& from) noexcept
    : ApplicationSystem() {
    *this = ::std::move(from);
  }

  inline ApplicationSystem& operator=(const ApplicationSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationSystem& operator=(ApplicationSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationSystem* internal_default_instance() {
    return reinterpret_cast<const ApplicationSystem*>(
               &_ApplicationSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ApplicationSystem& a, ApplicationSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationSystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationSystem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplicationSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplicationSystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplicationSystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplicationSystem& from) {
    ApplicationSystem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationSystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ApplicationSystem";
  }
  protected:
  explicit ApplicationSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMRIDFieldNumber = 2,
    kNamedObjectFieldNumber = 1,
  };
  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true];
  void clear_mrid() ;
  const std::string& mrid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mrid(Arg_&& arg, Args_... args);
  std::string* mutable_mrid();
  PROTOBUF_NODISCARD std::string* release_mrid();
  void set_allocated_mrid(std::string* ptr);

  private:
  const std::string& _internal_mrid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mrid(
      const std::string& value);
  std::string* _internal_mutable_mrid();

  public:
  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  bool has_namedobject() const;
  private:
  bool _internal_has_namedobject() const;

  public:
  void clear_namedobject() ;
  const ::commonmodule::NamedObject& namedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::NamedObject* release_namedobject();
  ::commonmodule::NamedObject* mutable_namedobject();
  void set_allocated_namedobject(::commonmodule::NamedObject* namedobject);
  private:
  const ::commonmodule::NamedObject& _internal_namedobject() const;
  ::commonmodule::NamedObject* _internal_mutable_namedobject();
  public:
  void unsafe_arena_set_allocated_namedobject(
      ::commonmodule::NamedObject* namedobject);
  ::commonmodule::NamedObject* unsafe_arena_release_namedobject();
  // @@protoc_insertion_point(class_scope:commonmodule.ApplicationSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mrid_;
    ::commonmodule::NamedObject* namedobject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ASG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ASG) */ {
 public:
  inline ASG() : ASG(nullptr) {}
  ~ASG() override;
  explicit PROTOBUF_CONSTEXPR ASG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ASG(const ASG& from);
  ASG(ASG&& from) noexcept
    : ASG() {
    *this = ::std::move(from);
  }

  inline ASG& operator=(const ASG& from) {
    CopyFrom(from);
    return *this;
  }
  inline ASG& operator=(ASG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ASG& default_instance() {
    return *internal_default_instance();
  }
  static inline const ASG* internal_default_instance() {
    return reinterpret_cast<const ASG*>(
               &_ASG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ASG& a, ASG& b) {
    a.Swap(&b);
  }
  inline void Swap(ASG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ASG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ASG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ASG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ASG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ASG& from) {
    ASG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ASG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ASG";
  }
  protected:
  explicit ASG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetMagFieldNumber = 1,
  };
  // double setMag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setmag() ;
  double setmag() const;
  void set_setmag(double value);

  private:
  double _internal_setmag() const;
  void _internal_set_setmag(double value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ASG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double setmag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class BCR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.BCR) */ {
 public:
  inline BCR() : BCR(nullptr) {}
  ~BCR() override;
  explicit PROTOBUF_CONSTEXPR BCR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BCR(const BCR& from);
  BCR(BCR&& from) noexcept
    : BCR() {
    *this = ::std::move(from);
  }

  inline BCR& operator=(const BCR& from) {
    CopyFrom(from);
    return *this;
  }
  inline BCR& operator=(BCR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BCR& default_instance() {
    return *internal_default_instance();
  }
  static inline const BCR* internal_default_instance() {
    return reinterpret_cast<const BCR*>(
               &_BCR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BCR& a, BCR& b) {
    a.Swap(&b);
  }
  inline void Swap(BCR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BCR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BCR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BCR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BCR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BCR& from) {
    BCR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BCR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.BCR";
  }
  protected:
  explicit BCR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 2,
    kTFieldNumber = 3,
    kActValFieldNumber = 1,
  };
  // .commonmodule.Quality q = 2;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // int64 actVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_actval() ;
  ::int64_t actval() const;
  void set_actval(::int64_t value);

  private:
  ::int64_t _internal_actval() const;
  void _internal_set_actval(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.BCR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    ::int64_t actval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusSPS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusSPS) */ {
 public:
  inline StatusSPS() : StatusSPS(nullptr) {}
  ~StatusSPS() override;
  explicit PROTOBUF_CONSTEXPR StatusSPS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusSPS(const StatusSPS& from);
  StatusSPS(StatusSPS&& from) noexcept
    : StatusSPS() {
    *this = ::std::move(from);
  }

  inline StatusSPS& operator=(const StatusSPS& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusSPS& operator=(StatusSPS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusSPS& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusSPS* internal_default_instance() {
    return reinterpret_cast<const StatusSPS*>(
               &_StatusSPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StatusSPS& a, StatusSPS& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusSPS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusSPS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusSPS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusSPS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusSPS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusSPS& from) {
    StatusSPS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusSPS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusSPS";
  }
  protected:
  explicit StatusSPS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  bool stval() const;
  void set_stval(bool value);

  private:
  bool _internal_stval() const;
  void _internal_set_stval(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.StatusSPS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    bool stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class BooleanEventAndStatusGGIO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.BooleanEventAndStatusGGIO) */ {
 public:
  inline BooleanEventAndStatusGGIO() : BooleanEventAndStatusGGIO(nullptr) {}
  ~BooleanEventAndStatusGGIO() override;
  explicit PROTOBUF_CONSTEXPR BooleanEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BooleanEventAndStatusGGIO(const BooleanEventAndStatusGGIO& from);
  BooleanEventAndStatusGGIO(BooleanEventAndStatusGGIO&& from) noexcept
    : BooleanEventAndStatusGGIO() {
    *this = ::std::move(from);
  }

  inline BooleanEventAndStatusGGIO& operator=(const BooleanEventAndStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  inline BooleanEventAndStatusGGIO& operator=(BooleanEventAndStatusGGIO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BooleanEventAndStatusGGIO& default_instance() {
    return *internal_default_instance();
  }
  static inline const BooleanEventAndStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const BooleanEventAndStatusGGIO*>(
               &_BooleanEventAndStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(BooleanEventAndStatusGGIO& a, BooleanEventAndStatusGGIO& b) {
    a.Swap(&b);
  }
  inline void Swap(BooleanEventAndStatusGGIO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BooleanEventAndStatusGGIO* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BooleanEventAndStatusGGIO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BooleanEventAndStatusGGIO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BooleanEventAndStatusGGIO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BooleanEventAndStatusGGIO& from) {
    BooleanEventAndStatusGGIO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BooleanEventAndStatusGGIO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.BooleanEventAndStatusGGIO";
  }
  protected:
  explicit BooleanEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kIndFieldNumber = 2,
    kPhaseFieldNumber = 3,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.StatusSPS Ind = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ind() const;
  private:
  bool _internal_has_ind() const;

  public:
  void clear_ind() ;
  const ::commonmodule::StatusSPS& ind() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_ind();
  ::commonmodule::StatusSPS* mutable_ind();
  void set_allocated_ind(::commonmodule::StatusSPS* ind);
  private:
  const ::commonmodule::StatusSPS& _internal_ind() const;
  ::commonmodule::StatusSPS* _internal_mutable_ind();
  public:
  void unsafe_arena_set_allocated_ind(
      ::commonmodule::StatusSPS* ind);
  ::commonmodule::StatusSPS* unsafe_arena_release_ind();
  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;

  public:
  void clear_phase() ;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);
  private:
  const ::commonmodule::Optional_PhaseCodeKind& _internal_phase() const;
  ::commonmodule::Optional_PhaseCodeKind* _internal_mutable_phase();
  public:
  void unsafe_arena_set_allocated_phase(
      ::commonmodule::Optional_PhaseCodeKind* phase);
  ::commonmodule::Optional_PhaseCodeKind* unsafe_arena_release_phase();
  // @@protoc_insertion_point(class_scope:commonmodule.BooleanEventAndStatusGGIO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::StatusSPS* ind_;
    ::commonmodule::Optional_PhaseCodeKind* phase_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class MessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.MessageInfo) */ {
 public:
  inline MessageInfo() : MessageInfo(nullptr) {}
  ~MessageInfo() override;
  explicit PROTOBUF_CONSTEXPR MessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageInfo(const MessageInfo& from);
  MessageInfo(MessageInfo&& from) noexcept
    : MessageInfo() {
    *this = ::std::move(from);
  }

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageInfo& operator=(MessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageInfo* internal_default_instance() {
    return reinterpret_cast<const MessageInfo*>(
               &_MessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MessageInfo& a, MessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageInfo& from) {
    MessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.MessageInfo";
  }
  protected:
  explicit MessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kMessageTimeStampFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .commonmodule.Timestamp messageTimeStamp = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_messagetimestamp() const;
  private:
  bool _internal_has_messagetimestamp() const;

  public:
  void clear_messagetimestamp() ;
  const ::commonmodule::Timestamp& messagetimestamp() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_messagetimestamp();
  ::commonmodule::Timestamp* mutable_messagetimestamp();
  void set_allocated_messagetimestamp(::commonmodule::Timestamp* messagetimestamp);
  private:
  const ::commonmodule::Timestamp& _internal_messagetimestamp() const;
  ::commonmodule::Timestamp* _internal_mutable_messagetimestamp();
  public:
  void unsafe_arena_set_allocated_messagetimestamp(
      ::commonmodule::Timestamp* messagetimestamp);
  ::commonmodule::Timestamp* unsafe_arena_release_messagetimestamp();
  // @@protoc_insertion_point(class_scope:commonmodule.MessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::commonmodule::Timestamp* messagetimestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class CapabilityMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.CapabilityMessageInfo) */ {
 public:
  inline CapabilityMessageInfo() : CapabilityMessageInfo(nullptr) {}
  ~CapabilityMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR CapabilityMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapabilityMessageInfo(const CapabilityMessageInfo& from);
  CapabilityMessageInfo(CapabilityMessageInfo&& from) noexcept
    : CapabilityMessageInfo() {
    *this = ::std::move(from);
  }

  inline CapabilityMessageInfo& operator=(const CapabilityMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityMessageInfo& operator=(CapabilityMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapabilityMessageInfo* internal_default_instance() {
    return reinterpret_cast<const CapabilityMessageInfo*>(
               &_CapabilityMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CapabilityMessageInfo& a, CapabilityMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CapabilityMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityMessageInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapabilityMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapabilityMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CapabilityMessageInfo& from) {
    CapabilityMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapabilityMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.CapabilityMessageInfo";
  }
  protected:
  explicit CapabilityMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageInfoFieldNumber = 1,
  };
  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  private:
  bool _internal_has_messageinfo() const;

  public:
  void clear_messageinfo() ;
  const ::commonmodule::MessageInfo& messageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);
  private:
  const ::commonmodule::MessageInfo& _internal_messageinfo() const;
  ::commonmodule::MessageInfo* _internal_mutable_messageinfo();
  public:
  void unsafe_arena_set_allocated_messageinfo(
      ::commonmodule::MessageInfo* messageinfo);
  ::commonmodule::MessageInfo* unsafe_arena_release_messageinfo();
  // @@protoc_insertion_point(class_scope:commonmodule.CapabilityMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::MessageInfo* messageinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class CheckConditions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.CheckConditions) */ {
 public:
  inline CheckConditions() : CheckConditions(nullptr) {}
  ~CheckConditions() override;
  explicit PROTOBUF_CONSTEXPR CheckConditions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckConditions(const CheckConditions& from);
  CheckConditions(CheckConditions&& from) noexcept
    : CheckConditions() {
    *this = ::std::move(from);
  }

  inline CheckConditions& operator=(const CheckConditions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckConditions& operator=(CheckConditions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckConditions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckConditions* internal_default_instance() {
    return reinterpret_cast<const CheckConditions*>(
               &_CheckConditions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CheckConditions& a, CheckConditions& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckConditions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckConditions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckConditions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckConditions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckConditions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckConditions& from) {
    CheckConditions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckConditions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.CheckConditions";
  }
  protected:
  explicit CheckConditions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterlockCheckFieldNumber = 1,
    kSynchroCheckFieldNumber = 2,
  };
  // .google.protobuf.BoolValue interlockCheck = 1;
  bool has_interlockcheck() const;
  private:
  bool _internal_has_interlockcheck() const;

  public:
  void clear_interlockcheck() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& interlockcheck() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_interlockcheck();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_interlockcheck();
  void set_allocated_interlockcheck(::PROTOBUF_NAMESPACE_ID::BoolValue* interlockcheck);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_interlockcheck() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_interlockcheck();
  public:
  void unsafe_arena_set_allocated_interlockcheck(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* interlockcheck);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_interlockcheck();
  // .google.protobuf.BoolValue synchroCheck = 2;
  bool has_synchrocheck() const;
  private:
  bool _internal_has_synchrocheck() const;

  public:
  void clear_synchrocheck() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& synchrocheck() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_synchrocheck();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_synchrocheck();
  void set_allocated_synchrocheck(::PROTOBUF_NAMESPACE_ID::BoolValue* synchrocheck);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_synchrocheck() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_synchrocheck();
  public:
  void unsafe_arena_set_allocated_synchrocheck(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* synchrocheck);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_synchrocheck();
  // @@protoc_insertion_point(class_scope:commonmodule.CheckConditions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::BoolValue* interlockcheck_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* synchrocheck_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ClearingTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ClearingTime) */ {
 public:
  inline ClearingTime() : ClearingTime(nullptr) {}
  ~ClearingTime() override;
  explicit PROTOBUF_CONSTEXPR ClearingTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearingTime(const ClearingTime& from);
  ClearingTime(ClearingTime&& from) noexcept
    : ClearingTime() {
    *this = ::std::move(from);
  }

  inline ClearingTime& operator=(const ClearingTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearingTime& operator=(ClearingTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearingTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearingTime* internal_default_instance() {
    return reinterpret_cast<const ClearingTime*>(
               &_ClearingTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ClearingTime& a, ClearingTime& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearingTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearingTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearingTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearingTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearingTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearingTime& from) {
    ClearingTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearingTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ClearingTime";
  }
  protected:
  explicit ClearingTime(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 2,
    kNanosecondsFieldNumber = 3,
  };
  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_seconds() ;
  ::uint64_t seconds() const;
  void set_seconds(::uint64_t value);

  private:
  ::uint64_t _internal_seconds() const;
  void _internal_set_seconds(::uint64_t value);

  public:
  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_nanoseconds() ;
  ::uint32_t nanoseconds() const;
  void set_nanoseconds(::uint32_t value);

  private:
  ::uint32_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ClearingTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t seconds_;
    ::uint32_t nanoseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Vector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  explicit PROTOBUF_CONSTEXPR Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector& from) {
    Vector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngFieldNumber = 1,
    kMagFieldNumber = 2,
  };
  // .google.protobuf.DoubleValue ang = 1;
  bool has_ang() const;
  private:
  bool _internal_has_ang() const;

  public:
  void clear_ang() ;
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& ang() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::DoubleValue* release_ang();
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_ang();
  void set_allocated_ang(::PROTOBUF_NAMESPACE_ID::DoubleValue* ang);
  private:
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_ang() const;
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_ang();
  public:
  void unsafe_arena_set_allocated_ang(
      ::PROTOBUF_NAMESPACE_ID::DoubleValue* ang);
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_ang();
  // double mag = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_mag() ;
  double mag() const;
  void set_mag(double value);

  private:
  double _internal_mag() const;
  void _internal_set_mag(double value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* ang_;
    double mag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class CMV final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.CMV) */ {
 public:
  inline CMV() : CMV(nullptr) {}
  ~CMV() override;
  explicit PROTOBUF_CONSTEXPR CMV(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMV(const CMV& from);
  CMV(CMV&& from) noexcept
    : CMV() {
    *this = ::std::move(from);
  }

  inline CMV& operator=(const CMV& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMV& operator=(CMV&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMV& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMV* internal_default_instance() {
    return reinterpret_cast<const CMV*>(
               &_CMV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CMV& a, CMV& b) {
    a.Swap(&b);
  }
  inline void Swap(CMV* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMV* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMV>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMV& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMV& from) {
    CMV::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMV* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.CMV";
  }
  protected:
  explicit CMV(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCValFieldNumber = 1,
    kQFieldNumber = 2,
    kTFieldNumber = 3,
  };
  // .commonmodule.Vector cVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_cval() const;
  private:
  bool _internal_has_cval() const;

  public:
  void clear_cval() ;
  const ::commonmodule::Vector& cval() const;
  PROTOBUF_NODISCARD ::commonmodule::Vector* release_cval();
  ::commonmodule::Vector* mutable_cval();
  void set_allocated_cval(::commonmodule::Vector* cval);
  private:
  const ::commonmodule::Vector& _internal_cval() const;
  ::commonmodule::Vector* _internal_mutable_cval();
  public:
  void unsafe_arena_set_allocated_cval(
      ::commonmodule::Vector* cval);
  ::commonmodule::Vector* unsafe_arena_release_cval();
  // .commonmodule.Quality q = 2;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // @@protoc_insertion_point(class_scope:commonmodule.CMV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Vector* cval_;
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ConductingEquipment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ConductingEquipment) */ {
 public:
  inline ConductingEquipment() : ConductingEquipment(nullptr) {}
  ~ConductingEquipment() override;
  explicit PROTOBUF_CONSTEXPR ConductingEquipment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConductingEquipment(const ConductingEquipment& from);
  ConductingEquipment(ConductingEquipment&& from) noexcept
    : ConductingEquipment() {
    *this = ::std::move(from);
  }

  inline ConductingEquipment& operator=(const ConductingEquipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConductingEquipment& operator=(ConductingEquipment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConductingEquipment& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConductingEquipment* internal_default_instance() {
    return reinterpret_cast<const ConductingEquipment*>(
               &_ConductingEquipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ConductingEquipment& a, ConductingEquipment& b) {
    a.Swap(&b);
  }
  inline void Swap(ConductingEquipment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConductingEquipment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConductingEquipment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConductingEquipment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConductingEquipment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConductingEquipment& from) {
    ConductingEquipment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConductingEquipment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ConductingEquipment";
  }
  protected:
  explicit ConductingEquipment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMRIDFieldNumber = 2,
    kNamedObjectFieldNumber = 1,
  };
  // string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true, (.uml.option_key) = true];
  void clear_mrid() ;
  const std::string& mrid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mrid(Arg_&& arg, Args_... args);
  std::string* mutable_mrid();
  PROTOBUF_NODISCARD std::string* release_mrid();
  void set_allocated_mrid(std::string* ptr);

  private:
  const std::string& _internal_mrid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mrid(
      const std::string& value);
  std::string* _internal_mutable_mrid();

  public:
  // .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
  bool has_namedobject() const;
  private:
  bool _internal_has_namedobject() const;

  public:
  void clear_namedobject() ;
  const ::commonmodule::NamedObject& namedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::NamedObject* release_namedobject();
  ::commonmodule::NamedObject* mutable_namedobject();
  void set_allocated_namedobject(::commonmodule::NamedObject* namedobject);
  private:
  const ::commonmodule::NamedObject& _internal_namedobject() const;
  ::commonmodule::NamedObject* _internal_mutable_namedobject();
  public:
  void unsafe_arena_set_allocated_namedobject(
      ::commonmodule::NamedObject* namedobject);
  ::commonmodule::NamedObject* unsafe_arena_release_namedobject();
  // @@protoc_insertion_point(class_scope:commonmodule.ConductingEquipment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mrid_;
    ::commonmodule::NamedObject* namedobject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Terminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Terminal) */ {
 public:
  inline Terminal() : Terminal(nullptr) {}
  ~Terminal() override;
  explicit PROTOBUF_CONSTEXPR Terminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Terminal(const Terminal& from);
  Terminal(Terminal&& from) noexcept
    : Terminal() {
    *this = ::std::move(from);
  }

  inline Terminal& operator=(const Terminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Terminal& operator=(Terminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Terminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Terminal* internal_default_instance() {
    return reinterpret_cast<const Terminal*>(
               &_Terminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Terminal& a, Terminal& b) {
    a.Swap(&b);
  }
  inline void Swap(Terminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Terminal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Terminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Terminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Terminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Terminal& from) {
    Terminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Terminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Terminal";
  }
  protected:
  explicit Terminal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kACDCTerminalFieldNumber = 1,
    kPhasesFieldNumber = 2,
  };
  // .commonmodule.ACDCTerminal aCDCTerminal = 1 [(.uml.option_parent_message) = true];
  bool has_acdcterminal() const;
  private:
  bool _internal_has_acdcterminal() const;

  public:
  void clear_acdcterminal() ;
  const ::commonmodule::ACDCTerminal& acdcterminal() const;
  PROTOBUF_NODISCARD ::commonmodule::ACDCTerminal* release_acdcterminal();
  ::commonmodule::ACDCTerminal* mutable_acdcterminal();
  void set_allocated_acdcterminal(::commonmodule::ACDCTerminal* acdcterminal);
  private:
  const ::commonmodule::ACDCTerminal& _internal_acdcterminal() const;
  ::commonmodule::ACDCTerminal* _internal_mutable_acdcterminal();
  public:
  void unsafe_arena_set_allocated_acdcterminal(
      ::commonmodule::ACDCTerminal* acdcterminal);
  ::commonmodule::ACDCTerminal* unsafe_arena_release_acdcterminal();
  // .commonmodule.Optional_PhaseCodeKind phases = 2;
  bool has_phases() const;
  private:
  bool _internal_has_phases() const;

  public:
  void clear_phases() ;
  const ::commonmodule::Optional_PhaseCodeKind& phases() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseCodeKind* release_phases();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phases();
  void set_allocated_phases(::commonmodule::Optional_PhaseCodeKind* phases);
  private:
  const ::commonmodule::Optional_PhaseCodeKind& _internal_phases() const;
  ::commonmodule::Optional_PhaseCodeKind* _internal_mutable_phases();
  public:
  void unsafe_arena_set_allocated_phases(
      ::commonmodule::Optional_PhaseCodeKind* phases);
  ::commonmodule::Optional_PhaseCodeKind* unsafe_arena_release_phases();
  // @@protoc_insertion_point(class_scope:commonmodule.Terminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ACDCTerminal* acdcterminal_;
    ::commonmodule::Optional_PhaseCodeKind* phases_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ConductingEquipmentTerminalReading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ConductingEquipmentTerminalReading) */ {
 public:
  inline ConductingEquipmentTerminalReading() : ConductingEquipmentTerminalReading(nullptr) {}
  ~ConductingEquipmentTerminalReading() override;
  explicit PROTOBUF_CONSTEXPR ConductingEquipmentTerminalReading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConductingEquipmentTerminalReading(const ConductingEquipmentTerminalReading& from);
  ConductingEquipmentTerminalReading(ConductingEquipmentTerminalReading&& from) noexcept
    : ConductingEquipmentTerminalReading() {
    *this = ::std::move(from);
  }

  inline ConductingEquipmentTerminalReading& operator=(const ConductingEquipmentTerminalReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConductingEquipmentTerminalReading& operator=(ConductingEquipmentTerminalReading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConductingEquipmentTerminalReading& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConductingEquipmentTerminalReading* internal_default_instance() {
    return reinterpret_cast<const ConductingEquipmentTerminalReading*>(
               &_ConductingEquipmentTerminalReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ConductingEquipmentTerminalReading& a, ConductingEquipmentTerminalReading& b) {
    a.Swap(&b);
  }
  inline void Swap(ConductingEquipmentTerminalReading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConductingEquipmentTerminalReading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConductingEquipmentTerminalReading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConductingEquipmentTerminalReading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConductingEquipmentTerminalReading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConductingEquipmentTerminalReading& from) {
    ConductingEquipmentTerminalReading::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConductingEquipmentTerminalReading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ConductingEquipmentTerminalReading";
  }
  protected:
  explicit ConductingEquipmentTerminalReading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalFieldNumber = 1,
  };
  // .commonmodule.Terminal terminal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_terminal() const;
  private:
  bool _internal_has_terminal() const;

  public:
  void clear_terminal() ;
  const ::commonmodule::Terminal& terminal() const;
  PROTOBUF_NODISCARD ::commonmodule::Terminal* release_terminal();
  ::commonmodule::Terminal* mutable_terminal();
  void set_allocated_terminal(::commonmodule::Terminal* terminal);
  private:
  const ::commonmodule::Terminal& _internal_terminal() const;
  ::commonmodule::Terminal* _internal_mutable_terminal();
  public:
  void unsafe_arena_set_allocated_terminal(
      ::commonmodule::Terminal* terminal);
  ::commonmodule::Terminal* unsafe_arena_release_terminal();
  // @@protoc_insertion_point(class_scope:commonmodule.ConductingEquipmentTerminalReading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Terminal* terminal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlAPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlAPC) */ {
 public:
  inline ControlAPC() : ControlAPC(nullptr) {}
  ~ControlAPC() override;
  explicit PROTOBUF_CONSTEXPR ControlAPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlAPC(const ControlAPC& from);
  ControlAPC(ControlAPC&& from) noexcept
    : ControlAPC() {
    *this = ::std::move(from);
  }

  inline ControlAPC& operator=(const ControlAPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlAPC& operator=(ControlAPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlAPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlAPC* internal_default_instance() {
    return reinterpret_cast<const ControlAPC*>(
               &_ControlAPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ControlAPC& a, ControlAPC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlAPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlAPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlAPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlAPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlAPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlAPC& from) {
    ControlAPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlAPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlAPC";
  }
  protected:
  explicit ControlAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlValFieldNumber = 1,
  };
  // double ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval() ;
  double ctlval() const;
  void set_ctlval(double value);

  private:
  double _internal_ctlval() const;
  void _internal_set_ctlval(double value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ControlAPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double ctlval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlDPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlDPC) */ {
 public:
  inline ControlDPC() : ControlDPC(nullptr) {}
  ~ControlDPC() override;
  explicit PROTOBUF_CONSTEXPR ControlDPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlDPC(const ControlDPC& from);
  ControlDPC(ControlDPC&& from) noexcept
    : ControlDPC() {
    *this = ::std::move(from);
  }

  inline ControlDPC& operator=(const ControlDPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlDPC& operator=(ControlDPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlDPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlDPC* internal_default_instance() {
    return reinterpret_cast<const ControlDPC*>(
               &_ControlDPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ControlDPC& a, ControlDPC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlDPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlDPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlDPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlDPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlDPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlDPC& from) {
    ControlDPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlDPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlDPC";
  }
  protected:
  explicit ControlDPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlValFieldNumber = 1,
  };
  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval() ;
  bool ctlval() const;
  void set_ctlval(bool value);

  private:
  bool _internal_ctlval() const;
  void _internal_set_ctlval(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ControlDPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ctlval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlTimestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlTimestamp) */ {
 public:
  inline ControlTimestamp() : ControlTimestamp(nullptr) {}
  ~ControlTimestamp() override;
  explicit PROTOBUF_CONSTEXPR ControlTimestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlTimestamp(const ControlTimestamp& from);
  ControlTimestamp(ControlTimestamp&& from) noexcept
    : ControlTimestamp() {
    *this = ::std::move(from);
  }

  inline ControlTimestamp& operator=(const ControlTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlTimestamp& operator=(ControlTimestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlTimestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlTimestamp* internal_default_instance() {
    return reinterpret_cast<const ControlTimestamp*>(
               &_ControlTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ControlTimestamp& a, ControlTimestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlTimestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlTimestamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlTimestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlTimestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlTimestamp& from) {
    ControlTimestamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlTimestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlTimestamp";
  }
  protected:
  explicit ControlTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 2,
    kNanosecondsFieldNumber = 3,
  };
  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_seconds() ;
  ::uint64_t seconds() const;
  void set_seconds(::uint64_t value);

  private:
  ::uint64_t _internal_seconds() const;
  void _internal_set_seconds(::uint64_t value);

  public:
  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_nanoseconds() ;
  ::uint32_t nanoseconds() const;
  void set_nanoseconds(::uint32_t value);

  private:
  ::uint32_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ControlTimestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t seconds_;
    ::uint32_t nanoseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_ScheduleParameterKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_ScheduleParameterKind) */ {
 public:
  inline Optional_ScheduleParameterKind() : Optional_ScheduleParameterKind(nullptr) {}
  ~Optional_ScheduleParameterKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_ScheduleParameterKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_ScheduleParameterKind(const Optional_ScheduleParameterKind& from);
  Optional_ScheduleParameterKind(Optional_ScheduleParameterKind&& from) noexcept
    : Optional_ScheduleParameterKind() {
    *this = ::std::move(from);
  }

  inline Optional_ScheduleParameterKind& operator=(const Optional_ScheduleParameterKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_ScheduleParameterKind& operator=(Optional_ScheduleParameterKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_ScheduleParameterKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_ScheduleParameterKind* internal_default_instance() {
    return reinterpret_cast<const Optional_ScheduleParameterKind*>(
               &_Optional_ScheduleParameterKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Optional_ScheduleParameterKind& a, Optional_ScheduleParameterKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_ScheduleParameterKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_ScheduleParameterKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_ScheduleParameterKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_ScheduleParameterKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_ScheduleParameterKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_ScheduleParameterKind& from) {
    Optional_ScheduleParameterKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_ScheduleParameterKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_ScheduleParameterKind";
  }
  protected:
  explicit Optional_ScheduleParameterKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.ScheduleParameterKind value = 1;
  void clear_value() ;
  ::commonmodule::ScheduleParameterKind value() const;
  void set_value(::commonmodule::ScheduleParameterKind value);

  private:
  ::commonmodule::ScheduleParameterKind _internal_value() const;
  void _internal_set_value(::commonmodule::ScheduleParameterKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_ScheduleParameterKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENG_ScheduleParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_ScheduleParameter) */ {
 public:
  inline ENG_ScheduleParameter() : ENG_ScheduleParameter(nullptr) {}
  ~ENG_ScheduleParameter() override;
  explicit PROTOBUF_CONSTEXPR ENG_ScheduleParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENG_ScheduleParameter(const ENG_ScheduleParameter& from);
  ENG_ScheduleParameter(ENG_ScheduleParameter&& from) noexcept
    : ENG_ScheduleParameter() {
    *this = ::std::move(from);
  }

  inline ENG_ScheduleParameter& operator=(const ENG_ScheduleParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENG_ScheduleParameter& operator=(ENG_ScheduleParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENG_ScheduleParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENG_ScheduleParameter* internal_default_instance() {
    return reinterpret_cast<const ENG_ScheduleParameter*>(
               &_ENG_ScheduleParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ENG_ScheduleParameter& a, ENG_ScheduleParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ENG_ScheduleParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENG_ScheduleParameter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENG_ScheduleParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENG_ScheduleParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENG_ScheduleParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENG_ScheduleParameter& from) {
    ENG_ScheduleParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_ScheduleParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENG_ScheduleParameter";
  }
  protected:
  explicit ENG_ScheduleParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kScheduleParameterTypeFieldNumber = 1,
  };
  // double value = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // .commonmodule.ScheduleParameterKind scheduleParameterType = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_scheduleparametertype() ;
  ::commonmodule::ScheduleParameterKind scheduleparametertype() const;
  void set_scheduleparametertype(::commonmodule::ScheduleParameterKind value);

  private:
  ::commonmodule::ScheduleParameterKind _internal_scheduleparametertype() const;
  void _internal_set_scheduleparametertype(::commonmodule::ScheduleParameterKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENG_ScheduleParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double value_;
    int scheduleparametertype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class SchedulePoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.SchedulePoint) */ {
 public:
  inline SchedulePoint() : SchedulePoint(nullptr) {}
  ~SchedulePoint() override;
  explicit PROTOBUF_CONSTEXPR SchedulePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedulePoint(const SchedulePoint& from);
  SchedulePoint(SchedulePoint&& from) noexcept
    : SchedulePoint() {
    *this = ::std::move(from);
  }

  inline SchedulePoint& operator=(const SchedulePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedulePoint& operator=(SchedulePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedulePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedulePoint* internal_default_instance() {
    return reinterpret_cast<const SchedulePoint*>(
               &_SchedulePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SchedulePoint& a, SchedulePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedulePoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedulePoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedulePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedulePoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedulePoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedulePoint& from) {
    SchedulePoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedulePoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.SchedulePoint";
  }
  protected:
  explicit SchedulePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleParameterFieldNumber = 1,
    kStartTimeFieldNumber = 2,
  };
  // repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int scheduleparameter_size() const;
  private:
  int _internal_scheduleparameter_size() const;

  public:
  void clear_scheduleparameter() ;
  ::commonmodule::ENG_ScheduleParameter* mutable_scheduleparameter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >*
      mutable_scheduleparameter();
  private:
  const ::commonmodule::ENG_ScheduleParameter& _internal_scheduleparameter(int index) const;
  ::commonmodule::ENG_ScheduleParameter* _internal_add_scheduleparameter();
  public:
  const ::commonmodule::ENG_ScheduleParameter& scheduleparameter(int index) const;
  ::commonmodule::ENG_ScheduleParameter* add_scheduleparameter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >&
      scheduleparameter() const;
  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;

  public:
  void clear_starttime() ;
  const ::commonmodule::ControlTimestamp& starttime() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);
  private:
  const ::commonmodule::ControlTimestamp& _internal_starttime() const;
  ::commonmodule::ControlTimestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::commonmodule::ControlTimestamp* starttime);
  ::commonmodule::ControlTimestamp* unsafe_arena_release_starttime();
  // @@protoc_insertion_point(class_scope:commonmodule.SchedulePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter > scheduleparameter_;
    ::commonmodule::ControlTimestamp* starttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ScheduleCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ScheduleCSG) */ {
 public:
  inline ScheduleCSG() : ScheduleCSG(nullptr) {}
  ~ScheduleCSG() override;
  explicit PROTOBUF_CONSTEXPR ScheduleCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleCSG(const ScheduleCSG& from);
  ScheduleCSG(ScheduleCSG&& from) noexcept
    : ScheduleCSG() {
    *this = ::std::move(from);
  }

  inline ScheduleCSG& operator=(const ScheduleCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleCSG& operator=(ScheduleCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleCSG* internal_default_instance() {
    return reinterpret_cast<const ScheduleCSG*>(
               &_ScheduleCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ScheduleCSG& a, ScheduleCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduleCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduleCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduleCSG& from) {
    ScheduleCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ScheduleCSG";
  }
  protected:
  explicit ScheduleCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchPtsFieldNumber = 1,
  };
  // repeated .commonmodule.SchedulePoint schPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int schpts_size() const;
  private:
  int _internal_schpts_size() const;

  public:
  void clear_schpts() ;
  ::commonmodule::SchedulePoint* mutable_schpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SchedulePoint >*
      mutable_schpts();
  private:
  const ::commonmodule::SchedulePoint& _internal_schpts(int index) const;
  ::commonmodule::SchedulePoint* _internal_add_schpts();
  public:
  const ::commonmodule::SchedulePoint& schpts(int index) const;
  ::commonmodule::SchedulePoint* add_schpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SchedulePoint >&
      schpts() const;
  // @@protoc_insertion_point(class_scope:commonmodule.ScheduleCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SchedulePoint > schpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlScheduleFSCH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlScheduleFSCH) */ {
 public:
  inline ControlScheduleFSCH() : ControlScheduleFSCH(nullptr) {}
  ~ControlScheduleFSCH() override;
  explicit PROTOBUF_CONSTEXPR ControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlScheduleFSCH(const ControlScheduleFSCH& from);
  ControlScheduleFSCH(ControlScheduleFSCH&& from) noexcept
    : ControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline ControlScheduleFSCH& operator=(const ControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlScheduleFSCH& operator=(ControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlScheduleFSCH& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const ControlScheduleFSCH*>(
               &_ControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ControlScheduleFSCH& a, ControlScheduleFSCH& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlScheduleFSCH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlScheduleFSCH* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlScheduleFSCH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlScheduleFSCH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlScheduleFSCH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlScheduleFSCH& from) {
    ControlScheduleFSCH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlScheduleFSCH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlScheduleFSCH";
  }
  protected:
  explicit ControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValACSGFieldNumber = 1,
  };
  // .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valacsg() const;
  private:
  bool _internal_has_valacsg() const;

  public:
  void clear_valacsg() ;
  const ::commonmodule::ScheduleCSG& valacsg() const;
  PROTOBUF_NODISCARD ::commonmodule::ScheduleCSG* release_valacsg();
  ::commonmodule::ScheduleCSG* mutable_valacsg();
  void set_allocated_valacsg(::commonmodule::ScheduleCSG* valacsg);
  private:
  const ::commonmodule::ScheduleCSG& _internal_valacsg() const;
  ::commonmodule::ScheduleCSG* _internal_mutable_valacsg();
  public:
  void unsafe_arena_set_allocated_valacsg(
      ::commonmodule::ScheduleCSG* valacsg);
  ::commonmodule::ScheduleCSG* unsafe_arena_release_valacsg();
  // @@protoc_insertion_point(class_scope:commonmodule.ControlScheduleFSCH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ScheduleCSG* valacsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class LogicalNodeForControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.LogicalNodeForControl) */ {
 public:
  inline LogicalNodeForControl() : LogicalNodeForControl(nullptr) {}
  ~LogicalNodeForControl() override;
  explicit PROTOBUF_CONSTEXPR LogicalNodeForControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicalNodeForControl(const LogicalNodeForControl& from);
  LogicalNodeForControl(LogicalNodeForControl&& from) noexcept
    : LogicalNodeForControl() {
    *this = ::std::move(from);
  }

  inline LogicalNodeForControl& operator=(const LogicalNodeForControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalNodeForControl& operator=(LogicalNodeForControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogicalNodeForControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalNodeForControl* internal_default_instance() {
    return reinterpret_cast<const LogicalNodeForControl*>(
               &_LogicalNodeForControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(LogicalNodeForControl& a, LogicalNodeForControl& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalNodeForControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalNodeForControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogicalNodeForControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogicalNodeForControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogicalNodeForControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogicalNodeForControl& from) {
    LogicalNodeForControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalNodeForControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.LogicalNodeForControl";
  }
  protected:
  explicit LogicalNodeForControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // @@protoc_insertion_point(class_scope:commonmodule.LogicalNodeForControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlFSCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlFSCC) */ {
 public:
  inline ControlFSCC() : ControlFSCC(nullptr) {}
  ~ControlFSCC() override;
  explicit PROTOBUF_CONSTEXPR ControlFSCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlFSCC(const ControlFSCC& from);
  ControlFSCC(ControlFSCC&& from) noexcept
    : ControlFSCC() {
    *this = ::std::move(from);
  }

  inline ControlFSCC& operator=(const ControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlFSCC& operator=(ControlFSCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlFSCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlFSCC* internal_default_instance() {
    return reinterpret_cast<const ControlFSCC*>(
               &_ControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ControlFSCC& a, ControlFSCC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlFSCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlFSCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlFSCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlFSCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlFSCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlFSCC& from) {
    ControlFSCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlFSCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlFSCC";
  }
  protected:
  explicit ControlFSCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kControlScheduleFSCHFieldNumber = 2,
    kIslandControlScheduleFSCHFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;

  public:
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();
  // .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;
  bool has_controlschedulefsch() const;
  private:
  bool _internal_has_controlschedulefsch() const;

  public:
  void clear_controlschedulefsch() ;
  const ::commonmodule::ControlScheduleFSCH& controlschedulefsch() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlScheduleFSCH* release_controlschedulefsch();
  ::commonmodule::ControlScheduleFSCH* mutable_controlschedulefsch();
  void set_allocated_controlschedulefsch(::commonmodule::ControlScheduleFSCH* controlschedulefsch);
  private:
  const ::commonmodule::ControlScheduleFSCH& _internal_controlschedulefsch() const;
  ::commonmodule::ControlScheduleFSCH* _internal_mutable_controlschedulefsch();
  public:
  void unsafe_arena_set_allocated_controlschedulefsch(
      ::commonmodule::ControlScheduleFSCH* controlschedulefsch);
  ::commonmodule::ControlScheduleFSCH* unsafe_arena_release_controlschedulefsch();
  // .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;
  bool has_islandcontrolschedulefsch() const;
  private:
  bool _internal_has_islandcontrolschedulefsch() const;

  public:
  void clear_islandcontrolschedulefsch() ;
  const ::commonmodule::ControlScheduleFSCH& islandcontrolschedulefsch() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlScheduleFSCH* release_islandcontrolschedulefsch();
  ::commonmodule::ControlScheduleFSCH* mutable_islandcontrolschedulefsch();
  void set_allocated_islandcontrolschedulefsch(::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch);
  private:
  const ::commonmodule::ControlScheduleFSCH& _internal_islandcontrolschedulefsch() const;
  ::commonmodule::ControlScheduleFSCH* _internal_mutable_islandcontrolschedulefsch();
  public:
  void unsafe_arena_set_allocated_islandcontrolschedulefsch(
      ::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch);
  ::commonmodule::ControlScheduleFSCH* unsafe_arena_release_islandcontrolschedulefsch();
  // @@protoc_insertion_point(class_scope:commonmodule.ControlFSCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
    ::commonmodule::ControlScheduleFSCH* controlschedulefsch_;
    ::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlINC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlINC) */ {
 public:
  inline ControlINC() : ControlINC(nullptr) {}
  ~ControlINC() override;
  explicit PROTOBUF_CONSTEXPR ControlINC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlINC(const ControlINC& from);
  ControlINC(ControlINC&& from) noexcept
    : ControlINC() {
    *this = ::std::move(from);
  }

  inline ControlINC& operator=(const ControlINC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlINC& operator=(ControlINC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlINC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlINC* internal_default_instance() {
    return reinterpret_cast<const ControlINC*>(
               &_ControlINC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ControlINC& a, ControlINC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlINC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlINC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlINC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlINC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlINC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlINC& from) {
    ControlINC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlINC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlINC";
  }
  protected:
  explicit ControlINC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlValFieldNumber = 1,
  };
  // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval() ;
  ::int32_t ctlval() const;
  void set_ctlval(::int32_t value);

  private:
  ::int32_t _internal_ctlval() const;
  void _internal_set_ctlval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ControlINC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t ctlval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlING) */ {
 public:
  inline ControlING() : ControlING(nullptr) {}
  ~ControlING() override;
  explicit PROTOBUF_CONSTEXPR ControlING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlING(const ControlING& from);
  ControlING(ControlING&& from) noexcept
    : ControlING() {
    *this = ::std::move(from);
  }

  inline ControlING& operator=(const ControlING& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlING& operator=(ControlING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlING& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlING* internal_default_instance() {
    return reinterpret_cast<const ControlING*>(
               &_ControlING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ControlING& a, ControlING& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlING* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlING& from) {
    ControlING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlING";
  }
  protected:
  explicit ControlING(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitsFieldNumber = 2,
    kSetValFieldNumber = 1,
  };
  // .commonmodule.Unit units = 2;
  bool has_units() const;
  private:
  bool _internal_has_units() const;

  public:
  void clear_units() ;
  const ::commonmodule::Unit& units() const;
  PROTOBUF_NODISCARD ::commonmodule::Unit* release_units();
  ::commonmodule::Unit* mutable_units();
  void set_allocated_units(::commonmodule::Unit* units);
  private:
  const ::commonmodule::Unit& _internal_units() const;
  ::commonmodule::Unit* _internal_mutable_units();
  public:
  void unsafe_arena_set_allocated_units(
      ::commonmodule::Unit* units);
  ::commonmodule::Unit* unsafe_arena_release_units();
  // int32 setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval() ;
  ::int32_t setval() const;
  void set_setval(::int32_t value);

  private:
  ::int32_t _internal_setval() const;
  void _internal_set_setval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ControlING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Unit* units_;
    ::int32_t setval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlISC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlISC) */ {
 public:
  inline ControlISC() : ControlISC(nullptr) {}
  ~ControlISC() override;
  explicit PROTOBUF_CONSTEXPR ControlISC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlISC(const ControlISC& from);
  ControlISC(ControlISC&& from) noexcept
    : ControlISC() {
    *this = ::std::move(from);
  }

  inline ControlISC& operator=(const ControlISC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlISC& operator=(ControlISC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlISC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlISC* internal_default_instance() {
    return reinterpret_cast<const ControlISC*>(
               &_ControlISC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ControlISC& a, ControlISC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlISC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlISC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlISC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlISC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlISC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlISC& from) {
    ControlISC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlISC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlISC";
  }
  protected:
  explicit ControlISC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlValFieldNumber = 1,
  };
  // int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval() ;
  ::int32_t ctlval() const;
  void set_ctlval(::int32_t value);

  private:
  ::int32_t _internal_ctlval() const;
  void _internal_set_ctlval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ControlISC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t ctlval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlMessageInfo) */ {
 public:
  inline ControlMessageInfo() : ControlMessageInfo(nullptr) {}
  ~ControlMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR ControlMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMessageInfo(const ControlMessageInfo& from);
  ControlMessageInfo(ControlMessageInfo&& from) noexcept
    : ControlMessageInfo() {
    *this = ::std::move(from);
  }

  inline ControlMessageInfo& operator=(const ControlMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMessageInfo& operator=(ControlMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMessageInfo* internal_default_instance() {
    return reinterpret_cast<const ControlMessageInfo*>(
               &_ControlMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ControlMessageInfo& a, ControlMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMessageInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlMessageInfo& from) {
    ControlMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlMessageInfo";
  }
  protected:
  explicit ControlMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageInfoFieldNumber = 1,
  };
  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  private:
  bool _internal_has_messageinfo() const;

  public:
  void clear_messageinfo() ;
  const ::commonmodule::MessageInfo& messageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);
  private:
  const ::commonmodule::MessageInfo& _internal_messageinfo() const;
  ::commonmodule::MessageInfo* _internal_mutable_messageinfo();
  public:
  void unsafe_arena_set_allocated_messageinfo(
      ::commonmodule::MessageInfo* messageinfo);
  ::commonmodule::MessageInfo* unsafe_arena_release_messageinfo();
  // @@protoc_insertion_point(class_scope:commonmodule.ControlMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::MessageInfo* messageinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlSPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlSPC) */ {
 public:
  inline ControlSPC() : ControlSPC(nullptr) {}
  ~ControlSPC() override;
  explicit PROTOBUF_CONSTEXPR ControlSPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlSPC(const ControlSPC& from);
  ControlSPC(ControlSPC&& from) noexcept
    : ControlSPC() {
    *this = ::std::move(from);
  }

  inline ControlSPC& operator=(const ControlSPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlSPC& operator=(ControlSPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlSPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlSPC* internal_default_instance() {
    return reinterpret_cast<const ControlSPC*>(
               &_ControlSPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ControlSPC& a, ControlSPC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlSPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlSPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlSPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlSPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlSPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlSPC& from) {
    ControlSPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlSPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlSPC";
  }
  protected:
  explicit ControlSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlValFieldNumber = 1,
  };
  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval() ;
  bool ctlval() const;
  void set_ctlval(bool value);

  private:
  bool _internal_ctlval() const;
  void _internal_set_ctlval(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ControlSPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ctlval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ControlValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ControlValue) */ {
 public:
  inline ControlValue() : ControlValue(nullptr) {}
  ~ControlValue() override;
  explicit PROTOBUF_CONSTEXPR ControlValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlValue(const ControlValue& from);
  ControlValue(ControlValue&& from) noexcept
    : ControlValue() {
    *this = ::std::move(from);
  }

  inline ControlValue& operator=(const ControlValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlValue& operator=(ControlValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlValue* internal_default_instance() {
    return reinterpret_cast<const ControlValue*>(
               &_ControlValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(ControlValue& a, ControlValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlValue& from) {
    ControlValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ControlValue";
  }
  protected:
  explicit ControlValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kModBlkFieldNumber = 3,
    kResetFieldNumber = 4,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .google.protobuf.BoolValue modBlk = 3;
  bool has_modblk() const;
  private:
  bool _internal_has_modblk() const;

  public:
  void clear_modblk() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& modblk() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_modblk();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_modblk();
  void set_allocated_modblk(::PROTOBUF_NAMESPACE_ID::BoolValue* modblk);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_modblk() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_modblk();
  public:
  void unsafe_arena_set_allocated_modblk(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_modblk();
  // .google.protobuf.BoolValue reset = 4;
  bool has_reset() const;
  private:
  bool _internal_has_reset() const;

  public:
  void clear_reset() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& reset() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_reset();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_reset();
  void set_allocated_reset(::PROTOBUF_NAMESPACE_ID::BoolValue* reset);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_reset() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_reset();
  public:
  void unsafe_arena_set_allocated_reset(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* reset);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_reset();
  // @@protoc_insertion_point(class_scope:commonmodule.ControlValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* reset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class CumulativeTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.CumulativeTime) */ {
 public:
  inline CumulativeTime() : CumulativeTime(nullptr) {}
  ~CumulativeTime() override;
  explicit PROTOBUF_CONSTEXPR CumulativeTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CumulativeTime(const CumulativeTime& from);
  CumulativeTime(CumulativeTime&& from) noexcept
    : CumulativeTime() {
    *this = ::std::move(from);
  }

  inline CumulativeTime& operator=(const CumulativeTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline CumulativeTime& operator=(CumulativeTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CumulativeTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const CumulativeTime* internal_default_instance() {
    return reinterpret_cast<const CumulativeTime*>(
               &_CumulativeTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CumulativeTime& a, CumulativeTime& b) {
    a.Swap(&b);
  }
  inline void Swap(CumulativeTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CumulativeTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CumulativeTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CumulativeTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CumulativeTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CumulativeTime& from) {
    CumulativeTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CumulativeTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.CumulativeTime";
  }
  protected:
  explicit CumulativeTime(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 2,
    kNanosecondsFieldNumber = 3,
  };
  // uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_seconds() ;
  ::uint64_t seconds() const;
  void set_seconds(::uint64_t value);

  private:
  ::uint64_t _internal_seconds() const;
  void _internal_set_seconds(::uint64_t value);

  public:
  // uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_nanoseconds() ;
  ::uint32_t nanoseconds() const;
  void set_nanoseconds(::uint32_t value);

  private:
  ::uint32_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.CumulativeTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t seconds_;
    ::uint32_t nanoseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class DateTimeInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.DateTimeInterval) */ {
 public:
  inline DateTimeInterval() : DateTimeInterval(nullptr) {}
  ~DateTimeInterval() override;
  explicit PROTOBUF_CONSTEXPR DateTimeInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateTimeInterval(const DateTimeInterval& from);
  DateTimeInterval(DateTimeInterval&& from) noexcept
    : DateTimeInterval() {
    *this = ::std::move(from);
  }

  inline DateTimeInterval& operator=(const DateTimeInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateTimeInterval& operator=(DateTimeInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DateTimeInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateTimeInterval* internal_default_instance() {
    return reinterpret_cast<const DateTimeInterval*>(
               &_DateTimeInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(DateTimeInterval& a, DateTimeInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(DateTimeInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateTimeInterval* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateTimeInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateTimeInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DateTimeInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DateTimeInterval& from) {
    DateTimeInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DateTimeInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.DateTimeInterval";
  }
  protected:
  explicit DateTimeInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndFieldNumber = 1,
    kStartFieldNumber = 2,
  };
  // .google.protobuf.Int64Value end = 1;
  bool has_end() const;
  private:
  bool _internal_has_end() const;

  public:
  void clear_end() ;
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& end() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int64Value* release_end();
  ::PROTOBUF_NAMESPACE_ID::Int64Value* mutable_end();
  void set_allocated_end(::PROTOBUF_NAMESPACE_ID::Int64Value* end);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& _internal_end() const;
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::PROTOBUF_NAMESPACE_ID::Int64Value* end);
  ::PROTOBUF_NAMESPACE_ID::Int64Value* unsafe_arena_release_end();
  // .google.protobuf.Int64Value start = 2;
  bool has_start() const;
  private:
  bool _internal_has_start() const;

  public:
  void clear_start() ;
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& start() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int64Value* release_start();
  ::PROTOBUF_NAMESPACE_ID::Int64Value* mutable_start();
  void set_allocated_start(::PROTOBUF_NAMESPACE_ID::Int64Value* start);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int64Value& _internal_start() const;
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::PROTOBUF_NAMESPACE_ID::Int64Value* start);
  ::PROTOBUF_NAMESPACE_ID::Int64Value* unsafe_arena_release_start();
  // @@protoc_insertion_point(class_scope:commonmodule.DateTimeInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Int64Value* end_;
    ::PROTOBUF_NAMESPACE_ID::Int64Value* start_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class DEL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.DEL) */ {
 public:
  inline DEL() : DEL(nullptr) {}
  ~DEL() override;
  explicit PROTOBUF_CONSTEXPR DEL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DEL(const DEL& from);
  DEL(DEL&& from) noexcept
    : DEL() {
    *this = ::std::move(from);
  }

  inline DEL& operator=(const DEL& from) {
    CopyFrom(from);
    return *this;
  }
  inline DEL& operator=(DEL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DEL& default_instance() {
    return *internal_default_instance();
  }
  static inline const DEL* internal_default_instance() {
    return reinterpret_cast<const DEL*>(
               &_DEL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(DEL& a, DEL& b) {
    a.Swap(&b);
  }
  inline void Swap(DEL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DEL* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DEL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DEL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DEL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DEL& from) {
    DEL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DEL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.DEL";
  }
  protected:
  explicit DEL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhsABFieldNumber = 1,
    kPhsBCFieldNumber = 2,
    kPhsCAFieldNumber = 3,
  };
  // .commonmodule.CMV phsAB = 1;
  bool has_phsab() const;
  private:
  bool _internal_has_phsab() const;

  public:
  void clear_phsab() ;
  const ::commonmodule::CMV& phsab() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_phsab();
  ::commonmodule::CMV* mutable_phsab();
  void set_allocated_phsab(::commonmodule::CMV* phsab);
  private:
  const ::commonmodule::CMV& _internal_phsab() const;
  ::commonmodule::CMV* _internal_mutable_phsab();
  public:
  void unsafe_arena_set_allocated_phsab(
      ::commonmodule::CMV* phsab);
  ::commonmodule::CMV* unsafe_arena_release_phsab();
  // .commonmodule.CMV phsBC = 2;
  bool has_phsbc() const;
  private:
  bool _internal_has_phsbc() const;

  public:
  void clear_phsbc() ;
  const ::commonmodule::CMV& phsbc() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_phsbc();
  ::commonmodule::CMV* mutable_phsbc();
  void set_allocated_phsbc(::commonmodule::CMV* phsbc);
  private:
  const ::commonmodule::CMV& _internal_phsbc() const;
  ::commonmodule::CMV* _internal_mutable_phsbc();
  public:
  void unsafe_arena_set_allocated_phsbc(
      ::commonmodule::CMV* phsbc);
  ::commonmodule::CMV* unsafe_arena_release_phsbc();
  // .commonmodule.CMV phsCA = 3;
  bool has_phsca() const;
  private:
  bool _internal_has_phsca() const;

  public:
  void clear_phsca() ;
  const ::commonmodule::CMV& phsca() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_phsca();
  ::commonmodule::CMV* mutable_phsca();
  void set_allocated_phsca(::commonmodule::CMV* phsca);
  private:
  const ::commonmodule::CMV& _internal_phsca() const;
  ::commonmodule::CMV* _internal_mutable_phsca();
  public:
  void unsafe_arena_set_allocated_phsca(
      ::commonmodule::CMV* phsca);
  ::commonmodule::CMV* unsafe_arena_release_phsca();
  // @@protoc_insertion_point(class_scope:commonmodule.DEL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::CMV* phsab_;
    ::commonmodule::CMV* phsbc_;
    ::commonmodule::CMV* phsca_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseDPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseDPC) */ {
 public:
  inline PhaseDPC() : PhaseDPC(nullptr) {}
  ~PhaseDPC() override;
  explicit PROTOBUF_CONSTEXPR PhaseDPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseDPC(const PhaseDPC& from);
  PhaseDPC(PhaseDPC&& from) noexcept
    : PhaseDPC() {
    *this = ::std::move(from);
  }

  inline PhaseDPC& operator=(const PhaseDPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseDPC& operator=(PhaseDPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseDPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseDPC* internal_default_instance() {
    return reinterpret_cast<const PhaseDPC*>(
               &_PhaseDPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(PhaseDPC& a, PhaseDPC& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseDPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseDPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseDPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseDPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseDPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseDPC& from) {
    PhaseDPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseDPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseDPC";
  }
  protected:
  explicit PhaseDPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.ControlDPC phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::ControlDPC& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlDPC* release_phs3();
  ::commonmodule::ControlDPC* mutable_phs3();
  void set_allocated_phs3(::commonmodule::ControlDPC* phs3);
  private:
  const ::commonmodule::ControlDPC& _internal_phs3() const;
  ::commonmodule::ControlDPC* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::ControlDPC* phs3);
  ::commonmodule::ControlDPC* unsafe_arena_release_phs3();
  // .commonmodule.ControlDPC phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::ControlDPC& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlDPC* release_phsa();
  ::commonmodule::ControlDPC* mutable_phsa();
  void set_allocated_phsa(::commonmodule::ControlDPC* phsa);
  private:
  const ::commonmodule::ControlDPC& _internal_phsa() const;
  ::commonmodule::ControlDPC* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::ControlDPC* phsa);
  ::commonmodule::ControlDPC* unsafe_arena_release_phsa();
  // .commonmodule.ControlDPC phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::ControlDPC& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlDPC* release_phsb();
  ::commonmodule::ControlDPC* mutable_phsb();
  void set_allocated_phsb(::commonmodule::ControlDPC* phsb);
  private:
  const ::commonmodule::ControlDPC& _internal_phsb() const;
  ::commonmodule::ControlDPC* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::ControlDPC* phsb);
  ::commonmodule::ControlDPC* unsafe_arena_release_phsb();
  // .commonmodule.ControlDPC phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::ControlDPC& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlDPC* release_phsc();
  ::commonmodule::ControlDPC* mutable_phsc();
  void set_allocated_phsc(::commonmodule::ControlDPC* phsc);
  private:
  const ::commonmodule::ControlDPC& _internal_phsc() const;
  ::commonmodule::ControlDPC* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::ControlDPC* phsc);
  ::commonmodule::ControlDPC* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseDPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlDPC* phs3_;
    ::commonmodule::ControlDPC* phsa_;
    ::commonmodule::ControlDPC* phsb_;
    ::commonmodule::ControlDPC* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class DiscreteControlXCBR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.DiscreteControlXCBR) */ {
 public:
  inline DiscreteControlXCBR() : DiscreteControlXCBR(nullptr) {}
  ~DiscreteControlXCBR() override;
  explicit PROTOBUF_CONSTEXPR DiscreteControlXCBR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiscreteControlXCBR(const DiscreteControlXCBR& from);
  DiscreteControlXCBR(DiscreteControlXCBR&& from) noexcept
    : DiscreteControlXCBR() {
    *this = ::std::move(from);
  }

  inline DiscreteControlXCBR& operator=(const DiscreteControlXCBR& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscreteControlXCBR& operator=(DiscreteControlXCBR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscreteControlXCBR& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiscreteControlXCBR* internal_default_instance() {
    return reinterpret_cast<const DiscreteControlXCBR*>(
               &_DiscreteControlXCBR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DiscreteControlXCBR& a, DiscreteControlXCBR& b) {
    a.Swap(&b);
  }
  inline void Swap(DiscreteControlXCBR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscreteControlXCBR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscreteControlXCBR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiscreteControlXCBR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiscreteControlXCBR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiscreteControlXCBR& from) {
    DiscreteControlXCBR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscreteControlXCBR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.DiscreteControlXCBR";
  }
  protected:
  explicit DiscreteControlXCBR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kPosFieldNumber = 2,
    kProtectionModeFieldNumber = 3,
    kRecloseEnabledFieldNumber = 4,
    kResetProtectionPickupFieldNumber = 5,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;

  public:
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();
  // .commonmodule.PhaseDPC Pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;

  public:
  void clear_pos() ;
  const ::commonmodule::PhaseDPC& pos() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseDPC* release_pos();
  ::commonmodule::PhaseDPC* mutable_pos();
  void set_allocated_pos(::commonmodule::PhaseDPC* pos);
  private:
  const ::commonmodule::PhaseDPC& _internal_pos() const;
  ::commonmodule::PhaseDPC* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::commonmodule::PhaseDPC* pos);
  ::commonmodule::PhaseDPC* unsafe_arena_release_pos();
  // .commonmodule.ControlINC ProtectionMode = 3;
  bool has_protectionmode() const;
  private:
  bool _internal_has_protectionmode() const;

  public:
  void clear_protectionmode() ;
  const ::commonmodule::ControlINC& protectionmode() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlINC* release_protectionmode();
  ::commonmodule::ControlINC* mutable_protectionmode();
  void set_allocated_protectionmode(::commonmodule::ControlINC* protectionmode);
  private:
  const ::commonmodule::ControlINC& _internal_protectionmode() const;
  ::commonmodule::ControlINC* _internal_mutable_protectionmode();
  public:
  void unsafe_arena_set_allocated_protectionmode(
      ::commonmodule::ControlINC* protectionmode);
  ::commonmodule::ControlINC* unsafe_arena_release_protectionmode();
  // .commonmodule.ControlSPC RecloseEnabled = 4;
  bool has_recloseenabled() const;
  private:
  bool _internal_has_recloseenabled() const;

  public:
  void clear_recloseenabled() ;
  const ::commonmodule::ControlSPC& recloseenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_recloseenabled();
  ::commonmodule::ControlSPC* mutable_recloseenabled();
  void set_allocated_recloseenabled(::commonmodule::ControlSPC* recloseenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_recloseenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_recloseenabled();
  public:
  void unsafe_arena_set_allocated_recloseenabled(
      ::commonmodule::ControlSPC* recloseenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_recloseenabled();
  // .commonmodule.ControlSPC ResetProtectionPickup = 5;
  bool has_resetprotectionpickup() const;
  private:
  bool _internal_has_resetprotectionpickup() const;

  public:
  void clear_resetprotectionpickup() ;
  const ::commonmodule::ControlSPC& resetprotectionpickup() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_resetprotectionpickup();
  ::commonmodule::ControlSPC* mutable_resetprotectionpickup();
  void set_allocated_resetprotectionpickup(::commonmodule::ControlSPC* resetprotectionpickup);
  private:
  const ::commonmodule::ControlSPC& _internal_resetprotectionpickup() const;
  ::commonmodule::ControlSPC* _internal_mutable_resetprotectionpickup();
  public:
  void unsafe_arena_set_allocated_resetprotectionpickup(
      ::commonmodule::ControlSPC* resetprotectionpickup);
  ::commonmodule::ControlSPC* unsafe_arena_release_resetprotectionpickup();
  // @@protoc_insertion_point(class_scope:commonmodule.DiscreteControlXCBR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
    ::commonmodule::PhaseDPC* pos_;
    ::commonmodule::ControlINC* protectionmode_;
    ::commonmodule::ControlSPC* recloseenabled_;
    ::commonmodule::ControlSPC* resetprotectionpickup_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class EnergyConsumer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.EnergyConsumer) */ {
 public:
  inline EnergyConsumer() : EnergyConsumer(nullptr) {}
  ~EnergyConsumer() override;
  explicit PROTOBUF_CONSTEXPR EnergyConsumer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnergyConsumer(const EnergyConsumer& from);
  EnergyConsumer(EnergyConsumer&& from) noexcept
    : EnergyConsumer() {
    *this = ::std::move(from);
  }

  inline EnergyConsumer& operator=(const EnergyConsumer& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnergyConsumer& operator=(EnergyConsumer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnergyConsumer& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnergyConsumer* internal_default_instance() {
    return reinterpret_cast<const EnergyConsumer*>(
               &_EnergyConsumer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(EnergyConsumer& a, EnergyConsumer& b) {
    a.Swap(&b);
  }
  inline void Swap(EnergyConsumer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnergyConsumer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnergyConsumer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnergyConsumer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnergyConsumer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnergyConsumer& from) {
    EnergyConsumer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnergyConsumer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.EnergyConsumer";
  }
  protected:
  explicit EnergyConsumer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentFieldNumber = 1,
    kOperatingLimitFieldNumber = 2,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  private:
  bool _internal_has_conductingequipment() const;

  public:
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);
  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_conductingequipment();
  public:
  void unsafe_arena_set_allocated_conductingequipment(
      ::commonmodule::ConductingEquipment* conductingequipment);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_conductingequipment();
  // .google.protobuf.StringValue operatingLimit = 2;
  bool has_operatinglimit() const;
  private:
  bool _internal_has_operatinglimit() const;

  public:
  void clear_operatinglimit() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& operatinglimit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_operatinglimit();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_operatinglimit();
  void set_allocated_operatinglimit(::PROTOBUF_NAMESPACE_ID::StringValue* operatinglimit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_operatinglimit() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_operatinglimit();
  public:
  void unsafe_arena_set_allocated_operatinglimit(
      ::PROTOBUF_NAMESPACE_ID::StringValue* operatinglimit);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_operatinglimit();
  // @@protoc_insertion_point(class_scope:commonmodule.EnergyConsumer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipment* conductingequipment_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* operatinglimit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_CalcMethodKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_CalcMethodKind) */ {
 public:
  inline Optional_CalcMethodKind() : Optional_CalcMethodKind(nullptr) {}
  ~Optional_CalcMethodKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_CalcMethodKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_CalcMethodKind(const Optional_CalcMethodKind& from);
  Optional_CalcMethodKind(Optional_CalcMethodKind&& from) noexcept
    : Optional_CalcMethodKind() {
    *this = ::std::move(from);
  }

  inline Optional_CalcMethodKind& operator=(const Optional_CalcMethodKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_CalcMethodKind& operator=(Optional_CalcMethodKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_CalcMethodKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_CalcMethodKind* internal_default_instance() {
    return reinterpret_cast<const Optional_CalcMethodKind*>(
               &_Optional_CalcMethodKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(Optional_CalcMethodKind& a, Optional_CalcMethodKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_CalcMethodKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_CalcMethodKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_CalcMethodKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_CalcMethodKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_CalcMethodKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_CalcMethodKind& from) {
    Optional_CalcMethodKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_CalcMethodKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_CalcMethodKind";
  }
  protected:
  explicit Optional_CalcMethodKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.CalcMethodKind value = 1;
  void clear_value() ;
  ::commonmodule::CalcMethodKind value() const;
  void set_value(::commonmodule::CalcMethodKind value);

  private:
  ::commonmodule::CalcMethodKind _internal_value() const;
  void _internal_set_value(::commonmodule::CalcMethodKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_CalcMethodKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENG_CalcMethodKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_CalcMethodKind) */ {
 public:
  inline ENG_CalcMethodKind() : ENG_CalcMethodKind(nullptr) {}
  ~ENG_CalcMethodKind() override;
  explicit PROTOBUF_CONSTEXPR ENG_CalcMethodKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENG_CalcMethodKind(const ENG_CalcMethodKind& from);
  ENG_CalcMethodKind(ENG_CalcMethodKind&& from) noexcept
    : ENG_CalcMethodKind() {
    *this = ::std::move(from);
  }

  inline ENG_CalcMethodKind& operator=(const ENG_CalcMethodKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENG_CalcMethodKind& operator=(ENG_CalcMethodKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENG_CalcMethodKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENG_CalcMethodKind* internal_default_instance() {
    return reinterpret_cast<const ENG_CalcMethodKind*>(
               &_ENG_CalcMethodKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ENG_CalcMethodKind& a, ENG_CalcMethodKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENG_CalcMethodKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENG_CalcMethodKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENG_CalcMethodKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENG_CalcMethodKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENG_CalcMethodKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENG_CalcMethodKind& from) {
    ENG_CalcMethodKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_CalcMethodKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENG_CalcMethodKind";
  }
  protected:
  explicit ENG_CalcMethodKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetValFieldNumber = 1,
  };
  // .commonmodule.CalcMethodKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval() ;
  ::commonmodule::CalcMethodKind setval() const;
  void set_setval(::commonmodule::CalcMethodKind value);

  private:
  ::commonmodule::CalcMethodKind _internal_setval() const;
  void _internal_set_setval(::commonmodule::CalcMethodKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENG_CalcMethodKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int setval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_GridConnectModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_GridConnectModeKind) */ {
 public:
  inline Optional_GridConnectModeKind() : Optional_GridConnectModeKind(nullptr) {}
  ~Optional_GridConnectModeKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_GridConnectModeKind(const Optional_GridConnectModeKind& from);
  Optional_GridConnectModeKind(Optional_GridConnectModeKind&& from) noexcept
    : Optional_GridConnectModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_GridConnectModeKind& operator=(const Optional_GridConnectModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_GridConnectModeKind& operator=(Optional_GridConnectModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_GridConnectModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_GridConnectModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_GridConnectModeKind*>(
               &_Optional_GridConnectModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Optional_GridConnectModeKind& a, Optional_GridConnectModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_GridConnectModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_GridConnectModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_GridConnectModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_GridConnectModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_GridConnectModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_GridConnectModeKind& from) {
    Optional_GridConnectModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_GridConnectModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_GridConnectModeKind";
  }
  protected:
  explicit Optional_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.GridConnectModeKind value = 1;
  void clear_value() ;
  ::commonmodule::GridConnectModeKind value() const;
  void set_value(::commonmodule::GridConnectModeKind value);

  private:
  ::commonmodule::GridConnectModeKind _internal_value() const;
  void _internal_set_value(::commonmodule::GridConnectModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_GridConnectModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENG_GridConnectModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_GridConnectModeKind) */ {
 public:
  inline ENG_GridConnectModeKind() : ENG_GridConnectModeKind(nullptr) {}
  ~ENG_GridConnectModeKind() override;
  explicit PROTOBUF_CONSTEXPR ENG_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENG_GridConnectModeKind(const ENG_GridConnectModeKind& from);
  ENG_GridConnectModeKind(ENG_GridConnectModeKind&& from) noexcept
    : ENG_GridConnectModeKind() {
    *this = ::std::move(from);
  }

  inline ENG_GridConnectModeKind& operator=(const ENG_GridConnectModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENG_GridConnectModeKind& operator=(ENG_GridConnectModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENG_GridConnectModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENG_GridConnectModeKind* internal_default_instance() {
    return reinterpret_cast<const ENG_GridConnectModeKind*>(
               &_ENG_GridConnectModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ENG_GridConnectModeKind& a, ENG_GridConnectModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENG_GridConnectModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENG_GridConnectModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENG_GridConnectModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENG_GridConnectModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENG_GridConnectModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENG_GridConnectModeKind& from) {
    ENG_GridConnectModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_GridConnectModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENG_GridConnectModeKind";
  }
  protected:
  explicit ENG_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetValExtensionFieldNumber = 2,
    kSetValFieldNumber = 1,
  };
  // .google.protobuf.StringValue setValExtension = 2;
  bool has_setvalextension() const;
  private:
  bool _internal_has_setvalextension() const;

  public:
  void clear_setvalextension() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& setvalextension() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_setvalextension();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_setvalextension();
  void set_allocated_setvalextension(::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_setvalextension() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_setvalextension();
  public:
  void unsafe_arena_set_allocated_setvalextension(
      ::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_setvalextension();
  // .commonmodule.GridConnectModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval() ;
  ::commonmodule::GridConnectModeKind setval() const;
  void set_setval(::commonmodule::GridConnectModeKind value);

  private:
  ::commonmodule::GridConnectModeKind _internal_setval() const;
  void _internal_set_setval(::commonmodule::GridConnectModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENG_GridConnectModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension_;
    int setval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_PFSignKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_PFSignKind) */ {
 public:
  inline Optional_PFSignKind() : Optional_PFSignKind(nullptr) {}
  ~Optional_PFSignKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_PFSignKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_PFSignKind(const Optional_PFSignKind& from);
  Optional_PFSignKind(Optional_PFSignKind&& from) noexcept
    : Optional_PFSignKind() {
    *this = ::std::move(from);
  }

  inline Optional_PFSignKind& operator=(const Optional_PFSignKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_PFSignKind& operator=(Optional_PFSignKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_PFSignKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_PFSignKind* internal_default_instance() {
    return reinterpret_cast<const Optional_PFSignKind*>(
               &_Optional_PFSignKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Optional_PFSignKind& a, Optional_PFSignKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_PFSignKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_PFSignKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_PFSignKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_PFSignKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_PFSignKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_PFSignKind& from) {
    Optional_PFSignKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_PFSignKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_PFSignKind";
  }
  protected:
  explicit Optional_PFSignKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.PFSignKind value = 1;
  void clear_value() ;
  ::commonmodule::PFSignKind value() const;
  void set_value(::commonmodule::PFSignKind value);

  private:
  ::commonmodule::PFSignKind _internal_value() const;
  void _internal_set_value(::commonmodule::PFSignKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_PFSignKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENG_PFSignKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENG_PFSignKind) */ {
 public:
  inline ENG_PFSignKind() : ENG_PFSignKind(nullptr) {}
  ~ENG_PFSignKind() override;
  explicit PROTOBUF_CONSTEXPR ENG_PFSignKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENG_PFSignKind(const ENG_PFSignKind& from);
  ENG_PFSignKind(ENG_PFSignKind&& from) noexcept
    : ENG_PFSignKind() {
    *this = ::std::move(from);
  }

  inline ENG_PFSignKind& operator=(const ENG_PFSignKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENG_PFSignKind& operator=(ENG_PFSignKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENG_PFSignKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENG_PFSignKind* internal_default_instance() {
    return reinterpret_cast<const ENG_PFSignKind*>(
               &_ENG_PFSignKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(ENG_PFSignKind& a, ENG_PFSignKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENG_PFSignKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENG_PFSignKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENG_PFSignKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENG_PFSignKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENG_PFSignKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENG_PFSignKind& from) {
    ENG_PFSignKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENG_PFSignKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENG_PFSignKind";
  }
  protected:
  explicit ENG_PFSignKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetValFieldNumber = 1,
  };
  // .commonmodule.PFSignKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_setval() ;
  ::commonmodule::PFSignKind setval() const;
  void set_setval(::commonmodule::PFSignKind value);

  private:
  ::commonmodule::PFSignKind _internal_setval() const;
  void _internal_set_setval(::commonmodule::PFSignKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENG_PFSignKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int setval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_BehaviourModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_BehaviourModeKind) */ {
 public:
  inline Optional_BehaviourModeKind() : Optional_BehaviourModeKind(nullptr) {}
  ~Optional_BehaviourModeKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_BehaviourModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_BehaviourModeKind(const Optional_BehaviourModeKind& from);
  Optional_BehaviourModeKind(Optional_BehaviourModeKind&& from) noexcept
    : Optional_BehaviourModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_BehaviourModeKind& operator=(const Optional_BehaviourModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_BehaviourModeKind& operator=(Optional_BehaviourModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_BehaviourModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_BehaviourModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_BehaviourModeKind*>(
               &_Optional_BehaviourModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(Optional_BehaviourModeKind& a, Optional_BehaviourModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_BehaviourModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_BehaviourModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_BehaviourModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_BehaviourModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_BehaviourModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_BehaviourModeKind& from) {
    Optional_BehaviourModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_BehaviourModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_BehaviourModeKind";
  }
  protected:
  explicit Optional_BehaviourModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.BehaviourModeKind value = 1;
  void clear_value() ;
  ::commonmodule::BehaviourModeKind value() const;
  void set_value(::commonmodule::BehaviourModeKind value);

  private:
  ::commonmodule::BehaviourModeKind _internal_value() const;
  void _internal_set_value(::commonmodule::BehaviourModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_BehaviourModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENS_BehaviourModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_BehaviourModeKind) */ {
 public:
  inline ENS_BehaviourModeKind() : ENS_BehaviourModeKind(nullptr) {}
  ~ENS_BehaviourModeKind() override;
  explicit PROTOBUF_CONSTEXPR ENS_BehaviourModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENS_BehaviourModeKind(const ENS_BehaviourModeKind& from);
  ENS_BehaviourModeKind(ENS_BehaviourModeKind&& from) noexcept
    : ENS_BehaviourModeKind() {
    *this = ::std::move(from);
  }

  inline ENS_BehaviourModeKind& operator=(const ENS_BehaviourModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_BehaviourModeKind& operator=(ENS_BehaviourModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_BehaviourModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENS_BehaviourModeKind* internal_default_instance() {
    return reinterpret_cast<const ENS_BehaviourModeKind*>(
               &_ENS_BehaviourModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(ENS_BehaviourModeKind& a, ENS_BehaviourModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENS_BehaviourModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_BehaviourModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_BehaviourModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENS_BehaviourModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENS_BehaviourModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENS_BehaviourModeKind& from) {
    ENS_BehaviourModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_BehaviourModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENS_BehaviourModeKind";
  }
  protected:
  explicit ENS_BehaviourModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // .commonmodule.BehaviourModeKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::commonmodule::BehaviourModeKind stval() const;
  void set_stval(::commonmodule::BehaviourModeKind value);

  private:
  ::commonmodule::BehaviourModeKind _internal_stval() const;
  void _internal_set_stval(::commonmodule::BehaviourModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENS_BehaviourModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    int stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_DERGeneratorStateKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_DERGeneratorStateKind) */ {
 public:
  inline Optional_DERGeneratorStateKind() : Optional_DERGeneratorStateKind(nullptr) {}
  ~Optional_DERGeneratorStateKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_DERGeneratorStateKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_DERGeneratorStateKind(const Optional_DERGeneratorStateKind& from);
  Optional_DERGeneratorStateKind(Optional_DERGeneratorStateKind&& from) noexcept
    : Optional_DERGeneratorStateKind() {
    *this = ::std::move(from);
  }

  inline Optional_DERGeneratorStateKind& operator=(const Optional_DERGeneratorStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_DERGeneratorStateKind& operator=(Optional_DERGeneratorStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_DERGeneratorStateKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_DERGeneratorStateKind* internal_default_instance() {
    return reinterpret_cast<const Optional_DERGeneratorStateKind*>(
               &_Optional_DERGeneratorStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(Optional_DERGeneratorStateKind& a, Optional_DERGeneratorStateKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_DERGeneratorStateKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_DERGeneratorStateKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_DERGeneratorStateKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_DERGeneratorStateKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_DERGeneratorStateKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_DERGeneratorStateKind& from) {
    Optional_DERGeneratorStateKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_DERGeneratorStateKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_DERGeneratorStateKind";
  }
  protected:
  explicit Optional_DERGeneratorStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.DERGeneratorStateKind value = 1;
  void clear_value() ;
  ::commonmodule::DERGeneratorStateKind value() const;
  void set_value(::commonmodule::DERGeneratorStateKind value);

  private:
  ::commonmodule::DERGeneratorStateKind _internal_value() const;
  void _internal_set_value(::commonmodule::DERGeneratorStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_DERGeneratorStateKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENS_DERGeneratorStateKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_DERGeneratorStateKind) */ {
 public:
  inline ENS_DERGeneratorStateKind() : ENS_DERGeneratorStateKind(nullptr) {}
  ~ENS_DERGeneratorStateKind() override;
  explicit PROTOBUF_CONSTEXPR ENS_DERGeneratorStateKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENS_DERGeneratorStateKind(const ENS_DERGeneratorStateKind& from);
  ENS_DERGeneratorStateKind(ENS_DERGeneratorStateKind&& from) noexcept
    : ENS_DERGeneratorStateKind() {
    *this = ::std::move(from);
  }

  inline ENS_DERGeneratorStateKind& operator=(const ENS_DERGeneratorStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_DERGeneratorStateKind& operator=(ENS_DERGeneratorStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_DERGeneratorStateKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENS_DERGeneratorStateKind* internal_default_instance() {
    return reinterpret_cast<const ENS_DERGeneratorStateKind*>(
               &_ENS_DERGeneratorStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(ENS_DERGeneratorStateKind& a, ENS_DERGeneratorStateKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENS_DERGeneratorStateKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_DERGeneratorStateKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_DERGeneratorStateKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENS_DERGeneratorStateKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENS_DERGeneratorStateKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENS_DERGeneratorStateKind& from) {
    ENS_DERGeneratorStateKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_DERGeneratorStateKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENS_DERGeneratorStateKind";
  }
  protected:
  explicit ENS_DERGeneratorStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // .commonmodule.DERGeneratorStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::commonmodule::DERGeneratorStateKind stval() const;
  void set_stval(::commonmodule::DERGeneratorStateKind value);

  private:
  ::commonmodule::DERGeneratorStateKind _internal_stval() const;
  void _internal_set_stval(::commonmodule::DERGeneratorStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENS_DERGeneratorStateKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    int stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_DynamicTestKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_DynamicTestKind) */ {
 public:
  inline Optional_DynamicTestKind() : Optional_DynamicTestKind(nullptr) {}
  ~Optional_DynamicTestKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_DynamicTestKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_DynamicTestKind(const Optional_DynamicTestKind& from);
  Optional_DynamicTestKind(Optional_DynamicTestKind&& from) noexcept
    : Optional_DynamicTestKind() {
    *this = ::std::move(from);
  }

  inline Optional_DynamicTestKind& operator=(const Optional_DynamicTestKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_DynamicTestKind& operator=(Optional_DynamicTestKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_DynamicTestKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_DynamicTestKind* internal_default_instance() {
    return reinterpret_cast<const Optional_DynamicTestKind*>(
               &_Optional_DynamicTestKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(Optional_DynamicTestKind& a, Optional_DynamicTestKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_DynamicTestKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_DynamicTestKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_DynamicTestKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_DynamicTestKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_DynamicTestKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_DynamicTestKind& from) {
    Optional_DynamicTestKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_DynamicTestKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_DynamicTestKind";
  }
  protected:
  explicit Optional_DynamicTestKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.DynamicTestKind value = 1;
  void clear_value() ;
  ::commonmodule::DynamicTestKind value() const;
  void set_value(::commonmodule::DynamicTestKind value);

  private:
  ::commonmodule::DynamicTestKind _internal_value() const;
  void _internal_set_value(::commonmodule::DynamicTestKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_DynamicTestKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENS_DynamicTestKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_DynamicTestKind) */ {
 public:
  inline ENS_DynamicTestKind() : ENS_DynamicTestKind(nullptr) {}
  ~ENS_DynamicTestKind() override;
  explicit PROTOBUF_CONSTEXPR ENS_DynamicTestKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENS_DynamicTestKind(const ENS_DynamicTestKind& from);
  ENS_DynamicTestKind(ENS_DynamicTestKind&& from) noexcept
    : ENS_DynamicTestKind() {
    *this = ::std::move(from);
  }

  inline ENS_DynamicTestKind& operator=(const ENS_DynamicTestKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_DynamicTestKind& operator=(ENS_DynamicTestKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_DynamicTestKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENS_DynamicTestKind* internal_default_instance() {
    return reinterpret_cast<const ENS_DynamicTestKind*>(
               &_ENS_DynamicTestKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ENS_DynamicTestKind& a, ENS_DynamicTestKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENS_DynamicTestKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_DynamicTestKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_DynamicTestKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENS_DynamicTestKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENS_DynamicTestKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENS_DynamicTestKind& from) {
    ENS_DynamicTestKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_DynamicTestKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENS_DynamicTestKind";
  }
  protected:
  explicit ENS_DynamicTestKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // .commonmodule.DynamicTestKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::commonmodule::DynamicTestKind stval() const;
  void set_stval(::commonmodule::DynamicTestKind value);

  private:
  ::commonmodule::DynamicTestKind _internal_stval() const;
  void _internal_set_stval(::commonmodule::DynamicTestKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENS_DynamicTestKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    int stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENS_GridConnectModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_GridConnectModeKind) */ {
 public:
  inline ENS_GridConnectModeKind() : ENS_GridConnectModeKind(nullptr) {}
  ~ENS_GridConnectModeKind() override;
  explicit PROTOBUF_CONSTEXPR ENS_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENS_GridConnectModeKind(const ENS_GridConnectModeKind& from);
  ENS_GridConnectModeKind(ENS_GridConnectModeKind&& from) noexcept
    : ENS_GridConnectModeKind() {
    *this = ::std::move(from);
  }

  inline ENS_GridConnectModeKind& operator=(const ENS_GridConnectModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_GridConnectModeKind& operator=(ENS_GridConnectModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_GridConnectModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENS_GridConnectModeKind* internal_default_instance() {
    return reinterpret_cast<const ENS_GridConnectModeKind*>(
               &_ENS_GridConnectModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(ENS_GridConnectModeKind& a, ENS_GridConnectModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENS_GridConnectModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_GridConnectModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_GridConnectModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENS_GridConnectModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENS_GridConnectModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENS_GridConnectModeKind& from) {
    ENS_GridConnectModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_GridConnectModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENS_GridConnectModeKind";
  }
  protected:
  explicit ENS_GridConnectModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStValExtensionFieldNumber = 2,
    kStValFieldNumber = 1,
  };
  // string stValExtension = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stvalextension() ;
  const std::string& stvalextension() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stvalextension(Arg_&& arg, Args_... args);
  std::string* mutable_stvalextension();
  PROTOBUF_NODISCARD std::string* release_stvalextension();
  void set_allocated_stvalextension(std::string* ptr);

  private:
  const std::string& _internal_stvalextension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stvalextension(
      const std::string& value);
  std::string* _internal_mutable_stvalextension();

  public:
  // .commonmodule.GridConnectModeKind stVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::commonmodule::GridConnectModeKind stval() const;
  void set_stval(::commonmodule::GridConnectModeKind value);

  private:
  ::commonmodule::GridConnectModeKind _internal_stval() const;
  void _internal_set_stval(::commonmodule::GridConnectModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENS_GridConnectModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stvalextension_;
    int stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_HealthKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_HealthKind) */ {
 public:
  inline Optional_HealthKind() : Optional_HealthKind(nullptr) {}
  ~Optional_HealthKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_HealthKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_HealthKind(const Optional_HealthKind& from);
  Optional_HealthKind(Optional_HealthKind&& from) noexcept
    : Optional_HealthKind() {
    *this = ::std::move(from);
  }

  inline Optional_HealthKind& operator=(const Optional_HealthKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_HealthKind& operator=(Optional_HealthKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_HealthKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_HealthKind* internal_default_instance() {
    return reinterpret_cast<const Optional_HealthKind*>(
               &_Optional_HealthKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(Optional_HealthKind& a, Optional_HealthKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_HealthKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_HealthKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_HealthKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_HealthKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_HealthKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_HealthKind& from) {
    Optional_HealthKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_HealthKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_HealthKind";
  }
  protected:
  explicit Optional_HealthKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.HealthKind value = 1;
  void clear_value() ;
  ::commonmodule::HealthKind value() const;
  void set_value(::commonmodule::HealthKind value);

  private:
  ::commonmodule::HealthKind _internal_value() const;
  void _internal_set_value(::commonmodule::HealthKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_HealthKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENS_HealthKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_HealthKind) */ {
 public:
  inline ENS_HealthKind() : ENS_HealthKind(nullptr) {}
  ~ENS_HealthKind() override;
  explicit PROTOBUF_CONSTEXPR ENS_HealthKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENS_HealthKind(const ENS_HealthKind& from);
  ENS_HealthKind(ENS_HealthKind&& from) noexcept
    : ENS_HealthKind() {
    *this = ::std::move(from);
  }

  inline ENS_HealthKind& operator=(const ENS_HealthKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_HealthKind& operator=(ENS_HealthKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_HealthKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENS_HealthKind* internal_default_instance() {
    return reinterpret_cast<const ENS_HealthKind*>(
               &_ENS_HealthKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ENS_HealthKind& a, ENS_HealthKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENS_HealthKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_HealthKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_HealthKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENS_HealthKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENS_HealthKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENS_HealthKind& from) {
    ENS_HealthKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_HealthKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENS_HealthKind";
  }
  protected:
  explicit ENS_HealthKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDFieldNumber = 1,
    kStValFieldNumber = 2,
  };
  // .google.protobuf.StringValue d = 1;
  bool has_d() const;
  private:
  bool _internal_has_d() const;

  public:
  void clear_d() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& d() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_d();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_d();
  void set_allocated_d(::PROTOBUF_NAMESPACE_ID::StringValue* d);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_d() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_d();
  public:
  void unsafe_arena_set_allocated_d(
      ::PROTOBUF_NAMESPACE_ID::StringValue* d);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_d();
  // .commonmodule.HealthKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::commonmodule::HealthKind stval() const;
  void set_stval(::commonmodule::HealthKind value);

  private:
  ::commonmodule::HealthKind _internal_stval() const;
  void _internal_set_stval(::commonmodule::HealthKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENS_HealthKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::StringValue* d_;
    int stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_SwitchingCapabilityKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_SwitchingCapabilityKind) */ {
 public:
  inline Optional_SwitchingCapabilityKind() : Optional_SwitchingCapabilityKind(nullptr) {}
  ~Optional_SwitchingCapabilityKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_SwitchingCapabilityKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_SwitchingCapabilityKind(const Optional_SwitchingCapabilityKind& from);
  Optional_SwitchingCapabilityKind(Optional_SwitchingCapabilityKind&& from) noexcept
    : Optional_SwitchingCapabilityKind() {
    *this = ::std::move(from);
  }

  inline Optional_SwitchingCapabilityKind& operator=(const Optional_SwitchingCapabilityKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_SwitchingCapabilityKind& operator=(Optional_SwitchingCapabilityKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_SwitchingCapabilityKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_SwitchingCapabilityKind* internal_default_instance() {
    return reinterpret_cast<const Optional_SwitchingCapabilityKind*>(
               &_Optional_SwitchingCapabilityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(Optional_SwitchingCapabilityKind& a, Optional_SwitchingCapabilityKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_SwitchingCapabilityKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_SwitchingCapabilityKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_SwitchingCapabilityKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_SwitchingCapabilityKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_SwitchingCapabilityKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_SwitchingCapabilityKind& from) {
    Optional_SwitchingCapabilityKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_SwitchingCapabilityKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_SwitchingCapabilityKind";
  }
  protected:
  explicit Optional_SwitchingCapabilityKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.SwitchingCapabilityKind value = 1;
  void clear_value() ;
  ::commonmodule::SwitchingCapabilityKind value() const;
  void set_value(::commonmodule::SwitchingCapabilityKind value);

  private:
  ::commonmodule::SwitchingCapabilityKind _internal_value() const;
  void _internal_set_value(::commonmodule::SwitchingCapabilityKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_SwitchingCapabilityKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ENS_SwitchingCapabilityKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ENS_SwitchingCapabilityKind) */ {
 public:
  inline ENS_SwitchingCapabilityKind() : ENS_SwitchingCapabilityKind(nullptr) {}
  ~ENS_SwitchingCapabilityKind() override;
  explicit PROTOBUF_CONSTEXPR ENS_SwitchingCapabilityKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ENS_SwitchingCapabilityKind(const ENS_SwitchingCapabilityKind& from);
  ENS_SwitchingCapabilityKind(ENS_SwitchingCapabilityKind&& from) noexcept
    : ENS_SwitchingCapabilityKind() {
    *this = ::std::move(from);
  }

  inline ENS_SwitchingCapabilityKind& operator=(const ENS_SwitchingCapabilityKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_SwitchingCapabilityKind& operator=(ENS_SwitchingCapabilityKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_SwitchingCapabilityKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const ENS_SwitchingCapabilityKind* internal_default_instance() {
    return reinterpret_cast<const ENS_SwitchingCapabilityKind*>(
               &_ENS_SwitchingCapabilityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ENS_SwitchingCapabilityKind& a, ENS_SwitchingCapabilityKind& b) {
    a.Swap(&b);
  }
  inline void Swap(ENS_SwitchingCapabilityKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_SwitchingCapabilityKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_SwitchingCapabilityKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ENS_SwitchingCapabilityKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ENS_SwitchingCapabilityKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ENS_SwitchingCapabilityKind& from) {
    ENS_SwitchingCapabilityKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ENS_SwitchingCapabilityKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ENS_SwitchingCapabilityKind";
  }
  protected:
  explicit ENS_SwitchingCapabilityKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlkEnaFieldNumber = 1,
    kStValFieldNumber = 2,
  };
  // .google.protobuf.BoolValue blkEna = 1;
  bool has_blkena() const;
  private:
  bool _internal_has_blkena() const;

  public:
  void clear_blkena() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& blkena() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_blkena();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_blkena();
  void set_allocated_blkena(::PROTOBUF_NAMESPACE_ID::BoolValue* blkena);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_blkena() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_blkena();
  public:
  void unsafe_arena_set_allocated_blkena(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* blkena);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_blkena();
  // .commonmodule.SwitchingCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::commonmodule::SwitchingCapabilityKind stval() const;
  void set_stval(::commonmodule::SwitchingCapabilityKind value);

  private:
  ::commonmodule::SwitchingCapabilityKind _internal_stval() const;
  void _internal_set_stval(::commonmodule::SwitchingCapabilityKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ENS_SwitchingCapabilityKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::BoolValue* blkena_;
    int stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDCTE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDCTE) */ {
 public:
  inline OperationDCTE() : OperationDCTE(nullptr) {}
  ~OperationDCTE() override;
  explicit PROTOBUF_CONSTEXPR OperationDCTE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDCTE(const OperationDCTE& from);
  OperationDCTE(OperationDCTE&& from) noexcept
    : OperationDCTE() {
    *this = ::std::move(from);
  }

  inline OperationDCTE& operator=(const OperationDCTE& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDCTE& operator=(OperationDCTE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDCTE& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDCTE* internal_default_instance() {
    return reinterpret_cast<const OperationDCTE*>(
               &_OperationDCTE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(OperationDCTE& a, OperationDCTE& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDCTE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDCTE* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDCTE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDCTE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDCTE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDCTE& from) {
    OperationDCTE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDCTE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDCTE";
  }
  protected:
  explicit OperationDCTE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRndDlTmmsFieldNumber = 1,
    kRtnDlTmmsFieldNumber = 2,
    kRtnRmpTmmsFieldNumber = 3,
  };
  // .commonmodule.ControlING rndDlTmms = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_rnddltmms() const;
  private:
  bool _internal_has_rnddltmms() const;

  public:
  void clear_rnddltmms() ;
  const ::commonmodule::ControlING& rnddltmms() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlING* release_rnddltmms();
  ::commonmodule::ControlING* mutable_rnddltmms();
  void set_allocated_rnddltmms(::commonmodule::ControlING* rnddltmms);
  private:
  const ::commonmodule::ControlING& _internal_rnddltmms() const;
  ::commonmodule::ControlING* _internal_mutable_rnddltmms();
  public:
  void unsafe_arena_set_allocated_rnddltmms(
      ::commonmodule::ControlING* rnddltmms);
  ::commonmodule::ControlING* unsafe_arena_release_rnddltmms();
  // .commonmodule.ControlING rtnDlTmms = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_rtndltmms() const;
  private:
  bool _internal_has_rtndltmms() const;

  public:
  void clear_rtndltmms() ;
  const ::commonmodule::ControlING& rtndltmms() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlING* release_rtndltmms();
  ::commonmodule::ControlING* mutable_rtndltmms();
  void set_allocated_rtndltmms(::commonmodule::ControlING* rtndltmms);
  private:
  const ::commonmodule::ControlING& _internal_rtndltmms() const;
  ::commonmodule::ControlING* _internal_mutable_rtndltmms();
  public:
  void unsafe_arena_set_allocated_rtndltmms(
      ::commonmodule::ControlING* rtndltmms);
  ::commonmodule::ControlING* unsafe_arena_release_rtndltmms();
  // .commonmodule.ControlING rtnRmpTmms = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_rtnrmptmms() const;
  private:
  bool _internal_has_rtnrmptmms() const;

  public:
  void clear_rtnrmptmms() ;
  const ::commonmodule::ControlING& rtnrmptmms() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlING* release_rtnrmptmms();
  ::commonmodule::ControlING* mutable_rtnrmptmms();
  void set_allocated_rtnrmptmms(::commonmodule::ControlING* rtnrmptmms);
  private:
  const ::commonmodule::ControlING& _internal_rtnrmptmms() const;
  ::commonmodule::ControlING* _internal_mutable_rtnrmptmms();
  public:
  void unsafe_arena_set_allocated_rtnrmptmms(
      ::commonmodule::ControlING* rtnrmptmms);
  ::commonmodule::ControlING* unsafe_arena_release_rtnrmptmms();
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDCTE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlING* rnddltmms_;
    ::commonmodule::ControlING* rtndltmms_;
    ::commonmodule::ControlING* rtnrmptmms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class EnterServiceAPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.EnterServiceAPC) */ {
 public:
  inline EnterServiceAPC() : EnterServiceAPC(nullptr) {}
  ~EnterServiceAPC() override;
  explicit PROTOBUF_CONSTEXPR EnterServiceAPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterServiceAPC(const EnterServiceAPC& from);
  EnterServiceAPC(EnterServiceAPC&& from) noexcept
    : EnterServiceAPC() {
    *this = ::std::move(from);
  }

  inline EnterServiceAPC& operator=(const EnterServiceAPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterServiceAPC& operator=(EnterServiceAPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterServiceAPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterServiceAPC* internal_default_instance() {
    return reinterpret_cast<const EnterServiceAPC*>(
               &_EnterServiceAPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(EnterServiceAPC& a, EnterServiceAPC& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterServiceAPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterServiceAPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterServiceAPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterServiceAPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterServiceAPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnterServiceAPC& from) {
    EnterServiceAPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterServiceAPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.EnterServiceAPC";
  }
  protected:
  explicit EnterServiceAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnterServiceParameterFieldNumber = 1,
    kHzHiLimFieldNumber = 2,
    kHzLoLimFieldNumber = 3,
    kRtnSrvAutoFieldNumber = 4,
    kVHiLimFieldNumber = 5,
    kVLoLimFieldNumber = 6,
  };
  // .commonmodule.OperationDCTE enterServiceParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_enterserviceparameter() const;
  private:
  bool _internal_has_enterserviceparameter() const;

  public:
  void clear_enterserviceparameter() ;
  const ::commonmodule::OperationDCTE& enterserviceparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDCTE* release_enterserviceparameter();
  ::commonmodule::OperationDCTE* mutable_enterserviceparameter();
  void set_allocated_enterserviceparameter(::commonmodule::OperationDCTE* enterserviceparameter);
  private:
  const ::commonmodule::OperationDCTE& _internal_enterserviceparameter() const;
  ::commonmodule::OperationDCTE* _internal_mutable_enterserviceparameter();
  public:
  void unsafe_arena_set_allocated_enterserviceparameter(
      ::commonmodule::OperationDCTE* enterserviceparameter);
  ::commonmodule::OperationDCTE* unsafe_arena_release_enterserviceparameter();
  // float hzHiLim = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_hzhilim() ;
  float hzhilim() const;
  void set_hzhilim(float value);

  private:
  float _internal_hzhilim() const;
  void _internal_set_hzhilim(float value);

  public:
  // float hzLoLim = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_hzlolim() ;
  float hzlolim() const;
  void set_hzlolim(float value);

  private:
  float _internal_hzlolim() const;
  void _internal_set_hzlolim(float value);

  public:
  // bool rtnSrvAuto = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_rtnsrvauto() ;
  bool rtnsrvauto() const;
  void set_rtnsrvauto(bool value);

  private:
  bool _internal_rtnsrvauto() const;
  void _internal_set_rtnsrvauto(bool value);

  public:
  // float vHiLim = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_vhilim() ;
  float vhilim() const;
  void set_vhilim(float value);

  private:
  float _internal_vhilim() const;
  void _internal_set_vhilim(float value);

  public:
  // float vLoLim = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_vlolim() ;
  float vlolim() const;
  void set_vlolim(float value);

  private:
  float _internal_vlolim() const;
  void _internal_set_vlolim(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.EnterServiceAPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::OperationDCTE* enterserviceparameter_;
    float hzhilim_;
    float hzlolim_;
    bool rtnsrvauto_;
    float vhilim_;
    float vlolim_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ESS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ESS) */ {
 public:
  inline ESS() : ESS(nullptr) {}
  ~ESS() override;
  explicit PROTOBUF_CONSTEXPR ESS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESS(const ESS& from);
  ESS(ESS&& from) noexcept
    : ESS() {
    *this = ::std::move(from);
  }

  inline ESS& operator=(const ESS& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESS& operator=(ESS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESS& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESS* internal_default_instance() {
    return reinterpret_cast<const ESS*>(
               &_ESS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ESS& a, ESS& b) {
    a.Swap(&b);
  }
  inline void Swap(ESS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESS& from) {
    ESS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ESS";
  }
  protected:
  explicit ESS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  private:
  bool _internal_has_conductingequipment() const;

  public:
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);
  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_conductingequipment();
  public:
  void unsafe_arena_set_allocated_conductingequipment(
      ::commonmodule::ConductingEquipment* conductingequipment);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_conductingequipment();
  // @@protoc_insertion_point(class_scope:commonmodule.ESS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipment* conductingequipment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class EventMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.EventMessageInfo) */ {
 public:
  inline EventMessageInfo() : EventMessageInfo(nullptr) {}
  ~EventMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR EventMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventMessageInfo(const EventMessageInfo& from);
  EventMessageInfo(EventMessageInfo&& from) noexcept
    : EventMessageInfo() {
    *this = ::std::move(from);
  }

  inline EventMessageInfo& operator=(const EventMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventMessageInfo& operator=(EventMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventMessageInfo* internal_default_instance() {
    return reinterpret_cast<const EventMessageInfo*>(
               &_EventMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(EventMessageInfo& a, EventMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EventMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventMessageInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventMessageInfo& from) {
    EventMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.EventMessageInfo";
  }
  protected:
  explicit EventMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageInfoFieldNumber = 1,
  };
  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  private:
  bool _internal_has_messageinfo() const;

  public:
  void clear_messageinfo() ;
  const ::commonmodule::MessageInfo& messageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);
  private:
  const ::commonmodule::MessageInfo& _internal_messageinfo() const;
  ::commonmodule::MessageInfo* _internal_mutable_messageinfo();
  public:
  void unsafe_arena_set_allocated_messageinfo(
      ::commonmodule::MessageInfo* messageinfo);
  ::commonmodule::MessageInfo* unsafe_arena_release_messageinfo();
  // @@protoc_insertion_point(class_scope:commonmodule.EventMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::MessageInfo* messageinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class EventValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.EventValue) */ {
 public:
  inline EventValue() : EventValue(nullptr) {}
  ~EventValue() override;
  explicit PROTOBUF_CONSTEXPR EventValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventValue(const EventValue& from);
  EventValue(EventValue&& from) noexcept
    : EventValue() {
    *this = ::std::move(from);
  }

  inline EventValue& operator=(const EventValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventValue& operator=(EventValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventValue* internal_default_instance() {
    return reinterpret_cast<const EventValue*>(
               &_EventValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(EventValue& a, EventValue& b) {
    a.Swap(&b);
  }
  inline void Swap(EventValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventValue& from) {
    EventValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.EventValue";
  }
  protected:
  explicit EventValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kModBlkFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .google.protobuf.BoolValue modBlk = 2;
  bool has_modblk() const;
  private:
  bool _internal_has_modblk() const;

  public:
  void clear_modblk() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& modblk() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_modblk();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_modblk();
  void set_allocated_modblk(::PROTOBUF_NAMESPACE_ID::BoolValue* modblk);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_modblk() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_modblk();
  public:
  void unsafe_arena_set_allocated_modblk(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_modblk();
  // @@protoc_insertion_point(class_scope:commonmodule.EventValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ForecastValueSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ForecastValueSource) */ {
 public:
  inline ForecastValueSource() : ForecastValueSource(nullptr) {}
  ~ForecastValueSource() override;
  explicit PROTOBUF_CONSTEXPR ForecastValueSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForecastValueSource(const ForecastValueSource& from);
  ForecastValueSource(ForecastValueSource&& from) noexcept
    : ForecastValueSource() {
    *this = ::std::move(from);
  }

  inline ForecastValueSource& operator=(const ForecastValueSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForecastValueSource& operator=(ForecastValueSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForecastValueSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForecastValueSource* internal_default_instance() {
    return reinterpret_cast<const ForecastValueSource*>(
               &_ForecastValueSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(ForecastValueSource& a, ForecastValueSource& b) {
    a.Swap(&b);
  }
  inline void Swap(ForecastValueSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForecastValueSource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForecastValueSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForecastValueSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForecastValueSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForecastValueSource& from) {
    ForecastValueSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForecastValueSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ForecastValueSource";
  }
  protected:
  explicit ForecastValueSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // @@protoc_insertion_point(class_scope:commonmodule.ForecastValueSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ForecastIED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ForecastIED) */ {
 public:
  inline ForecastIED() : ForecastIED(nullptr) {}
  ~ForecastIED() override;
  explicit PROTOBUF_CONSTEXPR ForecastIED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForecastIED(const ForecastIED& from);
  ForecastIED(ForecastIED&& from) noexcept
    : ForecastIED() {
    *this = ::std::move(from);
  }

  inline ForecastIED& operator=(const ForecastIED& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForecastIED& operator=(ForecastIED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForecastIED& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForecastIED* internal_default_instance() {
    return reinterpret_cast<const ForecastIED*>(
               &_ForecastIED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(ForecastIED& a, ForecastIED& b) {
    a.Swap(&b);
  }
  inline void Swap(ForecastIED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForecastIED* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForecastIED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForecastIED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForecastIED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForecastIED& from) {
    ForecastIED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForecastIED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ForecastIED";
  }
  protected:
  explicit ForecastIED(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceApplicationIDFieldNumber = 2,
    kForecastValueSourceFieldNumber = 1,
    kSourceDateTimeFieldNumber = 3,
  };
  // string sourceApplicationID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_sourceapplicationid() ;
  const std::string& sourceapplicationid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sourceapplicationid(Arg_&& arg, Args_... args);
  std::string* mutable_sourceapplicationid();
  PROTOBUF_NODISCARD std::string* release_sourceapplicationid();
  void set_allocated_sourceapplicationid(std::string* ptr);

  private:
  const std::string& _internal_sourceapplicationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceapplicationid(
      const std::string& value);
  std::string* _internal_mutable_sourceapplicationid();

  public:
  // .commonmodule.ForecastValueSource forecastValueSource = 1 [(.uml.option_parent_message) = true];
  bool has_forecastvaluesource() const;
  private:
  bool _internal_has_forecastvaluesource() const;

  public:
  void clear_forecastvaluesource() ;
  const ::commonmodule::ForecastValueSource& forecastvaluesource() const;
  PROTOBUF_NODISCARD ::commonmodule::ForecastValueSource* release_forecastvaluesource();
  ::commonmodule::ForecastValueSource* mutable_forecastvaluesource();
  void set_allocated_forecastvaluesource(::commonmodule::ForecastValueSource* forecastvaluesource);
  private:
  const ::commonmodule::ForecastValueSource& _internal_forecastvaluesource() const;
  ::commonmodule::ForecastValueSource* _internal_mutable_forecastvaluesource();
  public:
  void unsafe_arena_set_allocated_forecastvaluesource(
      ::commonmodule::ForecastValueSource* forecastvaluesource);
  ::commonmodule::ForecastValueSource* unsafe_arena_release_forecastvaluesource();
  // int64 sourceDateTime = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_sourcedatetime() ;
  ::int64_t sourcedatetime() const;
  void set_sourcedatetime(::int64_t value);

  private:
  ::int64_t _internal_sourcedatetime() const;
  void _internal_set_sourcedatetime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.ForecastIED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceapplicationid_;
    ::commonmodule::ForecastValueSource* forecastvaluesource_;
    ::int64_t sourcedatetime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ForecastValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ForecastValue) */ {
 public:
  inline ForecastValue() : ForecastValue(nullptr) {}
  ~ForecastValue() override;
  explicit PROTOBUF_CONSTEXPR ForecastValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForecastValue(const ForecastValue& from);
  ForecastValue(ForecastValue&& from) noexcept
    : ForecastValue() {
    *this = ::std::move(from);
  }

  inline ForecastValue& operator=(const ForecastValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForecastValue& operator=(ForecastValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForecastValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForecastValue* internal_default_instance() {
    return reinterpret_cast<const ForecastValue*>(
               &_ForecastValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(ForecastValue& a, ForecastValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ForecastValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForecastValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForecastValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForecastValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForecastValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForecastValue& from) {
    ForecastValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForecastValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ForecastValue";
  }
  protected:
  explicit ForecastValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // @@protoc_insertion_point(class_scope:commonmodule.ForecastValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDHFW final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDHFW) */ {
 public:
  inline OperationDHFW() : OperationDHFW(nullptr) {}
  ~OperationDHFW() override;
  explicit PROTOBUF_CONSTEXPR OperationDHFW(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDHFW(const OperationDHFW& from);
  OperationDHFW(OperationDHFW&& from) noexcept
    : OperationDHFW() {
    *this = ::std::move(from);
  }

  inline OperationDHFW& operator=(const OperationDHFW& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDHFW& operator=(OperationDHFW&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDHFW& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDHFW* internal_default_instance() {
    return reinterpret_cast<const OperationDHFW*>(
               &_OperationDHFW_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(OperationDHFW& a, OperationDHFW& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDHFW* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDHFW* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDHFW* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDHFW>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDHFW& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDHFW& from) {
    OperationDHFW::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDHFW* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDHFW";
  }
  protected:
  explicit OperationDHFW(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOplTmmsMaxFieldNumber = 2,
    kModEnaFieldNumber = 1,
  };
  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_opltmmsmax() const;
  private:
  bool _internal_has_opltmmsmax() const;

  public:
  void clear_opltmmsmax() ;
  const ::commonmodule::ClearingTime& opltmmsmax() const;
  PROTOBUF_NODISCARD ::commonmodule::ClearingTime* release_opltmmsmax();
  ::commonmodule::ClearingTime* mutable_opltmmsmax();
  void set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax);
  private:
  const ::commonmodule::ClearingTime& _internal_opltmmsmax() const;
  ::commonmodule::ClearingTime* _internal_mutable_opltmmsmax();
  public:
  void unsafe_arena_set_allocated_opltmmsmax(
      ::commonmodule::ClearingTime* opltmmsmax);
  ::commonmodule::ClearingTime* unsafe_arena_release_opltmmsmax();
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDHFW)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ClearingTime* opltmmsmax_;
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDLFW final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDLFW) */ {
 public:
  inline OperationDLFW() : OperationDLFW(nullptr) {}
  ~OperationDLFW() override;
  explicit PROTOBUF_CONSTEXPR OperationDLFW(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDLFW(const OperationDLFW& from);
  OperationDLFW(OperationDLFW&& from) noexcept
    : OperationDLFW() {
    *this = ::std::move(from);
  }

  inline OperationDLFW& operator=(const OperationDLFW& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDLFW& operator=(OperationDLFW&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDLFW& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDLFW* internal_default_instance() {
    return reinterpret_cast<const OperationDLFW*>(
               &_OperationDLFW_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(OperationDLFW& a, OperationDLFW& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDLFW* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDLFW* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDLFW* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDLFW>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDLFW& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDLFW& from) {
    OperationDLFW::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDLFW* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDLFW";
  }
  protected:
  explicit OperationDLFW(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOplTmmsMaxFieldNumber = 2,
    kModEnaFieldNumber = 1,
  };
  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_opltmmsmax() const;
  private:
  bool _internal_has_opltmmsmax() const;

  public:
  void clear_opltmmsmax() ;
  const ::commonmodule::ClearingTime& opltmmsmax() const;
  PROTOBUF_NODISCARD ::commonmodule::ClearingTime* release_opltmmsmax();
  ::commonmodule::ClearingTime* mutable_opltmmsmax();
  void set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax);
  private:
  const ::commonmodule::ClearingTime& _internal_opltmmsmax() const;
  ::commonmodule::ClearingTime* _internal_mutable_opltmmsmax();
  public:
  void unsafe_arena_set_allocated_opltmmsmax(
      ::commonmodule::ClearingTime* opltmmsmax);
  ::commonmodule::ClearingTime* unsafe_arena_release_opltmmsmax();
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDLFW)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ClearingTime* opltmmsmax_;
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class HzWPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.HzWPoint) */ {
 public:
  inline HzWPoint() : HzWPoint(nullptr) {}
  ~HzWPoint() override;
  explicit PROTOBUF_CONSTEXPR HzWPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HzWPoint(const HzWPoint& from);
  HzWPoint(HzWPoint&& from) noexcept
    : HzWPoint() {
    *this = ::std::move(from);
  }

  inline HzWPoint& operator=(const HzWPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline HzWPoint& operator=(HzWPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HzWPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const HzWPoint* internal_default_instance() {
    return reinterpret_cast<const HzWPoint*>(
               &_HzWPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(HzWPoint& a, HzWPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(HzWPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HzWPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HzWPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HzWPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HzWPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HzWPoint& from) {
    HzWPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HzWPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.HzWPoint";
  }
  protected:
  explicit HzWPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeadbandHzValFieldNumber = 1,
    kSlopeValFieldNumber = 2,
  };
  // float deadbandHzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_deadbandhzval() ;
  float deadbandhzval() const;
  void set_deadbandhzval(float value);

  private:
  float _internal_deadbandhzval() const;
  void _internal_set_deadbandhzval(float value);

  public:
  // float slopeVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_slopeval() ;
  float slopeval() const;
  void set_slopeval(float value);

  private:
  float _internal_slopeval() const;
  void _internal_set_slopeval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.HzWPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float deadbandhzval_;
    float slopeval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class HzWAPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.HzWAPC) */ {
 public:
  inline HzWAPC() : HzWAPC(nullptr) {}
  ~HzWAPC() override;
  explicit PROTOBUF_CONSTEXPR HzWAPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HzWAPC(const HzWAPC& from);
  HzWAPC(HzWAPC&& from) noexcept
    : HzWAPC() {
    *this = ::std::move(from);
  }

  inline HzWAPC& operator=(const HzWAPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline HzWAPC& operator=(HzWAPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HzWAPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const HzWAPC* internal_default_instance() {
    return reinterpret_cast<const HzWAPC*>(
               &_HzWAPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(HzWAPC& a, HzWAPC& b) {
    a.Swap(&b);
  }
  inline void Swap(HzWAPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HzWAPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HzWAPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HzWAPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HzWAPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HzWAPC& from) {
    HzWAPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HzWAPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.HzWAPC";
  }
  protected:
  explicit HzWAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverHzWPtFieldNumber = 1,
    kOverHzWParameterFieldNumber = 2,
    kUnderHzWPtFieldNumber = 3,
    kUnderHzWParameterFieldNumber = 4,
  };
  // .commonmodule.HzWPoint overHzWPt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_overhzwpt() const;
  private:
  bool _internal_has_overhzwpt() const;

  public:
  void clear_overhzwpt() ;
  const ::commonmodule::HzWPoint& overhzwpt() const;
  PROTOBUF_NODISCARD ::commonmodule::HzWPoint* release_overhzwpt();
  ::commonmodule::HzWPoint* mutable_overhzwpt();
  void set_allocated_overhzwpt(::commonmodule::HzWPoint* overhzwpt);
  private:
  const ::commonmodule::HzWPoint& _internal_overhzwpt() const;
  ::commonmodule::HzWPoint* _internal_mutable_overhzwpt();
  public:
  void unsafe_arena_set_allocated_overhzwpt(
      ::commonmodule::HzWPoint* overhzwpt);
  ::commonmodule::HzWPoint* unsafe_arena_release_overhzwpt();
  // .commonmodule.OperationDHFW overHzWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_overhzwparameter() const;
  private:
  bool _internal_has_overhzwparameter() const;

  public:
  void clear_overhzwparameter() ;
  const ::commonmodule::OperationDHFW& overhzwparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDHFW* release_overhzwparameter();
  ::commonmodule::OperationDHFW* mutable_overhzwparameter();
  void set_allocated_overhzwparameter(::commonmodule::OperationDHFW* overhzwparameter);
  private:
  const ::commonmodule::OperationDHFW& _internal_overhzwparameter() const;
  ::commonmodule::OperationDHFW* _internal_mutable_overhzwparameter();
  public:
  void unsafe_arena_set_allocated_overhzwparameter(
      ::commonmodule::OperationDHFW* overhzwparameter);
  ::commonmodule::OperationDHFW* unsafe_arena_release_overhzwparameter();
  // .commonmodule.HzWPoint underHzWPt = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_underhzwpt() const;
  private:
  bool _internal_has_underhzwpt() const;

  public:
  void clear_underhzwpt() ;
  const ::commonmodule::HzWPoint& underhzwpt() const;
  PROTOBUF_NODISCARD ::commonmodule::HzWPoint* release_underhzwpt();
  ::commonmodule::HzWPoint* mutable_underhzwpt();
  void set_allocated_underhzwpt(::commonmodule::HzWPoint* underhzwpt);
  private:
  const ::commonmodule::HzWPoint& _internal_underhzwpt() const;
  ::commonmodule::HzWPoint* _internal_mutable_underhzwpt();
  public:
  void unsafe_arena_set_allocated_underhzwpt(
      ::commonmodule::HzWPoint* underhzwpt);
  ::commonmodule::HzWPoint* unsafe_arena_release_underhzwpt();
  // .commonmodule.OperationDLFW underHzWParameter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_underhzwparameter() const;
  private:
  bool _internal_has_underhzwparameter() const;

  public:
  void clear_underhzwparameter() ;
  const ::commonmodule::OperationDLFW& underhzwparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDLFW* release_underhzwparameter();
  ::commonmodule::OperationDLFW* mutable_underhzwparameter();
  void set_allocated_underhzwparameter(::commonmodule::OperationDLFW* underhzwparameter);
  private:
  const ::commonmodule::OperationDLFW& _internal_underhzwparameter() const;
  ::commonmodule::OperationDLFW* _internal_mutable_underhzwparameter();
  public:
  void unsafe_arena_set_allocated_underhzwparameter(
      ::commonmodule::OperationDLFW* underhzwparameter);
  ::commonmodule::OperationDLFW* unsafe_arena_release_underhzwparameter();
  // @@protoc_insertion_point(class_scope:commonmodule.HzWAPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::HzWPoint* overhzwpt_;
    ::commonmodule::OperationDHFW* overhzwparameter_;
    ::commonmodule::HzWPoint* underhzwpt_;
    ::commonmodule::OperationDLFW* underhzwparameter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusINS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusINS) */ {
 public:
  inline StatusINS() : StatusINS(nullptr) {}
  ~StatusINS() override;
  explicit PROTOBUF_CONSTEXPR StatusINS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusINS(const StatusINS& from);
  StatusINS(StatusINS&& from) noexcept
    : StatusINS() {
    *this = ::std::move(from);
  }

  inline StatusINS& operator=(const StatusINS& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusINS& operator=(StatusINS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusINS& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusINS* internal_default_instance() {
    return reinterpret_cast<const StatusINS*>(
               &_StatusINS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(StatusINS& a, StatusINS& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusINS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusINS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusINS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusINS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusINS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusINS& from) {
    StatusINS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusINS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusINS";
  }
  protected:
  explicit StatusINS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::int32_t stval() const;
  void set_stval(::int32_t value);

  private:
  ::int32_t _internal_stval() const;
  void _internal_set_stval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.StatusINS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    ::int32_t stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class IntegerEventAndStatusGGIO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.IntegerEventAndStatusGGIO) */ {
 public:
  inline IntegerEventAndStatusGGIO() : IntegerEventAndStatusGGIO(nullptr) {}
  ~IntegerEventAndStatusGGIO() override;
  explicit PROTOBUF_CONSTEXPR IntegerEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntegerEventAndStatusGGIO(const IntegerEventAndStatusGGIO& from);
  IntegerEventAndStatusGGIO(IntegerEventAndStatusGGIO&& from) noexcept
    : IntegerEventAndStatusGGIO() {
    *this = ::std::move(from);
  }

  inline IntegerEventAndStatusGGIO& operator=(const IntegerEventAndStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerEventAndStatusGGIO& operator=(IntegerEventAndStatusGGIO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegerEventAndStatusGGIO& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntegerEventAndStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const IntegerEventAndStatusGGIO*>(
               &_IntegerEventAndStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(IntegerEventAndStatusGGIO& a, IntegerEventAndStatusGGIO& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerEventAndStatusGGIO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerEventAndStatusGGIO* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerEventAndStatusGGIO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntegerEventAndStatusGGIO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntegerEventAndStatusGGIO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntegerEventAndStatusGGIO& from) {
    IntegerEventAndStatusGGIO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerEventAndStatusGGIO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.IntegerEventAndStatusGGIO";
  }
  protected:
  explicit IntegerEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kIntInFieldNumber = 2,
    kPhaseFieldNumber = 3,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.StatusINS IntIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_intin() const;
  private:
  bool _internal_has_intin() const;

  public:
  void clear_intin() ;
  const ::commonmodule::StatusINS& intin() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusINS* release_intin();
  ::commonmodule::StatusINS* mutable_intin();
  void set_allocated_intin(::commonmodule::StatusINS* intin);
  private:
  const ::commonmodule::StatusINS& _internal_intin() const;
  ::commonmodule::StatusINS* _internal_mutable_intin();
  public:
  void unsafe_arena_set_allocated_intin(
      ::commonmodule::StatusINS* intin);
  ::commonmodule::StatusINS* unsafe_arena_release_intin();
  // .commonmodule.Optional_PhaseCodeKind Phase = 3;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;

  public:
  void clear_phase() ;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);
  private:
  const ::commonmodule::Optional_PhaseCodeKind& _internal_phase() const;
  ::commonmodule::Optional_PhaseCodeKind* _internal_mutable_phase();
  public:
  void unsafe_arena_set_allocated_phase(
      ::commonmodule::Optional_PhaseCodeKind* phase);
  ::commonmodule::Optional_PhaseCodeKind* unsafe_arena_release_phase();
  // @@protoc_insertion_point(class_scope:commonmodule.IntegerEventAndStatusGGIO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::StatusINS* intin_;
    ::commonmodule::Optional_PhaseCodeKind* phase_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDWMX final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDWMX) */ {
 public:
  inline OperationDWMX() : OperationDWMX(nullptr) {}
  ~OperationDWMX() override;
  explicit PROTOBUF_CONSTEXPR OperationDWMX(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDWMX(const OperationDWMX& from);
  OperationDWMX(OperationDWMX&& from) noexcept
    : OperationDWMX() {
    *this = ::std::move(from);
  }

  inline OperationDWMX& operator=(const OperationDWMX& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDWMX& operator=(OperationDWMX&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDWMX& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDWMX* internal_default_instance() {
    return reinterpret_cast<const OperationDWMX*>(
               &_OperationDWMX_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(OperationDWMX& a, OperationDWMX& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDWMX* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDWMX* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDWMX* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDWMX>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDWMX& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDWMX& from) {
    OperationDWMX::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDWMX* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDWMX";
  }
  protected:
  explicit OperationDWMX(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModEnaFieldNumber = 1,
  };
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDWMX)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDWMN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDWMN) */ {
 public:
  inline OperationDWMN() : OperationDWMN(nullptr) {}
  ~OperationDWMN() override;
  explicit PROTOBUF_CONSTEXPR OperationDWMN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDWMN(const OperationDWMN& from);
  OperationDWMN(OperationDWMN&& from) noexcept
    : OperationDWMN() {
    *this = ::std::move(from);
  }

  inline OperationDWMN& operator=(const OperationDWMN& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDWMN& operator=(OperationDWMN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDWMN& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDWMN* internal_default_instance() {
    return reinterpret_cast<const OperationDWMN*>(
               &_OperationDWMN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(OperationDWMN& a, OperationDWMN& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDWMN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDWMN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDWMN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDWMN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDWMN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDWMN& from) {
    OperationDWMN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDWMN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDWMN";
  }
  protected:
  explicit OperationDWMN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModEnaFieldNumber = 1,
  };
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDWMN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class LimitWAPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.LimitWAPC) */ {
 public:
  inline LimitWAPC() : LimitWAPC(nullptr) {}
  ~LimitWAPC() override;
  explicit PROTOBUF_CONSTEXPR LimitWAPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LimitWAPC(const LimitWAPC& from);
  LimitWAPC(LimitWAPC&& from) noexcept
    : LimitWAPC() {
    *this = ::std::move(from);
  }

  inline LimitWAPC& operator=(const LimitWAPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline LimitWAPC& operator=(LimitWAPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LimitWAPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const LimitWAPC* internal_default_instance() {
    return reinterpret_cast<const LimitWAPC*>(
               &_LimitWAPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(LimitWAPC& a, LimitWAPC& b) {
    a.Swap(&b);
  }
  inline void Swap(LimitWAPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LimitWAPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LimitWAPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LimitWAPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LimitWAPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LimitWAPC& from) {
    LimitWAPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LimitWAPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.LimitWAPC";
  }
  protected:
  explicit LimitWAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxLimParameterFieldNumber = 1,
    kMinLimParameterFieldNumber = 2,
    kWMaxSptValFieldNumber = 3,
    kWMinSptValFieldNumber = 4,
  };
  // .commonmodule.OperationDWMX maxLimParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_maxlimparameter() const;
  private:
  bool _internal_has_maxlimparameter() const;

  public:
  void clear_maxlimparameter() ;
  const ::commonmodule::OperationDWMX& maxlimparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDWMX* release_maxlimparameter();
  ::commonmodule::OperationDWMX* mutable_maxlimparameter();
  void set_allocated_maxlimparameter(::commonmodule::OperationDWMX* maxlimparameter);
  private:
  const ::commonmodule::OperationDWMX& _internal_maxlimparameter() const;
  ::commonmodule::OperationDWMX* _internal_mutable_maxlimparameter();
  public:
  void unsafe_arena_set_allocated_maxlimparameter(
      ::commonmodule::OperationDWMX* maxlimparameter);
  ::commonmodule::OperationDWMX* unsafe_arena_release_maxlimparameter();
  // .commonmodule.OperationDWMN minLimParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_minlimparameter() const;
  private:
  bool _internal_has_minlimparameter() const;

  public:
  void clear_minlimparameter() ;
  const ::commonmodule::OperationDWMN& minlimparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDWMN* release_minlimparameter();
  ::commonmodule::OperationDWMN* mutable_minlimparameter();
  void set_allocated_minlimparameter(::commonmodule::OperationDWMN* minlimparameter);
  private:
  const ::commonmodule::OperationDWMN& _internal_minlimparameter() const;
  ::commonmodule::OperationDWMN* _internal_mutable_minlimparameter();
  public:
  void unsafe_arena_set_allocated_minlimparameter(
      ::commonmodule::OperationDWMN* minlimparameter);
  ::commonmodule::OperationDWMN* unsafe_arena_release_minlimparameter();
  // float wMaxSptVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_wmaxsptval() ;
  float wmaxsptval() const;
  void set_wmaxsptval(float value);

  private:
  float _internal_wmaxsptval() const;
  void _internal_set_wmaxsptval(float value);

  public:
  // float wMinSptVal = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_wminsptval() ;
  float wminsptval() const;
  void set_wminsptval(float value);

  private:
  float _internal_wminsptval() const;
  void _internal_set_wminsptval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.LimitWAPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::OperationDWMX* maxlimparameter_;
    ::commonmodule::OperationDWMN* minlimparameter_;
    float wmaxsptval_;
    float wminsptval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class LogicalNodeForEventAndStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.LogicalNodeForEventAndStatus) */ {
 public:
  inline LogicalNodeForEventAndStatus() : LogicalNodeForEventAndStatus(nullptr) {}
  ~LogicalNodeForEventAndStatus() override;
  explicit PROTOBUF_CONSTEXPR LogicalNodeForEventAndStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicalNodeForEventAndStatus(const LogicalNodeForEventAndStatus& from);
  LogicalNodeForEventAndStatus(LogicalNodeForEventAndStatus&& from) noexcept
    : LogicalNodeForEventAndStatus() {
    *this = ::std::move(from);
  }

  inline LogicalNodeForEventAndStatus& operator=(const LogicalNodeForEventAndStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalNodeForEventAndStatus& operator=(LogicalNodeForEventAndStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogicalNodeForEventAndStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalNodeForEventAndStatus* internal_default_instance() {
    return reinterpret_cast<const LogicalNodeForEventAndStatus*>(
               &_LogicalNodeForEventAndStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(LogicalNodeForEventAndStatus& a, LogicalNodeForEventAndStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalNodeForEventAndStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalNodeForEventAndStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogicalNodeForEventAndStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogicalNodeForEventAndStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogicalNodeForEventAndStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogicalNodeForEventAndStatus& from) {
    LogicalNodeForEventAndStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalNodeForEventAndStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.LogicalNodeForEventAndStatus";
  }
  protected:
  explicit LogicalNodeForEventAndStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kBehFieldNumber = 2,
    kEEHealthFieldNumber = 3,
    kHotLineTagFieldNumber = 4,
    kRemoteBlkFieldNumber = 5,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.ENS_BehaviourModeKind Beh = 2;
  bool has_beh() const;
  private:
  bool _internal_has_beh() const;

  public:
  void clear_beh() ;
  const ::commonmodule::ENS_BehaviourModeKind& beh() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_BehaviourModeKind* release_beh();
  ::commonmodule::ENS_BehaviourModeKind* mutable_beh();
  void set_allocated_beh(::commonmodule::ENS_BehaviourModeKind* beh);
  private:
  const ::commonmodule::ENS_BehaviourModeKind& _internal_beh() const;
  ::commonmodule::ENS_BehaviourModeKind* _internal_mutable_beh();
  public:
  void unsafe_arena_set_allocated_beh(
      ::commonmodule::ENS_BehaviourModeKind* beh);
  ::commonmodule::ENS_BehaviourModeKind* unsafe_arena_release_beh();
  // .commonmodule.ENS_HealthKind EEHealth = 3;
  bool has_eehealth() const;
  private:
  bool _internal_has_eehealth() const;

  public:
  void clear_eehealth() ;
  const ::commonmodule::ENS_HealthKind& eehealth() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_HealthKind* release_eehealth();
  ::commonmodule::ENS_HealthKind* mutable_eehealth();
  void set_allocated_eehealth(::commonmodule::ENS_HealthKind* eehealth);
  private:
  const ::commonmodule::ENS_HealthKind& _internal_eehealth() const;
  ::commonmodule::ENS_HealthKind* _internal_mutable_eehealth();
  public:
  void unsafe_arena_set_allocated_eehealth(
      ::commonmodule::ENS_HealthKind* eehealth);
  ::commonmodule::ENS_HealthKind* unsafe_arena_release_eehealth();
  // .commonmodule.StatusSPS HotLineTag = 4;
  bool has_hotlinetag() const;
  private:
  bool _internal_has_hotlinetag() const;

  public:
  void clear_hotlinetag() ;
  const ::commonmodule::StatusSPS& hotlinetag() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_hotlinetag();
  ::commonmodule::StatusSPS* mutable_hotlinetag();
  void set_allocated_hotlinetag(::commonmodule::StatusSPS* hotlinetag);
  private:
  const ::commonmodule::StatusSPS& _internal_hotlinetag() const;
  ::commonmodule::StatusSPS* _internal_mutable_hotlinetag();
  public:
  void unsafe_arena_set_allocated_hotlinetag(
      ::commonmodule::StatusSPS* hotlinetag);
  ::commonmodule::StatusSPS* unsafe_arena_release_hotlinetag();
  // .commonmodule.StatusSPS RemoteBlk = 5;
  bool has_remoteblk() const;
  private:
  bool _internal_has_remoteblk() const;

  public:
  void clear_remoteblk() ;
  const ::commonmodule::StatusSPS& remoteblk() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_remoteblk();
  ::commonmodule::StatusSPS* mutable_remoteblk();
  void set_allocated_remoteblk(::commonmodule::StatusSPS* remoteblk);
  private:
  const ::commonmodule::StatusSPS& _internal_remoteblk() const;
  ::commonmodule::StatusSPS* _internal_mutable_remoteblk();
  public:
  void unsafe_arena_set_allocated_remoteblk(
      ::commonmodule::StatusSPS* remoteblk);
  ::commonmodule::StatusSPS* unsafe_arena_release_remoteblk();
  // @@protoc_insertion_point(class_scope:commonmodule.LogicalNodeForEventAndStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::ENS_BehaviourModeKind* beh_;
    ::commonmodule::ENS_HealthKind* eehealth_;
    ::commonmodule::StatusSPS* hotlinetag_;
    ::commonmodule::StatusSPS* remoteblk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class MeasurementValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.MeasurementValue) */ {
 public:
  inline MeasurementValue() : MeasurementValue(nullptr) {}
  ~MeasurementValue() override;
  explicit PROTOBUF_CONSTEXPR MeasurementValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MeasurementValue(const MeasurementValue& from);
  MeasurementValue(MeasurementValue&& from) noexcept
    : MeasurementValue() {
    *this = ::std::move(from);
  }

  inline MeasurementValue& operator=(const MeasurementValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline MeasurementValue& operator=(MeasurementValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MeasurementValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const MeasurementValue* internal_default_instance() {
    return reinterpret_cast<const MeasurementValue*>(
               &_MeasurementValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(MeasurementValue& a, MeasurementValue& b) {
    a.Swap(&b);
  }
  inline void Swap(MeasurementValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MeasurementValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MeasurementValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MeasurementValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MeasurementValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MeasurementValue& from) {
    MeasurementValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeasurementValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.MeasurementValue";
  }
  protected:
  explicit MeasurementValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // @@protoc_insertion_point(class_scope:commonmodule.MeasurementValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Meter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Meter) */ {
 public:
  inline Meter() : Meter(nullptr) {}
  ~Meter() override;
  explicit PROTOBUF_CONSTEXPR Meter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Meter(const Meter& from);
  Meter(Meter&& from) noexcept
    : Meter() {
    *this = ::std::move(from);
  }

  inline Meter& operator=(const Meter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Meter& operator=(Meter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Meter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Meter* internal_default_instance() {
    return reinterpret_cast<const Meter*>(
               &_Meter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(Meter& a, Meter& b) {
    a.Swap(&b);
  }
  inline void Swap(Meter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Meter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Meter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Meter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Meter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Meter& from) {
    Meter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Meter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Meter";
  }
  protected:
  explicit Meter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  private:
  bool _internal_has_conductingequipment() const;

  public:
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);
  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_conductingequipment();
  public:
  void unsafe_arena_set_allocated_conductingequipment(
      ::commonmodule::ConductingEquipment* conductingequipment);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_conductingequipment();
  // @@protoc_insertion_point(class_scope:commonmodule.Meter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipment* conductingequipment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class NameplateValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.NameplateValue) */ {
 public:
  inline NameplateValue() : NameplateValue(nullptr) {}
  ~NameplateValue() override;
  explicit PROTOBUF_CONSTEXPR NameplateValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NameplateValue(const NameplateValue& from);
  NameplateValue(NameplateValue&& from) noexcept
    : NameplateValue() {
    *this = ::std::move(from);
  }

  inline NameplateValue& operator=(const NameplateValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameplateValue& operator=(NameplateValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NameplateValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const NameplateValue* internal_default_instance() {
    return reinterpret_cast<const NameplateValue*>(
               &_NameplateValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(NameplateValue& a, NameplateValue& b) {
    a.Swap(&b);
  }
  inline void Swap(NameplateValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameplateValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NameplateValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NameplateValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NameplateValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NameplateValue& from) {
    NameplateValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameplateValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.NameplateValue";
  }
  protected:
  explicit NameplateValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kModelFieldNumber = 2,
    kSernumFieldNumber = 3,
    kSwRevFieldNumber = 4,
    kVendorFieldNumber = 5,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .google.protobuf.StringValue model = 2;
  bool has_model() const;
  private:
  bool _internal_has_model() const;

  public:
  void clear_model() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& model() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_model();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_model();
  void set_allocated_model(::PROTOBUF_NAMESPACE_ID::StringValue* model);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_model() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::PROTOBUF_NAMESPACE_ID::StringValue* model);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_model();
  // .google.protobuf.StringValue sernum = 3;
  bool has_sernum() const;
  private:
  bool _internal_has_sernum() const;

  public:
  void clear_sernum() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& sernum() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_sernum();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_sernum();
  void set_allocated_sernum(::PROTOBUF_NAMESPACE_ID::StringValue* sernum);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_sernum() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_sernum();
  public:
  void unsafe_arena_set_allocated_sernum(
      ::PROTOBUF_NAMESPACE_ID::StringValue* sernum);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_sernum();
  // .google.protobuf.StringValue swRev = 4;
  bool has_swrev() const;
  private:
  bool _internal_has_swrev() const;

  public:
  void clear_swrev() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& swrev() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_swrev();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_swrev();
  void set_allocated_swrev(::PROTOBUF_NAMESPACE_ID::StringValue* swrev);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_swrev() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_swrev();
  public:
  void unsafe_arena_set_allocated_swrev(
      ::PROTOBUF_NAMESPACE_ID::StringValue* swrev);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_swrev();
  // .google.protobuf.StringValue vendor = 5;
  bool has_vendor() const;
  private:
  bool _internal_has_vendor() const;

  public:
  void clear_vendor() ;
  const ::PROTOBUF_NAMESPACE_ID::StringValue& vendor() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_vendor();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_vendor();
  void set_allocated_vendor(::PROTOBUF_NAMESPACE_ID::StringValue* vendor);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_vendor() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_vendor();
  public:
  void unsafe_arena_set_allocated_vendor(
      ::PROTOBUF_NAMESPACE_ID::StringValue* vendor);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_vendor();
  // @@protoc_insertion_point(class_scope:commonmodule.NameplateValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* model_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* sernum_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* swrev_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* vendor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDFPF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDFPF) */ {
 public:
  inline OperationDFPF() : OperationDFPF(nullptr) {}
  ~OperationDFPF() override;
  explicit PROTOBUF_CONSTEXPR OperationDFPF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDFPF(const OperationDFPF& from);
  OperationDFPF(OperationDFPF&& from) noexcept
    : OperationDFPF() {
    *this = ::std::move(from);
  }

  inline OperationDFPF& operator=(const OperationDFPF& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDFPF& operator=(OperationDFPF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDFPF& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDFPF* internal_default_instance() {
    return reinterpret_cast<const OperationDFPF*>(
               &_OperationDFPF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(OperationDFPF& a, OperationDFPF& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDFPF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDFPF* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDFPF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDFPF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDFPF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDFPF& from) {
    OperationDFPF::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDFPF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDFPF";
  }
  protected:
  explicit OperationDFPF(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModEnaFieldNumber = 1,
    kPFExtSetFieldNumber = 2,
    kPFGnTgtMxValFieldNumber = 3,
  };
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // bool pFExtSet = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_pfextset() ;
  bool pfextset() const;
  void set_pfextset(bool value);

  private:
  bool _internal_pfextset() const;
  void _internal_set_pfextset(bool value);

  public:
  // float pFGnTgtMxVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_pfgntgtmxval() ;
  float pfgntgtmxval() const;
  void set_pfgntgtmxval(float value);

  private:
  float _internal_pfgntgtmxval() const;
  void _internal_set_pfgntgtmxval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDFPF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool modena_;
    bool pfextset_;
    float pfgntgtmxval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDVAR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDVAR) */ {
 public:
  inline OperationDVAR() : OperationDVAR(nullptr) {}
  ~OperationDVAR() override;
  explicit PROTOBUF_CONSTEXPR OperationDVAR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDVAR(const OperationDVAR& from);
  OperationDVAR(OperationDVAR&& from) noexcept
    : OperationDVAR() {
    *this = ::std::move(from);
  }

  inline OperationDVAR& operator=(const OperationDVAR& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDVAR& operator=(OperationDVAR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDVAR& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDVAR* internal_default_instance() {
    return reinterpret_cast<const OperationDVAR*>(
               &_OperationDVAR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(OperationDVAR& a, OperationDVAR& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDVAR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDVAR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDVAR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDVAR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDVAR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDVAR& from) {
    OperationDVAR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDVAR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDVAR";
  }
  protected:
  explicit OperationDVAR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarTgtSptFieldNumber = 1,
  };
  // float varTgtSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_vartgtspt() ;
  float vartgtspt() const;
  void set_vartgtspt(float value);

  private:
  float _internal_vartgtspt() const;
  void _internal_set_vartgtspt(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDVAR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float vartgtspt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDVVR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDVVR) */ {
 public:
  inline OperationDVVR() : OperationDVVR(nullptr) {}
  ~OperationDVVR() override;
  explicit PROTOBUF_CONSTEXPR OperationDVVR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDVVR(const OperationDVVR& from);
  OperationDVVR(OperationDVVR&& from) noexcept
    : OperationDVVR() {
    *this = ::std::move(from);
  }

  inline OperationDVVR& operator=(const OperationDVVR& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDVVR& operator=(OperationDVVR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDVVR& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDVVR* internal_default_instance() {
    return reinterpret_cast<const OperationDVVR*>(
               &_OperationDVVR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(OperationDVVR& a, OperationDVVR& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDVVR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDVVR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDVVR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDVVR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDVVR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDVVR& from) {
    OperationDVVR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDVVR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDVVR";
  }
  protected:
  explicit OperationDVVR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOplTmmsMaxFieldNumber = 2,
    kVRefTmmsFieldNumber = 5,
    kModEnaFieldNumber = 1,
    kVRefAdjEnaFieldNumber = 4,
    kVRefFieldNumber = 3,
  };
  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_opltmmsmax() const;
  private:
  bool _internal_has_opltmmsmax() const;

  public:
  void clear_opltmmsmax() ;
  const ::commonmodule::ClearingTime& opltmmsmax() const;
  PROTOBUF_NODISCARD ::commonmodule::ClearingTime* release_opltmmsmax();
  ::commonmodule::ClearingTime* mutable_opltmmsmax();
  void set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax);
  private:
  const ::commonmodule::ClearingTime& _internal_opltmmsmax() const;
  ::commonmodule::ClearingTime* _internal_mutable_opltmmsmax();
  public:
  void unsafe_arena_set_allocated_opltmmsmax(
      ::commonmodule::ClearingTime* opltmmsmax);
  ::commonmodule::ClearingTime* unsafe_arena_release_opltmmsmax();
  // .commonmodule.ControlING VRefTmms = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vreftmms() const;
  private:
  bool _internal_has_vreftmms() const;

  public:
  void clear_vreftmms() ;
  const ::commonmodule::ControlING& vreftmms() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlING* release_vreftmms();
  ::commonmodule::ControlING* mutable_vreftmms();
  void set_allocated_vreftmms(::commonmodule::ControlING* vreftmms);
  private:
  const ::commonmodule::ControlING& _internal_vreftmms() const;
  ::commonmodule::ControlING* _internal_mutable_vreftmms();
  public:
  void unsafe_arena_set_allocated_vreftmms(
      ::commonmodule::ControlING* vreftmms);
  ::commonmodule::ControlING* unsafe_arena_release_vreftmms();
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // bool VRefAdjEna = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_vrefadjena() ;
  bool vrefadjena() const;
  void set_vrefadjena(bool value);

  private:
  bool _internal_vrefadjena() const;
  void _internal_set_vrefadjena(bool value);

  public:
  // float VRef = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_vref() ;
  float vref() const;
  void set_vref(float value);

  private:
  float _internal_vref() const;
  void _internal_set_vref(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDVVR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ClearingTime* opltmmsmax_;
    ::commonmodule::ControlING* vreftmms_;
    bool modena_;
    bool vrefadjena_;
    float vref_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDVWC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDVWC) */ {
 public:
  inline OperationDVWC() : OperationDVWC(nullptr) {}
  ~OperationDVWC() override;
  explicit PROTOBUF_CONSTEXPR OperationDVWC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDVWC(const OperationDVWC& from);
  OperationDVWC(OperationDVWC&& from) noexcept
    : OperationDVWC() {
    *this = ::std::move(from);
  }

  inline OperationDVWC& operator=(const OperationDVWC& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDVWC& operator=(OperationDVWC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDVWC& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDVWC* internal_default_instance() {
    return reinterpret_cast<const OperationDVWC*>(
               &_OperationDVWC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(OperationDVWC& a, OperationDVWC& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDVWC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDVWC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDVWC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDVWC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDVWC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDVWC& from) {
    OperationDVWC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDVWC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDVWC";
  }
  protected:
  explicit OperationDVWC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOplTmmsMaxFieldNumber = 2,
    kModEnaFieldNumber = 1,
  };
  // .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_opltmmsmax() const;
  private:
  bool _internal_has_opltmmsmax() const;

  public:
  void clear_opltmmsmax() ;
  const ::commonmodule::ClearingTime& opltmmsmax() const;
  PROTOBUF_NODISCARD ::commonmodule::ClearingTime* release_opltmmsmax();
  ::commonmodule::ClearingTime* mutable_opltmmsmax();
  void set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax);
  private:
  const ::commonmodule::ClearingTime& _internal_opltmmsmax() const;
  ::commonmodule::ClearingTime* _internal_mutable_opltmmsmax();
  public:
  void unsafe_arena_set_allocated_opltmmsmax(
      ::commonmodule::ClearingTime* opltmmsmax);
  ::commonmodule::ClearingTime* unsafe_arena_release_opltmmsmax();
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDVWC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ClearingTime* opltmmsmax_;
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDWGC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDWGC) */ {
 public:
  inline OperationDWGC() : OperationDWGC(nullptr) {}
  ~OperationDWGC() override;
  explicit PROTOBUF_CONSTEXPR OperationDWGC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDWGC(const OperationDWGC& from);
  OperationDWGC(OperationDWGC&& from) noexcept
    : OperationDWGC() {
    *this = ::std::move(from);
  }

  inline OperationDWGC& operator=(const OperationDWGC& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDWGC& operator=(OperationDWGC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDWGC& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDWGC* internal_default_instance() {
    return reinterpret_cast<const OperationDWGC*>(
               &_OperationDWGC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(OperationDWGC& a, OperationDWGC& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDWGC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDWGC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDWGC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDWGC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDWGC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDWGC& from) {
    OperationDWGC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDWGC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDWGC";
  }
  protected:
  explicit OperationDWGC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWSptFieldNumber = 1,
  };
  // float wSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_wspt() ;
  float wspt() const;
  void set_wspt(float value);

  private:
  float _internal_wspt() const;
  void _internal_set_wspt(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDWGC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float wspt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OperationDWVR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OperationDWVR) */ {
 public:
  inline OperationDWVR() : OperationDWVR(nullptr) {}
  ~OperationDWVR() override;
  explicit PROTOBUF_CONSTEXPR OperationDWVR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationDWVR(const OperationDWVR& from);
  OperationDWVR(OperationDWVR&& from) noexcept
    : OperationDWVR() {
    *this = ::std::move(from);
  }

  inline OperationDWVR& operator=(const OperationDWVR& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationDWVR& operator=(OperationDWVR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationDWVR& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationDWVR* internal_default_instance() {
    return reinterpret_cast<const OperationDWVR*>(
               &_OperationDWVR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(OperationDWVR& a, OperationDWVR& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationDWVR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationDWVR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationDWVR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationDWVR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationDWVR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationDWVR& from) {
    OperationDWVR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationDWVR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OperationDWVR";
  }
  protected:
  explicit OperationDWVR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModEnaFieldNumber = 1,
  };
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.OperationDWVR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class OptimizationMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.OptimizationMessageInfo) */ {
 public:
  inline OptimizationMessageInfo() : OptimizationMessageInfo(nullptr) {}
  ~OptimizationMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR OptimizationMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptimizationMessageInfo(const OptimizationMessageInfo& from);
  OptimizationMessageInfo(OptimizationMessageInfo&& from) noexcept
    : OptimizationMessageInfo() {
    *this = ::std::move(from);
  }

  inline OptimizationMessageInfo& operator=(const OptimizationMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimizationMessageInfo& operator=(OptimizationMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimizationMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptimizationMessageInfo* internal_default_instance() {
    return reinterpret_cast<const OptimizationMessageInfo*>(
               &_OptimizationMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(OptimizationMessageInfo& a, OptimizationMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OptimizationMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimizationMessageInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimizationMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptimizationMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptimizationMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptimizationMessageInfo& from) {
    OptimizationMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptimizationMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.OptimizationMessageInfo";
  }
  protected:
  explicit OptimizationMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageInfoFieldNumber = 1,
  };
  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  private:
  bool _internal_has_messageinfo() const;

  public:
  void clear_messageinfo() ;
  const ::commonmodule::MessageInfo& messageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);
  private:
  const ::commonmodule::MessageInfo& _internal_messageinfo() const;
  ::commonmodule::MessageInfo* _internal_mutable_messageinfo();
  public:
  void unsafe_arena_set_allocated_messageinfo(
      ::commonmodule::MessageInfo* messageinfo);
  ::commonmodule::MessageInfo* unsafe_arena_release_messageinfo();
  // @@protoc_insertion_point(class_scope:commonmodule.OptimizationMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::MessageInfo* messageinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PFSPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PFSPC) */ {
 public:
  inline PFSPC() : PFSPC(nullptr) {}
  ~PFSPC() override;
  explicit PROTOBUF_CONSTEXPR PFSPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PFSPC(const PFSPC& from);
  PFSPC(PFSPC&& from) noexcept
    : PFSPC() {
    *this = ::std::move(from);
  }

  inline PFSPC& operator=(const PFSPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline PFSPC& operator=(PFSPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PFSPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const PFSPC* internal_default_instance() {
    return reinterpret_cast<const PFSPC*>(
               &_PFSPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(PFSPC& a, PFSPC& b) {
    a.Swap(&b);
  }
  inline void Swap(PFSPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PFSPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PFSPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PFSPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PFSPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PFSPC& from) {
    PFSPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PFSPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PFSPC";
  }
  protected:
  explicit PFSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPFParameterFieldNumber = 2,
    kCtlValFieldNumber = 1,
  };
  // .commonmodule.OperationDFPF pFParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pfparameter() const;
  private:
  bool _internal_has_pfparameter() const;

  public:
  void clear_pfparameter() ;
  const ::commonmodule::OperationDFPF& pfparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDFPF* release_pfparameter();
  ::commonmodule::OperationDFPF* mutable_pfparameter();
  void set_allocated_pfparameter(::commonmodule::OperationDFPF* pfparameter);
  private:
  const ::commonmodule::OperationDFPF& _internal_pfparameter() const;
  ::commonmodule::OperationDFPF* _internal_mutable_pfparameter();
  public:
  void unsafe_arena_set_allocated_pfparameter(
      ::commonmodule::OperationDFPF* pfparameter);
  ::commonmodule::OperationDFPF* unsafe_arena_release_pfparameter();
  // bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval() ;
  bool ctlval() const;
  void set_ctlval(bool value);

  private:
  bool _internal_ctlval() const;
  void _internal_set_ctlval(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.PFSPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::OperationDFPF* pfparameter_;
    bool ctlval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseAPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseAPC) */ {
 public:
  inline PhaseAPC() : PhaseAPC(nullptr) {}
  ~PhaseAPC() override;
  explicit PROTOBUF_CONSTEXPR PhaseAPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseAPC(const PhaseAPC& from);
  PhaseAPC(PhaseAPC&& from) noexcept
    : PhaseAPC() {
    *this = ::std::move(from);
  }

  inline PhaseAPC& operator=(const PhaseAPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseAPC& operator=(PhaseAPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseAPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseAPC* internal_default_instance() {
    return reinterpret_cast<const PhaseAPC*>(
               &_PhaseAPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(PhaseAPC& a, PhaseAPC& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseAPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseAPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseAPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseAPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseAPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseAPC& from) {
    PhaseAPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseAPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseAPC";
  }
  protected:
  explicit PhaseAPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.ControlAPC phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::ControlAPC& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlAPC* release_phs3();
  ::commonmodule::ControlAPC* mutable_phs3();
  void set_allocated_phs3(::commonmodule::ControlAPC* phs3);
  private:
  const ::commonmodule::ControlAPC& _internal_phs3() const;
  ::commonmodule::ControlAPC* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::ControlAPC* phs3);
  ::commonmodule::ControlAPC* unsafe_arena_release_phs3();
  // .commonmodule.ControlAPC phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::ControlAPC& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlAPC* release_phsa();
  ::commonmodule::ControlAPC* mutable_phsa();
  void set_allocated_phsa(::commonmodule::ControlAPC* phsa);
  private:
  const ::commonmodule::ControlAPC& _internal_phsa() const;
  ::commonmodule::ControlAPC* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::ControlAPC* phsa);
  ::commonmodule::ControlAPC* unsafe_arena_release_phsa();
  // .commonmodule.ControlAPC phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::ControlAPC& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlAPC* release_phsb();
  ::commonmodule::ControlAPC* mutable_phsb();
  void set_allocated_phsb(::commonmodule::ControlAPC* phsb);
  private:
  const ::commonmodule::ControlAPC& _internal_phsb() const;
  ::commonmodule::ControlAPC* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::ControlAPC* phsb);
  ::commonmodule::ControlAPC* unsafe_arena_release_phsb();
  // .commonmodule.ControlAPC phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::ControlAPC& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlAPC* release_phsc();
  ::commonmodule::ControlAPC* mutable_phsc();
  void set_allocated_phsc(::commonmodule::ControlAPC* phsc);
  private:
  const ::commonmodule::ControlAPC& _internal_phsc() const;
  ::commonmodule::ControlAPC* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::ControlAPC* phsc);
  ::commonmodule::ControlAPC* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseAPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlAPC* phs3_;
    ::commonmodule::ControlAPC* phsa_;
    ::commonmodule::ControlAPC* phsb_;
    ::commonmodule::ControlAPC* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_DbPosKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_DbPosKind) */ {
 public:
  inline Optional_DbPosKind() : Optional_DbPosKind(nullptr) {}
  ~Optional_DbPosKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_DbPosKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_DbPosKind(const Optional_DbPosKind& from);
  Optional_DbPosKind(Optional_DbPosKind&& from) noexcept
    : Optional_DbPosKind() {
    *this = ::std::move(from);
  }

  inline Optional_DbPosKind& operator=(const Optional_DbPosKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_DbPosKind& operator=(Optional_DbPosKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_DbPosKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_DbPosKind* internal_default_instance() {
    return reinterpret_cast<const Optional_DbPosKind*>(
               &_Optional_DbPosKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(Optional_DbPosKind& a, Optional_DbPosKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_DbPosKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_DbPosKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_DbPosKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_DbPosKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_DbPosKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_DbPosKind& from) {
    Optional_DbPosKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_DbPosKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_DbPosKind";
  }
  protected:
  explicit Optional_DbPosKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.DbPosKind value = 1;
  void clear_value() ;
  ::commonmodule::DbPosKind value() const;
  void set_value(::commonmodule::DbPosKind value);

  private:
  ::commonmodule::DbPosKind _internal_value() const;
  void _internal_set_value(::commonmodule::DbPosKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_DbPosKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusDPS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusDPS) */ {
 public:
  inline StatusDPS() : StatusDPS(nullptr) {}
  ~StatusDPS() override;
  explicit PROTOBUF_CONSTEXPR StatusDPS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusDPS(const StatusDPS& from);
  StatusDPS(StatusDPS&& from) noexcept
    : StatusDPS() {
    *this = ::std::move(from);
  }

  inline StatusDPS& operator=(const StatusDPS& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusDPS& operator=(StatusDPS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusDPS& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusDPS* internal_default_instance() {
    return reinterpret_cast<const StatusDPS*>(
               &_StatusDPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(StatusDPS& a, StatusDPS& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusDPS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusDPS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusDPS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusDPS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusDPS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusDPS& from) {
    StatusDPS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusDPS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusDPS";
  }
  protected:
  explicit StatusDPS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // .commonmodule.DbPosKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::commonmodule::DbPosKind stval() const;
  void set_stval(::commonmodule::DbPosKind value);

  private:
  ::commonmodule::DbPosKind _internal_stval() const;
  void _internal_set_stval(::commonmodule::DbPosKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.StatusDPS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    int stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseDPS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseDPS) */ {
 public:
  inline PhaseDPS() : PhaseDPS(nullptr) {}
  ~PhaseDPS() override;
  explicit PROTOBUF_CONSTEXPR PhaseDPS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseDPS(const PhaseDPS& from);
  PhaseDPS(PhaseDPS&& from) noexcept
    : PhaseDPS() {
    *this = ::std::move(from);
  }

  inline PhaseDPS& operator=(const PhaseDPS& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseDPS& operator=(PhaseDPS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseDPS& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseDPS* internal_default_instance() {
    return reinterpret_cast<const PhaseDPS*>(
               &_PhaseDPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(PhaseDPS& a, PhaseDPS& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseDPS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseDPS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseDPS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseDPS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseDPS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseDPS& from) {
    PhaseDPS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseDPS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseDPS";
  }
  protected:
  explicit PhaseDPS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.StatusDPS phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::StatusDPS& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusDPS* release_phs3();
  ::commonmodule::StatusDPS* mutable_phs3();
  void set_allocated_phs3(::commonmodule::StatusDPS* phs3);
  private:
  const ::commonmodule::StatusDPS& _internal_phs3() const;
  ::commonmodule::StatusDPS* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::StatusDPS* phs3);
  ::commonmodule::StatusDPS* unsafe_arena_release_phs3();
  // .commonmodule.StatusDPS phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::StatusDPS& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusDPS* release_phsa();
  ::commonmodule::StatusDPS* mutable_phsa();
  void set_allocated_phsa(::commonmodule::StatusDPS* phsa);
  private:
  const ::commonmodule::StatusDPS& _internal_phsa() const;
  ::commonmodule::StatusDPS* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::StatusDPS* phsa);
  ::commonmodule::StatusDPS* unsafe_arena_release_phsa();
  // .commonmodule.StatusDPS phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::StatusDPS& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusDPS* release_phsb();
  ::commonmodule::StatusDPS* mutable_phsb();
  void set_allocated_phsb(::commonmodule::StatusDPS* phsb);
  private:
  const ::commonmodule::StatusDPS& _internal_phsb() const;
  ::commonmodule::StatusDPS* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::StatusDPS* phsb);
  ::commonmodule::StatusDPS* unsafe_arena_release_phsb();
  // .commonmodule.StatusDPS phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::StatusDPS& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusDPS* release_phsc();
  ::commonmodule::StatusDPS* mutable_phsc();
  void set_allocated_phsc(::commonmodule::StatusDPS* phsc);
  private:
  const ::commonmodule::StatusDPS& _internal_phsc() const;
  ::commonmodule::StatusDPS* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::StatusDPS* phsc);
  ::commonmodule::StatusDPS* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseDPS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusDPS* phs3_;
    ::commonmodule::StatusDPS* phsa_;
    ::commonmodule::StatusDPS* phsb_;
    ::commonmodule::StatusDPS* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseINS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseINS) */ {
 public:
  inline PhaseINS() : PhaseINS(nullptr) {}
  ~PhaseINS() override;
  explicit PROTOBUF_CONSTEXPR PhaseINS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseINS(const PhaseINS& from);
  PhaseINS(PhaseINS&& from) noexcept
    : PhaseINS() {
    *this = ::std::move(from);
  }

  inline PhaseINS& operator=(const PhaseINS& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseINS& operator=(PhaseINS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseINS& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseINS* internal_default_instance() {
    return reinterpret_cast<const PhaseINS*>(
               &_PhaseINS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(PhaseINS& a, PhaseINS& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseINS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseINS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseINS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseINS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseINS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseINS& from) {
    PhaseINS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseINS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseINS";
  }
  protected:
  explicit PhaseINS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.StatusINS phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::StatusINS& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusINS* release_phs3();
  ::commonmodule::StatusINS* mutable_phs3();
  void set_allocated_phs3(::commonmodule::StatusINS* phs3);
  private:
  const ::commonmodule::StatusINS& _internal_phs3() const;
  ::commonmodule::StatusINS* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::StatusINS* phs3);
  ::commonmodule::StatusINS* unsafe_arena_release_phs3();
  // .commonmodule.StatusINS phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::StatusINS& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusINS* release_phsa();
  ::commonmodule::StatusINS* mutable_phsa();
  void set_allocated_phsa(::commonmodule::StatusINS* phsa);
  private:
  const ::commonmodule::StatusINS& _internal_phsa() const;
  ::commonmodule::StatusINS* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::StatusINS* phsa);
  ::commonmodule::StatusINS* unsafe_arena_release_phsa();
  // .commonmodule.StatusINS phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::StatusINS& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusINS* release_phsb();
  ::commonmodule::StatusINS* mutable_phsb();
  void set_allocated_phsb(::commonmodule::StatusINS* phsb);
  private:
  const ::commonmodule::StatusINS& _internal_phsb() const;
  ::commonmodule::StatusINS* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::StatusINS* phsb);
  ::commonmodule::StatusINS* unsafe_arena_release_phsb();
  // .commonmodule.StatusINS phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::StatusINS& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusINS* release_phsc();
  ::commonmodule::StatusINS* mutable_phsc();
  void set_allocated_phsc(::commonmodule::StatusINS* phsc);
  private:
  const ::commonmodule::StatusINS& _internal_phsc() const;
  ::commonmodule::StatusINS* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::StatusINS* phsc);
  ::commonmodule::StatusINS* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseINS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusINS* phs3_;
    ::commonmodule::StatusINS* phsa_;
    ::commonmodule::StatusINS* phsb_;
    ::commonmodule::StatusINS* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseISC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseISC) */ {
 public:
  inline PhaseISC() : PhaseISC(nullptr) {}
  ~PhaseISC() override;
  explicit PROTOBUF_CONSTEXPR PhaseISC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseISC(const PhaseISC& from);
  PhaseISC(PhaseISC&& from) noexcept
    : PhaseISC() {
    *this = ::std::move(from);
  }

  inline PhaseISC& operator=(const PhaseISC& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseISC& operator=(PhaseISC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseISC& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseISC* internal_default_instance() {
    return reinterpret_cast<const PhaseISC*>(
               &_PhaseISC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(PhaseISC& a, PhaseISC& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseISC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseISC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseISC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseISC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseISC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseISC& from) {
    PhaseISC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseISC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseISC";
  }
  protected:
  explicit PhaseISC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.ControlISC phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::ControlISC& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlISC* release_phs3();
  ::commonmodule::ControlISC* mutable_phs3();
  void set_allocated_phs3(::commonmodule::ControlISC* phs3);
  private:
  const ::commonmodule::ControlISC& _internal_phs3() const;
  ::commonmodule::ControlISC* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::ControlISC* phs3);
  ::commonmodule::ControlISC* unsafe_arena_release_phs3();
  // .commonmodule.ControlISC phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::ControlISC& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlISC* release_phsa();
  ::commonmodule::ControlISC* mutable_phsa();
  void set_allocated_phsa(::commonmodule::ControlISC* phsa);
  private:
  const ::commonmodule::ControlISC& _internal_phsa() const;
  ::commonmodule::ControlISC* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::ControlISC* phsa);
  ::commonmodule::ControlISC* unsafe_arena_release_phsa();
  // .commonmodule.ControlISC phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::ControlISC& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlISC* release_phsb();
  ::commonmodule::ControlISC* mutable_phsb();
  void set_allocated_phsb(::commonmodule::ControlISC* phsb);
  private:
  const ::commonmodule::ControlISC& _internal_phsb() const;
  ::commonmodule::ControlISC* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::ControlISC* phsb);
  ::commonmodule::ControlISC* unsafe_arena_release_phsb();
  // .commonmodule.ControlISC phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::ControlISC& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlISC* release_phsc();
  ::commonmodule::ControlISC* mutable_phsc();
  void set_allocated_phsc(::commonmodule::ControlISC* phsc);
  private:
  const ::commonmodule::ControlISC& _internal_phsc() const;
  ::commonmodule::ControlISC* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::ControlISC* phsc);
  ::commonmodule::ControlISC* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseISC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlISC* phs3_;
    ::commonmodule::ControlISC* phsa_;
    ::commonmodule::ControlISC* phsb_;
    ::commonmodule::ControlISC* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ReadingMMTN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMMTN) */ {
 public:
  inline ReadingMMTN() : ReadingMMTN(nullptr) {}
  ~ReadingMMTN() override;
  explicit PROTOBUF_CONSTEXPR ReadingMMTN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadingMMTN(const ReadingMMTN& from);
  ReadingMMTN(ReadingMMTN&& from) noexcept
    : ReadingMMTN() {
    *this = ::std::move(from);
  }

  inline ReadingMMTN& operator=(const ReadingMMTN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadingMMTN& operator=(ReadingMMTN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadingMMTN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadingMMTN* internal_default_instance() {
    return reinterpret_cast<const ReadingMMTN*>(
               &_ReadingMMTN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(ReadingMMTN& a, ReadingMMTN& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadingMMTN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadingMMTN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadingMMTN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadingMMTN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadingMMTN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadingMMTN& from) {
    ReadingMMTN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMMTN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ReadingMMTN";
  }
  protected:
  explicit ReadingMMTN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kDmdVAhFieldNumber = 2,
    kDmdVArhFieldNumber = 3,
    kDmdWhFieldNumber = 4,
    kSupVAhFieldNumber = 5,
    kSupVArhFieldNumber = 6,
    kSupWhFieldNumber = 7,
    kTotVAhFieldNumber = 8,
    kTotVArhFieldNumber = 9,
    kTotWhFieldNumber = 10,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.BCR DmdVAh = 2;
  bool has_dmdvah() const;
  private:
  bool _internal_has_dmdvah() const;

  public:
  void clear_dmdvah() ;
  const ::commonmodule::BCR& dmdvah() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_dmdvah();
  ::commonmodule::BCR* mutable_dmdvah();
  void set_allocated_dmdvah(::commonmodule::BCR* dmdvah);
  private:
  const ::commonmodule::BCR& _internal_dmdvah() const;
  ::commonmodule::BCR* _internal_mutable_dmdvah();
  public:
  void unsafe_arena_set_allocated_dmdvah(
      ::commonmodule::BCR* dmdvah);
  ::commonmodule::BCR* unsafe_arena_release_dmdvah();
  // .commonmodule.BCR DmdVArh = 3;
  bool has_dmdvarh() const;
  private:
  bool _internal_has_dmdvarh() const;

  public:
  void clear_dmdvarh() ;
  const ::commonmodule::BCR& dmdvarh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_dmdvarh();
  ::commonmodule::BCR* mutable_dmdvarh();
  void set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh);
  private:
  const ::commonmodule::BCR& _internal_dmdvarh() const;
  ::commonmodule::BCR* _internal_mutable_dmdvarh();
  public:
  void unsafe_arena_set_allocated_dmdvarh(
      ::commonmodule::BCR* dmdvarh);
  ::commonmodule::BCR* unsafe_arena_release_dmdvarh();
  // .commonmodule.BCR DmdWh = 4;
  bool has_dmdwh() const;
  private:
  bool _internal_has_dmdwh() const;

  public:
  void clear_dmdwh() ;
  const ::commonmodule::BCR& dmdwh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_dmdwh();
  ::commonmodule::BCR* mutable_dmdwh();
  void set_allocated_dmdwh(::commonmodule::BCR* dmdwh);
  private:
  const ::commonmodule::BCR& _internal_dmdwh() const;
  ::commonmodule::BCR* _internal_mutable_dmdwh();
  public:
  void unsafe_arena_set_allocated_dmdwh(
      ::commonmodule::BCR* dmdwh);
  ::commonmodule::BCR* unsafe_arena_release_dmdwh();
  // .commonmodule.BCR SupVAh = 5;
  bool has_supvah() const;
  private:
  bool _internal_has_supvah() const;

  public:
  void clear_supvah() ;
  const ::commonmodule::BCR& supvah() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_supvah();
  ::commonmodule::BCR* mutable_supvah();
  void set_allocated_supvah(::commonmodule::BCR* supvah);
  private:
  const ::commonmodule::BCR& _internal_supvah() const;
  ::commonmodule::BCR* _internal_mutable_supvah();
  public:
  void unsafe_arena_set_allocated_supvah(
      ::commonmodule::BCR* supvah);
  ::commonmodule::BCR* unsafe_arena_release_supvah();
  // .commonmodule.BCR SupVArh = 6;
  bool has_supvarh() const;
  private:
  bool _internal_has_supvarh() const;

  public:
  void clear_supvarh() ;
  const ::commonmodule::BCR& supvarh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_supvarh();
  ::commonmodule::BCR* mutable_supvarh();
  void set_allocated_supvarh(::commonmodule::BCR* supvarh);
  private:
  const ::commonmodule::BCR& _internal_supvarh() const;
  ::commonmodule::BCR* _internal_mutable_supvarh();
  public:
  void unsafe_arena_set_allocated_supvarh(
      ::commonmodule::BCR* supvarh);
  ::commonmodule::BCR* unsafe_arena_release_supvarh();
  // .commonmodule.BCR SupWh = 7;
  bool has_supwh() const;
  private:
  bool _internal_has_supwh() const;

  public:
  void clear_supwh() ;
  const ::commonmodule::BCR& supwh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_supwh();
  ::commonmodule::BCR* mutable_supwh();
  void set_allocated_supwh(::commonmodule::BCR* supwh);
  private:
  const ::commonmodule::BCR& _internal_supwh() const;
  ::commonmodule::BCR* _internal_mutable_supwh();
  public:
  void unsafe_arena_set_allocated_supwh(
      ::commonmodule::BCR* supwh);
  ::commonmodule::BCR* unsafe_arena_release_supwh();
  // .commonmodule.BCR TotVAh = 8;
  bool has_totvah() const;
  private:
  bool _internal_has_totvah() const;

  public:
  void clear_totvah() ;
  const ::commonmodule::BCR& totvah() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_totvah();
  ::commonmodule::BCR* mutable_totvah();
  void set_allocated_totvah(::commonmodule::BCR* totvah);
  private:
  const ::commonmodule::BCR& _internal_totvah() const;
  ::commonmodule::BCR* _internal_mutable_totvah();
  public:
  void unsafe_arena_set_allocated_totvah(
      ::commonmodule::BCR* totvah);
  ::commonmodule::BCR* unsafe_arena_release_totvah();
  // .commonmodule.BCR TotVArh = 9;
  bool has_totvarh() const;
  private:
  bool _internal_has_totvarh() const;

  public:
  void clear_totvarh() ;
  const ::commonmodule::BCR& totvarh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_totvarh();
  ::commonmodule::BCR* mutable_totvarh();
  void set_allocated_totvarh(::commonmodule::BCR* totvarh);
  private:
  const ::commonmodule::BCR& _internal_totvarh() const;
  ::commonmodule::BCR* _internal_mutable_totvarh();
  public:
  void unsafe_arena_set_allocated_totvarh(
      ::commonmodule::BCR* totvarh);
  ::commonmodule::BCR* unsafe_arena_release_totvarh();
  // .commonmodule.BCR TotWh = 10;
  bool has_totwh() const;
  private:
  bool _internal_has_totwh() const;

  public:
  void clear_totwh() ;
  const ::commonmodule::BCR& totwh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_totwh();
  ::commonmodule::BCR* mutable_totwh();
  void set_allocated_totwh(::commonmodule::BCR* totwh);
  private:
  const ::commonmodule::BCR& _internal_totwh() const;
  ::commonmodule::BCR* _internal_mutable_totwh();
  public:
  void unsafe_arena_set_allocated_totwh(
      ::commonmodule::BCR* totwh);
  ::commonmodule::BCR* unsafe_arena_release_totwh();
  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMMTN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::BCR* dmdvah_;
    ::commonmodule::BCR* dmdvarh_;
    ::commonmodule::BCR* dmdwh_;
    ::commonmodule::BCR* supvah_;
    ::commonmodule::BCR* supvarh_;
    ::commonmodule::BCR* supwh_;
    ::commonmodule::BCR* totvah_;
    ::commonmodule::BCR* totvarh_;
    ::commonmodule::BCR* totwh_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseMMTN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseMMTN) */ {
 public:
  inline PhaseMMTN() : PhaseMMTN(nullptr) {}
  ~PhaseMMTN() override;
  explicit PROTOBUF_CONSTEXPR PhaseMMTN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseMMTN(const PhaseMMTN& from);
  PhaseMMTN(PhaseMMTN&& from) noexcept
    : PhaseMMTN() {
    *this = ::std::move(from);
  }

  inline PhaseMMTN& operator=(const PhaseMMTN& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseMMTN& operator=(PhaseMMTN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseMMTN& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseMMTN* internal_default_instance() {
    return reinterpret_cast<const PhaseMMTN*>(
               &_PhaseMMTN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(PhaseMMTN& a, PhaseMMTN& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseMMTN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseMMTN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseMMTN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseMMTN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseMMTN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseMMTN& from) {
    PhaseMMTN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseMMTN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseMMTN";
  }
  protected:
  explicit PhaseMMTN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhsAFieldNumber = 1,
    kPhsABFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsBCFieldNumber = 4,
    kPhsCFieldNumber = 5,
    kPhsCAFieldNumber = 6,
  };
  // .commonmodule.ReadingMMTN phsA = 1;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::ReadingMMTN& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTN* release_phsa();
  ::commonmodule::ReadingMMTN* mutable_phsa();
  void set_allocated_phsa(::commonmodule::ReadingMMTN* phsa);
  private:
  const ::commonmodule::ReadingMMTN& _internal_phsa() const;
  ::commonmodule::ReadingMMTN* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::ReadingMMTN* phsa);
  ::commonmodule::ReadingMMTN* unsafe_arena_release_phsa();
  // .commonmodule.ReadingMMTN phsAB = 2;
  bool has_phsab() const;
  private:
  bool _internal_has_phsab() const;

  public:
  void clear_phsab() ;
  const ::commonmodule::ReadingMMTN& phsab() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTN* release_phsab();
  ::commonmodule::ReadingMMTN* mutable_phsab();
  void set_allocated_phsab(::commonmodule::ReadingMMTN* phsab);
  private:
  const ::commonmodule::ReadingMMTN& _internal_phsab() const;
  ::commonmodule::ReadingMMTN* _internal_mutable_phsab();
  public:
  void unsafe_arena_set_allocated_phsab(
      ::commonmodule::ReadingMMTN* phsab);
  ::commonmodule::ReadingMMTN* unsafe_arena_release_phsab();
  // .commonmodule.ReadingMMTN phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::ReadingMMTN& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTN* release_phsb();
  ::commonmodule::ReadingMMTN* mutable_phsb();
  void set_allocated_phsb(::commonmodule::ReadingMMTN* phsb);
  private:
  const ::commonmodule::ReadingMMTN& _internal_phsb() const;
  ::commonmodule::ReadingMMTN* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::ReadingMMTN* phsb);
  ::commonmodule::ReadingMMTN* unsafe_arena_release_phsb();
  // .commonmodule.ReadingMMTN phsBC = 4;
  bool has_phsbc() const;
  private:
  bool _internal_has_phsbc() const;

  public:
  void clear_phsbc() ;
  const ::commonmodule::ReadingMMTN& phsbc() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTN* release_phsbc();
  ::commonmodule::ReadingMMTN* mutable_phsbc();
  void set_allocated_phsbc(::commonmodule::ReadingMMTN* phsbc);
  private:
  const ::commonmodule::ReadingMMTN& _internal_phsbc() const;
  ::commonmodule::ReadingMMTN* _internal_mutable_phsbc();
  public:
  void unsafe_arena_set_allocated_phsbc(
      ::commonmodule::ReadingMMTN* phsbc);
  ::commonmodule::ReadingMMTN* unsafe_arena_release_phsbc();
  // .commonmodule.ReadingMMTN phsC = 5;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::ReadingMMTN& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTN* release_phsc();
  ::commonmodule::ReadingMMTN* mutable_phsc();
  void set_allocated_phsc(::commonmodule::ReadingMMTN* phsc);
  private:
  const ::commonmodule::ReadingMMTN& _internal_phsc() const;
  ::commonmodule::ReadingMMTN* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::ReadingMMTN* phsc);
  ::commonmodule::ReadingMMTN* unsafe_arena_release_phsc();
  // .commonmodule.ReadingMMTN phsCA = 6;
  bool has_phsca() const;
  private:
  bool _internal_has_phsca() const;

  public:
  void clear_phsca() ;
  const ::commonmodule::ReadingMMTN& phsca() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTN* release_phsca();
  ::commonmodule::ReadingMMTN* mutable_phsca();
  void set_allocated_phsca(::commonmodule::ReadingMMTN* phsca);
  private:
  const ::commonmodule::ReadingMMTN& _internal_phsca() const;
  ::commonmodule::ReadingMMTN* _internal_mutable_phsca();
  public:
  void unsafe_arena_set_allocated_phsca(
      ::commonmodule::ReadingMMTN* phsca);
  ::commonmodule::ReadingMMTN* unsafe_arena_release_phsca();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseMMTN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ReadingMMTN* phsa_;
    ::commonmodule::ReadingMMTN* phsab_;
    ::commonmodule::ReadingMMTN* phsb_;
    ::commonmodule::ReadingMMTN* phsbc_;
    ::commonmodule::ReadingMMTN* phsc_;
    ::commonmodule::ReadingMMTN* phsca_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_RecloseActionKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_RecloseActionKind) */ {
 public:
  inline Optional_RecloseActionKind() : Optional_RecloseActionKind(nullptr) {}
  ~Optional_RecloseActionKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_RecloseActionKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_RecloseActionKind(const Optional_RecloseActionKind& from);
  Optional_RecloseActionKind(Optional_RecloseActionKind&& from) noexcept
    : Optional_RecloseActionKind() {
    *this = ::std::move(from);
  }

  inline Optional_RecloseActionKind& operator=(const Optional_RecloseActionKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_RecloseActionKind& operator=(Optional_RecloseActionKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_RecloseActionKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_RecloseActionKind* internal_default_instance() {
    return reinterpret_cast<const Optional_RecloseActionKind*>(
               &_Optional_RecloseActionKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(Optional_RecloseActionKind& a, Optional_RecloseActionKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_RecloseActionKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_RecloseActionKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_RecloseActionKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_RecloseActionKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_RecloseActionKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_RecloseActionKind& from) {
    Optional_RecloseActionKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_RecloseActionKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_RecloseActionKind";
  }
  protected:
  explicit Optional_RecloseActionKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.RecloseActionKind value = 1;
  void clear_value() ;
  ::commonmodule::RecloseActionKind value() const;
  void set_value(::commonmodule::RecloseActionKind value);

  private:
  ::commonmodule::RecloseActionKind _internal_value() const;
  void _internal_set_value(::commonmodule::RecloseActionKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_RecloseActionKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseRecloseAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseRecloseAction) */ {
 public:
  inline PhaseRecloseAction() : PhaseRecloseAction(nullptr) {}
  ~PhaseRecloseAction() override;
  explicit PROTOBUF_CONSTEXPR PhaseRecloseAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseRecloseAction(const PhaseRecloseAction& from);
  PhaseRecloseAction(PhaseRecloseAction&& from) noexcept
    : PhaseRecloseAction() {
    *this = ::std::move(from);
  }

  inline PhaseRecloseAction& operator=(const PhaseRecloseAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseRecloseAction& operator=(PhaseRecloseAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseRecloseAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseRecloseAction* internal_default_instance() {
    return reinterpret_cast<const PhaseRecloseAction*>(
               &_PhaseRecloseAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(PhaseRecloseAction& a, PhaseRecloseAction& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseRecloseAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseRecloseAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseRecloseAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseRecloseAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseRecloseAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseRecloseAction& from) {
    PhaseRecloseAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseRecloseAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseRecloseAction";
  }
  protected:
  explicit PhaseRecloseAction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.Optional_RecloseActionKind phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::Optional_RecloseActionKind& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_RecloseActionKind* release_phs3();
  ::commonmodule::Optional_RecloseActionKind* mutable_phs3();
  void set_allocated_phs3(::commonmodule::Optional_RecloseActionKind* phs3);
  private:
  const ::commonmodule::Optional_RecloseActionKind& _internal_phs3() const;
  ::commonmodule::Optional_RecloseActionKind* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::Optional_RecloseActionKind* phs3);
  ::commonmodule::Optional_RecloseActionKind* unsafe_arena_release_phs3();
  // .commonmodule.Optional_RecloseActionKind phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::Optional_RecloseActionKind& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_RecloseActionKind* release_phsa();
  ::commonmodule::Optional_RecloseActionKind* mutable_phsa();
  void set_allocated_phsa(::commonmodule::Optional_RecloseActionKind* phsa);
  private:
  const ::commonmodule::Optional_RecloseActionKind& _internal_phsa() const;
  ::commonmodule::Optional_RecloseActionKind* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::Optional_RecloseActionKind* phsa);
  ::commonmodule::Optional_RecloseActionKind* unsafe_arena_release_phsa();
  // .commonmodule.Optional_RecloseActionKind phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::Optional_RecloseActionKind& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_RecloseActionKind* release_phsb();
  ::commonmodule::Optional_RecloseActionKind* mutable_phsb();
  void set_allocated_phsb(::commonmodule::Optional_RecloseActionKind* phsb);
  private:
  const ::commonmodule::Optional_RecloseActionKind& _internal_phsb() const;
  ::commonmodule::Optional_RecloseActionKind* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::Optional_RecloseActionKind* phsb);
  ::commonmodule::Optional_RecloseActionKind* unsafe_arena_release_phsb();
  // .commonmodule.Optional_RecloseActionKind phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::Optional_RecloseActionKind& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_RecloseActionKind* release_phsc();
  ::commonmodule::Optional_RecloseActionKind* mutable_phsc();
  void set_allocated_phsc(::commonmodule::Optional_RecloseActionKind* phsc);
  private:
  const ::commonmodule::Optional_RecloseActionKind& _internal_phsc() const;
  ::commonmodule::Optional_RecloseActionKind* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::Optional_RecloseActionKind* phsc);
  ::commonmodule::Optional_RecloseActionKind* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseRecloseAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Optional_RecloseActionKind* phs3_;
    ::commonmodule::Optional_RecloseActionKind* phsa_;
    ::commonmodule::Optional_RecloseActionKind* phsb_;
    ::commonmodule::Optional_RecloseActionKind* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseSPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseSPC) */ {
 public:
  inline PhaseSPC() : PhaseSPC(nullptr) {}
  ~PhaseSPC() override;
  explicit PROTOBUF_CONSTEXPR PhaseSPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseSPC(const PhaseSPC& from);
  PhaseSPC(PhaseSPC&& from) noexcept
    : PhaseSPC() {
    *this = ::std::move(from);
  }

  inline PhaseSPC& operator=(const PhaseSPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseSPC& operator=(PhaseSPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseSPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseSPC* internal_default_instance() {
    return reinterpret_cast<const PhaseSPC*>(
               &_PhaseSPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(PhaseSPC& a, PhaseSPC& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseSPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseSPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseSPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseSPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseSPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseSPC& from) {
    PhaseSPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseSPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseSPC";
  }
  protected:
  explicit PhaseSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.ControlSPC phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::ControlSPC& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_phs3();
  ::commonmodule::ControlSPC* mutable_phs3();
  void set_allocated_phs3(::commonmodule::ControlSPC* phs3);
  private:
  const ::commonmodule::ControlSPC& _internal_phs3() const;
  ::commonmodule::ControlSPC* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::ControlSPC* phs3);
  ::commonmodule::ControlSPC* unsafe_arena_release_phs3();
  // .commonmodule.ControlSPC phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::ControlSPC& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_phsa();
  ::commonmodule::ControlSPC* mutable_phsa();
  void set_allocated_phsa(::commonmodule::ControlSPC* phsa);
  private:
  const ::commonmodule::ControlSPC& _internal_phsa() const;
  ::commonmodule::ControlSPC* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::ControlSPC* phsa);
  ::commonmodule::ControlSPC* unsafe_arena_release_phsa();
  // .commonmodule.ControlSPC phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::ControlSPC& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_phsb();
  ::commonmodule::ControlSPC* mutable_phsb();
  void set_allocated_phsb(::commonmodule::ControlSPC* phsb);
  private:
  const ::commonmodule::ControlSPC& _internal_phsb() const;
  ::commonmodule::ControlSPC* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::ControlSPC* phsb);
  ::commonmodule::ControlSPC* unsafe_arena_release_phsb();
  // .commonmodule.ControlSPC phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::ControlSPC& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_phsc();
  ::commonmodule::ControlSPC* mutable_phsc();
  void set_allocated_phsc(::commonmodule::ControlSPC* phsc);
  private:
  const ::commonmodule::ControlSPC& _internal_phsc() const;
  ::commonmodule::ControlSPC* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::ControlSPC* phsc);
  ::commonmodule::ControlSPC* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseSPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlSPC* phs3_;
    ::commonmodule::ControlSPC* phsa_;
    ::commonmodule::ControlSPC* phsb_;
    ::commonmodule::ControlSPC* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PhaseSPS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PhaseSPS) */ {
 public:
  inline PhaseSPS() : PhaseSPS(nullptr) {}
  ~PhaseSPS() override;
  explicit PROTOBUF_CONSTEXPR PhaseSPS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseSPS(const PhaseSPS& from);
  PhaseSPS(PhaseSPS&& from) noexcept
    : PhaseSPS() {
    *this = ::std::move(from);
  }

  inline PhaseSPS& operator=(const PhaseSPS& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseSPS& operator=(PhaseSPS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseSPS& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseSPS* internal_default_instance() {
    return reinterpret_cast<const PhaseSPS*>(
               &_PhaseSPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(PhaseSPS& a, PhaseSPS& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseSPS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseSPS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseSPS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseSPS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseSPS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseSPS& from) {
    PhaseSPS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseSPS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PhaseSPS";
  }
  protected:
  explicit PhaseSPS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhs3FieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.StatusSPS phs3 = 1;
  bool has_phs3() const;
  private:
  bool _internal_has_phs3() const;

  public:
  void clear_phs3() ;
  const ::commonmodule::StatusSPS& phs3() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_phs3();
  ::commonmodule::StatusSPS* mutable_phs3();
  void set_allocated_phs3(::commonmodule::StatusSPS* phs3);
  private:
  const ::commonmodule::StatusSPS& _internal_phs3() const;
  ::commonmodule::StatusSPS* _internal_mutable_phs3();
  public:
  void unsafe_arena_set_allocated_phs3(
      ::commonmodule::StatusSPS* phs3);
  ::commonmodule::StatusSPS* unsafe_arena_release_phs3();
  // .commonmodule.StatusSPS phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::StatusSPS& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_phsa();
  ::commonmodule::StatusSPS* mutable_phsa();
  void set_allocated_phsa(::commonmodule::StatusSPS* phsa);
  private:
  const ::commonmodule::StatusSPS& _internal_phsa() const;
  ::commonmodule::StatusSPS* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::StatusSPS* phsa);
  ::commonmodule::StatusSPS* unsafe_arena_release_phsa();
  // .commonmodule.StatusSPS phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::StatusSPS& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_phsb();
  ::commonmodule::StatusSPS* mutable_phsb();
  void set_allocated_phsb(::commonmodule::StatusSPS* phsb);
  private:
  const ::commonmodule::StatusSPS& _internal_phsb() const;
  ::commonmodule::StatusSPS* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::StatusSPS* phsb);
  ::commonmodule::StatusSPS* unsafe_arena_release_phsb();
  // .commonmodule.StatusSPS phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::StatusSPS& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_phsc();
  ::commonmodule::StatusSPS* mutable_phsc();
  void set_allocated_phsc(::commonmodule::StatusSPS* phsc);
  private:
  const ::commonmodule::StatusSPS& _internal_phsc() const;
  ::commonmodule::StatusSPS* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::StatusSPS* phsc);
  ::commonmodule::StatusSPS* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PhaseSPS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusSPS* phs3_;
    ::commonmodule::StatusSPS* phsa_;
    ::commonmodule::StatusSPS* phsb_;
    ::commonmodule::StatusSPS* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class PMG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.PMG) */ {
 public:
  inline PMG() : PMG(nullptr) {}
  ~PMG() override;
  explicit PROTOBUF_CONSTEXPR PMG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PMG(const PMG& from);
  PMG(PMG&& from) noexcept
    : PMG() {
    *this = ::std::move(from);
  }

  inline PMG& operator=(const PMG& from) {
    CopyFrom(from);
    return *this;
  }
  inline PMG& operator=(PMG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PMG& default_instance() {
    return *internal_default_instance();
  }
  static inline const PMG* internal_default_instance() {
    return reinterpret_cast<const PMG*>(
               &_PMG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(PMG& a, PMG& b) {
    a.Swap(&b);
  }
  inline void Swap(PMG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PMG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PMG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PMG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PMG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PMG& from) {
    PMG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PMG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.PMG";
  }
  protected:
  explicit PMG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
    kPhsAFieldNumber = 2,
    kPhsBFieldNumber = 3,
    kPhsCFieldNumber = 4,
  };
  // .commonmodule.MV net = 1;
  bool has_net() const;
  private:
  bool _internal_has_net() const;

  public:
  void clear_net() ;
  const ::commonmodule::MV& net() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_net();
  ::commonmodule::MV* mutable_net();
  void set_allocated_net(::commonmodule::MV* net);
  private:
  const ::commonmodule::MV& _internal_net() const;
  ::commonmodule::MV* _internal_mutable_net();
  public:
  void unsafe_arena_set_allocated_net(
      ::commonmodule::MV* net);
  ::commonmodule::MV* unsafe_arena_release_net();
  // .commonmodule.MV phsA = 2;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::MV& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_phsa();
  ::commonmodule::MV* mutable_phsa();
  void set_allocated_phsa(::commonmodule::MV* phsa);
  private:
  const ::commonmodule::MV& _internal_phsa() const;
  ::commonmodule::MV* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::MV* phsa);
  ::commonmodule::MV* unsafe_arena_release_phsa();
  // .commonmodule.MV phsB = 3;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::MV& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_phsb();
  ::commonmodule::MV* mutable_phsb();
  void set_allocated_phsb(::commonmodule::MV* phsb);
  private:
  const ::commonmodule::MV& _internal_phsb() const;
  ::commonmodule::MV* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::MV* phsb);
  ::commonmodule::MV* unsafe_arena_release_phsb();
  // .commonmodule.MV phsC = 4;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::MV& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_phsc();
  ::commonmodule::MV* mutable_phsc();
  void set_allocated_phsc(::commonmodule::MV* phsc);
  private:
  const ::commonmodule::MV& _internal_phsc() const;
  ::commonmodule::MV* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::MV* phsc);
  ::commonmodule::MV* unsafe_arena_release_phsc();
  // @@protoc_insertion_point(class_scope:commonmodule.PMG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::MV* net_;
    ::commonmodule::MV* phsa_;
    ::commonmodule::MV* phsb_;
    ::commonmodule::MV* phsc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class RampRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.RampRate) */ {
 public:
  inline RampRate() : RampRate(nullptr) {}
  ~RampRate() override;
  explicit PROTOBUF_CONSTEXPR RampRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RampRate(const RampRate& from);
  RampRate(RampRate&& from) noexcept
    : RampRate() {
    *this = ::std::move(from);
  }

  inline RampRate& operator=(const RampRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RampRate& operator=(RampRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RampRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RampRate* internal_default_instance() {
    return reinterpret_cast<const RampRate*>(
               &_RampRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(RampRate& a, RampRate& b) {
    a.Swap(&b);
  }
  inline void Swap(RampRate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RampRate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RampRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RampRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RampRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RampRate& from) {
    RampRate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RampRate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.RampRate";
  }
  protected:
  explicit RampRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNegativeReactivePowerKVArPerMinFieldNumber = 1,
    kNegativeRealPowerKWPerMinFieldNumber = 2,
    kPositiveReactivePowerKVArPerMinFieldNumber = 3,
    kPositiveRealPowerKWPerMinFieldNumber = 4,
  };
  // .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;
  bool has_negativereactivepowerkvarpermin() const;
  private:
  bool _internal_has_negativereactivepowerkvarpermin() const;

  public:
  void clear_negativereactivepowerkvarpermin() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& negativereactivepowerkvarpermin() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_negativereactivepowerkvarpermin();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_negativereactivepowerkvarpermin();
  void set_allocated_negativereactivepowerkvarpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* negativereactivepowerkvarpermin);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_negativereactivepowerkvarpermin() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_negativereactivepowerkvarpermin();
  public:
  void unsafe_arena_set_allocated_negativereactivepowerkvarpermin(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* negativereactivepowerkvarpermin);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_negativereactivepowerkvarpermin();
  // .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;
  bool has_negativerealpowerkwpermin() const;
  private:
  bool _internal_has_negativerealpowerkwpermin() const;

  public:
  void clear_negativerealpowerkwpermin() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& negativerealpowerkwpermin() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_negativerealpowerkwpermin();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_negativerealpowerkwpermin();
  void set_allocated_negativerealpowerkwpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* negativerealpowerkwpermin);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_negativerealpowerkwpermin() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_negativerealpowerkwpermin();
  public:
  void unsafe_arena_set_allocated_negativerealpowerkwpermin(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* negativerealpowerkwpermin);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_negativerealpowerkwpermin();
  // .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;
  bool has_positivereactivepowerkvarpermin() const;
  private:
  bool _internal_has_positivereactivepowerkvarpermin() const;

  public:
  void clear_positivereactivepowerkvarpermin() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& positivereactivepowerkvarpermin() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_positivereactivepowerkvarpermin();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_positivereactivepowerkvarpermin();
  void set_allocated_positivereactivepowerkvarpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* positivereactivepowerkvarpermin);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_positivereactivepowerkvarpermin() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_positivereactivepowerkvarpermin();
  public:
  void unsafe_arena_set_allocated_positivereactivepowerkvarpermin(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* positivereactivepowerkvarpermin);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_positivereactivepowerkvarpermin();
  // .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;
  bool has_positiverealpowerkwpermin() const;
  private:
  bool _internal_has_positiverealpowerkwpermin() const;

  public:
  void clear_positiverealpowerkwpermin() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& positiverealpowerkwpermin() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_positiverealpowerkwpermin();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_positiverealpowerkwpermin();
  void set_allocated_positiverealpowerkwpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* positiverealpowerkwpermin);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_positiverealpowerkwpermin() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_positiverealpowerkwpermin();
  public:
  void unsafe_arena_set_allocated_positiverealpowerkwpermin(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* positiverealpowerkwpermin);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_positiverealpowerkwpermin();
  // @@protoc_insertion_point(class_scope:commonmodule.RampRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::FloatValue* negativereactivepowerkvarpermin_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* negativerealpowerkwpermin_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* positivereactivepowerkvarpermin_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* positiverealpowerkwpermin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ReadingMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMessageInfo) */ {
 public:
  inline ReadingMessageInfo() : ReadingMessageInfo(nullptr) {}
  ~ReadingMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR ReadingMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadingMessageInfo(const ReadingMessageInfo& from);
  ReadingMessageInfo(ReadingMessageInfo&& from) noexcept
    : ReadingMessageInfo() {
    *this = ::std::move(from);
  }

  inline ReadingMessageInfo& operator=(const ReadingMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadingMessageInfo& operator=(ReadingMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadingMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadingMessageInfo* internal_default_instance() {
    return reinterpret_cast<const ReadingMessageInfo*>(
               &_ReadingMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(ReadingMessageInfo& a, ReadingMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadingMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadingMessageInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadingMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadingMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadingMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadingMessageInfo& from) {
    ReadingMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ReadingMessageInfo";
  }
  protected:
  explicit ReadingMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageInfoFieldNumber = 1,
  };
  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  private:
  bool _internal_has_messageinfo() const;

  public:
  void clear_messageinfo() ;
  const ::commonmodule::MessageInfo& messageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);
  private:
  const ::commonmodule::MessageInfo& _internal_messageinfo() const;
  ::commonmodule::MessageInfo* _internal_mutable_messageinfo();
  public:
  void unsafe_arena_set_allocated_messageinfo(
      ::commonmodule::MessageInfo* messageinfo);
  ::commonmodule::MessageInfo* unsafe_arena_release_messageinfo();
  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::MessageInfo* messageinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ReadingMMTR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMMTR) */ {
 public:
  inline ReadingMMTR() : ReadingMMTR(nullptr) {}
  ~ReadingMMTR() override;
  explicit PROTOBUF_CONSTEXPR ReadingMMTR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadingMMTR(const ReadingMMTR& from);
  ReadingMMTR(ReadingMMTR&& from) noexcept
    : ReadingMMTR() {
    *this = ::std::move(from);
  }

  inline ReadingMMTR& operator=(const ReadingMMTR& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadingMMTR& operator=(ReadingMMTR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadingMMTR& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadingMMTR* internal_default_instance() {
    return reinterpret_cast<const ReadingMMTR*>(
               &_ReadingMMTR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(ReadingMMTR& a, ReadingMMTR& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadingMMTR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadingMMTR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadingMMTR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadingMMTR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadingMMTR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadingMMTR& from) {
    ReadingMMTR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMMTR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ReadingMMTR";
  }
  protected:
  explicit ReadingMMTR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kDmdVAhFieldNumber = 2,
    kDmdVArhFieldNumber = 3,
    kDmdWhFieldNumber = 4,
    kSupVAhFieldNumber = 5,
    kSupVArhFieldNumber = 6,
    kSupWhFieldNumber = 7,
    kTotVAhFieldNumber = 8,
    kTotVArhFieldNumber = 9,
    kTotWhFieldNumber = 10,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.BCR DmdVAh = 2;
  bool has_dmdvah() const;
  private:
  bool _internal_has_dmdvah() const;

  public:
  void clear_dmdvah() ;
  const ::commonmodule::BCR& dmdvah() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_dmdvah();
  ::commonmodule::BCR* mutable_dmdvah();
  void set_allocated_dmdvah(::commonmodule::BCR* dmdvah);
  private:
  const ::commonmodule::BCR& _internal_dmdvah() const;
  ::commonmodule::BCR* _internal_mutable_dmdvah();
  public:
  void unsafe_arena_set_allocated_dmdvah(
      ::commonmodule::BCR* dmdvah);
  ::commonmodule::BCR* unsafe_arena_release_dmdvah();
  // .commonmodule.BCR DmdVArh = 3;
  bool has_dmdvarh() const;
  private:
  bool _internal_has_dmdvarh() const;

  public:
  void clear_dmdvarh() ;
  const ::commonmodule::BCR& dmdvarh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_dmdvarh();
  ::commonmodule::BCR* mutable_dmdvarh();
  void set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh);
  private:
  const ::commonmodule::BCR& _internal_dmdvarh() const;
  ::commonmodule::BCR* _internal_mutable_dmdvarh();
  public:
  void unsafe_arena_set_allocated_dmdvarh(
      ::commonmodule::BCR* dmdvarh);
  ::commonmodule::BCR* unsafe_arena_release_dmdvarh();
  // .commonmodule.BCR DmdWh = 4;
  bool has_dmdwh() const;
  private:
  bool _internal_has_dmdwh() const;

  public:
  void clear_dmdwh() ;
  const ::commonmodule::BCR& dmdwh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_dmdwh();
  ::commonmodule::BCR* mutable_dmdwh();
  void set_allocated_dmdwh(::commonmodule::BCR* dmdwh);
  private:
  const ::commonmodule::BCR& _internal_dmdwh() const;
  ::commonmodule::BCR* _internal_mutable_dmdwh();
  public:
  void unsafe_arena_set_allocated_dmdwh(
      ::commonmodule::BCR* dmdwh);
  ::commonmodule::BCR* unsafe_arena_release_dmdwh();
  // .commonmodule.BCR SupVAh = 5;
  bool has_supvah() const;
  private:
  bool _internal_has_supvah() const;

  public:
  void clear_supvah() ;
  const ::commonmodule::BCR& supvah() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_supvah();
  ::commonmodule::BCR* mutable_supvah();
  void set_allocated_supvah(::commonmodule::BCR* supvah);
  private:
  const ::commonmodule::BCR& _internal_supvah() const;
  ::commonmodule::BCR* _internal_mutable_supvah();
  public:
  void unsafe_arena_set_allocated_supvah(
      ::commonmodule::BCR* supvah);
  ::commonmodule::BCR* unsafe_arena_release_supvah();
  // .commonmodule.BCR SupVArh = 6;
  bool has_supvarh() const;
  private:
  bool _internal_has_supvarh() const;

  public:
  void clear_supvarh() ;
  const ::commonmodule::BCR& supvarh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_supvarh();
  ::commonmodule::BCR* mutable_supvarh();
  void set_allocated_supvarh(::commonmodule::BCR* supvarh);
  private:
  const ::commonmodule::BCR& _internal_supvarh() const;
  ::commonmodule::BCR* _internal_mutable_supvarh();
  public:
  void unsafe_arena_set_allocated_supvarh(
      ::commonmodule::BCR* supvarh);
  ::commonmodule::BCR* unsafe_arena_release_supvarh();
  // .commonmodule.BCR SupWh = 7;
  bool has_supwh() const;
  private:
  bool _internal_has_supwh() const;

  public:
  void clear_supwh() ;
  const ::commonmodule::BCR& supwh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_supwh();
  ::commonmodule::BCR* mutable_supwh();
  void set_allocated_supwh(::commonmodule::BCR* supwh);
  private:
  const ::commonmodule::BCR& _internal_supwh() const;
  ::commonmodule::BCR* _internal_mutable_supwh();
  public:
  void unsafe_arena_set_allocated_supwh(
      ::commonmodule::BCR* supwh);
  ::commonmodule::BCR* unsafe_arena_release_supwh();
  // .commonmodule.BCR TotVAh = 8;
  bool has_totvah() const;
  private:
  bool _internal_has_totvah() const;

  public:
  void clear_totvah() ;
  const ::commonmodule::BCR& totvah() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_totvah();
  ::commonmodule::BCR* mutable_totvah();
  void set_allocated_totvah(::commonmodule::BCR* totvah);
  private:
  const ::commonmodule::BCR& _internal_totvah() const;
  ::commonmodule::BCR* _internal_mutable_totvah();
  public:
  void unsafe_arena_set_allocated_totvah(
      ::commonmodule::BCR* totvah);
  ::commonmodule::BCR* unsafe_arena_release_totvah();
  // .commonmodule.BCR TotVArh = 9;
  bool has_totvarh() const;
  private:
  bool _internal_has_totvarh() const;

  public:
  void clear_totvarh() ;
  const ::commonmodule::BCR& totvarh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_totvarh();
  ::commonmodule::BCR* mutable_totvarh();
  void set_allocated_totvarh(::commonmodule::BCR* totvarh);
  private:
  const ::commonmodule::BCR& _internal_totvarh() const;
  ::commonmodule::BCR* _internal_mutable_totvarh();
  public:
  void unsafe_arena_set_allocated_totvarh(
      ::commonmodule::BCR* totvarh);
  ::commonmodule::BCR* unsafe_arena_release_totvarh();
  // .commonmodule.BCR TotWh = 10;
  bool has_totwh() const;
  private:
  bool _internal_has_totwh() const;

  public:
  void clear_totwh() ;
  const ::commonmodule::BCR& totwh() const;
  PROTOBUF_NODISCARD ::commonmodule::BCR* release_totwh();
  ::commonmodule::BCR* mutable_totwh();
  void set_allocated_totwh(::commonmodule::BCR* totwh);
  private:
  const ::commonmodule::BCR& _internal_totwh() const;
  ::commonmodule::BCR* _internal_mutable_totwh();
  public:
  void unsafe_arena_set_allocated_totwh(
      ::commonmodule::BCR* totwh);
  ::commonmodule::BCR* unsafe_arena_release_totwh();
  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMMTR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::BCR* dmdvah_;
    ::commonmodule::BCR* dmdvarh_;
    ::commonmodule::BCR* dmdwh_;
    ::commonmodule::BCR* supvah_;
    ::commonmodule::BCR* supvarh_;
    ::commonmodule::BCR* supwh_;
    ::commonmodule::BCR* totvah_;
    ::commonmodule::BCR* totvarh_;
    ::commonmodule::BCR* totwh_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class WYE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.WYE) */ {
 public:
  inline WYE() : WYE(nullptr) {}
  ~WYE() override;
  explicit PROTOBUF_CONSTEXPR WYE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WYE(const WYE& from);
  WYE(WYE&& from) noexcept
    : WYE() {
    *this = ::std::move(from);
  }

  inline WYE& operator=(const WYE& from) {
    CopyFrom(from);
    return *this;
  }
  inline WYE& operator=(WYE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WYE& default_instance() {
    return *internal_default_instance();
  }
  static inline const WYE* internal_default_instance() {
    return reinterpret_cast<const WYE*>(
               &_WYE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(WYE& a, WYE& b) {
    a.Swap(&b);
  }
  inline void Swap(WYE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WYE* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WYE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WYE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WYE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WYE& from) {
    WYE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WYE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.WYE";
  }
  protected:
  explicit WYE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
    kNeutFieldNumber = 2,
    kPhsAFieldNumber = 3,
    kPhsBFieldNumber = 4,
    kPhsCFieldNumber = 5,
    kResFieldNumber = 6,
  };
  // .commonmodule.CMV net = 1;
  bool has_net() const;
  private:
  bool _internal_has_net() const;

  public:
  void clear_net() ;
  const ::commonmodule::CMV& net() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_net();
  ::commonmodule::CMV* mutable_net();
  void set_allocated_net(::commonmodule::CMV* net);
  private:
  const ::commonmodule::CMV& _internal_net() const;
  ::commonmodule::CMV* _internal_mutable_net();
  public:
  void unsafe_arena_set_allocated_net(
      ::commonmodule::CMV* net);
  ::commonmodule::CMV* unsafe_arena_release_net();
  // .commonmodule.CMV neut = 2;
  bool has_neut() const;
  private:
  bool _internal_has_neut() const;

  public:
  void clear_neut() ;
  const ::commonmodule::CMV& neut() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_neut();
  ::commonmodule::CMV* mutable_neut();
  void set_allocated_neut(::commonmodule::CMV* neut);
  private:
  const ::commonmodule::CMV& _internal_neut() const;
  ::commonmodule::CMV* _internal_mutable_neut();
  public:
  void unsafe_arena_set_allocated_neut(
      ::commonmodule::CMV* neut);
  ::commonmodule::CMV* unsafe_arena_release_neut();
  // .commonmodule.CMV phsA = 3;
  bool has_phsa() const;
  private:
  bool _internal_has_phsa() const;

  public:
  void clear_phsa() ;
  const ::commonmodule::CMV& phsa() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_phsa();
  ::commonmodule::CMV* mutable_phsa();
  void set_allocated_phsa(::commonmodule::CMV* phsa);
  private:
  const ::commonmodule::CMV& _internal_phsa() const;
  ::commonmodule::CMV* _internal_mutable_phsa();
  public:
  void unsafe_arena_set_allocated_phsa(
      ::commonmodule::CMV* phsa);
  ::commonmodule::CMV* unsafe_arena_release_phsa();
  // .commonmodule.CMV phsB = 4;
  bool has_phsb() const;
  private:
  bool _internal_has_phsb() const;

  public:
  void clear_phsb() ;
  const ::commonmodule::CMV& phsb() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_phsb();
  ::commonmodule::CMV* mutable_phsb();
  void set_allocated_phsb(::commonmodule::CMV* phsb);
  private:
  const ::commonmodule::CMV& _internal_phsb() const;
  ::commonmodule::CMV* _internal_mutable_phsb();
  public:
  void unsafe_arena_set_allocated_phsb(
      ::commonmodule::CMV* phsb);
  ::commonmodule::CMV* unsafe_arena_release_phsb();
  // .commonmodule.CMV phsC = 5;
  bool has_phsc() const;
  private:
  bool _internal_has_phsc() const;

  public:
  void clear_phsc() ;
  const ::commonmodule::CMV& phsc() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_phsc();
  ::commonmodule::CMV* mutable_phsc();
  void set_allocated_phsc(::commonmodule::CMV* phsc);
  private:
  const ::commonmodule::CMV& _internal_phsc() const;
  ::commonmodule::CMV* _internal_mutable_phsc();
  public:
  void unsafe_arena_set_allocated_phsc(
      ::commonmodule::CMV* phsc);
  ::commonmodule::CMV* unsafe_arena_release_phsc();
  // .commonmodule.CMV res = 6;
  bool has_res() const;
  private:
  bool _internal_has_res() const;

  public:
  void clear_res() ;
  const ::commonmodule::CMV& res() const;
  PROTOBUF_NODISCARD ::commonmodule::CMV* release_res();
  ::commonmodule::CMV* mutable_res();
  void set_allocated_res(::commonmodule::CMV* res);
  private:
  const ::commonmodule::CMV& _internal_res() const;
  ::commonmodule::CMV* _internal_mutable_res();
  public:
  void unsafe_arena_set_allocated_res(
      ::commonmodule::CMV* res);
  ::commonmodule::CMV* unsafe_arena_release_res();
  // @@protoc_insertion_point(class_scope:commonmodule.WYE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::CMV* net_;
    ::commonmodule::CMV* neut_;
    ::commonmodule::CMV* phsa_;
    ::commonmodule::CMV* phsb_;
    ::commonmodule::CMV* phsc_;
    ::commonmodule::CMV* res_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class ReadingMMXU final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.ReadingMMXU) */ {
 public:
  inline ReadingMMXU() : ReadingMMXU(nullptr) {}
  ~ReadingMMXU() override;
  explicit PROTOBUF_CONSTEXPR ReadingMMXU(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadingMMXU(const ReadingMMXU& from);
  ReadingMMXU(ReadingMMXU&& from) noexcept
    : ReadingMMXU() {
    *this = ::std::move(from);
  }

  inline ReadingMMXU& operator=(const ReadingMMXU& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadingMMXU& operator=(ReadingMMXU&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadingMMXU& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadingMMXU* internal_default_instance() {
    return reinterpret_cast<const ReadingMMXU*>(
               &_ReadingMMXU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(ReadingMMXU& a, ReadingMMXU& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadingMMXU* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadingMMXU* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadingMMXU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadingMMXU>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadingMMXU& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadingMMXU& from) {
    ReadingMMXU::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadingMMXU* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.ReadingMMXU";
  }
  protected:
  explicit ReadingMMXU(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kAFieldNumber = 2,
    kClcMthFieldNumber = 3,
    kHzFieldNumber = 4,
    kPFFieldNumber = 5,
    kPFSignFieldNumber = 6,
    kPhVFieldNumber = 7,
    kPPVFieldNumber = 8,
    kVAFieldNumber = 9,
    kVArFieldNumber = 10,
    kWFieldNumber = 11,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.WYE A = 2;
  bool has_a() const;
  private:
  bool _internal_has_a() const;

  public:
  void clear_a() ;
  const ::commonmodule::WYE& a() const;
  PROTOBUF_NODISCARD ::commonmodule::WYE* release_a();
  ::commonmodule::WYE* mutable_a();
  void set_allocated_a(::commonmodule::WYE* a);
  private:
  const ::commonmodule::WYE& _internal_a() const;
  ::commonmodule::WYE* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::commonmodule::WYE* a);
  ::commonmodule::WYE* unsafe_arena_release_a();
  // .commonmodule.ENG_CalcMethodKind ClcMth = 3;
  bool has_clcmth() const;
  private:
  bool _internal_has_clcmth() const;

  public:
  void clear_clcmth() ;
  const ::commonmodule::ENG_CalcMethodKind& clcmth() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_CalcMethodKind* release_clcmth();
  ::commonmodule::ENG_CalcMethodKind* mutable_clcmth();
  void set_allocated_clcmth(::commonmodule::ENG_CalcMethodKind* clcmth);
  private:
  const ::commonmodule::ENG_CalcMethodKind& _internal_clcmth() const;
  ::commonmodule::ENG_CalcMethodKind* _internal_mutable_clcmth();
  public:
  void unsafe_arena_set_allocated_clcmth(
      ::commonmodule::ENG_CalcMethodKind* clcmth);
  ::commonmodule::ENG_CalcMethodKind* unsafe_arena_release_clcmth();
  // .commonmodule.MV Hz = 4;
  bool has_hz() const;
  private:
  bool _internal_has_hz() const;

  public:
  void clear_hz() ;
  const ::commonmodule::MV& hz() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_hz();
  ::commonmodule::MV* mutable_hz();
  void set_allocated_hz(::commonmodule::MV* hz);
  private:
  const ::commonmodule::MV& _internal_hz() const;
  ::commonmodule::MV* _internal_mutable_hz();
  public:
  void unsafe_arena_set_allocated_hz(
      ::commonmodule::MV* hz);
  ::commonmodule::MV* unsafe_arena_release_hz();
  // .commonmodule.WYE PF = 5;
  bool has_pf() const;
  private:
  bool _internal_has_pf() const;

  public:
  void clear_pf() ;
  const ::commonmodule::WYE& pf() const;
  PROTOBUF_NODISCARD ::commonmodule::WYE* release_pf();
  ::commonmodule::WYE* mutable_pf();
  void set_allocated_pf(::commonmodule::WYE* pf);
  private:
  const ::commonmodule::WYE& _internal_pf() const;
  ::commonmodule::WYE* _internal_mutable_pf();
  public:
  void unsafe_arena_set_allocated_pf(
      ::commonmodule::WYE* pf);
  ::commonmodule::WYE* unsafe_arena_release_pf();
  // .commonmodule.ENG_PFSignKind PFSign = 6;
  bool has_pfsign() const;
  private:
  bool _internal_has_pfsign() const;

  public:
  void clear_pfsign() ;
  const ::commonmodule::ENG_PFSignKind& pfsign() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_PFSignKind* release_pfsign();
  ::commonmodule::ENG_PFSignKind* mutable_pfsign();
  void set_allocated_pfsign(::commonmodule::ENG_PFSignKind* pfsign);
  private:
  const ::commonmodule::ENG_PFSignKind& _internal_pfsign() const;
  ::commonmodule::ENG_PFSignKind* _internal_mutable_pfsign();
  public:
  void unsafe_arena_set_allocated_pfsign(
      ::commonmodule::ENG_PFSignKind* pfsign);
  ::commonmodule::ENG_PFSignKind* unsafe_arena_release_pfsign();
  // .commonmodule.WYE PhV = 7;
  bool has_phv() const;
  private:
  bool _internal_has_phv() const;

  public:
  void clear_phv() ;
  const ::commonmodule::WYE& phv() const;
  PROTOBUF_NODISCARD ::commonmodule::WYE* release_phv();
  ::commonmodule::WYE* mutable_phv();
  void set_allocated_phv(::commonmodule::WYE* phv);
  private:
  const ::commonmodule::WYE& _internal_phv() const;
  ::commonmodule::WYE* _internal_mutable_phv();
  public:
  void unsafe_arena_set_allocated_phv(
      ::commonmodule::WYE* phv);
  ::commonmodule::WYE* unsafe_arena_release_phv();
  // .commonmodule.DEL PPV = 8;
  bool has_ppv() const;
  private:
  bool _internal_has_ppv() const;

  public:
  void clear_ppv() ;
  const ::commonmodule::DEL& ppv() const;
  PROTOBUF_NODISCARD ::commonmodule::DEL* release_ppv();
  ::commonmodule::DEL* mutable_ppv();
  void set_allocated_ppv(::commonmodule::DEL* ppv);
  private:
  const ::commonmodule::DEL& _internal_ppv() const;
  ::commonmodule::DEL* _internal_mutable_ppv();
  public:
  void unsafe_arena_set_allocated_ppv(
      ::commonmodule::DEL* ppv);
  ::commonmodule::DEL* unsafe_arena_release_ppv();
  // .commonmodule.WYE VA = 9;
  bool has_va() const;
  private:
  bool _internal_has_va() const;

  public:
  void clear_va() ;
  const ::commonmodule::WYE& va() const;
  PROTOBUF_NODISCARD ::commonmodule::WYE* release_va();
  ::commonmodule::WYE* mutable_va();
  void set_allocated_va(::commonmodule::WYE* va);
  private:
  const ::commonmodule::WYE& _internal_va() const;
  ::commonmodule::WYE* _internal_mutable_va();
  public:
  void unsafe_arena_set_allocated_va(
      ::commonmodule::WYE* va);
  ::commonmodule::WYE* unsafe_arena_release_va();
  // .commonmodule.WYE VAr = 10;
  bool has_var() const;
  private:
  bool _internal_has_var() const;

  public:
  void clear_var() ;
  const ::commonmodule::WYE& var() const;
  PROTOBUF_NODISCARD ::commonmodule::WYE* release_var();
  ::commonmodule::WYE* mutable_var();
  void set_allocated_var(::commonmodule::WYE* var);
  private:
  const ::commonmodule::WYE& _internal_var() const;
  ::commonmodule::WYE* _internal_mutable_var();
  public:
  void unsafe_arena_set_allocated_var(
      ::commonmodule::WYE* var);
  ::commonmodule::WYE* unsafe_arena_release_var();
  // .commonmodule.WYE W = 11;
  bool has_w() const;
  private:
  bool _internal_has_w() const;

  public:
  void clear_w() ;
  const ::commonmodule::WYE& w() const;
  PROTOBUF_NODISCARD ::commonmodule::WYE* release_w();
  ::commonmodule::WYE* mutable_w();
  void set_allocated_w(::commonmodule::WYE* w);
  private:
  const ::commonmodule::WYE& _internal_w() const;
  ::commonmodule::WYE* _internal_mutable_w();
  public:
  void unsafe_arena_set_allocated_w(
      ::commonmodule::WYE* w);
  ::commonmodule::WYE* unsafe_arena_release_w();
  // @@protoc_insertion_point(class_scope:commonmodule.ReadingMMXU)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::WYE* a_;
    ::commonmodule::ENG_CalcMethodKind* clcmth_;
    ::commonmodule::MV* hz_;
    ::commonmodule::WYE* pf_;
    ::commonmodule::ENG_PFSignKind* pfsign_;
    ::commonmodule::WYE* phv_;
    ::commonmodule::DEL* ppv_;
    ::commonmodule::WYE* va_;
    ::commonmodule::WYE* var_;
    ::commonmodule::WYE* w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class SourceCapabilityConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.SourceCapabilityConfiguration) */ {
 public:
  inline SourceCapabilityConfiguration() : SourceCapabilityConfiguration(nullptr) {}
  ~SourceCapabilityConfiguration() override;
  explicit PROTOBUF_CONSTEXPR SourceCapabilityConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceCapabilityConfiguration(const SourceCapabilityConfiguration& from);
  SourceCapabilityConfiguration(SourceCapabilityConfiguration&& from) noexcept
    : SourceCapabilityConfiguration() {
    *this = ::std::move(from);
  }

  inline SourceCapabilityConfiguration& operator=(const SourceCapabilityConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceCapabilityConfiguration& operator=(SourceCapabilityConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceCapabilityConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceCapabilityConfiguration* internal_default_instance() {
    return reinterpret_cast<const SourceCapabilityConfiguration*>(
               &_SourceCapabilityConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(SourceCapabilityConfiguration& a, SourceCapabilityConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceCapabilityConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceCapabilityConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceCapabilityConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceCapabilityConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceCapabilityConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SourceCapabilityConfiguration& from) {
    SourceCapabilityConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceCapabilityConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.SourceCapabilityConfiguration";
  }
  protected:
  explicit SourceCapabilityConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kAMaxFieldNumber = 2,
    kVAMaxFieldNumber = 3,
    kVarMaxAbsFieldNumber = 4,
    kVarMaxInjFieldNumber = 5,
    kVMaxFieldNumber = 6,
    kVMinFieldNumber = 7,
    kVNomFieldNumber = 8,
    kWMaxFieldNumber = 9,
    kWOvrExtFieldNumber = 10,
    kWOvrExtPFFieldNumber = 11,
    kWUndExtFieldNumber = 12,
    kWUndExtPFFieldNumber = 13,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.ASG AMax = 2;
  bool has_amax() const;
  private:
  bool _internal_has_amax() const;

  public:
  void clear_amax() ;
  const ::commonmodule::ASG& amax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_amax();
  ::commonmodule::ASG* mutable_amax();
  void set_allocated_amax(::commonmodule::ASG* amax);
  private:
  const ::commonmodule::ASG& _internal_amax() const;
  ::commonmodule::ASG* _internal_mutable_amax();
  public:
  void unsafe_arena_set_allocated_amax(
      ::commonmodule::ASG* amax);
  ::commonmodule::ASG* unsafe_arena_release_amax();
  // .commonmodule.ASG VAMax = 3;
  bool has_vamax() const;
  private:
  bool _internal_has_vamax() const;

  public:
  void clear_vamax() ;
  const ::commonmodule::ASG& vamax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vamax();
  ::commonmodule::ASG* mutable_vamax();
  void set_allocated_vamax(::commonmodule::ASG* vamax);
  private:
  const ::commonmodule::ASG& _internal_vamax() const;
  ::commonmodule::ASG* _internal_mutable_vamax();
  public:
  void unsafe_arena_set_allocated_vamax(
      ::commonmodule::ASG* vamax);
  ::commonmodule::ASG* unsafe_arena_release_vamax();
  // .commonmodule.ASG VarMaxAbs = 4;
  bool has_varmaxabs() const;
  private:
  bool _internal_has_varmaxabs() const;

  public:
  void clear_varmaxabs() ;
  const ::commonmodule::ASG& varmaxabs() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_varmaxabs();
  ::commonmodule::ASG* mutable_varmaxabs();
  void set_allocated_varmaxabs(::commonmodule::ASG* varmaxabs);
  private:
  const ::commonmodule::ASG& _internal_varmaxabs() const;
  ::commonmodule::ASG* _internal_mutable_varmaxabs();
  public:
  void unsafe_arena_set_allocated_varmaxabs(
      ::commonmodule::ASG* varmaxabs);
  ::commonmodule::ASG* unsafe_arena_release_varmaxabs();
  // .commonmodule.ASG VarMaxInj = 5;
  bool has_varmaxinj() const;
  private:
  bool _internal_has_varmaxinj() const;

  public:
  void clear_varmaxinj() ;
  const ::commonmodule::ASG& varmaxinj() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_varmaxinj();
  ::commonmodule::ASG* mutable_varmaxinj();
  void set_allocated_varmaxinj(::commonmodule::ASG* varmaxinj);
  private:
  const ::commonmodule::ASG& _internal_varmaxinj() const;
  ::commonmodule::ASG* _internal_mutable_varmaxinj();
  public:
  void unsafe_arena_set_allocated_varmaxinj(
      ::commonmodule::ASG* varmaxinj);
  ::commonmodule::ASG* unsafe_arena_release_varmaxinj();
  // .commonmodule.ASG VMax = 6;
  bool has_vmax() const;
  private:
  bool _internal_has_vmax() const;

  public:
  void clear_vmax() ;
  const ::commonmodule::ASG& vmax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vmax();
  ::commonmodule::ASG* mutable_vmax();
  void set_allocated_vmax(::commonmodule::ASG* vmax);
  private:
  const ::commonmodule::ASG& _internal_vmax() const;
  ::commonmodule::ASG* _internal_mutable_vmax();
  public:
  void unsafe_arena_set_allocated_vmax(
      ::commonmodule::ASG* vmax);
  ::commonmodule::ASG* unsafe_arena_release_vmax();
  // .commonmodule.ASG VMin = 7;
  bool has_vmin() const;
  private:
  bool _internal_has_vmin() const;

  public:
  void clear_vmin() ;
  const ::commonmodule::ASG& vmin() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vmin();
  ::commonmodule::ASG* mutable_vmin();
  void set_allocated_vmin(::commonmodule::ASG* vmin);
  private:
  const ::commonmodule::ASG& _internal_vmin() const;
  ::commonmodule::ASG* _internal_mutable_vmin();
  public:
  void unsafe_arena_set_allocated_vmin(
      ::commonmodule::ASG* vmin);
  ::commonmodule::ASG* unsafe_arena_release_vmin();
  // .commonmodule.ASG VNom = 8;
  bool has_vnom() const;
  private:
  bool _internal_has_vnom() const;

  public:
  void clear_vnom() ;
  const ::commonmodule::ASG& vnom() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vnom();
  ::commonmodule::ASG* mutable_vnom();
  void set_allocated_vnom(::commonmodule::ASG* vnom);
  private:
  const ::commonmodule::ASG& _internal_vnom() const;
  ::commonmodule::ASG* _internal_mutable_vnom();
  public:
  void unsafe_arena_set_allocated_vnom(
      ::commonmodule::ASG* vnom);
  ::commonmodule::ASG* unsafe_arena_release_vnom();
  // .commonmodule.ASG WMax = 9;
  bool has_wmax() const;
  private:
  bool _internal_has_wmax() const;

  public:
  void clear_wmax() ;
  const ::commonmodule::ASG& wmax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wmax();
  ::commonmodule::ASG* mutable_wmax();
  void set_allocated_wmax(::commonmodule::ASG* wmax);
  private:
  const ::commonmodule::ASG& _internal_wmax() const;
  ::commonmodule::ASG* _internal_mutable_wmax();
  public:
  void unsafe_arena_set_allocated_wmax(
      ::commonmodule::ASG* wmax);
  ::commonmodule::ASG* unsafe_arena_release_wmax();
  // .commonmodule.ASG WOvrExt = 10;
  bool has_wovrext() const;
  private:
  bool _internal_has_wovrext() const;

  public:
  void clear_wovrext() ;
  const ::commonmodule::ASG& wovrext() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wovrext();
  ::commonmodule::ASG* mutable_wovrext();
  void set_allocated_wovrext(::commonmodule::ASG* wovrext);
  private:
  const ::commonmodule::ASG& _internal_wovrext() const;
  ::commonmodule::ASG* _internal_mutable_wovrext();
  public:
  void unsafe_arena_set_allocated_wovrext(
      ::commonmodule::ASG* wovrext);
  ::commonmodule::ASG* unsafe_arena_release_wovrext();
  // .commonmodule.ASG WOvrExtPF = 11;
  bool has_wovrextpf() const;
  private:
  bool _internal_has_wovrextpf() const;

  public:
  void clear_wovrextpf() ;
  const ::commonmodule::ASG& wovrextpf() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wovrextpf();
  ::commonmodule::ASG* mutable_wovrextpf();
  void set_allocated_wovrextpf(::commonmodule::ASG* wovrextpf);
  private:
  const ::commonmodule::ASG& _internal_wovrextpf() const;
  ::commonmodule::ASG* _internal_mutable_wovrextpf();
  public:
  void unsafe_arena_set_allocated_wovrextpf(
      ::commonmodule::ASG* wovrextpf);
  ::commonmodule::ASG* unsafe_arena_release_wovrextpf();
  // .commonmodule.ASG WUndExt = 12;
  bool has_wundext() const;
  private:
  bool _internal_has_wundext() const;

  public:
  void clear_wundext() ;
  const ::commonmodule::ASG& wundext() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wundext();
  ::commonmodule::ASG* mutable_wundext();
  void set_allocated_wundext(::commonmodule::ASG* wundext);
  private:
  const ::commonmodule::ASG& _internal_wundext() const;
  ::commonmodule::ASG* _internal_mutable_wundext();
  public:
  void unsafe_arena_set_allocated_wundext(
      ::commonmodule::ASG* wundext);
  ::commonmodule::ASG* unsafe_arena_release_wundext();
  // .commonmodule.ASG WUndExtPF = 13;
  bool has_wundextpf() const;
  private:
  bool _internal_has_wundextpf() const;

  public:
  void clear_wundextpf() ;
  const ::commonmodule::ASG& wundextpf() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wundextpf();
  ::commonmodule::ASG* mutable_wundextpf();
  void set_allocated_wundextpf(::commonmodule::ASG* wundextpf);
  private:
  const ::commonmodule::ASG& _internal_wundextpf() const;
  ::commonmodule::ASG* _internal_mutable_wundextpf();
  public:
  void unsafe_arena_set_allocated_wundextpf(
      ::commonmodule::ASG* wundextpf);
  ::commonmodule::ASG* unsafe_arena_release_wundextpf();
  // @@protoc_insertion_point(class_scope:commonmodule.SourceCapabilityConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::ASG* amax_;
    ::commonmodule::ASG* vamax_;
    ::commonmodule::ASG* varmaxabs_;
    ::commonmodule::ASG* varmaxinj_;
    ::commonmodule::ASG* vmax_;
    ::commonmodule::ASG* vmin_;
    ::commonmodule::ASG* vnom_;
    ::commonmodule::ASG* wmax_;
    ::commonmodule::ASG* wovrext_;
    ::commonmodule::ASG* wovrextpf_;
    ::commonmodule::ASG* wundext_;
    ::commonmodule::ASG* wundextpf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_NorOpCatKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_NorOpCatKind) */ {
 public:
  inline Optional_NorOpCatKind() : Optional_NorOpCatKind(nullptr) {}
  ~Optional_NorOpCatKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_NorOpCatKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_NorOpCatKind(const Optional_NorOpCatKind& from);
  Optional_NorOpCatKind(Optional_NorOpCatKind&& from) noexcept
    : Optional_NorOpCatKind() {
    *this = ::std::move(from);
  }

  inline Optional_NorOpCatKind& operator=(const Optional_NorOpCatKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_NorOpCatKind& operator=(Optional_NorOpCatKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_NorOpCatKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_NorOpCatKind* internal_default_instance() {
    return reinterpret_cast<const Optional_NorOpCatKind*>(
               &_Optional_NorOpCatKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(Optional_NorOpCatKind& a, Optional_NorOpCatKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_NorOpCatKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_NorOpCatKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_NorOpCatKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_NorOpCatKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_NorOpCatKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_NorOpCatKind& from) {
    Optional_NorOpCatKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_NorOpCatKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_NorOpCatKind";
  }
  protected:
  explicit Optional_NorOpCatKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.NorOpCatKind value = 1;
  void clear_value() ;
  ::commonmodule::NorOpCatKind value() const;
  void set_value(::commonmodule::NorOpCatKind value);

  private:
  ::commonmodule::NorOpCatKind _internal_value() const;
  void _internal_set_value(::commonmodule::NorOpCatKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_NorOpCatKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_AbnOpCatKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_AbnOpCatKind) */ {
 public:
  inline Optional_AbnOpCatKind() : Optional_AbnOpCatKind(nullptr) {}
  ~Optional_AbnOpCatKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_AbnOpCatKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_AbnOpCatKind(const Optional_AbnOpCatKind& from);
  Optional_AbnOpCatKind(Optional_AbnOpCatKind&& from) noexcept
    : Optional_AbnOpCatKind() {
    *this = ::std::move(from);
  }

  inline Optional_AbnOpCatKind& operator=(const Optional_AbnOpCatKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_AbnOpCatKind& operator=(Optional_AbnOpCatKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_AbnOpCatKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_AbnOpCatKind* internal_default_instance() {
    return reinterpret_cast<const Optional_AbnOpCatKind*>(
               &_Optional_AbnOpCatKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(Optional_AbnOpCatKind& a, Optional_AbnOpCatKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_AbnOpCatKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_AbnOpCatKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_AbnOpCatKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_AbnOpCatKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_AbnOpCatKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_AbnOpCatKind& from) {
    Optional_AbnOpCatKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_AbnOpCatKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_AbnOpCatKind";
  }
  protected:
  explicit Optional_AbnOpCatKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.AbnOpCatKind value = 1;
  void clear_value() ;
  ::commonmodule::AbnOpCatKind value() const;
  void set_value(::commonmodule::AbnOpCatKind value);

  private:
  ::commonmodule::AbnOpCatKind _internal_value() const;
  void _internal_set_value(::commonmodule::AbnOpCatKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_AbnOpCatKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class SourceCapabilityRatings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.SourceCapabilityRatings) */ {
 public:
  inline SourceCapabilityRatings() : SourceCapabilityRatings(nullptr) {}
  ~SourceCapabilityRatings() override;
  explicit PROTOBUF_CONSTEXPR SourceCapabilityRatings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceCapabilityRatings(const SourceCapabilityRatings& from);
  SourceCapabilityRatings(SourceCapabilityRatings&& from) noexcept
    : SourceCapabilityRatings() {
    *this = ::std::move(from);
  }

  inline SourceCapabilityRatings& operator=(const SourceCapabilityRatings& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceCapabilityRatings& operator=(SourceCapabilityRatings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceCapabilityRatings& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceCapabilityRatings* internal_default_instance() {
    return reinterpret_cast<const SourceCapabilityRatings*>(
               &_SourceCapabilityRatings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(SourceCapabilityRatings& a, SourceCapabilityRatings& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceCapabilityRatings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceCapabilityRatings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceCapabilityRatings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceCapabilityRatings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceCapabilityRatings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SourceCapabilityRatings& from) {
    SourceCapabilityRatings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceCapabilityRatings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.SourceCapabilityRatings";
  }
  protected:
  explicit SourceCapabilityRatings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kAMaxRtgFieldNumber = 3,
    kFreqNomRtgFieldNumber = 4,
    kReactSusceptRtgFieldNumber = 6,
    kVAMaxRtgFieldNumber = 7,
    kVarMaxAbsRtgFieldNumber = 8,
    kVarMaxInjRtgFieldNumber = 9,
    kVMaxRtgFieldNumber = 10,
    kVMinRtgFieldNumber = 11,
    kVNomRtgFieldNumber = 12,
    kWMaxRtgFieldNumber = 13,
    kWOvrExtRtgFieldNumber = 14,
    kWOvrExtRtgPFFieldNumber = 15,
    kWUndExtRtgFieldNumber = 16,
    kWUndExtRtgPFFieldNumber = 17,
    kAbnOpCatRtgFieldNumber = 2,
    kNorOpCatRtgFieldNumber = 5,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.ASG AMaxRtg = 3;
  bool has_amaxrtg() const;
  private:
  bool _internal_has_amaxrtg() const;

  public:
  void clear_amaxrtg() ;
  const ::commonmodule::ASG& amaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_amaxrtg();
  ::commonmodule::ASG* mutable_amaxrtg();
  void set_allocated_amaxrtg(::commonmodule::ASG* amaxrtg);
  private:
  const ::commonmodule::ASG& _internal_amaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_amaxrtg();
  public:
  void unsafe_arena_set_allocated_amaxrtg(
      ::commonmodule::ASG* amaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_amaxrtg();
  // .commonmodule.ASG FreqNomRtg = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_freqnomrtg() const;
  private:
  bool _internal_has_freqnomrtg() const;

  public:
  void clear_freqnomrtg() ;
  const ::commonmodule::ASG& freqnomrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_freqnomrtg();
  ::commonmodule::ASG* mutable_freqnomrtg();
  void set_allocated_freqnomrtg(::commonmodule::ASG* freqnomrtg);
  private:
  const ::commonmodule::ASG& _internal_freqnomrtg() const;
  ::commonmodule::ASG* _internal_mutable_freqnomrtg();
  public:
  void unsafe_arena_set_allocated_freqnomrtg(
      ::commonmodule::ASG* freqnomrtg);
  ::commonmodule::ASG* unsafe_arena_release_freqnomrtg();
  // .commonmodule.ASG ReactSusceptRtg = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_reactsusceptrtg() const;
  private:
  bool _internal_has_reactsusceptrtg() const;

  public:
  void clear_reactsusceptrtg() ;
  const ::commonmodule::ASG& reactsusceptrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_reactsusceptrtg();
  ::commonmodule::ASG* mutable_reactsusceptrtg();
  void set_allocated_reactsusceptrtg(::commonmodule::ASG* reactsusceptrtg);
  private:
  const ::commonmodule::ASG& _internal_reactsusceptrtg() const;
  ::commonmodule::ASG* _internal_mutable_reactsusceptrtg();
  public:
  void unsafe_arena_set_allocated_reactsusceptrtg(
      ::commonmodule::ASG* reactsusceptrtg);
  ::commonmodule::ASG* unsafe_arena_release_reactsusceptrtg();
  // .commonmodule.ASG VAMaxRtg = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vamaxrtg() const;
  private:
  bool _internal_has_vamaxrtg() const;

  public:
  void clear_vamaxrtg() ;
  const ::commonmodule::ASG& vamaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vamaxrtg();
  ::commonmodule::ASG* mutable_vamaxrtg();
  void set_allocated_vamaxrtg(::commonmodule::ASG* vamaxrtg);
  private:
  const ::commonmodule::ASG& _internal_vamaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_vamaxrtg();
  public:
  void unsafe_arena_set_allocated_vamaxrtg(
      ::commonmodule::ASG* vamaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_vamaxrtg();
  // .commonmodule.ASG VarMaxAbsRtg = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_varmaxabsrtg() const;
  private:
  bool _internal_has_varmaxabsrtg() const;

  public:
  void clear_varmaxabsrtg() ;
  const ::commonmodule::ASG& varmaxabsrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_varmaxabsrtg();
  ::commonmodule::ASG* mutable_varmaxabsrtg();
  void set_allocated_varmaxabsrtg(::commonmodule::ASG* varmaxabsrtg);
  private:
  const ::commonmodule::ASG& _internal_varmaxabsrtg() const;
  ::commonmodule::ASG* _internal_mutable_varmaxabsrtg();
  public:
  void unsafe_arena_set_allocated_varmaxabsrtg(
      ::commonmodule::ASG* varmaxabsrtg);
  ::commonmodule::ASG* unsafe_arena_release_varmaxabsrtg();
  // .commonmodule.ASG VarMaxInjRtg = 9 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_varmaxinjrtg() const;
  private:
  bool _internal_has_varmaxinjrtg() const;

  public:
  void clear_varmaxinjrtg() ;
  const ::commonmodule::ASG& varmaxinjrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_varmaxinjrtg();
  ::commonmodule::ASG* mutable_varmaxinjrtg();
  void set_allocated_varmaxinjrtg(::commonmodule::ASG* varmaxinjrtg);
  private:
  const ::commonmodule::ASG& _internal_varmaxinjrtg() const;
  ::commonmodule::ASG* _internal_mutable_varmaxinjrtg();
  public:
  void unsafe_arena_set_allocated_varmaxinjrtg(
      ::commonmodule::ASG* varmaxinjrtg);
  ::commonmodule::ASG* unsafe_arena_release_varmaxinjrtg();
  // .commonmodule.ASG VMaxRtg = 10 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vmaxrtg() const;
  private:
  bool _internal_has_vmaxrtg() const;

  public:
  void clear_vmaxrtg() ;
  const ::commonmodule::ASG& vmaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vmaxrtg();
  ::commonmodule::ASG* mutable_vmaxrtg();
  void set_allocated_vmaxrtg(::commonmodule::ASG* vmaxrtg);
  private:
  const ::commonmodule::ASG& _internal_vmaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_vmaxrtg();
  public:
  void unsafe_arena_set_allocated_vmaxrtg(
      ::commonmodule::ASG* vmaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_vmaxrtg();
  // .commonmodule.ASG VMinRtg = 11 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vminrtg() const;
  private:
  bool _internal_has_vminrtg() const;

  public:
  void clear_vminrtg() ;
  const ::commonmodule::ASG& vminrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vminrtg();
  ::commonmodule::ASG* mutable_vminrtg();
  void set_allocated_vminrtg(::commonmodule::ASG* vminrtg);
  private:
  const ::commonmodule::ASG& _internal_vminrtg() const;
  ::commonmodule::ASG* _internal_mutable_vminrtg();
  public:
  void unsafe_arena_set_allocated_vminrtg(
      ::commonmodule::ASG* vminrtg);
  ::commonmodule::ASG* unsafe_arena_release_vminrtg();
  // .commonmodule.ASG VNomRtg = 12 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vnomrtg() const;
  private:
  bool _internal_has_vnomrtg() const;

  public:
  void clear_vnomrtg() ;
  const ::commonmodule::ASG& vnomrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vnomrtg();
  ::commonmodule::ASG* mutable_vnomrtg();
  void set_allocated_vnomrtg(::commonmodule::ASG* vnomrtg);
  private:
  const ::commonmodule::ASG& _internal_vnomrtg() const;
  ::commonmodule::ASG* _internal_mutable_vnomrtg();
  public:
  void unsafe_arena_set_allocated_vnomrtg(
      ::commonmodule::ASG* vnomrtg);
  ::commonmodule::ASG* unsafe_arena_release_vnomrtg();
  // .commonmodule.ASG WMaxRtg = 13 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wmaxrtg() const;
  private:
  bool _internal_has_wmaxrtg() const;

  public:
  void clear_wmaxrtg() ;
  const ::commonmodule::ASG& wmaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wmaxrtg();
  ::commonmodule::ASG* mutable_wmaxrtg();
  void set_allocated_wmaxrtg(::commonmodule::ASG* wmaxrtg);
  private:
  const ::commonmodule::ASG& _internal_wmaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_wmaxrtg();
  public:
  void unsafe_arena_set_allocated_wmaxrtg(
      ::commonmodule::ASG* wmaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_wmaxrtg();
  // .commonmodule.ASG WOvrExtRtg = 14 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wovrextrtg() const;
  private:
  bool _internal_has_wovrextrtg() const;

  public:
  void clear_wovrextrtg() ;
  const ::commonmodule::ASG& wovrextrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wovrextrtg();
  ::commonmodule::ASG* mutable_wovrextrtg();
  void set_allocated_wovrextrtg(::commonmodule::ASG* wovrextrtg);
  private:
  const ::commonmodule::ASG& _internal_wovrextrtg() const;
  ::commonmodule::ASG* _internal_mutable_wovrextrtg();
  public:
  void unsafe_arena_set_allocated_wovrextrtg(
      ::commonmodule::ASG* wovrextrtg);
  ::commonmodule::ASG* unsafe_arena_release_wovrextrtg();
  // .commonmodule.ASG WOvrExtRtgPF = 15 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wovrextrtgpf() const;
  private:
  bool _internal_has_wovrextrtgpf() const;

  public:
  void clear_wovrextrtgpf() ;
  const ::commonmodule::ASG& wovrextrtgpf() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wovrextrtgpf();
  ::commonmodule::ASG* mutable_wovrextrtgpf();
  void set_allocated_wovrextrtgpf(::commonmodule::ASG* wovrextrtgpf);
  private:
  const ::commonmodule::ASG& _internal_wovrextrtgpf() const;
  ::commonmodule::ASG* _internal_mutable_wovrextrtgpf();
  public:
  void unsafe_arena_set_allocated_wovrextrtgpf(
      ::commonmodule::ASG* wovrextrtgpf);
  ::commonmodule::ASG* unsafe_arena_release_wovrextrtgpf();
  // .commonmodule.ASG WUndExtRtg = 16 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wundextrtg() const;
  private:
  bool _internal_has_wundextrtg() const;

  public:
  void clear_wundextrtg() ;
  const ::commonmodule::ASG& wundextrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wundextrtg();
  ::commonmodule::ASG* mutable_wundextrtg();
  void set_allocated_wundextrtg(::commonmodule::ASG* wundextrtg);
  private:
  const ::commonmodule::ASG& _internal_wundextrtg() const;
  ::commonmodule::ASG* _internal_mutable_wundextrtg();
  public:
  void unsafe_arena_set_allocated_wundextrtg(
      ::commonmodule::ASG* wundextrtg);
  ::commonmodule::ASG* unsafe_arena_release_wundextrtg();
  // .commonmodule.ASG WUndExtRtgPF = 17 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wundextrtgpf() const;
  private:
  bool _internal_has_wundextrtgpf() const;

  public:
  void clear_wundextrtgpf() ;
  const ::commonmodule::ASG& wundextrtgpf() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wundextrtgpf();
  ::commonmodule::ASG* mutable_wundextrtgpf();
  void set_allocated_wundextrtgpf(::commonmodule::ASG* wundextrtgpf);
  private:
  const ::commonmodule::ASG& _internal_wundextrtgpf() const;
  ::commonmodule::ASG* _internal_mutable_wundextrtgpf();
  public:
  void unsafe_arena_set_allocated_wundextrtgpf(
      ::commonmodule::ASG* wundextrtgpf);
  ::commonmodule::ASG* unsafe_arena_release_wundextrtgpf();
  // .commonmodule.AbnOpCatKind AbnOpCatRtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_abnopcatrtg() ;
  ::commonmodule::AbnOpCatKind abnopcatrtg() const;
  void set_abnopcatrtg(::commonmodule::AbnOpCatKind value);

  private:
  ::commonmodule::AbnOpCatKind _internal_abnopcatrtg() const;
  void _internal_set_abnopcatrtg(::commonmodule::AbnOpCatKind value);

  public:
  // .commonmodule.NorOpCatKind NorOpCatRtg = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_noropcatrtg() ;
  ::commonmodule::NorOpCatKind noropcatrtg() const;
  void set_noropcatrtg(::commonmodule::NorOpCatKind value);

  private:
  ::commonmodule::NorOpCatKind _internal_noropcatrtg() const;
  void _internal_set_noropcatrtg(::commonmodule::NorOpCatKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.SourceCapabilityRatings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::ASG* amaxrtg_;
    ::commonmodule::ASG* freqnomrtg_;
    ::commonmodule::ASG* reactsusceptrtg_;
    ::commonmodule::ASG* vamaxrtg_;
    ::commonmodule::ASG* varmaxabsrtg_;
    ::commonmodule::ASG* varmaxinjrtg_;
    ::commonmodule::ASG* vmaxrtg_;
    ::commonmodule::ASG* vminrtg_;
    ::commonmodule::ASG* vnomrtg_;
    ::commonmodule::ASG* wmaxrtg_;
    ::commonmodule::ASG* wovrextrtg_;
    ::commonmodule::ASG* wovrextrtgpf_;
    ::commonmodule::ASG* wundextrtg_;
    ::commonmodule::ASG* wundextrtgpf_;
    int abnopcatrtg_;
    int noropcatrtg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusAndEventXCBR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusAndEventXCBR) */ {
 public:
  inline StatusAndEventXCBR() : StatusAndEventXCBR(nullptr) {}
  ~StatusAndEventXCBR() override;
  explicit PROTOBUF_CONSTEXPR StatusAndEventXCBR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusAndEventXCBR(const StatusAndEventXCBR& from);
  StatusAndEventXCBR(StatusAndEventXCBR&& from) noexcept
    : StatusAndEventXCBR() {
    *this = ::std::move(from);
  }

  inline StatusAndEventXCBR& operator=(const StatusAndEventXCBR& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusAndEventXCBR& operator=(StatusAndEventXCBR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusAndEventXCBR& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusAndEventXCBR* internal_default_instance() {
    return reinterpret_cast<const StatusAndEventXCBR*>(
               &_StatusAndEventXCBR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(StatusAndEventXCBR& a, StatusAndEventXCBR& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusAndEventXCBR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusAndEventXCBR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusAndEventXCBR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusAndEventXCBR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusAndEventXCBR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusAndEventXCBR& from) {
    StatusAndEventXCBR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusAndEventXCBR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusAndEventXCBR";
  }
  protected:
  explicit StatusAndEventXCBR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kDynamicTestFieldNumber = 2,
    kPosFieldNumber = 3,
    kProtectionPickupFieldNumber = 4,
    kProtectionModeFieldNumber = 5,
    kRecloseEnabledFieldNumber = 6,
    kReclosingActionFieldNumber = 7,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  private:
  bool _internal_has_dynamictest() const;

  public:
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);
  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* _internal_mutable_dynamictest();
  public:
  void unsafe_arena_set_allocated_dynamictest(
      ::commonmodule::ENS_DynamicTestKind* dynamictest);
  ::commonmodule::ENS_DynamicTestKind* unsafe_arena_release_dynamictest();
  // .commonmodule.PhaseDPS Pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;

  public:
  void clear_pos() ;
  const ::commonmodule::PhaseDPS& pos() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseDPS* release_pos();
  ::commonmodule::PhaseDPS* mutable_pos();
  void set_allocated_pos(::commonmodule::PhaseDPS* pos);
  private:
  const ::commonmodule::PhaseDPS& _internal_pos() const;
  ::commonmodule::PhaseDPS* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::commonmodule::PhaseDPS* pos);
  ::commonmodule::PhaseDPS* unsafe_arena_release_pos();
  // .commonmodule.ACD ProtectionPickup = 4;
  bool has_protectionpickup() const;
  private:
  bool _internal_has_protectionpickup() const;

  public:
  void clear_protectionpickup() ;
  const ::commonmodule::ACD& protectionpickup() const;
  PROTOBUF_NODISCARD ::commonmodule::ACD* release_protectionpickup();
  ::commonmodule::ACD* mutable_protectionpickup();
  void set_allocated_protectionpickup(::commonmodule::ACD* protectionpickup);
  private:
  const ::commonmodule::ACD& _internal_protectionpickup() const;
  ::commonmodule::ACD* _internal_mutable_protectionpickup();
  public:
  void unsafe_arena_set_allocated_protectionpickup(
      ::commonmodule::ACD* protectionpickup);
  ::commonmodule::ACD* unsafe_arena_release_protectionpickup();
  // .commonmodule.StatusINS ProtectionMode = 5;
  bool has_protectionmode() const;
  private:
  bool _internal_has_protectionmode() const;

  public:
  void clear_protectionmode() ;
  const ::commonmodule::StatusINS& protectionmode() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusINS* release_protectionmode();
  ::commonmodule::StatusINS* mutable_protectionmode();
  void set_allocated_protectionmode(::commonmodule::StatusINS* protectionmode);
  private:
  const ::commonmodule::StatusINS& _internal_protectionmode() const;
  ::commonmodule::StatusINS* _internal_mutable_protectionmode();
  public:
  void unsafe_arena_set_allocated_protectionmode(
      ::commonmodule::StatusINS* protectionmode);
  ::commonmodule::StatusINS* unsafe_arena_release_protectionmode();
  // .commonmodule.PhaseSPS RecloseEnabled = 6;
  bool has_recloseenabled() const;
  private:
  bool _internal_has_recloseenabled() const;

  public:
  void clear_recloseenabled() ;
  const ::commonmodule::PhaseSPS& recloseenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_recloseenabled();
  ::commonmodule::PhaseSPS* mutable_recloseenabled();
  void set_allocated_recloseenabled(::commonmodule::PhaseSPS* recloseenabled);
  private:
  const ::commonmodule::PhaseSPS& _internal_recloseenabled() const;
  ::commonmodule::PhaseSPS* _internal_mutable_recloseenabled();
  public:
  void unsafe_arena_set_allocated_recloseenabled(
      ::commonmodule::PhaseSPS* recloseenabled);
  ::commonmodule::PhaseSPS* unsafe_arena_release_recloseenabled();
  // .commonmodule.PhaseRecloseAction ReclosingAction = 7;
  bool has_reclosingaction() const;
  private:
  bool _internal_has_reclosingaction() const;

  public:
  void clear_reclosingaction() ;
  const ::commonmodule::PhaseRecloseAction& reclosingaction() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseRecloseAction* release_reclosingaction();
  ::commonmodule::PhaseRecloseAction* mutable_reclosingaction();
  void set_allocated_reclosingaction(::commonmodule::PhaseRecloseAction* reclosingaction);
  private:
  const ::commonmodule::PhaseRecloseAction& _internal_reclosingaction() const;
  ::commonmodule::PhaseRecloseAction* _internal_mutable_reclosingaction();
  public:
  void unsafe_arena_set_allocated_reclosingaction(
      ::commonmodule::PhaseRecloseAction* reclosingaction);
  ::commonmodule::PhaseRecloseAction* unsafe_arena_release_reclosingaction();
  // @@protoc_insertion_point(class_scope:commonmodule.StatusAndEventXCBR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::ENS_DynamicTestKind* dynamictest_;
    ::commonmodule::PhaseDPS* pos_;
    ::commonmodule::ACD* protectionpickup_;
    ::commonmodule::StatusINS* protectionmode_;
    ::commonmodule::PhaseSPS* recloseenabled_;
    ::commonmodule::PhaseRecloseAction* reclosingaction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusINC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusINC) */ {
 public:
  inline StatusINC() : StatusINC(nullptr) {}
  ~StatusINC() override;
  explicit PROTOBUF_CONSTEXPR StatusINC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusINC(const StatusINC& from);
  StatusINC(StatusINC&& from) noexcept
    : StatusINC() {
    *this = ::std::move(from);
  }

  inline StatusINC& operator=(const StatusINC& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusINC& operator=(StatusINC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusINC& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusINC* internal_default_instance() {
    return reinterpret_cast<const StatusINC*>(
               &_StatusINC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(StatusINC& a, StatusINC& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusINC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusINC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusINC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusINC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusINC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusINC& from) {
    StatusINC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusINC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusINC";
  }
  protected:
  explicit StatusINC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::int32_t stval() const;
  void set_stval(::int32_t value);

  private:
  ::int32_t _internal_stval() const;
  void _internal_set_stval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.StatusINC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    ::int32_t stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusISC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusISC) */ {
 public:
  inline StatusISC() : StatusISC(nullptr) {}
  ~StatusISC() override;
  explicit PROTOBUF_CONSTEXPR StatusISC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusISC(const StatusISC& from);
  StatusISC(StatusISC&& from) noexcept
    : StatusISC() {
    *this = ::std::move(from);
  }

  inline StatusISC& operator=(const StatusISC& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusISC& operator=(StatusISC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusISC& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusISC* internal_default_instance() {
    return reinterpret_cast<const StatusISC*>(
               &_StatusISC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(StatusISC& a, StatusISC& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusISC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusISC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusISC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusISC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusISC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusISC& from) {
    StatusISC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusISC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusISC";
  }
  protected:
  explicit StatusISC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::int32_t stval() const;
  void set_stval(::int32_t value);

  private:
  ::int32_t _internal_stval() const;
  void _internal_set_stval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.StatusISC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    ::int32_t stval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusMessageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusMessageInfo) */ {
 public:
  inline StatusMessageInfo() : StatusMessageInfo(nullptr) {}
  ~StatusMessageInfo() override;
  explicit PROTOBUF_CONSTEXPR StatusMessageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusMessageInfo(const StatusMessageInfo& from);
  StatusMessageInfo(StatusMessageInfo&& from) noexcept
    : StatusMessageInfo() {
    *this = ::std::move(from);
  }

  inline StatusMessageInfo& operator=(const StatusMessageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusMessageInfo& operator=(StatusMessageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusMessageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusMessageInfo* internal_default_instance() {
    return reinterpret_cast<const StatusMessageInfo*>(
               &_StatusMessageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(StatusMessageInfo& a, StatusMessageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusMessageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusMessageInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusMessageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusMessageInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusMessageInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusMessageInfo& from) {
    StatusMessageInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusMessageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusMessageInfo";
  }
  protected:
  explicit StatusMessageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageInfoFieldNumber = 1,
  };
  // .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_messageinfo() const;
  private:
  bool _internal_has_messageinfo() const;

  public:
  void clear_messageinfo() ;
  const ::commonmodule::MessageInfo& messageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::MessageInfo* release_messageinfo();
  ::commonmodule::MessageInfo* mutable_messageinfo();
  void set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo);
  private:
  const ::commonmodule::MessageInfo& _internal_messageinfo() const;
  ::commonmodule::MessageInfo* _internal_mutable_messageinfo();
  public:
  void unsafe_arena_set_allocated_messageinfo(
      ::commonmodule::MessageInfo* messageinfo);
  ::commonmodule::MessageInfo* unsafe_arena_release_messageinfo();
  // @@protoc_insertion_point(class_scope:commonmodule.StatusMessageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::MessageInfo* messageinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StatusValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StatusValue) */ {
 public:
  inline StatusValue() : StatusValue(nullptr) {}
  ~StatusValue() override;
  explicit PROTOBUF_CONSTEXPR StatusValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusValue(const StatusValue& from);
  StatusValue(StatusValue&& from) noexcept
    : StatusValue() {
    *this = ::std::move(from);
  }

  inline StatusValue& operator=(const StatusValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusValue& operator=(StatusValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusValue* internal_default_instance() {
    return reinterpret_cast<const StatusValue*>(
               &_StatusValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(StatusValue& a, StatusValue& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusValue& from) {
    StatusValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StatusValue";
  }
  protected:
  explicit StatusValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kModBlkFieldNumber = 2,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .google.protobuf.BoolValue modBlk = 2;
  bool has_modblk() const;
  private:
  bool _internal_has_modblk() const;

  public:
  void clear_modblk() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& modblk() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_modblk();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_modblk();
  void set_allocated_modblk(::PROTOBUF_NAMESPACE_ID::BoolValue* modblk);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_modblk() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_modblk();
  public:
  void unsafe_arena_set_allocated_modblk(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_modblk();
  // @@protoc_insertion_point(class_scope:commonmodule.StatusValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class VSS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.VSS) */ {
 public:
  inline VSS() : VSS(nullptr) {}
  ~VSS() override;
  explicit PROTOBUF_CONSTEXPR VSS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VSS(const VSS& from);
  VSS(VSS&& from) noexcept
    : VSS() {
    *this = ::std::move(from);
  }

  inline VSS& operator=(const VSS& from) {
    CopyFrom(from);
    return *this;
  }
  inline VSS& operator=(VSS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VSS& default_instance() {
    return *internal_default_instance();
  }
  static inline const VSS* internal_default_instance() {
    return reinterpret_cast<const VSS*>(
               &_VSS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(VSS& a, VSS& b) {
    a.Swap(&b);
  }
  inline void Swap(VSS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VSS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VSS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VSS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VSS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VSS& from) {
    VSS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.VSS";
  }
  protected:
  explicit VSS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStValFieldNumber = 2,
    kQFieldNumber = 1,
    kTFieldNumber = 3,
  };
  // string stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  const std::string& stval() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stval(Arg_&& arg, Args_... args);
  std::string* mutable_stval();
  PROTOBUF_NODISCARD std::string* release_stval();
  void set_allocated_stval(std::string* ptr);

  private:
  const std::string& _internal_stval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stval(
      const std::string& value);
  std::string* _internal_mutable_stval();

  public:
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;

  public:
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  PROTOBUF_NODISCARD ::commonmodule::Quality* release_q();
  ::commonmodule::Quality* mutable_q();
  void set_allocated_q(::commonmodule::Quality* q);
  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::commonmodule::Quality* q);
  ::commonmodule::Quality* unsafe_arena_release_q();
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  private:
  bool _internal_has_t() const;

  public:
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_t();
  ::commonmodule::Timestamp* mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* t);
  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::commonmodule::Timestamp* t);
  ::commonmodule::Timestamp* unsafe_arena_release_t();
  // @@protoc_insertion_point(class_scope:commonmodule.VSS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stval_;
    ::commonmodule::Quality* q_;
    ::commonmodule::Timestamp* t_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class StringEventAndStatusGGIO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.StringEventAndStatusGGIO) */ {
 public:
  inline StringEventAndStatusGGIO() : StringEventAndStatusGGIO(nullptr) {}
  ~StringEventAndStatusGGIO() override;
  explicit PROTOBUF_CONSTEXPR StringEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringEventAndStatusGGIO(const StringEventAndStatusGGIO& from);
  StringEventAndStatusGGIO(StringEventAndStatusGGIO&& from) noexcept
    : StringEventAndStatusGGIO() {
    *this = ::std::move(from);
  }

  inline StringEventAndStatusGGIO& operator=(const StringEventAndStatusGGIO& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringEventAndStatusGGIO& operator=(StringEventAndStatusGGIO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringEventAndStatusGGIO& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringEventAndStatusGGIO* internal_default_instance() {
    return reinterpret_cast<const StringEventAndStatusGGIO*>(
               &_StringEventAndStatusGGIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(StringEventAndStatusGGIO& a, StringEventAndStatusGGIO& b) {
    a.Swap(&b);
  }
  inline void Swap(StringEventAndStatusGGIO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringEventAndStatusGGIO* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringEventAndStatusGGIO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringEventAndStatusGGIO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringEventAndStatusGGIO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringEventAndStatusGGIO& from) {
    StringEventAndStatusGGIO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringEventAndStatusGGIO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.StringEventAndStatusGGIO";
  }
  protected:
  explicit StringEventAndStatusGGIO(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kStrInFieldNumber = 3,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  private:
  bool _internal_has_logicalnode() const;

  public:
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNode* release_logicalnode();
  ::commonmodule::LogicalNode* mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode);
  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* _internal_mutable_logicalnode();
  public:
  void unsafe_arena_set_allocated_logicalnode(
      ::commonmodule::LogicalNode* logicalnode);
  ::commonmodule::LogicalNode* unsafe_arena_release_logicalnode();
  // .commonmodule.Optional_PhaseCodeKind Phase = 2;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;

  public:
  void clear_phase() ;
  const ::commonmodule::Optional_PhaseCodeKind& phase() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_PhaseCodeKind* release_phase();
  ::commonmodule::Optional_PhaseCodeKind* mutable_phase();
  void set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase);
  private:
  const ::commonmodule::Optional_PhaseCodeKind& _internal_phase() const;
  ::commonmodule::Optional_PhaseCodeKind* _internal_mutable_phase();
  public:
  void unsafe_arena_set_allocated_phase(
      ::commonmodule::Optional_PhaseCodeKind* phase);
  ::commonmodule::Optional_PhaseCodeKind* unsafe_arena_release_phase();
  // .commonmodule.VSS StrIn = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_strin() const;
  private:
  bool _internal_has_strin() const;

  public:
  void clear_strin() ;
  const ::commonmodule::VSS& strin() const;
  PROTOBUF_NODISCARD ::commonmodule::VSS* release_strin();
  ::commonmodule::VSS* mutable_strin();
  void set_allocated_strin(::commonmodule::VSS* strin);
  private:
  const ::commonmodule::VSS& _internal_strin() const;
  ::commonmodule::VSS* _internal_mutable_strin();
  public:
  void unsafe_arena_set_allocated_strin(
      ::commonmodule::VSS* strin);
  ::commonmodule::VSS* unsafe_arena_release_strin();
  // @@protoc_insertion_point(class_scope:commonmodule.StringEventAndStatusGGIO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNode* logicalnode_;
    ::commonmodule::Optional_PhaseCodeKind* phase_;
    ::commonmodule::VSS* strin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.SwitchPoint) */ {
 public:
  inline SwitchPoint() : SwitchPoint(nullptr) {}
  ~SwitchPoint() override;
  explicit PROTOBUF_CONSTEXPR SwitchPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchPoint(const SwitchPoint& from);
  SwitchPoint(SwitchPoint&& from) noexcept
    : SwitchPoint() {
    *this = ::std::move(from);
  }

  inline SwitchPoint& operator=(const SwitchPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchPoint& operator=(SwitchPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchPoint* internal_default_instance() {
    return reinterpret_cast<const SwitchPoint*>(
               &_SwitchPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(SwitchPoint& a, SwitchPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchPoint& from) {
    SwitchPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.SwitchPoint";
  }
  protected:
  explicit SwitchPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kStartTimeFieldNumber = 2,
  };
  // .commonmodule.ControlDPC Pos = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;

  public:
  void clear_pos() ;
  const ::commonmodule::ControlDPC& pos() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlDPC* release_pos();
  ::commonmodule::ControlDPC* mutable_pos();
  void set_allocated_pos(::commonmodule::ControlDPC* pos);
  private:
  const ::commonmodule::ControlDPC& _internal_pos() const;
  ::commonmodule::ControlDPC* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::commonmodule::ControlDPC* pos);
  ::commonmodule::ControlDPC* unsafe_arena_release_pos();
  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;

  public:
  void clear_starttime() ;
  const ::commonmodule::ControlTimestamp& starttime() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);
  private:
  const ::commonmodule::ControlTimestamp& _internal_starttime() const;
  ::commonmodule::ControlTimestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::commonmodule::ControlTimestamp* starttime);
  ::commonmodule::ControlTimestamp* unsafe_arena_release_starttime();
  // @@protoc_insertion_point(class_scope:commonmodule.SwitchPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlDPC* pos_;
    ::commonmodule::ControlTimestamp* starttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class SwitchCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.SwitchCSG) */ {
 public:
  inline SwitchCSG() : SwitchCSG(nullptr) {}
  ~SwitchCSG() override;
  explicit PROTOBUF_CONSTEXPR SwitchCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwitchCSG(const SwitchCSG& from);
  SwitchCSG(SwitchCSG&& from) noexcept
    : SwitchCSG() {
    *this = ::std::move(from);
  }

  inline SwitchCSG& operator=(const SwitchCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchCSG& operator=(SwitchCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwitchCSG* internal_default_instance() {
    return reinterpret_cast<const SwitchCSG*>(
               &_SwitchCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(SwitchCSG& a, SwitchCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwitchCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwitchCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwitchCSG& from) {
    SwitchCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.SwitchCSG";
  }
  protected:
  explicit SwitchCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .commonmodule.SwitchPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::commonmodule::SwitchPoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SwitchPoint >*
      mutable_crvpts();
  private:
  const ::commonmodule::SwitchPoint& _internal_crvpts(int index) const;
  ::commonmodule::SwitchPoint* _internal_add_crvpts();
  public:
  const ::commonmodule::SwitchPoint& crvpts(int index) const;
  ::commonmodule::SwitchPoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SwitchPoint >&
      crvpts() const;
  // @@protoc_insertion_point(class_scope:commonmodule.SwitchCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SwitchPoint > crvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class TmHzPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.TmHzPoint) */ {
 public:
  inline TmHzPoint() : TmHzPoint(nullptr) {}
  ~TmHzPoint() override;
  explicit PROTOBUF_CONSTEXPR TmHzPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TmHzPoint(const TmHzPoint& from);
  TmHzPoint(TmHzPoint&& from) noexcept
    : TmHzPoint() {
    *this = ::std::move(from);
  }

  inline TmHzPoint& operator=(const TmHzPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TmHzPoint& operator=(TmHzPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TmHzPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TmHzPoint* internal_default_instance() {
    return reinterpret_cast<const TmHzPoint*>(
               &_TmHzPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(TmHzPoint& a, TmHzPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TmHzPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TmHzPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TmHzPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TmHzPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TmHzPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TmHzPoint& from) {
    TmHzPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TmHzPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.TmHzPoint";
  }
  protected:
  explicit TmHzPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTmValFieldNumber = 2,
    kHzValFieldNumber = 1,
  };
  // .commonmodule.ClearingTime tmVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_tmval() const;
  private:
  bool _internal_has_tmval() const;

  public:
  void clear_tmval() ;
  const ::commonmodule::ClearingTime& tmval() const;
  PROTOBUF_NODISCARD ::commonmodule::ClearingTime* release_tmval();
  ::commonmodule::ClearingTime* mutable_tmval();
  void set_allocated_tmval(::commonmodule::ClearingTime* tmval);
  private:
  const ::commonmodule::ClearingTime& _internal_tmval() const;
  ::commonmodule::ClearingTime* _internal_mutable_tmval();
  public:
  void unsafe_arena_set_allocated_tmval(
      ::commonmodule::ClearingTime* tmval);
  ::commonmodule::ClearingTime* unsafe_arena_release_tmval();
  // float hzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_hzval() ;
  float hzval() const;
  void set_hzval(float value);

  private:
  float _internal_hzval() const;
  void _internal_set_hzval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.TmHzPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ClearingTime* tmval_;
    float hzval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class TmHzCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.TmHzCSG) */ {
 public:
  inline TmHzCSG() : TmHzCSG(nullptr) {}
  ~TmHzCSG() override;
  explicit PROTOBUF_CONSTEXPR TmHzCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TmHzCSG(const TmHzCSG& from);
  TmHzCSG(TmHzCSG&& from) noexcept
    : TmHzCSG() {
    *this = ::std::move(from);
  }

  inline TmHzCSG& operator=(const TmHzCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline TmHzCSG& operator=(TmHzCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TmHzCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const TmHzCSG* internal_default_instance() {
    return reinterpret_cast<const TmHzCSG*>(
               &_TmHzCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(TmHzCSG& a, TmHzCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(TmHzCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TmHzCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TmHzCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TmHzCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TmHzCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TmHzCSG& from) {
    TmHzCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TmHzCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.TmHzCSG";
  }
  protected:
  explicit TmHzCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverCrvPtsFieldNumber = 1,
    kUnderCrvPtsFieldNumber = 2,
  };
  // repeated .commonmodule.TmHzPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int overcrvpts_size() const;
  private:
  int _internal_overcrvpts_size() const;

  public:
  void clear_overcrvpts() ;
  ::commonmodule::TmHzPoint* mutable_overcrvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >*
      mutable_overcrvpts();
  private:
  const ::commonmodule::TmHzPoint& _internal_overcrvpts(int index) const;
  ::commonmodule::TmHzPoint* _internal_add_overcrvpts();
  public:
  const ::commonmodule::TmHzPoint& overcrvpts(int index) const;
  ::commonmodule::TmHzPoint* add_overcrvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >&
      overcrvpts() const;
  // repeated .commonmodule.TmHzPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int undercrvpts_size() const;
  private:
  int _internal_undercrvpts_size() const;

  public:
  void clear_undercrvpts() ;
  ::commonmodule::TmHzPoint* mutable_undercrvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >*
      mutable_undercrvpts();
  private:
  const ::commonmodule::TmHzPoint& _internal_undercrvpts(int index) const;
  ::commonmodule::TmHzPoint* _internal_add_undercrvpts();
  public:
  const ::commonmodule::TmHzPoint& undercrvpts(int index) const;
  ::commonmodule::TmHzPoint* add_undercrvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >&
      undercrvpts() const;
  // @@protoc_insertion_point(class_scope:commonmodule.TmHzCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint > overcrvpts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint > undercrvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class TmVoltPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.TmVoltPoint) */ {
 public:
  inline TmVoltPoint() : TmVoltPoint(nullptr) {}
  ~TmVoltPoint() override;
  explicit PROTOBUF_CONSTEXPR TmVoltPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TmVoltPoint(const TmVoltPoint& from);
  TmVoltPoint(TmVoltPoint&& from) noexcept
    : TmVoltPoint() {
    *this = ::std::move(from);
  }

  inline TmVoltPoint& operator=(const TmVoltPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TmVoltPoint& operator=(TmVoltPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TmVoltPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TmVoltPoint* internal_default_instance() {
    return reinterpret_cast<const TmVoltPoint*>(
               &_TmVoltPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(TmVoltPoint& a, TmVoltPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TmVoltPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TmVoltPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TmVoltPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TmVoltPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TmVoltPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TmVoltPoint& from) {
    TmVoltPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TmVoltPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.TmVoltPoint";
  }
  protected:
  explicit TmVoltPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTmValFieldNumber = 1,
    kVoltValFieldNumber = 2,
  };
  // .commonmodule.ClearingTime tmVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_tmval() const;
  private:
  bool _internal_has_tmval() const;

  public:
  void clear_tmval() ;
  const ::commonmodule::ClearingTime& tmval() const;
  PROTOBUF_NODISCARD ::commonmodule::ClearingTime* release_tmval();
  ::commonmodule::ClearingTime* mutable_tmval();
  void set_allocated_tmval(::commonmodule::ClearingTime* tmval);
  private:
  const ::commonmodule::ClearingTime& _internal_tmval() const;
  ::commonmodule::ClearingTime* _internal_mutable_tmval();
  public:
  void unsafe_arena_set_allocated_tmval(
      ::commonmodule::ClearingTime* tmval);
  ::commonmodule::ClearingTime* unsafe_arena_release_tmval();
  // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_voltval() ;
  float voltval() const;
  void set_voltval(float value);

  private:
  float _internal_voltval() const;
  void _internal_set_voltval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.TmVoltPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ClearingTime* tmval_;
    float voltval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class TmVoltCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.TmVoltCSG) */ {
 public:
  inline TmVoltCSG() : TmVoltCSG(nullptr) {}
  ~TmVoltCSG() override;
  explicit PROTOBUF_CONSTEXPR TmVoltCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TmVoltCSG(const TmVoltCSG& from);
  TmVoltCSG(TmVoltCSG&& from) noexcept
    : TmVoltCSG() {
    *this = ::std::move(from);
  }

  inline TmVoltCSG& operator=(const TmVoltCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline TmVoltCSG& operator=(TmVoltCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TmVoltCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const TmVoltCSG* internal_default_instance() {
    return reinterpret_cast<const TmVoltCSG*>(
               &_TmVoltCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(TmVoltCSG& a, TmVoltCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(TmVoltCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TmVoltCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TmVoltCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TmVoltCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TmVoltCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TmVoltCSG& from) {
    TmVoltCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TmVoltCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.TmVoltCSG";
  }
  protected:
  explicit TmVoltCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverCrvPtsFieldNumber = 1,
    kUnderCrvPtsFieldNumber = 2,
  };
  // repeated .commonmodule.TmVoltPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int overcrvpts_size() const;
  private:
  int _internal_overcrvpts_size() const;

  public:
  void clear_overcrvpts() ;
  ::commonmodule::TmVoltPoint* mutable_overcrvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >*
      mutable_overcrvpts();
  private:
  const ::commonmodule::TmVoltPoint& _internal_overcrvpts(int index) const;
  ::commonmodule::TmVoltPoint* _internal_add_overcrvpts();
  public:
  const ::commonmodule::TmVoltPoint& overcrvpts(int index) const;
  ::commonmodule::TmVoltPoint* add_overcrvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >&
      overcrvpts() const;
  // repeated .commonmodule.TmVoltPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int undercrvpts_size() const;
  private:
  int _internal_undercrvpts_size() const;

  public:
  void clear_undercrvpts() ;
  ::commonmodule::TmVoltPoint* mutable_undercrvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >*
      mutable_undercrvpts();
  private:
  const ::commonmodule::TmVoltPoint& _internal_undercrvpts(int index) const;
  ::commonmodule::TmVoltPoint* _internal_add_undercrvpts();
  public:
  const ::commonmodule::TmVoltPoint& undercrvpts(int index) const;
  ::commonmodule::TmVoltPoint* add_undercrvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >&
      undercrvpts() const;
  // @@protoc_insertion_point(class_scope:commonmodule.TmVoltCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint > overcrvpts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint > undercrvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class VarSPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.VarSPC) */ {
 public:
  inline VarSPC() : VarSPC(nullptr) {}
  ~VarSPC() override;
  explicit PROTOBUF_CONSTEXPR VarSPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarSPC(const VarSPC& from);
  VarSPC(VarSPC&& from) noexcept
    : VarSPC() {
    *this = ::std::move(from);
  }

  inline VarSPC& operator=(const VarSPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarSPC& operator=(VarSPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarSPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarSPC* internal_default_instance() {
    return reinterpret_cast<const VarSPC*>(
               &_VarSPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(VarSPC& a, VarSPC& b) {
    a.Swap(&b);
  }
  inline void Swap(VarSPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarSPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarSPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarSPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarSPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarSPC& from) {
    VarSPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarSPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.VarSPC";
  }
  protected:
  explicit VarSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarParameterFieldNumber = 2,
    kModEnaFieldNumber = 1,
  };
  // .commonmodule.OperationDVAR varParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_varparameter() const;
  private:
  bool _internal_has_varparameter() const;

  public:
  void clear_varparameter() ;
  const ::commonmodule::OperationDVAR& varparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDVAR* release_varparameter();
  ::commonmodule::OperationDVAR* mutable_varparameter();
  void set_allocated_varparameter(::commonmodule::OperationDVAR* varparameter);
  private:
  const ::commonmodule::OperationDVAR& _internal_varparameter() const;
  ::commonmodule::OperationDVAR* _internal_mutable_varparameter();
  public:
  void unsafe_arena_set_allocated_varparameter(
      ::commonmodule::OperationDVAR* varparameter);
  ::commonmodule::OperationDVAR* unsafe_arena_release_varparameter();
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.VarSPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::OperationDVAR* varparameter_;
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class VoltVarPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.VoltVarPoint) */ {
 public:
  inline VoltVarPoint() : VoltVarPoint(nullptr) {}
  ~VoltVarPoint() override;
  explicit PROTOBUF_CONSTEXPR VoltVarPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoltVarPoint(const VoltVarPoint& from);
  VoltVarPoint(VoltVarPoint&& from) noexcept
    : VoltVarPoint() {
    *this = ::std::move(from);
  }

  inline VoltVarPoint& operator=(const VoltVarPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoltVarPoint& operator=(VoltVarPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoltVarPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoltVarPoint* internal_default_instance() {
    return reinterpret_cast<const VoltVarPoint*>(
               &_VoltVarPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(VoltVarPoint& a, VoltVarPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(VoltVarPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoltVarPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoltVarPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoltVarPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoltVarPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoltVarPoint& from) {
    VoltVarPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltVarPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.VoltVarPoint";
  }
  protected:
  explicit VoltVarPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarValFieldNumber = 1,
    kVoltValFieldNumber = 2,
  };
  // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_varval() ;
  float varval() const;
  void set_varval(float value);

  private:
  float _internal_varval() const;
  void _internal_set_varval(float value);

  public:
  // float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_voltval() ;
  float voltval() const;
  void set_voltval(float value);

  private:
  float _internal_voltval() const;
  void _internal_set_voltval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.VoltVarPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float varval_;
    float voltval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class VoltVarCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.VoltVarCSG) */ {
 public:
  inline VoltVarCSG() : VoltVarCSG(nullptr) {}
  ~VoltVarCSG() override;
  explicit PROTOBUF_CONSTEXPR VoltVarCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoltVarCSG(const VoltVarCSG& from);
  VoltVarCSG(VoltVarCSG&& from) noexcept
    : VoltVarCSG() {
    *this = ::std::move(from);
  }

  inline VoltVarCSG& operator=(const VoltVarCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoltVarCSG& operator=(VoltVarCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoltVarCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoltVarCSG* internal_default_instance() {
    return reinterpret_cast<const VoltVarCSG*>(
               &_VoltVarCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(VoltVarCSG& a, VoltVarCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(VoltVarCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoltVarCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoltVarCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoltVarCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoltVarCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoltVarCSG& from) {
    VoltVarCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltVarCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.VoltVarCSG";
  }
  protected:
  explicit VoltVarCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
    kVVarParameterFieldNumber = 2,
  };
  // repeated .commonmodule.VoltVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::commonmodule::VoltVarPoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltVarPoint >*
      mutable_crvpts();
  private:
  const ::commonmodule::VoltVarPoint& _internal_crvpts(int index) const;
  ::commonmodule::VoltVarPoint* _internal_add_crvpts();
  public:
  const ::commonmodule::VoltVarPoint& crvpts(int index) const;
  ::commonmodule::VoltVarPoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltVarPoint >&
      crvpts() const;
  // .commonmodule.OperationDVVR vVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vvarparameter() const;
  private:
  bool _internal_has_vvarparameter() const;

  public:
  void clear_vvarparameter() ;
  const ::commonmodule::OperationDVVR& vvarparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDVVR* release_vvarparameter();
  ::commonmodule::OperationDVVR* mutable_vvarparameter();
  void set_allocated_vvarparameter(::commonmodule::OperationDVVR* vvarparameter);
  private:
  const ::commonmodule::OperationDVVR& _internal_vvarparameter() const;
  ::commonmodule::OperationDVVR* _internal_mutable_vvarparameter();
  public:
  void unsafe_arena_set_allocated_vvarparameter(
      ::commonmodule::OperationDVVR* vvarparameter);
  ::commonmodule::OperationDVVR* unsafe_arena_release_vvarparameter();
  // @@protoc_insertion_point(class_scope:commonmodule.VoltVarCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltVarPoint > crvpts_;
    ::commonmodule::OperationDVVR* vvarparameter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class VoltWPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.VoltWPoint) */ {
 public:
  inline VoltWPoint() : VoltWPoint(nullptr) {}
  ~VoltWPoint() override;
  explicit PROTOBUF_CONSTEXPR VoltWPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoltWPoint(const VoltWPoint& from);
  VoltWPoint(VoltWPoint&& from) noexcept
    : VoltWPoint() {
    *this = ::std::move(from);
  }

  inline VoltWPoint& operator=(const VoltWPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoltWPoint& operator=(VoltWPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoltWPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoltWPoint* internal_default_instance() {
    return reinterpret_cast<const VoltWPoint*>(
               &_VoltWPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(VoltWPoint& a, VoltWPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(VoltWPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoltWPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoltWPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoltWPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoltWPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoltWPoint& from) {
    VoltWPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltWPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.VoltWPoint";
  }
  protected:
  explicit VoltWPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoltValFieldNumber = 1,
    kWValFieldNumber = 2,
  };
  // float voltVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_voltval() ;
  float voltval() const;
  void set_voltval(float value);

  private:
  float _internal_voltval() const;
  void _internal_set_voltval(float value);

  public:
  // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_wval() ;
  float wval() const;
  void set_wval(float value);

  private:
  float _internal_wval() const;
  void _internal_set_wval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.VoltWPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float voltval_;
    float wval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class VoltWCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.VoltWCSG) */ {
 public:
  inline VoltWCSG() : VoltWCSG(nullptr) {}
  ~VoltWCSG() override;
  explicit PROTOBUF_CONSTEXPR VoltWCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoltWCSG(const VoltWCSG& from);
  VoltWCSG(VoltWCSG&& from) noexcept
    : VoltWCSG() {
    *this = ::std::move(from);
  }

  inline VoltWCSG& operator=(const VoltWCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoltWCSG& operator=(VoltWCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoltWCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoltWCSG* internal_default_instance() {
    return reinterpret_cast<const VoltWCSG*>(
               &_VoltWCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(VoltWCSG& a, VoltWCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(VoltWCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoltWCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoltWCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoltWCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoltWCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoltWCSG& from) {
    VoltWCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltWCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.VoltWCSG";
  }
  protected:
  explicit VoltWCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
    kVoltWParameterFieldNumber = 2,
  };
  // repeated .commonmodule.VoltWPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::commonmodule::VoltWPoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltWPoint >*
      mutable_crvpts();
  private:
  const ::commonmodule::VoltWPoint& _internal_crvpts(int index) const;
  ::commonmodule::VoltWPoint* _internal_add_crvpts();
  public:
  const ::commonmodule::VoltWPoint& crvpts(int index) const;
  ::commonmodule::VoltWPoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltWPoint >&
      crvpts() const;
  // .commonmodule.OperationDVWC voltWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_voltwparameter() const;
  private:
  bool _internal_has_voltwparameter() const;

  public:
  void clear_voltwparameter() ;
  const ::commonmodule::OperationDVWC& voltwparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDVWC* release_voltwparameter();
  ::commonmodule::OperationDVWC* mutable_voltwparameter();
  void set_allocated_voltwparameter(::commonmodule::OperationDVWC* voltwparameter);
  private:
  const ::commonmodule::OperationDVWC& _internal_voltwparameter() const;
  ::commonmodule::OperationDVWC* _internal_mutable_voltwparameter();
  public:
  void unsafe_arena_set_allocated_voltwparameter(
      ::commonmodule::OperationDVWC* voltwparameter);
  ::commonmodule::OperationDVWC* unsafe_arena_release_voltwparameter();
  // @@protoc_insertion_point(class_scope:commonmodule.VoltWCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltWPoint > crvpts_;
    ::commonmodule::OperationDVWC* voltwparameter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class VSC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.VSC) */ {
 public:
  inline VSC() : VSC(nullptr) {}
  ~VSC() override;
  explicit PROTOBUF_CONSTEXPR VSC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VSC(const VSC& from);
  VSC(VSC&& from) noexcept
    : VSC() {
    *this = ::std::move(from);
  }

  inline VSC& operator=(const VSC& from) {
    CopyFrom(from);
    return *this;
  }
  inline VSC& operator=(VSC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VSC& default_instance() {
    return *internal_default_instance();
  }
  static inline const VSC* internal_default_instance() {
    return reinterpret_cast<const VSC*>(
               &_VSC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(VSC& a, VSC& b) {
    a.Swap(&b);
  }
  inline void Swap(VSC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VSC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VSC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VSC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VSC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VSC& from) {
    VSC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.VSC";
  }
  protected:
  explicit VSC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlValFieldNumber = 1,
  };
  // string ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_ctlval() ;
  const std::string& ctlval() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ctlval(Arg_&& arg, Args_... args);
  std::string* mutable_ctlval();
  PROTOBUF_NODISCARD std::string* release_ctlval();
  void set_allocated_ctlval(std::string* ptr);

  private:
  const std::string& _internal_ctlval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ctlval(
      const std::string& value);
  std::string* _internal_mutable_ctlval();

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.VSC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ctlval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class WSPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.WSPC) */ {
 public:
  inline WSPC() : WSPC(nullptr) {}
  ~WSPC() override;
  explicit PROTOBUF_CONSTEXPR WSPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WSPC(const WSPC& from);
  WSPC(WSPC&& from) noexcept
    : WSPC() {
    *this = ::std::move(from);
  }

  inline WSPC& operator=(const WSPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline WSPC& operator=(WSPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WSPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const WSPC* internal_default_instance() {
    return reinterpret_cast<const WSPC*>(
               &_WSPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(WSPC& a, WSPC& b) {
    a.Swap(&b);
  }
  inline void Swap(WSPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WSPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WSPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WSPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WSPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WSPC& from) {
    WSPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WSPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.WSPC";
  }
  protected:
  explicit WSPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWParameterFieldNumber = 2,
    kModEnaFieldNumber = 1,
  };
  // .commonmodule.OperationDWGC wParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wparameter() const;
  private:
  bool _internal_has_wparameter() const;

  public:
  void clear_wparameter() ;
  const ::commonmodule::OperationDWGC& wparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDWGC* release_wparameter();
  ::commonmodule::OperationDWGC* mutable_wparameter();
  void set_allocated_wparameter(::commonmodule::OperationDWGC* wparameter);
  private:
  const ::commonmodule::OperationDWGC& _internal_wparameter() const;
  ::commonmodule::OperationDWGC* _internal_mutable_wparameter();
  public:
  void unsafe_arena_set_allocated_wparameter(
      ::commonmodule::OperationDWGC* wparameter);
  ::commonmodule::OperationDWGC* unsafe_arena_release_wparameter();
  // bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_modena() ;
  bool modena() const;
  void set_modena(bool value);

  private:
  bool _internal_modena() const;
  void _internal_set_modena(bool value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.WSPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::OperationDWGC* wparameter_;
    bool modena_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class WVarPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.WVarPoint) */ {
 public:
  inline WVarPoint() : WVarPoint(nullptr) {}
  ~WVarPoint() override;
  explicit PROTOBUF_CONSTEXPR WVarPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WVarPoint(const WVarPoint& from);
  WVarPoint(WVarPoint&& from) noexcept
    : WVarPoint() {
    *this = ::std::move(from);
  }

  inline WVarPoint& operator=(const WVarPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline WVarPoint& operator=(WVarPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WVarPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const WVarPoint* internal_default_instance() {
    return reinterpret_cast<const WVarPoint*>(
               &_WVarPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(WVarPoint& a, WVarPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(WVarPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WVarPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WVarPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WVarPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WVarPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WVarPoint& from) {
    WVarPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WVarPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.WVarPoint";
  }
  protected:
  explicit WVarPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarValFieldNumber = 1,
    kWValFieldNumber = 2,
  };
  // float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_varval() ;
  float varval() const;
  void set_varval(float value);

  private:
  float _internal_varval() const;
  void _internal_set_varval(float value);

  public:
  // float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_wval() ;
  float wval() const;
  void set_wval(float value);

  private:
  float _internal_wval() const;
  void _internal_set_wval(float value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.WVarPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float varval_;
    float wval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class WVarCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.WVarCSG) */ {
 public:
  inline WVarCSG() : WVarCSG(nullptr) {}
  ~WVarCSG() override;
  explicit PROTOBUF_CONSTEXPR WVarCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WVarCSG(const WVarCSG& from);
  WVarCSG(WVarCSG&& from) noexcept
    : WVarCSG() {
    *this = ::std::move(from);
  }

  inline WVarCSG& operator=(const WVarCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline WVarCSG& operator=(WVarCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WVarCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const WVarCSG* internal_default_instance() {
    return reinterpret_cast<const WVarCSG*>(
               &_WVarCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(WVarCSG& a, WVarCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(WVarCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WVarCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WVarCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WVarCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WVarCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WVarCSG& from) {
    WVarCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WVarCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.WVarCSG";
  }
  protected:
  explicit WVarCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
    kWVarParameterFieldNumber = 2,
  };
  // repeated .commonmodule.WVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::commonmodule::WVarPoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::WVarPoint >*
      mutable_crvpts();
  private:
  const ::commonmodule::WVarPoint& _internal_crvpts(int index) const;
  ::commonmodule::WVarPoint* _internal_add_crvpts();
  public:
  const ::commonmodule::WVarPoint& crvpts(int index) const;
  ::commonmodule::WVarPoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::WVarPoint >&
      crvpts() const;
  // .commonmodule.OperationDWVR wVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wvarparameter() const;
  private:
  bool _internal_has_wvarparameter() const;

  public:
  void clear_wvarparameter() ;
  const ::commonmodule::OperationDWVR& wvarparameter() const;
  PROTOBUF_NODISCARD ::commonmodule::OperationDWVR* release_wvarparameter();
  ::commonmodule::OperationDWVR* mutable_wvarparameter();
  void set_allocated_wvarparameter(::commonmodule::OperationDWVR* wvarparameter);
  private:
  const ::commonmodule::OperationDWVR& _internal_wvarparameter() const;
  ::commonmodule::OperationDWVR* _internal_mutable_wvarparameter();
  public:
  void unsafe_arena_set_allocated_wvarparameter(
      ::commonmodule::OperationDWVR* wvarparameter);
  ::commonmodule::OperationDWVR* unsafe_arena_release_wvarparameter();
  // @@protoc_insertion_point(class_scope:commonmodule.WVarCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::WVarPoint > crvpts_;
    ::commonmodule::OperationDWVR* wvarparameter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_AlrmKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_AlrmKind) */ {
 public:
  inline Optional_AlrmKind() : Optional_AlrmKind(nullptr) {}
  ~Optional_AlrmKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_AlrmKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_AlrmKind(const Optional_AlrmKind& from);
  Optional_AlrmKind(Optional_AlrmKind&& from) noexcept
    : Optional_AlrmKind() {
    *this = ::std::move(from);
  }

  inline Optional_AlrmKind& operator=(const Optional_AlrmKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_AlrmKind& operator=(Optional_AlrmKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_AlrmKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_AlrmKind* internal_default_instance() {
    return reinterpret_cast<const Optional_AlrmKind*>(
               &_Optional_AlrmKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(Optional_AlrmKind& a, Optional_AlrmKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_AlrmKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_AlrmKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_AlrmKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_AlrmKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_AlrmKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_AlrmKind& from) {
    Optional_AlrmKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_AlrmKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_AlrmKind";
  }
  protected:
  explicit Optional_AlrmKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.AlrmKind value = 1;
  void clear_value() ;
  ::commonmodule::AlrmKind value() const;
  void set_value(::commonmodule::AlrmKind value);

  private:
  ::commonmodule::AlrmKind _internal_value() const;
  void _internal_set_value(::commonmodule::AlrmKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_AlrmKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_ControlModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_ControlModeKind) */ {
 public:
  inline Optional_ControlModeKind() : Optional_ControlModeKind(nullptr) {}
  ~Optional_ControlModeKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_ControlModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_ControlModeKind(const Optional_ControlModeKind& from);
  Optional_ControlModeKind(Optional_ControlModeKind&& from) noexcept
    : Optional_ControlModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_ControlModeKind& operator=(const Optional_ControlModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_ControlModeKind& operator=(Optional_ControlModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_ControlModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_ControlModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_ControlModeKind*>(
               &_Optional_ControlModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(Optional_ControlModeKind& a, Optional_ControlModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_ControlModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_ControlModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_ControlModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_ControlModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_ControlModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_ControlModeKind& from) {
    Optional_ControlModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_ControlModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_ControlModeKind";
  }
  protected:
  explicit Optional_ControlModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.ControlModeKind value = 1;
  void clear_value() ;
  ::commonmodule::ControlModeKind value() const;
  void set_value(::commonmodule::ControlModeKind value);

  private:
  ::commonmodule::ControlModeKind _internal_value() const;
  void _internal_set_value(::commonmodule::ControlModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_ControlModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_DirectionModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_DirectionModeKind) */ {
 public:
  inline Optional_DirectionModeKind() : Optional_DirectionModeKind(nullptr) {}
  ~Optional_DirectionModeKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_DirectionModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_DirectionModeKind(const Optional_DirectionModeKind& from);
  Optional_DirectionModeKind(Optional_DirectionModeKind&& from) noexcept
    : Optional_DirectionModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_DirectionModeKind& operator=(const Optional_DirectionModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_DirectionModeKind& operator=(Optional_DirectionModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_DirectionModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_DirectionModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_DirectionModeKind*>(
               &_Optional_DirectionModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(Optional_DirectionModeKind& a, Optional_DirectionModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_DirectionModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_DirectionModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_DirectionModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_DirectionModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_DirectionModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_DirectionModeKind& from) {
    Optional_DirectionModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_DirectionModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_DirectionModeKind";
  }
  protected:
  explicit Optional_DirectionModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.DirectionModeKind value = 1;
  void clear_value() ;
  ::commonmodule::DirectionModeKind value() const;
  void set_value(::commonmodule::DirectionModeKind value);

  private:
  ::commonmodule::DirectionModeKind _internal_value() const;
  void _internal_set_value(::commonmodule::DirectionModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_DirectionModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_GridConnectionStateKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_GridConnectionStateKind) */ {
 public:
  inline Optional_GridConnectionStateKind() : Optional_GridConnectionStateKind(nullptr) {}
  ~Optional_GridConnectionStateKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_GridConnectionStateKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_GridConnectionStateKind(const Optional_GridConnectionStateKind& from);
  Optional_GridConnectionStateKind(Optional_GridConnectionStateKind&& from) noexcept
    : Optional_GridConnectionStateKind() {
    *this = ::std::move(from);
  }

  inline Optional_GridConnectionStateKind& operator=(const Optional_GridConnectionStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_GridConnectionStateKind& operator=(Optional_GridConnectionStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_GridConnectionStateKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_GridConnectionStateKind* internal_default_instance() {
    return reinterpret_cast<const Optional_GridConnectionStateKind*>(
               &_Optional_GridConnectionStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(Optional_GridConnectionStateKind& a, Optional_GridConnectionStateKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_GridConnectionStateKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_GridConnectionStateKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_GridConnectionStateKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_GridConnectionStateKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_GridConnectionStateKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_GridConnectionStateKind& from) {
    Optional_GridConnectionStateKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_GridConnectionStateKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_GridConnectionStateKind";
  }
  protected:
  explicit Optional_GridConnectionStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.GridConnectionStateKind value = 1;
  void clear_value() ;
  ::commonmodule::GridConnectionStateKind value() const;
  void set_value(::commonmodule::GridConnectionStateKind value);

  private:
  ::commonmodule::GridConnectionStateKind _internal_value() const;
  void _internal_set_value(::commonmodule::GridConnectionStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_GridConnectionStateKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_OperatingStateKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_OperatingStateKind) */ {
 public:
  inline Optional_OperatingStateKind() : Optional_OperatingStateKind(nullptr) {}
  ~Optional_OperatingStateKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_OperatingStateKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_OperatingStateKind(const Optional_OperatingStateKind& from);
  Optional_OperatingStateKind(Optional_OperatingStateKind&& from) noexcept
    : Optional_OperatingStateKind() {
    *this = ::std::move(from);
  }

  inline Optional_OperatingStateKind& operator=(const Optional_OperatingStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_OperatingStateKind& operator=(Optional_OperatingStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_OperatingStateKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_OperatingStateKind* internal_default_instance() {
    return reinterpret_cast<const Optional_OperatingStateKind*>(
               &_Optional_OperatingStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(Optional_OperatingStateKind& a, Optional_OperatingStateKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_OperatingStateKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_OperatingStateKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_OperatingStateKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_OperatingStateKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_OperatingStateKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_OperatingStateKind& from) {
    Optional_OperatingStateKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_OperatingStateKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_OperatingStateKind";
  }
  protected:
  explicit Optional_OperatingStateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.OperatingStateKind value = 1;
  void clear_value() ;
  ::commonmodule::OperatingStateKind value() const;
  void set_value(::commonmodule::OperatingStateKind value);

  private:
  ::commonmodule::OperatingStateKind _internal_value() const;
  void _internal_set_value(::commonmodule::OperatingStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_OperatingStateKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_ReactivePowerControlKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_ReactivePowerControlKind) */ {
 public:
  inline Optional_ReactivePowerControlKind() : Optional_ReactivePowerControlKind(nullptr) {}
  ~Optional_ReactivePowerControlKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_ReactivePowerControlKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_ReactivePowerControlKind(const Optional_ReactivePowerControlKind& from);
  Optional_ReactivePowerControlKind(Optional_ReactivePowerControlKind&& from) noexcept
    : Optional_ReactivePowerControlKind() {
    *this = ::std::move(from);
  }

  inline Optional_ReactivePowerControlKind& operator=(const Optional_ReactivePowerControlKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_ReactivePowerControlKind& operator=(Optional_ReactivePowerControlKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_ReactivePowerControlKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_ReactivePowerControlKind* internal_default_instance() {
    return reinterpret_cast<const Optional_ReactivePowerControlKind*>(
               &_Optional_ReactivePowerControlKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(Optional_ReactivePowerControlKind& a, Optional_ReactivePowerControlKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_ReactivePowerControlKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_ReactivePowerControlKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_ReactivePowerControlKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_ReactivePowerControlKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_ReactivePowerControlKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_ReactivePowerControlKind& from) {
    Optional_ReactivePowerControlKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_ReactivePowerControlKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_ReactivePowerControlKind";
  }
  protected:
  explicit Optional_ReactivePowerControlKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.ReactivePowerControlKind value = 1;
  void clear_value() ;
  ::commonmodule::ReactivePowerControlKind value() const;
  void set_value(::commonmodule::ReactivePowerControlKind value);

  private:
  ::commonmodule::ReactivePowerControlKind _internal_value() const;
  void _internal_set_value(::commonmodule::ReactivePowerControlKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_ReactivePowerControlKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_RealPowerControlKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_RealPowerControlKind) */ {
 public:
  inline Optional_RealPowerControlKind() : Optional_RealPowerControlKind(nullptr) {}
  ~Optional_RealPowerControlKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_RealPowerControlKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_RealPowerControlKind(const Optional_RealPowerControlKind& from);
  Optional_RealPowerControlKind(Optional_RealPowerControlKind&& from) noexcept
    : Optional_RealPowerControlKind() {
    *this = ::std::move(from);
  }

  inline Optional_RealPowerControlKind& operator=(const Optional_RealPowerControlKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_RealPowerControlKind& operator=(Optional_RealPowerControlKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_RealPowerControlKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_RealPowerControlKind* internal_default_instance() {
    return reinterpret_cast<const Optional_RealPowerControlKind*>(
               &_Optional_RealPowerControlKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(Optional_RealPowerControlKind& a, Optional_RealPowerControlKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_RealPowerControlKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_RealPowerControlKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_RealPowerControlKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_RealPowerControlKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_RealPowerControlKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_RealPowerControlKind& from) {
    Optional_RealPowerControlKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_RealPowerControlKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_RealPowerControlKind";
  }
  protected:
  explicit Optional_RealPowerControlKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.RealPowerControlKind value = 1;
  void clear_value() ;
  ::commonmodule::RealPowerControlKind value() const;
  void set_value(::commonmodule::RealPowerControlKind value);

  private:
  ::commonmodule::RealPowerControlKind _internal_value() const;
  void _internal_set_value(::commonmodule::RealPowerControlKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_RealPowerControlKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_StateKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_StateKind) */ {
 public:
  inline Optional_StateKind() : Optional_StateKind(nullptr) {}
  ~Optional_StateKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_StateKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_StateKind(const Optional_StateKind& from);
  Optional_StateKind(Optional_StateKind&& from) noexcept
    : Optional_StateKind() {
    *this = ::std::move(from);
  }

  inline Optional_StateKind& operator=(const Optional_StateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_StateKind& operator=(Optional_StateKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_StateKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_StateKind* internal_default_instance() {
    return reinterpret_cast<const Optional_StateKind*>(
               &_Optional_StateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(Optional_StateKind& a, Optional_StateKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_StateKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_StateKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_StateKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_StateKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_StateKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_StateKind& from) {
    Optional_StateKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_StateKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_StateKind";
  }
  protected:
  explicit Optional_StateKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.StateKind value = 1;
  void clear_value() ;
  ::commonmodule::StateKind value() const;
  void set_value(::commonmodule::StateKind value);

  private:
  ::commonmodule::StateKind _internal_value() const;
  void _internal_set_value(::commonmodule::StateKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_StateKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};// -------------------------------------------------------------------

class Optional_VoltLimitModeKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commonmodule.Optional_VoltLimitModeKind) */ {
 public:
  inline Optional_VoltLimitModeKind() : Optional_VoltLimitModeKind(nullptr) {}
  ~Optional_VoltLimitModeKind() override;
  explicit PROTOBUF_CONSTEXPR Optional_VoltLimitModeKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optional_VoltLimitModeKind(const Optional_VoltLimitModeKind& from);
  Optional_VoltLimitModeKind(Optional_VoltLimitModeKind&& from) noexcept
    : Optional_VoltLimitModeKind() {
    *this = ::std::move(from);
  }

  inline Optional_VoltLimitModeKind& operator=(const Optional_VoltLimitModeKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_VoltLimitModeKind& operator=(Optional_VoltLimitModeKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_VoltLimitModeKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Optional_VoltLimitModeKind* internal_default_instance() {
    return reinterpret_cast<const Optional_VoltLimitModeKind*>(
               &_Optional_VoltLimitModeKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(Optional_VoltLimitModeKind& a, Optional_VoltLimitModeKind& b) {
    a.Swap(&b);
  }
  inline void Swap(Optional_VoltLimitModeKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_VoltLimitModeKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_VoltLimitModeKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Optional_VoltLimitModeKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optional_VoltLimitModeKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Optional_VoltLimitModeKind& from) {
    Optional_VoltLimitModeKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optional_VoltLimitModeKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "commonmodule.Optional_VoltLimitModeKind";
  }
  protected:
  explicit Optional_VoltLimitModeKind(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .commonmodule.VoltLimitModeKind value = 1;
  void clear_value() ;
  ::commonmodule::VoltLimitModeKind value() const;
  void set_value(::commonmodule::VoltLimitModeKind value);

  private:
  ::commonmodule::VoltLimitModeKind _internal_value() const;
  void _internal_set_value(::commonmodule::VoltLimitModeKind value);

  public:
  // @@protoc_insertion_point(class_scope:commonmodule.Optional_VoltLimitModeKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_commonmodule_2fcommonmodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Optional_FaultDirectionKind

// .commonmodule.FaultDirectionKind value = 1;
inline void Optional_FaultDirectionKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::FaultDirectionKind Optional_FaultDirectionKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_FaultDirectionKind.value)
  return _internal_value();
}
inline void Optional_FaultDirectionKind::set_value(::commonmodule::FaultDirectionKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_FaultDirectionKind.value)
}
inline ::commonmodule::FaultDirectionKind Optional_FaultDirectionKind::_internal_value() const {
  return static_cast<::commonmodule::FaultDirectionKind>(_impl_.value_);
}
inline void Optional_FaultDirectionKind::_internal_set_value(::commonmodule::FaultDirectionKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_PhaseFaultDirectionKind

// .commonmodule.PhaseFaultDirectionKind value = 1;
inline void Optional_PhaseFaultDirectionKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::PhaseFaultDirectionKind Optional_PhaseFaultDirectionKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_PhaseFaultDirectionKind.value)
  return _internal_value();
}
inline void Optional_PhaseFaultDirectionKind::set_value(::commonmodule::PhaseFaultDirectionKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_PhaseFaultDirectionKind.value)
}
inline ::commonmodule::PhaseFaultDirectionKind Optional_PhaseFaultDirectionKind::_internal_value() const {
  return static_cast<::commonmodule::PhaseFaultDirectionKind>(_impl_.value_);
}
inline void Optional_PhaseFaultDirectionKind::_internal_set_value(::commonmodule::PhaseFaultDirectionKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ACD

// .commonmodule.FaultDirectionKind dirGeneral = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ACD::clear_dirgeneral() {
  _impl_.dirgeneral_ = 0;
}
inline ::commonmodule::FaultDirectionKind ACD::dirgeneral() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.dirGeneral)
  return _internal_dirgeneral();
}
inline void ACD::set_dirgeneral(::commonmodule::FaultDirectionKind value) {
   _internal_set_dirgeneral(value);
  // @@protoc_insertion_point(field_set:commonmodule.ACD.dirGeneral)
}
inline ::commonmodule::FaultDirectionKind ACD::_internal_dirgeneral() const {
  return static_cast<::commonmodule::FaultDirectionKind>(_impl_.dirgeneral_);
}
inline void ACD::_internal_set_dirgeneral(::commonmodule::FaultDirectionKind value) {
  ;
  _impl_.dirgeneral_ = value;
}

// .commonmodule.Optional_PhaseFaultDirectionKind dirNeut = 2;
inline bool ACD::_internal_has_dirneut() const {
  return this != internal_default_instance() && _impl_.dirneut_ != nullptr;
}
inline bool ACD::has_dirneut() const {
  return _internal_has_dirneut();
}
inline void ACD::clear_dirneut() {
  if (GetArenaForAllocation() == nullptr && _impl_.dirneut_ != nullptr) {
    delete _impl_.dirneut_;
  }
  _impl_.dirneut_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::_internal_dirneut() const {
  const ::commonmodule::Optional_PhaseFaultDirectionKind* p = _impl_.dirneut_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseFaultDirectionKind&>(
      ::commonmodule::_Optional_PhaseFaultDirectionKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::dirneut() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.dirNeut)
  return _internal_dirneut();
}
inline void ACD::unsafe_arena_set_allocated_dirneut(
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirneut) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirneut_);
  }
  _impl_.dirneut_ = dirneut;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.dirNeut)
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::release_dirneut() {
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirneut_;
  _impl_.dirneut_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::unsafe_arena_release_dirneut() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.dirNeut)
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirneut_;
  _impl_.dirneut_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::_internal_mutable_dirneut() {
  
  if (_impl_.dirneut_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseFaultDirectionKind>(GetArenaForAllocation());
    _impl_.dirneut_ = p;
  }
  return _impl_.dirneut_;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::mutable_dirneut() {
  ::commonmodule::Optional_PhaseFaultDirectionKind* _msg = _internal_mutable_dirneut();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.dirNeut)
  return _msg;
}
inline void ACD::set_allocated_dirneut(::commonmodule::Optional_PhaseFaultDirectionKind* dirneut) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dirneut_;
  }
  if (dirneut) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dirneut);
    if (message_arena != submessage_arena) {
      dirneut = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirneut, submessage_arena);
    }

  } else {

  }
  _impl_.dirneut_ = dirneut;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.dirNeut)
}

// .commonmodule.Optional_PhaseFaultDirectionKind dirPhsA = 3;
inline bool ACD::_internal_has_dirphsa() const {
  return this != internal_default_instance() && _impl_.dirphsa_ != nullptr;
}
inline bool ACD::has_dirphsa() const {
  return _internal_has_dirphsa();
}
inline void ACD::clear_dirphsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.dirphsa_ != nullptr) {
    delete _impl_.dirphsa_;
  }
  _impl_.dirphsa_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::_internal_dirphsa() const {
  const ::commonmodule::Optional_PhaseFaultDirectionKind* p = _impl_.dirphsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseFaultDirectionKind&>(
      ::commonmodule::_Optional_PhaseFaultDirectionKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::dirphsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.dirPhsA)
  return _internal_dirphsa();
}
inline void ACD::unsafe_arena_set_allocated_dirphsa(
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirphsa_);
  }
  _impl_.dirphsa_ = dirphsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.dirPhsA)
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::release_dirphsa() {
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirphsa_;
  _impl_.dirphsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::unsafe_arena_release_dirphsa() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.dirPhsA)
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirphsa_;
  _impl_.dirphsa_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::_internal_mutable_dirphsa() {
  
  if (_impl_.dirphsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseFaultDirectionKind>(GetArenaForAllocation());
    _impl_.dirphsa_ = p;
  }
  return _impl_.dirphsa_;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::mutable_dirphsa() {
  ::commonmodule::Optional_PhaseFaultDirectionKind* _msg = _internal_mutable_dirphsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.dirPhsA)
  return _msg;
}
inline void ACD::set_allocated_dirphsa(::commonmodule::Optional_PhaseFaultDirectionKind* dirphsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dirphsa_;
  }
  if (dirphsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dirphsa);
    if (message_arena != submessage_arena) {
      dirphsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirphsa, submessage_arena);
    }

  } else {

  }
  _impl_.dirphsa_ = dirphsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.dirPhsA)
}

// .commonmodule.Optional_PhaseFaultDirectionKind dirPhsB = 4;
inline bool ACD::_internal_has_dirphsb() const {
  return this != internal_default_instance() && _impl_.dirphsb_ != nullptr;
}
inline bool ACD::has_dirphsb() const {
  return _internal_has_dirphsb();
}
inline void ACD::clear_dirphsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.dirphsb_ != nullptr) {
    delete _impl_.dirphsb_;
  }
  _impl_.dirphsb_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::_internal_dirphsb() const {
  const ::commonmodule::Optional_PhaseFaultDirectionKind* p = _impl_.dirphsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseFaultDirectionKind&>(
      ::commonmodule::_Optional_PhaseFaultDirectionKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::dirphsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.dirPhsB)
  return _internal_dirphsb();
}
inline void ACD::unsafe_arena_set_allocated_dirphsb(
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirphsb_);
  }
  _impl_.dirphsb_ = dirphsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.dirPhsB)
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::release_dirphsb() {
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirphsb_;
  _impl_.dirphsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::unsafe_arena_release_dirphsb() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.dirPhsB)
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirphsb_;
  _impl_.dirphsb_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::_internal_mutable_dirphsb() {
  
  if (_impl_.dirphsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseFaultDirectionKind>(GetArenaForAllocation());
    _impl_.dirphsb_ = p;
  }
  return _impl_.dirphsb_;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::mutable_dirphsb() {
  ::commonmodule::Optional_PhaseFaultDirectionKind* _msg = _internal_mutable_dirphsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.dirPhsB)
  return _msg;
}
inline void ACD::set_allocated_dirphsb(::commonmodule::Optional_PhaseFaultDirectionKind* dirphsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dirphsb_;
  }
  if (dirphsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dirphsb);
    if (message_arena != submessage_arena) {
      dirphsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirphsb, submessage_arena);
    }

  } else {

  }
  _impl_.dirphsb_ = dirphsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.dirPhsB)
}

// .commonmodule.Optional_PhaseFaultDirectionKind dirPhsC = 5;
inline bool ACD::_internal_has_dirphsc() const {
  return this != internal_default_instance() && _impl_.dirphsc_ != nullptr;
}
inline bool ACD::has_dirphsc() const {
  return _internal_has_dirphsc();
}
inline void ACD::clear_dirphsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.dirphsc_ != nullptr) {
    delete _impl_.dirphsc_;
  }
  _impl_.dirphsc_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::_internal_dirphsc() const {
  const ::commonmodule::Optional_PhaseFaultDirectionKind* p = _impl_.dirphsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseFaultDirectionKind&>(
      ::commonmodule::_Optional_PhaseFaultDirectionKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseFaultDirectionKind& ACD::dirphsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.dirPhsC)
  return _internal_dirphsc();
}
inline void ACD::unsafe_arena_set_allocated_dirphsc(
    ::commonmodule::Optional_PhaseFaultDirectionKind* dirphsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirphsc_);
  }
  _impl_.dirphsc_ = dirphsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.dirPhsC)
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::release_dirphsc() {
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirphsc_;
  _impl_.dirphsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::unsafe_arena_release_dirphsc() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.dirPhsC)
  
  ::commonmodule::Optional_PhaseFaultDirectionKind* temp = _impl_.dirphsc_;
  _impl_.dirphsc_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::_internal_mutable_dirphsc() {
  
  if (_impl_.dirphsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseFaultDirectionKind>(GetArenaForAllocation());
    _impl_.dirphsc_ = p;
  }
  return _impl_.dirphsc_;
}
inline ::commonmodule::Optional_PhaseFaultDirectionKind* ACD::mutable_dirphsc() {
  ::commonmodule::Optional_PhaseFaultDirectionKind* _msg = _internal_mutable_dirphsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.dirPhsC)
  return _msg;
}
inline void ACD::set_allocated_dirphsc(::commonmodule::Optional_PhaseFaultDirectionKind* dirphsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dirphsc_;
  }
  if (dirphsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dirphsc);
    if (message_arena != submessage_arena) {
      dirphsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirphsc, submessage_arena);
    }

  } else {

  }
  _impl_.dirphsc_ = dirphsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.dirPhsC)
}

// bool general = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ACD::clear_general() {
  _impl_.general_ = false;
}
inline bool ACD::general() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.general)
  return _internal_general();
}
inline void ACD::set_general(bool value) {
  _internal_set_general(value);
  // @@protoc_insertion_point(field_set:commonmodule.ACD.general)
}
inline bool ACD::_internal_general() const {
  return _impl_.general_;
}
inline void ACD::_internal_set_general(bool value) {
  ;
  _impl_.general_ = value;
}

// .google.protobuf.BoolValue neut = 7;
inline bool ACD::_internal_has_neut() const {
  return this != internal_default_instance() && _impl_.neut_ != nullptr;
}
inline bool ACD::has_neut() const {
  return _internal_has_neut();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::_internal_neut() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.neut_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::neut() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.neut)
  return _internal_neut();
}
inline void ACD::unsafe_arena_set_allocated_neut(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* neut) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.neut_);
  }
  _impl_.neut_ = neut;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.neut)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::release_neut() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.neut_;
  _impl_.neut_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::unsafe_arena_release_neut() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.neut)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.neut_;
  _impl_.neut_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::_internal_mutable_neut() {
  
  if (_impl_.neut_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.neut_ = p;
  }
  return _impl_.neut_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::mutable_neut() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_neut();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.neut)
  return _msg;
}
inline void ACD::set_allocated_neut(::PROTOBUF_NAMESPACE_ID::BoolValue* neut) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.neut_);
  }
  if (neut) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(neut));
    if (message_arena != submessage_arena) {
      neut = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neut, submessage_arena);
    }

  } else {

  }
  _impl_.neut_ = neut;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.neut)
}

// .google.protobuf.BoolValue phsA = 8;
inline bool ACD::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool ACD::has_phsa() const {
  return _internal_has_phsa();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::_internal_phsa() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.phsA)
  return _internal_phsa();
}
inline void ACD::unsafe_arena_set_allocated_phsa(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.phsA)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::release_phsa() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.phsA)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::mutable_phsa() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.phsA)
  return _msg;
}
inline void ACD::set_allocated_phsa(::PROTOBUF_NAMESPACE_ID::BoolValue* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phsa));
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.phsA)
}

// .google.protobuf.BoolValue phsB = 9;
inline bool ACD::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool ACD::has_phsb() const {
  return _internal_has_phsb();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::_internal_phsb() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.phsB)
  return _internal_phsb();
}
inline void ACD::unsafe_arena_set_allocated_phsb(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.phsB)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::release_phsb() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.phsB)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::mutable_phsb() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.phsB)
  return _msg;
}
inline void ACD::set_allocated_phsb(::PROTOBUF_NAMESPACE_ID::BoolValue* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phsb));
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.phsB)
}

// .google.protobuf.BoolValue phsC = 10;
inline bool ACD::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool ACD::has_phsc() const {
  return _internal_has_phsc();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::_internal_phsc() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACD::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACD.phsC)
  return _internal_phsc();
}
inline void ACD::unsafe_arena_set_allocated_phsc(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACD.phsC)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::release_phsc() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.ACD.phsC)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACD::mutable_phsc() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACD.phsC)
  return _msg;
}
inline void ACD::set_allocated_phsc(::PROTOBUF_NAMESPACE_ID::BoolValue* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phsc));
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACD.phsC)
}

// -------------------------------------------------------------------

// IdentifiedObject

// .google.protobuf.StringValue description = 1;
inline bool IdentifiedObject::_internal_has_description() const {
  return this != internal_default_instance() && _impl_.description_ != nullptr;
}
inline bool IdentifiedObject::has_description() const {
  return _internal_has_description();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& IdentifiedObject::_internal_description() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.description_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& IdentifiedObject::description() const {
  // @@protoc_insertion_point(field_get:commonmodule.IdentifiedObject.description)
  return _internal_description();
}
inline void IdentifiedObject::unsafe_arena_set_allocated_description(
    ::PROTOBUF_NAMESPACE_ID::StringValue* description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_);
  }
  _impl_.description_ = description;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.IdentifiedObject.description)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::release_description() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.description_;
  _impl_.description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_release:commonmodule.IdentifiedObject.description)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.description_;
  _impl_.description_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::_internal_mutable_description() {
  
  if (_impl_.description_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.description_ = p;
  }
  return _impl_.description_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::mutable_description() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:commonmodule.IdentifiedObject.description)
  return _msg;
}
inline void IdentifiedObject::set_allocated_description(::PROTOBUF_NAMESPACE_ID::StringValue* description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_);
  }
  if (description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(description));
    if (message_arena != submessage_arena) {
      description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }

  } else {

  }
  _impl_.description_ = description;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IdentifiedObject.description)
}

// .google.protobuf.StringValue mRID = 2 [(.uml.option_uuid) = true];
inline bool IdentifiedObject::_internal_has_mrid() const {
  return this != internal_default_instance() && _impl_.mrid_ != nullptr;
}
inline bool IdentifiedObject::has_mrid() const {
  return _internal_has_mrid();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& IdentifiedObject::_internal_mrid() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.mrid_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& IdentifiedObject::mrid() const {
  // @@protoc_insertion_point(field_get:commonmodule.IdentifiedObject.mRID)
  return _internal_mrid();
}
inline void IdentifiedObject::unsafe_arena_set_allocated_mrid(
    ::PROTOBUF_NAMESPACE_ID::StringValue* mrid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mrid_);
  }
  _impl_.mrid_ = mrid;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.IdentifiedObject.mRID)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::release_mrid() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.mrid_;
  _impl_.mrid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::unsafe_arena_release_mrid() {
  // @@protoc_insertion_point(field_release:commonmodule.IdentifiedObject.mRID)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.mrid_;
  _impl_.mrid_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::_internal_mutable_mrid() {
  
  if (_impl_.mrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.mrid_ = p;
  }
  return _impl_.mrid_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::mutable_mrid() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_mrid();
  // @@protoc_insertion_point(field_mutable:commonmodule.IdentifiedObject.mRID)
  return _msg;
}
inline void IdentifiedObject::set_allocated_mrid(::PROTOBUF_NAMESPACE_ID::StringValue* mrid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mrid_);
  }
  if (mrid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mrid));
    if (message_arena != submessage_arena) {
      mrid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mrid, submessage_arena);
    }

  } else {

  }
  _impl_.mrid_ = mrid;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IdentifiedObject.mRID)
}

// .google.protobuf.StringValue name = 3;
inline bool IdentifiedObject::_internal_has_name() const {
  return this != internal_default_instance() && _impl_.name_ != nullptr;
}
inline bool IdentifiedObject::has_name() const {
  return _internal_has_name();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& IdentifiedObject::_internal_name() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& IdentifiedObject::name() const {
  // @@protoc_insertion_point(field_get:commonmodule.IdentifiedObject.name)
  return _internal_name();
}
inline void IdentifiedObject::unsafe_arena_set_allocated_name(
    ::PROTOBUF_NAMESPACE_ID::StringValue* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.IdentifiedObject.name)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::release_name() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:commonmodule.IdentifiedObject.name)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::_internal_mutable_name() {
  
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* IdentifiedObject::mutable_name() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:commonmodule.IdentifiedObject.name)
  return _msg;
}
inline void IdentifiedObject::set_allocated_name(::PROTOBUF_NAMESPACE_ID::StringValue* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }

  } else {

  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IdentifiedObject.name)
}

// -------------------------------------------------------------------

// ACDCTerminal

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ACDCTerminal::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool ACDCTerminal::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void ACDCTerminal::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ACDCTerminal::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& ACDCTerminal::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACDCTerminal.identifiedObject)
  return _internal_identifiedobject();
}
inline void ACDCTerminal::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACDCTerminal.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* ACDCTerminal::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* ACDCTerminal::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ACDCTerminal.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ACDCTerminal::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* ACDCTerminal::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACDCTerminal.identifiedObject)
  return _msg;
}
inline void ACDCTerminal::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACDCTerminal.identifiedObject)
}

// .google.protobuf.BoolValue connected = 2;
inline bool ACDCTerminal::_internal_has_connected() const {
  return this != internal_default_instance() && _impl_.connected_ != nullptr;
}
inline bool ACDCTerminal::has_connected() const {
  return _internal_has_connected();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACDCTerminal::_internal_connected() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.connected_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ACDCTerminal::connected() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACDCTerminal.connected)
  return _internal_connected();
}
inline void ACDCTerminal::unsafe_arena_set_allocated_connected(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* connected) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connected_);
  }
  _impl_.connected_ = connected;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACDCTerminal.connected)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACDCTerminal::release_connected() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.connected_;
  _impl_.connected_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACDCTerminal::unsafe_arena_release_connected() {
  // @@protoc_insertion_point(field_release:commonmodule.ACDCTerminal.connected)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.connected_;
  _impl_.connected_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACDCTerminal::_internal_mutable_connected() {
  
  if (_impl_.connected_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.connected_ = p;
  }
  return _impl_.connected_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ACDCTerminal::mutable_connected() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_connected();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACDCTerminal.connected)
  return _msg;
}
inline void ACDCTerminal::set_allocated_connected(::PROTOBUF_NAMESPACE_ID::BoolValue* connected) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connected_);
  }
  if (connected) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected));
    if (message_arena != submessage_arena) {
      connected = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected, submessage_arena);
    }

  } else {

  }
  _impl_.connected_ = connected;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACDCTerminal.connected)
}

// .google.protobuf.Int32Value sequenceNumber = 3;
inline bool ACDCTerminal::_internal_has_sequencenumber() const {
  return this != internal_default_instance() && _impl_.sequencenumber_ != nullptr;
}
inline bool ACDCTerminal::has_sequencenumber() const {
  return _internal_has_sequencenumber();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ACDCTerminal::_internal_sequencenumber() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = _impl_.sequencenumber_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ACDCTerminal::sequencenumber() const {
  // @@protoc_insertion_point(field_get:commonmodule.ACDCTerminal.sequenceNumber)
  return _internal_sequencenumber();
}
inline void ACDCTerminal::unsafe_arena_set_allocated_sequencenumber(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* sequencenumber) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sequencenumber_);
  }
  _impl_.sequencenumber_ = sequencenumber;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ACDCTerminal.sequenceNumber)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ACDCTerminal::release_sequencenumber() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.sequencenumber_;
  _impl_.sequencenumber_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ACDCTerminal::unsafe_arena_release_sequencenumber() {
  // @@protoc_insertion_point(field_release:commonmodule.ACDCTerminal.sequenceNumber)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.sequencenumber_;
  _impl_.sequencenumber_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ACDCTerminal::_internal_mutable_sequencenumber() {
  
  if (_impl_.sequencenumber_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    _impl_.sequencenumber_ = p;
  }
  return _impl_.sequencenumber_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ACDCTerminal::mutable_sequencenumber() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_sequencenumber();
  // @@protoc_insertion_point(field_mutable:commonmodule.ACDCTerminal.sequenceNumber)
  return _msg;
}
inline void ACDCTerminal::set_allocated_sequencenumber(::PROTOBUF_NAMESPACE_ID::Int32Value* sequencenumber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sequencenumber_);
  }
  if (sequencenumber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequencenumber));
    if (message_arena != submessage_arena) {
      sequencenumber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequencenumber, submessage_arena);
    }

  } else {

  }
  _impl_.sequencenumber_ = sequencenumber;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ACDCTerminal.sequenceNumber)
}

// -------------------------------------------------------------------

// Optional_UnitSymbolKind

// .commonmodule.UnitSymbolKind value = 1;
inline void Optional_UnitSymbolKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::UnitSymbolKind Optional_UnitSymbolKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_UnitSymbolKind.value)
  return _internal_value();
}
inline void Optional_UnitSymbolKind::set_value(::commonmodule::UnitSymbolKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_UnitSymbolKind.value)
}
inline ::commonmodule::UnitSymbolKind Optional_UnitSymbolKind::_internal_value() const {
  return static_cast<::commonmodule::UnitSymbolKind>(_impl_.value_);
}
inline void Optional_UnitSymbolKind::_internal_set_value(::commonmodule::UnitSymbolKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_UnitMultiplierKind

// .commonmodule.UnitMultiplierKind value = 1;
inline void Optional_UnitMultiplierKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::UnitMultiplierKind Optional_UnitMultiplierKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_UnitMultiplierKind.value)
  return _internal_value();
}
inline void Optional_UnitMultiplierKind::set_value(::commonmodule::UnitMultiplierKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_UnitMultiplierKind.value)
}
inline ::commonmodule::UnitMultiplierKind Optional_UnitMultiplierKind::_internal_value() const {
  return static_cast<::commonmodule::UnitMultiplierKind>(_impl_.value_);
}
inline void Optional_UnitMultiplierKind::_internal_set_value(::commonmodule::UnitMultiplierKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ActivePower

// .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
inline bool ActivePower::_internal_has_multiplier() const {
  return this != internal_default_instance() && _impl_.multiplier_ != nullptr;
}
inline bool ActivePower::has_multiplier() const {
  return _internal_has_multiplier();
}
inline void ActivePower::clear_multiplier() {
  if (GetArenaForAllocation() == nullptr && _impl_.multiplier_ != nullptr) {
    delete _impl_.multiplier_;
  }
  _impl_.multiplier_ = nullptr;
}
inline const ::commonmodule::Optional_UnitMultiplierKind& ActivePower::_internal_multiplier() const {
  const ::commonmodule::Optional_UnitMultiplierKind* p = _impl_.multiplier_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_UnitMultiplierKind&>(
      ::commonmodule::_Optional_UnitMultiplierKind_default_instance_);
}
inline const ::commonmodule::Optional_UnitMultiplierKind& ActivePower::multiplier() const {
  // @@protoc_insertion_point(field_get:commonmodule.ActivePower.multiplier)
  return _internal_multiplier();
}
inline void ActivePower::unsafe_arena_set_allocated_multiplier(
    ::commonmodule::Optional_UnitMultiplierKind* multiplier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiplier_);
  }
  _impl_.multiplier_ = multiplier;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ActivePower.multiplier)
}
inline ::commonmodule::Optional_UnitMultiplierKind* ActivePower::release_multiplier() {
  
  ::commonmodule::Optional_UnitMultiplierKind* temp = _impl_.multiplier_;
  _impl_.multiplier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_UnitMultiplierKind* ActivePower::unsafe_arena_release_multiplier() {
  // @@protoc_insertion_point(field_release:commonmodule.ActivePower.multiplier)
  
  ::commonmodule::Optional_UnitMultiplierKind* temp = _impl_.multiplier_;
  _impl_.multiplier_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_UnitMultiplierKind* ActivePower::_internal_mutable_multiplier() {
  
  if (_impl_.multiplier_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_UnitMultiplierKind>(GetArenaForAllocation());
    _impl_.multiplier_ = p;
  }
  return _impl_.multiplier_;
}
inline ::commonmodule::Optional_UnitMultiplierKind* ActivePower::mutable_multiplier() {
  ::commonmodule::Optional_UnitMultiplierKind* _msg = _internal_mutable_multiplier();
  // @@protoc_insertion_point(field_mutable:commonmodule.ActivePower.multiplier)
  return _msg;
}
inline void ActivePower::set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.multiplier_;
  }
  if (multiplier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multiplier);
    if (message_arena != submessage_arena) {
      multiplier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiplier, submessage_arena);
    }

  } else {

  }
  _impl_.multiplier_ = multiplier;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ActivePower.multiplier)
}

// .commonmodule.Optional_UnitSymbolKind unit = 2;
inline bool ActivePower::_internal_has_unit() const {
  return this != internal_default_instance() && _impl_.unit_ != nullptr;
}
inline bool ActivePower::has_unit() const {
  return _internal_has_unit();
}
inline void ActivePower::clear_unit() {
  if (GetArenaForAllocation() == nullptr && _impl_.unit_ != nullptr) {
    delete _impl_.unit_;
  }
  _impl_.unit_ = nullptr;
}
inline const ::commonmodule::Optional_UnitSymbolKind& ActivePower::_internal_unit() const {
  const ::commonmodule::Optional_UnitSymbolKind* p = _impl_.unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_UnitSymbolKind&>(
      ::commonmodule::_Optional_UnitSymbolKind_default_instance_);
}
inline const ::commonmodule::Optional_UnitSymbolKind& ActivePower::unit() const {
  // @@protoc_insertion_point(field_get:commonmodule.ActivePower.unit)
  return _internal_unit();
}
inline void ActivePower::unsafe_arena_set_allocated_unit(
    ::commonmodule::Optional_UnitSymbolKind* unit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_);
  }
  _impl_.unit_ = unit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ActivePower.unit)
}
inline ::commonmodule::Optional_UnitSymbolKind* ActivePower::release_unit() {
  
  ::commonmodule::Optional_UnitSymbolKind* temp = _impl_.unit_;
  _impl_.unit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_UnitSymbolKind* ActivePower::unsafe_arena_release_unit() {
  // @@protoc_insertion_point(field_release:commonmodule.ActivePower.unit)
  
  ::commonmodule::Optional_UnitSymbolKind* temp = _impl_.unit_;
  _impl_.unit_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_UnitSymbolKind* ActivePower::_internal_mutable_unit() {
  
  if (_impl_.unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_UnitSymbolKind>(GetArenaForAllocation());
    _impl_.unit_ = p;
  }
  return _impl_.unit_;
}
inline ::commonmodule::Optional_UnitSymbolKind* ActivePower::mutable_unit() {
  ::commonmodule::Optional_UnitSymbolKind* _msg = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:commonmodule.ActivePower.unit)
  return _msg;
}
inline void ActivePower::set_allocated_unit(::commonmodule::Optional_UnitSymbolKind* unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.unit_;
  }
  if (unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unit);
    if (message_arena != submessage_arena) {
      unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }

  } else {

  }
  _impl_.unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ActivePower.unit)
}

// .google.protobuf.FloatValue value = 3;
inline bool ActivePower::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool ActivePower::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& ActivePower::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& ActivePower::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.ActivePower.value)
  return _internal_value();
}
inline void ActivePower::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ActivePower.value)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ActivePower::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ActivePower::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:commonmodule.ActivePower.value)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ActivePower::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ActivePower::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:commonmodule.ActivePower.value)
  return _msg;
}
inline void ActivePower::set_allocated_value(::PROTOBUF_NAMESPACE_ID::FloatValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }

  } else {

  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ActivePower.value)
}

// -------------------------------------------------------------------

// Optional_PhaseCodeKind

// .commonmodule.PhaseCodeKind value = 1;
inline void Optional_PhaseCodeKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::PhaseCodeKind Optional_PhaseCodeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_PhaseCodeKind.value)
  return _internal_value();
}
inline void Optional_PhaseCodeKind::set_value(::commonmodule::PhaseCodeKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_PhaseCodeKind.value)
}
inline ::commonmodule::PhaseCodeKind Optional_PhaseCodeKind::_internal_value() const {
  return static_cast<::commonmodule::PhaseCodeKind>(_impl_.value_);
}
inline void Optional_PhaseCodeKind::_internal_set_value(::commonmodule::PhaseCodeKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Unit

// .commonmodule.Optional_UnitMultiplierKind multiplier = 1;
inline bool Unit::_internal_has_multiplier() const {
  return this != internal_default_instance() && _impl_.multiplier_ != nullptr;
}
inline bool Unit::has_multiplier() const {
  return _internal_has_multiplier();
}
inline void Unit::clear_multiplier() {
  if (GetArenaForAllocation() == nullptr && _impl_.multiplier_ != nullptr) {
    delete _impl_.multiplier_;
  }
  _impl_.multiplier_ = nullptr;
}
inline const ::commonmodule::Optional_UnitMultiplierKind& Unit::_internal_multiplier() const {
  const ::commonmodule::Optional_UnitMultiplierKind* p = _impl_.multiplier_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_UnitMultiplierKind&>(
      ::commonmodule::_Optional_UnitMultiplierKind_default_instance_);
}
inline const ::commonmodule::Optional_UnitMultiplierKind& Unit::multiplier() const {
  // @@protoc_insertion_point(field_get:commonmodule.Unit.multiplier)
  return _internal_multiplier();
}
inline void Unit::unsafe_arena_set_allocated_multiplier(
    ::commonmodule::Optional_UnitMultiplierKind* multiplier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiplier_);
  }
  _impl_.multiplier_ = multiplier;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.Unit.multiplier)
}
inline ::commonmodule::Optional_UnitMultiplierKind* Unit::release_multiplier() {
  
  ::commonmodule::Optional_UnitMultiplierKind* temp = _impl_.multiplier_;
  _impl_.multiplier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_UnitMultiplierKind* Unit::unsafe_arena_release_multiplier() {
  // @@protoc_insertion_point(field_release:commonmodule.Unit.multiplier)
  
  ::commonmodule::Optional_UnitMultiplierKind* temp = _impl_.multiplier_;
  _impl_.multiplier_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_UnitMultiplierKind* Unit::_internal_mutable_multiplier() {
  
  if (_impl_.multiplier_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_UnitMultiplierKind>(GetArenaForAllocation());
    _impl_.multiplier_ = p;
  }
  return _impl_.multiplier_;
}
inline ::commonmodule::Optional_UnitMultiplierKind* Unit::mutable_multiplier() {
  ::commonmodule::Optional_UnitMultiplierKind* _msg = _internal_mutable_multiplier();
  // @@protoc_insertion_point(field_mutable:commonmodule.Unit.multiplier)
  return _msg;
}
inline void Unit::set_allocated_multiplier(::commonmodule::Optional_UnitMultiplierKind* multiplier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.multiplier_;
  }
  if (multiplier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multiplier);
    if (message_arena != submessage_arena) {
      multiplier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiplier, submessage_arena);
    }

  } else {

  }
  _impl_.multiplier_ = multiplier;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Unit.multiplier)
}

// .commonmodule.UnitSymbolKind SIUnit = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Unit::clear_siunit() {
  _impl_.siunit_ = 0;
}
inline ::commonmodule::UnitSymbolKind Unit::siunit() const {
  // @@protoc_insertion_point(field_get:commonmodule.Unit.SIUnit)
  return _internal_siunit();
}
inline void Unit::set_siunit(::commonmodule::UnitSymbolKind value) {
   _internal_set_siunit(value);
  // @@protoc_insertion_point(field_set:commonmodule.Unit.SIUnit)
}
inline ::commonmodule::UnitSymbolKind Unit::_internal_siunit() const {
  return static_cast<::commonmodule::UnitSymbolKind>(_impl_.siunit_);
}
inline void Unit::_internal_set_siunit(::commonmodule::UnitSymbolKind value) {
  ;
  _impl_.siunit_ = value;
}

// -------------------------------------------------------------------

// Optional_ValidityKind

// .commonmodule.ValidityKind value = 1;
inline void Optional_ValidityKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::ValidityKind Optional_ValidityKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_ValidityKind.value)
  return _internal_value();
}
inline void Optional_ValidityKind::set_value(::commonmodule::ValidityKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_ValidityKind.value)
}
inline ::commonmodule::ValidityKind Optional_ValidityKind::_internal_value() const {
  return static_cast<::commonmodule::ValidityKind>(_impl_.value_);
}
inline void Optional_ValidityKind::_internal_set_value(::commonmodule::ValidityKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// DetailQual

// bool badReference = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_badreference() {
  _impl_.badreference_ = false;
}
inline bool DetailQual::badreference() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.badReference)
  return _internal_badreference();
}
inline void DetailQual::set_badreference(bool value) {
  _internal_set_badreference(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.badReference)
}
inline bool DetailQual::_internal_badreference() const {
  return _impl_.badreference_;
}
inline void DetailQual::_internal_set_badreference(bool value) {
  ;
  _impl_.badreference_ = value;
}

// bool failure = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_failure() {
  _impl_.failure_ = false;
}
inline bool DetailQual::failure() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.failure)
  return _internal_failure();
}
inline void DetailQual::set_failure(bool value) {
  _internal_set_failure(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.failure)
}
inline bool DetailQual::_internal_failure() const {
  return _impl_.failure_;
}
inline void DetailQual::_internal_set_failure(bool value) {
  ;
  _impl_.failure_ = value;
}

// bool inaccurate = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_inaccurate() {
  _impl_.inaccurate_ = false;
}
inline bool DetailQual::inaccurate() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.inaccurate)
  return _internal_inaccurate();
}
inline void DetailQual::set_inaccurate(bool value) {
  _internal_set_inaccurate(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.inaccurate)
}
inline bool DetailQual::_internal_inaccurate() const {
  return _impl_.inaccurate_;
}
inline void DetailQual::_internal_set_inaccurate(bool value) {
  ;
  _impl_.inaccurate_ = value;
}

// bool inconsistent = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_inconsistent() {
  _impl_.inconsistent_ = false;
}
inline bool DetailQual::inconsistent() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.inconsistent)
  return _internal_inconsistent();
}
inline void DetailQual::set_inconsistent(bool value) {
  _internal_set_inconsistent(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.inconsistent)
}
inline bool DetailQual::_internal_inconsistent() const {
  return _impl_.inconsistent_;
}
inline void DetailQual::_internal_set_inconsistent(bool value) {
  ;
  _impl_.inconsistent_ = value;
}

// bool oldData = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_olddata() {
  _impl_.olddata_ = false;
}
inline bool DetailQual::olddata() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.oldData)
  return _internal_olddata();
}
inline void DetailQual::set_olddata(bool value) {
  _internal_set_olddata(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.oldData)
}
inline bool DetailQual::_internal_olddata() const {
  return _impl_.olddata_;
}
inline void DetailQual::_internal_set_olddata(bool value) {
  ;
  _impl_.olddata_ = value;
}

// bool oscillatory = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_oscillatory() {
  _impl_.oscillatory_ = false;
}
inline bool DetailQual::oscillatory() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.oscillatory)
  return _internal_oscillatory();
}
inline void DetailQual::set_oscillatory(bool value) {
  _internal_set_oscillatory(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.oscillatory)
}
inline bool DetailQual::_internal_oscillatory() const {
  return _impl_.oscillatory_;
}
inline void DetailQual::_internal_set_oscillatory(bool value) {
  ;
  _impl_.oscillatory_ = value;
}

// bool outOfRange = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_outofrange() {
  _impl_.outofrange_ = false;
}
inline bool DetailQual::outofrange() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.outOfRange)
  return _internal_outofrange();
}
inline void DetailQual::set_outofrange(bool value) {
  _internal_set_outofrange(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.outOfRange)
}
inline bool DetailQual::_internal_outofrange() const {
  return _impl_.outofrange_;
}
inline void DetailQual::_internal_set_outofrange(bool value) {
  ;
  _impl_.outofrange_ = value;
}

// bool overflow = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void DetailQual::clear_overflow() {
  _impl_.overflow_ = false;
}
inline bool DetailQual::overflow() const {
  // @@protoc_insertion_point(field_get:commonmodule.DetailQual.overflow)
  return _internal_overflow();
}
inline void DetailQual::set_overflow(bool value) {
  _internal_set_overflow(value);
  // @@protoc_insertion_point(field_set:commonmodule.DetailQual.overflow)
}
inline bool DetailQual::_internal_overflow() const {
  return _impl_.overflow_;
}
inline void DetailQual::_internal_set_overflow(bool value) {
  ;
  _impl_.overflow_ = value;
}

// -------------------------------------------------------------------

// Optional_SourceKind

// .commonmodule.SourceKind value = 1;
inline void Optional_SourceKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::SourceKind Optional_SourceKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_SourceKind.value)
  return _internal_value();
}
inline void Optional_SourceKind::set_value(::commonmodule::SourceKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_SourceKind.value)
}
inline ::commonmodule::SourceKind Optional_SourceKind::_internal_value() const {
  return static_cast<::commonmodule::SourceKind>(_impl_.value_);
}
inline void Optional_SourceKind::_internal_set_value(::commonmodule::SourceKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Quality

// .commonmodule.DetailQual detailQual = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool Quality::_internal_has_detailqual() const {
  return this != internal_default_instance() && _impl_.detailqual_ != nullptr;
}
inline bool Quality::has_detailqual() const {
  return _internal_has_detailqual();
}
inline void Quality::clear_detailqual() {
  if (GetArenaForAllocation() == nullptr && _impl_.detailqual_ != nullptr) {
    delete _impl_.detailqual_;
  }
  _impl_.detailqual_ = nullptr;
}
inline const ::commonmodule::DetailQual& Quality::_internal_detailqual() const {
  const ::commonmodule::DetailQual* p = _impl_.detailqual_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::DetailQual&>(
      ::commonmodule::_DetailQual_default_instance_);
}
inline const ::commonmodule::DetailQual& Quality::detailqual() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.detailQual)
  return _internal_detailqual();
}
inline void Quality::unsafe_arena_set_allocated_detailqual(
    ::commonmodule::DetailQual* detailqual) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detailqual_);
  }
  _impl_.detailqual_ = detailqual;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.Quality.detailQual)
}
inline ::commonmodule::DetailQual* Quality::release_detailqual() {
  
  ::commonmodule::DetailQual* temp = _impl_.detailqual_;
  _impl_.detailqual_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::DetailQual* Quality::unsafe_arena_release_detailqual() {
  // @@protoc_insertion_point(field_release:commonmodule.Quality.detailQual)
  
  ::commonmodule::DetailQual* temp = _impl_.detailqual_;
  _impl_.detailqual_ = nullptr;
  return temp;
}
inline ::commonmodule::DetailQual* Quality::_internal_mutable_detailqual() {
  
  if (_impl_.detailqual_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::DetailQual>(GetArenaForAllocation());
    _impl_.detailqual_ = p;
  }
  return _impl_.detailqual_;
}
inline ::commonmodule::DetailQual* Quality::mutable_detailqual() {
  ::commonmodule::DetailQual* _msg = _internal_mutable_detailqual();
  // @@protoc_insertion_point(field_mutable:commonmodule.Quality.detailQual)
  return _msg;
}
inline void Quality::set_allocated_detailqual(::commonmodule::DetailQual* detailqual) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.detailqual_;
  }
  if (detailqual) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(detailqual);
    if (message_arena != submessage_arena) {
      detailqual = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detailqual, submessage_arena);
    }

  } else {

  }
  _impl_.detailqual_ = detailqual;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Quality.detailQual)
}

// bool operatorBlocked = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_operatorblocked() {
  _impl_.operatorblocked_ = false;
}
inline bool Quality::operatorblocked() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.operatorBlocked)
  return _internal_operatorblocked();
}
inline void Quality::set_operatorblocked(bool value) {
  _internal_set_operatorblocked(value);
  // @@protoc_insertion_point(field_set:commonmodule.Quality.operatorBlocked)
}
inline bool Quality::_internal_operatorblocked() const {
  return _impl_.operatorblocked_;
}
inline void Quality::_internal_set_operatorblocked(bool value) {
  ;
  _impl_.operatorblocked_ = value;
}

// .commonmodule.SourceKind source = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_source() {
  _impl_.source_ = 0;
}
inline ::commonmodule::SourceKind Quality::source() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.source)
  return _internal_source();
}
inline void Quality::set_source(::commonmodule::SourceKind value) {
   _internal_set_source(value);
  // @@protoc_insertion_point(field_set:commonmodule.Quality.source)
}
inline ::commonmodule::SourceKind Quality::_internal_source() const {
  return static_cast<::commonmodule::SourceKind>(_impl_.source_);
}
inline void Quality::_internal_set_source(::commonmodule::SourceKind value) {
  ;
  _impl_.source_ = value;
}

// bool test = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_test() {
  _impl_.test_ = false;
}
inline bool Quality::test() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.test)
  return _internal_test();
}
inline void Quality::set_test(bool value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:commonmodule.Quality.test)
}
inline bool Quality::_internal_test() const {
  return _impl_.test_;
}
inline void Quality::_internal_set_test(bool value) {
  ;
  _impl_.test_ = value;
}

// .commonmodule.ValidityKind validity = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Quality::clear_validity() {
  _impl_.validity_ = 0;
}
inline ::commonmodule::ValidityKind Quality::validity() const {
  // @@protoc_insertion_point(field_get:commonmodule.Quality.validity)
  return _internal_validity();
}
inline void Quality::set_validity(::commonmodule::ValidityKind value) {
   _internal_set_validity(value);
  // @@protoc_insertion_point(field_set:commonmodule.Quality.validity)
}
inline ::commonmodule::ValidityKind Quality::_internal_validity() const {
  return static_cast<::commonmodule::ValidityKind>(_impl_.validity_);
}
inline void Quality::_internal_set_validity(::commonmodule::ValidityKind value) {
  ;
  _impl_.validity_ = value;
}

// -------------------------------------------------------------------

// Optional_TimeAccuracyKind

// .commonmodule.TimeAccuracyKind value = 1;
inline void Optional_TimeAccuracyKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::TimeAccuracyKind Optional_TimeAccuracyKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_TimeAccuracyKind.value)
  return _internal_value();
}
inline void Optional_TimeAccuracyKind::set_value(::commonmodule::TimeAccuracyKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_TimeAccuracyKind.value)
}
inline ::commonmodule::TimeAccuracyKind Optional_TimeAccuracyKind::_internal_value() const {
  return static_cast<::commonmodule::TimeAccuracyKind>(_impl_.value_);
}
inline void Optional_TimeAccuracyKind::_internal_set_value(::commonmodule::TimeAccuracyKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// TimeQuality

// bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_clockfailure() {
  _impl_.clockfailure_ = false;
}
inline bool TimeQuality::clockfailure() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.clockFailure)
  return _internal_clockfailure();
}
inline void TimeQuality::set_clockfailure(bool value) {
  _internal_set_clockfailure(value);
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.clockFailure)
}
inline bool TimeQuality::_internal_clockfailure() const {
  return _impl_.clockfailure_;
}
inline void TimeQuality::_internal_set_clockfailure(bool value) {
  ;
  _impl_.clockfailure_ = value;
}

// bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_clocknotsynchronized() {
  _impl_.clocknotsynchronized_ = false;
}
inline bool TimeQuality::clocknotsynchronized() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.clockNotSynchronized)
  return _internal_clocknotsynchronized();
}
inline void TimeQuality::set_clocknotsynchronized(bool value) {
  _internal_set_clocknotsynchronized(value);
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.clockNotSynchronized)
}
inline bool TimeQuality::_internal_clocknotsynchronized() const {
  return _impl_.clocknotsynchronized_;
}
inline void TimeQuality::_internal_set_clocknotsynchronized(bool value) {
  ;
  _impl_.clocknotsynchronized_ = value;
}

// bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_leapsecondsknown() {
  _impl_.leapsecondsknown_ = false;
}
inline bool TimeQuality::leapsecondsknown() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.leapSecondsKnown)
  return _internal_leapsecondsknown();
}
inline void TimeQuality::set_leapsecondsknown(bool value) {
  _internal_set_leapsecondsknown(value);
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.leapSecondsKnown)
}
inline bool TimeQuality::_internal_leapsecondsknown() const {
  return _impl_.leapsecondsknown_;
}
inline void TimeQuality::_internal_set_leapsecondsknown(bool value) {
  ;
  _impl_.leapsecondsknown_ = value;
}

// .commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TimeQuality::clear_timeaccuracy() {
  _impl_.timeaccuracy_ = 0;
}
inline ::commonmodule::TimeAccuracyKind TimeQuality::timeaccuracy() const {
  // @@protoc_insertion_point(field_get:commonmodule.TimeQuality.timeAccuracy)
  return _internal_timeaccuracy();
}
inline void TimeQuality::set_timeaccuracy(::commonmodule::TimeAccuracyKind value) {
   _internal_set_timeaccuracy(value);
  // @@protoc_insertion_point(field_set:commonmodule.TimeQuality.timeAccuracy)
}
inline ::commonmodule::TimeAccuracyKind TimeQuality::_internal_timeaccuracy() const {
  return static_cast<::commonmodule::TimeAccuracyKind>(_impl_.timeaccuracy_);
}
inline void TimeQuality::_internal_set_timeaccuracy(::commonmodule::TimeAccuracyKind value) {
  ;
  _impl_.timeaccuracy_ = value;
}

// -------------------------------------------------------------------

// Timestamp

// uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Timestamp::clear_seconds() {
  _impl_.seconds_ = ::uint64_t{0u};
}
inline ::uint64_t Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.Timestamp.seconds)
  return _internal_seconds();
}
inline void Timestamp::set_seconds(::uint64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.Timestamp.seconds)
}
inline ::uint64_t Timestamp::_internal_seconds() const {
  return _impl_.seconds_;
}
inline void Timestamp::_internal_set_seconds(::uint64_t value) {
  ;
  _impl_.seconds_ = value;
}

// .commonmodule.TimeQuality tq = 3;
inline bool Timestamp::_internal_has_tq() const {
  return this != internal_default_instance() && _impl_.tq_ != nullptr;
}
inline bool Timestamp::has_tq() const {
  return _internal_has_tq();
}
inline void Timestamp::clear_tq() {
  if (GetArenaForAllocation() == nullptr && _impl_.tq_ != nullptr) {
    delete _impl_.tq_;
  }
  _impl_.tq_ = nullptr;
}
inline const ::commonmodule::TimeQuality& Timestamp::_internal_tq() const {
  const ::commonmodule::TimeQuality* p = _impl_.tq_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TimeQuality&>(
      ::commonmodule::_TimeQuality_default_instance_);
}
inline const ::commonmodule::TimeQuality& Timestamp::tq() const {
  // @@protoc_insertion_point(field_get:commonmodule.Timestamp.tq)
  return _internal_tq();
}
inline void Timestamp::unsafe_arena_set_allocated_tq(
    ::commonmodule::TimeQuality* tq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tq_);
  }
  _impl_.tq_ = tq;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.Timestamp.tq)
}
inline ::commonmodule::TimeQuality* Timestamp::release_tq() {
  
  ::commonmodule::TimeQuality* temp = _impl_.tq_;
  _impl_.tq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TimeQuality* Timestamp::unsafe_arena_release_tq() {
  // @@protoc_insertion_point(field_release:commonmodule.Timestamp.tq)
  
  ::commonmodule::TimeQuality* temp = _impl_.tq_;
  _impl_.tq_ = nullptr;
  return temp;
}
inline ::commonmodule::TimeQuality* Timestamp::_internal_mutable_tq() {
  
  if (_impl_.tq_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TimeQuality>(GetArenaForAllocation());
    _impl_.tq_ = p;
  }
  return _impl_.tq_;
}
inline ::commonmodule::TimeQuality* Timestamp::mutable_tq() {
  ::commonmodule::TimeQuality* _msg = _internal_mutable_tq();
  // @@protoc_insertion_point(field_mutable:commonmodule.Timestamp.tq)
  return _msg;
}
inline void Timestamp::set_allocated_tq(::commonmodule::TimeQuality* tq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tq_;
  }
  if (tq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tq);
    if (message_arena != submessage_arena) {
      tq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tq, submessage_arena);
    }

  } else {

  }
  _impl_.tq_ = tq;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Timestamp.tq)
}

// uint32 nanoseconds = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Timestamp::clear_nanoseconds() {
  _impl_.nanoseconds_ = 0u;
}
inline ::uint32_t Timestamp::nanoseconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.Timestamp.nanoseconds)
  return _internal_nanoseconds();
}
inline void Timestamp::set_nanoseconds(::uint32_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.Timestamp.nanoseconds)
}
inline ::uint32_t Timestamp::_internal_nanoseconds() const {
  return _impl_.nanoseconds_;
}
inline void Timestamp::_internal_set_nanoseconds(::uint32_t value) {
  ;
  _impl_.nanoseconds_ = value;
}

// -------------------------------------------------------------------

// MV

// double mag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void MV::clear_mag() {
  _impl_.mag_ = 0;
}
inline double MV::mag() const {
  // @@protoc_insertion_point(field_get:commonmodule.MV.mag)
  return _internal_mag();
}
inline void MV::set_mag(double value) {
  _internal_set_mag(value);
  // @@protoc_insertion_point(field_set:commonmodule.MV.mag)
}
inline double MV::_internal_mag() const {
  return _impl_.mag_;
}
inline void MV::_internal_set_mag(double value) {
  ;
  _impl_.mag_ = value;
}

// .commonmodule.Quality q = 2;
inline bool MV::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool MV::has_q() const {
  return _internal_has_q();
}
inline void MV::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& MV::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& MV::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.MV.q)
  return _internal_q();
}
inline void MV::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.MV.q)
}
inline ::commonmodule::Quality* MV::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* MV::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.MV.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* MV::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* MV::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.MV.q)
  return _msg;
}
inline void MV::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MV.q)
}

// .commonmodule.Timestamp t = 3;
inline bool MV::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool MV::has_t() const {
  return _internal_has_t();
}
inline void MV::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& MV::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& MV::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.MV.t)
  return _internal_t();
}
inline void MV::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.MV.t)
}
inline ::commonmodule::Timestamp* MV::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* MV::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.MV.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* MV::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* MV::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.MV.t)
  return _msg;
}
inline void MV::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MV.t)
}

// .commonmodule.Unit units = 4;
inline bool MV::_internal_has_units() const {
  return this != internal_default_instance() && _impl_.units_ != nullptr;
}
inline bool MV::has_units() const {
  return _internal_has_units();
}
inline void MV::clear_units() {
  if (GetArenaForAllocation() == nullptr && _impl_.units_ != nullptr) {
    delete _impl_.units_;
  }
  _impl_.units_ = nullptr;
}
inline const ::commonmodule::Unit& MV::_internal_units() const {
  const ::commonmodule::Unit* p = _impl_.units_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Unit&>(
      ::commonmodule::_Unit_default_instance_);
}
inline const ::commonmodule::Unit& MV::units() const {
  // @@protoc_insertion_point(field_get:commonmodule.MV.units)
  return _internal_units();
}
inline void MV::unsafe_arena_set_allocated_units(
    ::commonmodule::Unit* units) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.units_);
  }
  _impl_.units_ = units;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.MV.units)
}
inline ::commonmodule::Unit* MV::release_units() {
  
  ::commonmodule::Unit* temp = _impl_.units_;
  _impl_.units_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Unit* MV::unsafe_arena_release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.MV.units)
  
  ::commonmodule::Unit* temp = _impl_.units_;
  _impl_.units_ = nullptr;
  return temp;
}
inline ::commonmodule::Unit* MV::_internal_mutable_units() {
  
  if (_impl_.units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Unit>(GetArenaForAllocation());
    _impl_.units_ = p;
  }
  return _impl_.units_;
}
inline ::commonmodule::Unit* MV::mutable_units() {
  ::commonmodule::Unit* _msg = _internal_mutable_units();
  // @@protoc_insertion_point(field_mutable:commonmodule.MV.units)
  return _msg;
}
inline void MV::set_allocated_units(::commonmodule::Unit* units) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.units_;
  }
  if (units) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(units);
    if (message_arena != submessage_arena) {
      units = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }

  } else {

  }
  _impl_.units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MV.units)
}

// -------------------------------------------------------------------

// LogicalNode

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool LogicalNode::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool LogicalNode::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void LogicalNode::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& LogicalNode::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& LogicalNode::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNode.identifiedObject)
  return _internal_identifiedobject();
}
inline void LogicalNode::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LogicalNode.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* LogicalNode::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* LogicalNode::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNode.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* LogicalNode::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* LogicalNode::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNode.identifiedObject)
  return _msg;
}
inline void LogicalNode::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNode.identifiedObject)
}

// -------------------------------------------------------------------

// AnalogEventAndStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool AnalogEventAndStatusGGIO::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool AnalogEventAndStatusGGIO::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void AnalogEventAndStatusGGIO::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& AnalogEventAndStatusGGIO::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& AnalogEventAndStatusGGIO::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.AnalogEventAndStatusGGIO.logicalNode)
  return _internal_logicalnode();
}
inline void AnalogEventAndStatusGGIO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.AnalogEventAndStatusGGIO.logicalNode)
}
inline ::commonmodule::LogicalNode* AnalogEventAndStatusGGIO::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* AnalogEventAndStatusGGIO::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogEventAndStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* AnalogEventAndStatusGGIO::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* AnalogEventAndStatusGGIO::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogEventAndStatusGGIO.logicalNode)
  return _msg;
}
inline void AnalogEventAndStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogEventAndStatusGGIO.logicalNode)
}

// .commonmodule.MV AnIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool AnalogEventAndStatusGGIO::_internal_has_anin() const {
  return this != internal_default_instance() && _impl_.anin_ != nullptr;
}
inline bool AnalogEventAndStatusGGIO::has_anin() const {
  return _internal_has_anin();
}
inline void AnalogEventAndStatusGGIO::clear_anin() {
  if (GetArenaForAllocation() == nullptr && _impl_.anin_ != nullptr) {
    delete _impl_.anin_;
  }
  _impl_.anin_ = nullptr;
}
inline const ::commonmodule::MV& AnalogEventAndStatusGGIO::_internal_anin() const {
  const ::commonmodule::MV* p = _impl_.anin_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& AnalogEventAndStatusGGIO::anin() const {
  // @@protoc_insertion_point(field_get:commonmodule.AnalogEventAndStatusGGIO.AnIn)
  return _internal_anin();
}
inline void AnalogEventAndStatusGGIO::unsafe_arena_set_allocated_anin(
    ::commonmodule::MV* anin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.anin_);
  }
  _impl_.anin_ = anin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.AnalogEventAndStatusGGIO.AnIn)
}
inline ::commonmodule::MV* AnalogEventAndStatusGGIO::release_anin() {
  
  ::commonmodule::MV* temp = _impl_.anin_;
  _impl_.anin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* AnalogEventAndStatusGGIO::unsafe_arena_release_anin() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogEventAndStatusGGIO.AnIn)
  
  ::commonmodule::MV* temp = _impl_.anin_;
  _impl_.anin_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* AnalogEventAndStatusGGIO::_internal_mutable_anin() {
  
  if (_impl_.anin_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.anin_ = p;
  }
  return _impl_.anin_;
}
inline ::commonmodule::MV* AnalogEventAndStatusGGIO::mutable_anin() {
  ::commonmodule::MV* _msg = _internal_mutable_anin();
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogEventAndStatusGGIO.AnIn)
  return _msg;
}
inline void AnalogEventAndStatusGGIO::set_allocated_anin(::commonmodule::MV* anin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.anin_;
  }
  if (anin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(anin);
    if (message_arena != submessage_arena) {
      anin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anin, submessage_arena);
    }

  } else {

  }
  _impl_.anin_ = anin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogEventAndStatusGGIO.AnIn)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 3;
inline bool AnalogEventAndStatusGGIO::_internal_has_phase() const {
  return this != internal_default_instance() && _impl_.phase_ != nullptr;
}
inline bool AnalogEventAndStatusGGIO::has_phase() const {
  return _internal_has_phase();
}
inline void AnalogEventAndStatusGGIO::clear_phase() {
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& AnalogEventAndStatusGGIO::_internal_phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = _impl_.phase_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind&>(
      ::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseCodeKind& AnalogEventAndStatusGGIO::phase() const {
  // @@protoc_insertion_point(field_get:commonmodule.AnalogEventAndStatusGGIO.Phase)
  return _internal_phase();
}
inline void AnalogEventAndStatusGGIO::unsafe_arena_set_allocated_phase(
    ::commonmodule::Optional_PhaseCodeKind* phase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phase_);
  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.AnalogEventAndStatusGGIO.Phase)
}
inline ::commonmodule::Optional_PhaseCodeKind* AnalogEventAndStatusGGIO::release_phase() {
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* AnalogEventAndStatusGGIO::unsafe_arena_release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.AnalogEventAndStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* AnalogEventAndStatusGGIO::_internal_mutable_phase() {
  
  if (_impl_.phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaForAllocation());
    _impl_.phase_ = p;
  }
  return _impl_.phase_;
}
inline ::commonmodule::Optional_PhaseCodeKind* AnalogEventAndStatusGGIO::mutable_phase() {
  ::commonmodule::Optional_PhaseCodeKind* _msg = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:commonmodule.AnalogEventAndStatusGGIO.Phase)
  return _msg;
}
inline void AnalogEventAndStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phase_;
  }
  if (phase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phase);
    if (message_arena != submessage_arena) {
      phase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }

  } else {

  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.AnalogEventAndStatusGGIO.Phase)
}

// -------------------------------------------------------------------

// NamedObject

// .google.protobuf.StringValue description = 1;
inline bool NamedObject::_internal_has_description() const {
  return this != internal_default_instance() && _impl_.description_ != nullptr;
}
inline bool NamedObject::has_description() const {
  return _internal_has_description();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NamedObject::_internal_description() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.description_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NamedObject::description() const {
  // @@protoc_insertion_point(field_get:commonmodule.NamedObject.description)
  return _internal_description();
}
inline void NamedObject::unsafe_arena_set_allocated_description(
    ::PROTOBUF_NAMESPACE_ID::StringValue* description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_);
  }
  _impl_.description_ = description;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.NamedObject.description)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::release_description() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.description_;
  _impl_.description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_release:commonmodule.NamedObject.description)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.description_;
  _impl_.description_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::_internal_mutable_description() {
  
  if (_impl_.description_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.description_ = p;
  }
  return _impl_.description_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::mutable_description() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:commonmodule.NamedObject.description)
  return _msg;
}
inline void NamedObject::set_allocated_description(::PROTOBUF_NAMESPACE_ID::StringValue* description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_);
  }
  if (description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(description));
    if (message_arena != submessage_arena) {
      description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }

  } else {

  }
  _impl_.description_ = description;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NamedObject.description)
}

// .google.protobuf.StringValue name = 2;
inline bool NamedObject::_internal_has_name() const {
  return this != internal_default_instance() && _impl_.name_ != nullptr;
}
inline bool NamedObject::has_name() const {
  return _internal_has_name();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NamedObject::_internal_name() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NamedObject::name() const {
  // @@protoc_insertion_point(field_get:commonmodule.NamedObject.name)
  return _internal_name();
}
inline void NamedObject::unsafe_arena_set_allocated_name(
    ::PROTOBUF_NAMESPACE_ID::StringValue* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.NamedObject.name)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::release_name() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:commonmodule.NamedObject.name)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::_internal_mutable_name() {
  
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NamedObject::mutable_name() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:commonmodule.NamedObject.name)
  return _msg;
}
inline void NamedObject::set_allocated_name(::PROTOBUF_NAMESPACE_ID::StringValue* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }

  } else {

  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NamedObject.name)
}

// -------------------------------------------------------------------

// ApplicationSystem

// .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
inline bool ApplicationSystem::_internal_has_namedobject() const {
  return this != internal_default_instance() && _impl_.namedobject_ != nullptr;
}
inline bool ApplicationSystem::has_namedobject() const {
  return _internal_has_namedobject();
}
inline void ApplicationSystem::clear_namedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.namedobject_ != nullptr) {
    delete _impl_.namedobject_;
  }
  _impl_.namedobject_ = nullptr;
}
inline const ::commonmodule::NamedObject& ApplicationSystem::_internal_namedobject() const {
  const ::commonmodule::NamedObject* p = _impl_.namedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::NamedObject&>(
      ::commonmodule::_NamedObject_default_instance_);
}
inline const ::commonmodule::NamedObject& ApplicationSystem::namedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.ApplicationSystem.namedObject)
  return _internal_namedobject();
}
inline void ApplicationSystem::unsafe_arena_set_allocated_namedobject(
    ::commonmodule::NamedObject* namedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.namedobject_);
  }
  _impl_.namedobject_ = namedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ApplicationSystem.namedObject)
}
inline ::commonmodule::NamedObject* ApplicationSystem::release_namedobject() {
  
  ::commonmodule::NamedObject* temp = _impl_.namedobject_;
  _impl_.namedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::NamedObject* ApplicationSystem::unsafe_arena_release_namedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ApplicationSystem.namedObject)
  
  ::commonmodule::NamedObject* temp = _impl_.namedobject_;
  _impl_.namedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::NamedObject* ApplicationSystem::_internal_mutable_namedobject() {
  
  if (_impl_.namedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::NamedObject>(GetArenaForAllocation());
    _impl_.namedobject_ = p;
  }
  return _impl_.namedobject_;
}
inline ::commonmodule::NamedObject* ApplicationSystem::mutable_namedobject() {
  ::commonmodule::NamedObject* _msg = _internal_mutable_namedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.ApplicationSystem.namedObject)
  return _msg;
}
inline void ApplicationSystem::set_allocated_namedobject(::commonmodule::NamedObject* namedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.namedobject_;
  }
  if (namedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(namedobject);
    if (message_arena != submessage_arena) {
      namedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namedobject, submessage_arena);
    }

  } else {

  }
  _impl_.namedobject_ = namedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ApplicationSystem.namedObject)
}

// string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true];
inline void ApplicationSystem::clear_mrid() {
  _impl_.mrid_.ClearToEmpty();
}
inline const std::string& ApplicationSystem::mrid() const {
  // @@protoc_insertion_point(field_get:commonmodule.ApplicationSystem.mRID)
  return _internal_mrid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApplicationSystem::set_mrid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mrid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commonmodule.ApplicationSystem.mRID)
}
inline std::string* ApplicationSystem::mutable_mrid() {
  std::string* _s = _internal_mutable_mrid();
  // @@protoc_insertion_point(field_mutable:commonmodule.ApplicationSystem.mRID)
  return _s;
}
inline const std::string& ApplicationSystem::_internal_mrid() const {
  return _impl_.mrid_.Get();
}
inline void ApplicationSystem::_internal_set_mrid(const std::string& value) {
  ;


  _impl_.mrid_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplicationSystem::_internal_mutable_mrid() {
  ;
  return _impl_.mrid_.Mutable( GetArenaForAllocation());
}
inline std::string* ApplicationSystem::release_mrid() {
  // @@protoc_insertion_point(field_release:commonmodule.ApplicationSystem.mRID)
  return _impl_.mrid_.Release();
}
inline void ApplicationSystem::set_allocated_mrid(std::string* value) {
  _impl_.mrid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mrid_.IsDefault()) {
          _impl_.mrid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ApplicationSystem.mRID)
}

// -------------------------------------------------------------------

// ASG

// double setMag = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ASG::clear_setmag() {
  _impl_.setmag_ = 0;
}
inline double ASG::setmag() const {
  // @@protoc_insertion_point(field_get:commonmodule.ASG.setMag)
  return _internal_setmag();
}
inline void ASG::set_setmag(double value) {
  _internal_set_setmag(value);
  // @@protoc_insertion_point(field_set:commonmodule.ASG.setMag)
}
inline double ASG::_internal_setmag() const {
  return _impl_.setmag_;
}
inline void ASG::_internal_set_setmag(double value) {
  ;
  _impl_.setmag_ = value;
}

// -------------------------------------------------------------------

// BCR

// int64 actVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void BCR::clear_actval() {
  _impl_.actval_ = ::int64_t{0};
}
inline ::int64_t BCR::actval() const {
  // @@protoc_insertion_point(field_get:commonmodule.BCR.actVal)
  return _internal_actval();
}
inline void BCR::set_actval(::int64_t value) {
  _internal_set_actval(value);
  // @@protoc_insertion_point(field_set:commonmodule.BCR.actVal)
}
inline ::int64_t BCR::_internal_actval() const {
  return _impl_.actval_;
}
inline void BCR::_internal_set_actval(::int64_t value) {
  ;
  _impl_.actval_ = value;
}

// .commonmodule.Quality q = 2;
inline bool BCR::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool BCR::has_q() const {
  return _internal_has_q();
}
inline void BCR::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& BCR::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& BCR::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.BCR.q)
  return _internal_q();
}
inline void BCR::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.BCR.q)
}
inline ::commonmodule::Quality* BCR::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* BCR::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.BCR.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* BCR::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* BCR::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.BCR.q)
  return _msg;
}
inline void BCR::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BCR.q)
}

// .commonmodule.Timestamp t = 3;
inline bool BCR::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool BCR::has_t() const {
  return _internal_has_t();
}
inline void BCR::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& BCR::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& BCR::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.BCR.t)
  return _internal_t();
}
inline void BCR::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.BCR.t)
}
inline ::commonmodule::Timestamp* BCR::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* BCR::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.BCR.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* BCR::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* BCR::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.BCR.t)
  return _msg;
}
inline void BCR::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BCR.t)
}

// -------------------------------------------------------------------

// StatusSPS

// .commonmodule.Quality q = 1;
inline bool StatusSPS::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool StatusSPS::has_q() const {
  return _internal_has_q();
}
inline void StatusSPS::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusSPS::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& StatusSPS::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPS.q)
  return _internal_q();
}
inline void StatusSPS::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusSPS.q)
}
inline ::commonmodule::Quality* StatusSPS::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* StatusSPS::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusSPS.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusSPS::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* StatusSPS::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusSPS.q)
  return _msg;
}
inline void StatusSPS::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusSPS.q)
}

// bool stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusSPS::clear_stval() {
  _impl_.stval_ = false;
}
inline bool StatusSPS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPS.stVal)
  return _internal_stval();
}
inline void StatusSPS::set_stval(bool value) {
  _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.StatusSPS.stVal)
}
inline bool StatusSPS::_internal_stval() const {
  return _impl_.stval_;
}
inline void StatusSPS::_internal_set_stval(bool value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool StatusSPS::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool StatusSPS::has_t() const {
  return _internal_has_t();
}
inline void StatusSPS::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusSPS::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& StatusSPS::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusSPS.t)
  return _internal_t();
}
inline void StatusSPS::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusSPS.t)
}
inline ::commonmodule::Timestamp* StatusSPS::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* StatusSPS::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusSPS.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusSPS::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* StatusSPS::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusSPS.t)
  return _msg;
}
inline void StatusSPS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusSPS.t)
}

// -------------------------------------------------------------------

// BooleanEventAndStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool BooleanEventAndStatusGGIO::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool BooleanEventAndStatusGGIO::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void BooleanEventAndStatusGGIO::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& BooleanEventAndStatusGGIO::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& BooleanEventAndStatusGGIO::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.BooleanEventAndStatusGGIO.logicalNode)
  return _internal_logicalnode();
}
inline void BooleanEventAndStatusGGIO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.BooleanEventAndStatusGGIO.logicalNode)
}
inline ::commonmodule::LogicalNode* BooleanEventAndStatusGGIO::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* BooleanEventAndStatusGGIO::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.BooleanEventAndStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* BooleanEventAndStatusGGIO::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* BooleanEventAndStatusGGIO::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.BooleanEventAndStatusGGIO.logicalNode)
  return _msg;
}
inline void BooleanEventAndStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BooleanEventAndStatusGGIO.logicalNode)
}

// .commonmodule.StatusSPS Ind = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool BooleanEventAndStatusGGIO::_internal_has_ind() const {
  return this != internal_default_instance() && _impl_.ind_ != nullptr;
}
inline bool BooleanEventAndStatusGGIO::has_ind() const {
  return _internal_has_ind();
}
inline void BooleanEventAndStatusGGIO::clear_ind() {
  if (GetArenaForAllocation() == nullptr && _impl_.ind_ != nullptr) {
    delete _impl_.ind_;
  }
  _impl_.ind_ = nullptr;
}
inline const ::commonmodule::StatusSPS& BooleanEventAndStatusGGIO::_internal_ind() const {
  const ::commonmodule::StatusSPS* p = _impl_.ind_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& BooleanEventAndStatusGGIO::ind() const {
  // @@protoc_insertion_point(field_get:commonmodule.BooleanEventAndStatusGGIO.Ind)
  return _internal_ind();
}
inline void BooleanEventAndStatusGGIO::unsafe_arena_set_allocated_ind(
    ::commonmodule::StatusSPS* ind) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ind_);
  }
  _impl_.ind_ = ind;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.BooleanEventAndStatusGGIO.Ind)
}
inline ::commonmodule::StatusSPS* BooleanEventAndStatusGGIO::release_ind() {
  
  ::commonmodule::StatusSPS* temp = _impl_.ind_;
  _impl_.ind_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* BooleanEventAndStatusGGIO::unsafe_arena_release_ind() {
  // @@protoc_insertion_point(field_release:commonmodule.BooleanEventAndStatusGGIO.Ind)
  
  ::commonmodule::StatusSPS* temp = _impl_.ind_;
  _impl_.ind_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* BooleanEventAndStatusGGIO::_internal_mutable_ind() {
  
  if (_impl_.ind_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.ind_ = p;
  }
  return _impl_.ind_;
}
inline ::commonmodule::StatusSPS* BooleanEventAndStatusGGIO::mutable_ind() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_ind();
  // @@protoc_insertion_point(field_mutable:commonmodule.BooleanEventAndStatusGGIO.Ind)
  return _msg;
}
inline void BooleanEventAndStatusGGIO::set_allocated_ind(::commonmodule::StatusSPS* ind) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ind_;
  }
  if (ind) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ind);
    if (message_arena != submessage_arena) {
      ind = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ind, submessage_arena);
    }

  } else {

  }
  _impl_.ind_ = ind;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BooleanEventAndStatusGGIO.Ind)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 3;
inline bool BooleanEventAndStatusGGIO::_internal_has_phase() const {
  return this != internal_default_instance() && _impl_.phase_ != nullptr;
}
inline bool BooleanEventAndStatusGGIO::has_phase() const {
  return _internal_has_phase();
}
inline void BooleanEventAndStatusGGIO::clear_phase() {
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& BooleanEventAndStatusGGIO::_internal_phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = _impl_.phase_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind&>(
      ::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseCodeKind& BooleanEventAndStatusGGIO::phase() const {
  // @@protoc_insertion_point(field_get:commonmodule.BooleanEventAndStatusGGIO.Phase)
  return _internal_phase();
}
inline void BooleanEventAndStatusGGIO::unsafe_arena_set_allocated_phase(
    ::commonmodule::Optional_PhaseCodeKind* phase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phase_);
  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.BooleanEventAndStatusGGIO.Phase)
}
inline ::commonmodule::Optional_PhaseCodeKind* BooleanEventAndStatusGGIO::release_phase() {
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* BooleanEventAndStatusGGIO::unsafe_arena_release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.BooleanEventAndStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* BooleanEventAndStatusGGIO::_internal_mutable_phase() {
  
  if (_impl_.phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaForAllocation());
    _impl_.phase_ = p;
  }
  return _impl_.phase_;
}
inline ::commonmodule::Optional_PhaseCodeKind* BooleanEventAndStatusGGIO::mutable_phase() {
  ::commonmodule::Optional_PhaseCodeKind* _msg = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:commonmodule.BooleanEventAndStatusGGIO.Phase)
  return _msg;
}
inline void BooleanEventAndStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phase_;
  }
  if (phase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phase);
    if (message_arena != submessage_arena) {
      phase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }

  } else {

  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.BooleanEventAndStatusGGIO.Phase)
}

// -------------------------------------------------------------------

// MessageInfo

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool MessageInfo::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool MessageInfo::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void MessageInfo::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& MessageInfo::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& MessageInfo::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.MessageInfo.identifiedObject)
  return _internal_identifiedobject();
}
inline void MessageInfo::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.MessageInfo.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* MessageInfo::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* MessageInfo::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.MessageInfo.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* MessageInfo::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* MessageInfo::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.MessageInfo.identifiedObject)
  return _msg;
}
inline void MessageInfo::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MessageInfo.identifiedObject)
}

// .commonmodule.Timestamp messageTimeStamp = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool MessageInfo::_internal_has_messagetimestamp() const {
  return this != internal_default_instance() && _impl_.messagetimestamp_ != nullptr;
}
inline bool MessageInfo::has_messagetimestamp() const {
  return _internal_has_messagetimestamp();
}
inline void MessageInfo::clear_messagetimestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.messagetimestamp_ != nullptr) {
    delete _impl_.messagetimestamp_;
  }
  _impl_.messagetimestamp_ = nullptr;
}
inline const ::commonmodule::Timestamp& MessageInfo::_internal_messagetimestamp() const {
  const ::commonmodule::Timestamp* p = _impl_.messagetimestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& MessageInfo::messagetimestamp() const {
  // @@protoc_insertion_point(field_get:commonmodule.MessageInfo.messageTimeStamp)
  return _internal_messagetimestamp();
}
inline void MessageInfo::unsafe_arena_set_allocated_messagetimestamp(
    ::commonmodule::Timestamp* messagetimestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messagetimestamp_);
  }
  _impl_.messagetimestamp_ = messagetimestamp;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.MessageInfo.messageTimeStamp)
}
inline ::commonmodule::Timestamp* MessageInfo::release_messagetimestamp() {
  
  ::commonmodule::Timestamp* temp = _impl_.messagetimestamp_;
  _impl_.messagetimestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* MessageInfo::unsafe_arena_release_messagetimestamp() {
  // @@protoc_insertion_point(field_release:commonmodule.MessageInfo.messageTimeStamp)
  
  ::commonmodule::Timestamp* temp = _impl_.messagetimestamp_;
  _impl_.messagetimestamp_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* MessageInfo::_internal_mutable_messagetimestamp() {
  
  if (_impl_.messagetimestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.messagetimestamp_ = p;
  }
  return _impl_.messagetimestamp_;
}
inline ::commonmodule::Timestamp* MessageInfo::mutable_messagetimestamp() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_messagetimestamp();
  // @@protoc_insertion_point(field_mutable:commonmodule.MessageInfo.messageTimeStamp)
  return _msg;
}
inline void MessageInfo::set_allocated_messagetimestamp(::commonmodule::Timestamp* messagetimestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messagetimestamp_;
  }
  if (messagetimestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messagetimestamp);
    if (message_arena != submessage_arena) {
      messagetimestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messagetimestamp, submessage_arena);
    }

  } else {

  }
  _impl_.messagetimestamp_ = messagetimestamp;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MessageInfo.messageTimeStamp)
}

// -------------------------------------------------------------------

// CapabilityMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityMessageInfo::_internal_has_messageinfo() const {
  return this != internal_default_instance() && _impl_.messageinfo_ != nullptr;
}
inline bool CapabilityMessageInfo::has_messageinfo() const {
  return _internal_has_messageinfo();
}
inline void CapabilityMessageInfo::clear_messageinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& CapabilityMessageInfo::_internal_messageinfo() const {
  const ::commonmodule::MessageInfo* p = _impl_.messageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MessageInfo&>(
      ::commonmodule::_MessageInfo_default_instance_);
}
inline const ::commonmodule::MessageInfo& CapabilityMessageInfo::messageinfo() const {
  // @@protoc_insertion_point(field_get:commonmodule.CapabilityMessageInfo.messageInfo)
  return _internal_messageinfo();
}
inline void CapabilityMessageInfo::unsafe_arena_set_allocated_messageinfo(
    ::commonmodule::MessageInfo* messageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageinfo_);
  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.CapabilityMessageInfo.messageInfo)
}
inline ::commonmodule::MessageInfo* CapabilityMessageInfo::release_messageinfo() {
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MessageInfo* CapabilityMessageInfo::unsafe_arena_release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.CapabilityMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* CapabilityMessageInfo::_internal_mutable_messageinfo() {
  
  if (_impl_.messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaForAllocation());
    _impl_.messageinfo_ = p;
  }
  return _impl_.messageinfo_;
}
inline ::commonmodule::MessageInfo* CapabilityMessageInfo::mutable_messageinfo() {
  ::commonmodule::MessageInfo* _msg = _internal_mutable_messageinfo();
  // @@protoc_insertion_point(field_mutable:commonmodule.CapabilityMessageInfo.messageInfo)
  return _msg;
}
inline void CapabilityMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messageinfo_;
  }
  if (messageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messageinfo);
    if (message_arena != submessage_arena) {
      messageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CapabilityMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// CheckConditions

// .google.protobuf.BoolValue interlockCheck = 1;
inline bool CheckConditions::_internal_has_interlockcheck() const {
  return this != internal_default_instance() && _impl_.interlockcheck_ != nullptr;
}
inline bool CheckConditions::has_interlockcheck() const {
  return _internal_has_interlockcheck();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& CheckConditions::_internal_interlockcheck() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.interlockcheck_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& CheckConditions::interlockcheck() const {
  // @@protoc_insertion_point(field_get:commonmodule.CheckConditions.interlockCheck)
  return _internal_interlockcheck();
}
inline void CheckConditions::unsafe_arena_set_allocated_interlockcheck(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* interlockcheck) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interlockcheck_);
  }
  _impl_.interlockcheck_ = interlockcheck;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.CheckConditions.interlockCheck)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::release_interlockcheck() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.interlockcheck_;
  _impl_.interlockcheck_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::unsafe_arena_release_interlockcheck() {
  // @@protoc_insertion_point(field_release:commonmodule.CheckConditions.interlockCheck)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.interlockcheck_;
  _impl_.interlockcheck_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::_internal_mutable_interlockcheck() {
  
  if (_impl_.interlockcheck_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.interlockcheck_ = p;
  }
  return _impl_.interlockcheck_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::mutable_interlockcheck() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_interlockcheck();
  // @@protoc_insertion_point(field_mutable:commonmodule.CheckConditions.interlockCheck)
  return _msg;
}
inline void CheckConditions::set_allocated_interlockcheck(::PROTOBUF_NAMESPACE_ID::BoolValue* interlockcheck) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interlockcheck_);
  }
  if (interlockcheck) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interlockcheck));
    if (message_arena != submessage_arena) {
      interlockcheck = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interlockcheck, submessage_arena);
    }

  } else {

  }
  _impl_.interlockcheck_ = interlockcheck;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CheckConditions.interlockCheck)
}

// .google.protobuf.BoolValue synchroCheck = 2;
inline bool CheckConditions::_internal_has_synchrocheck() const {
  return this != internal_default_instance() && _impl_.synchrocheck_ != nullptr;
}
inline bool CheckConditions::has_synchrocheck() const {
  return _internal_has_synchrocheck();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& CheckConditions::_internal_synchrocheck() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.synchrocheck_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& CheckConditions::synchrocheck() const {
  // @@protoc_insertion_point(field_get:commonmodule.CheckConditions.synchroCheck)
  return _internal_synchrocheck();
}
inline void CheckConditions::unsafe_arena_set_allocated_synchrocheck(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* synchrocheck) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.synchrocheck_);
  }
  _impl_.synchrocheck_ = synchrocheck;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.CheckConditions.synchroCheck)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::release_synchrocheck() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.synchrocheck_;
  _impl_.synchrocheck_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::unsafe_arena_release_synchrocheck() {
  // @@protoc_insertion_point(field_release:commonmodule.CheckConditions.synchroCheck)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.synchrocheck_;
  _impl_.synchrocheck_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::_internal_mutable_synchrocheck() {
  
  if (_impl_.synchrocheck_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.synchrocheck_ = p;
  }
  return _impl_.synchrocheck_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CheckConditions::mutable_synchrocheck() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_synchrocheck();
  // @@protoc_insertion_point(field_mutable:commonmodule.CheckConditions.synchroCheck)
  return _msg;
}
inline void CheckConditions::set_allocated_synchrocheck(::PROTOBUF_NAMESPACE_ID::BoolValue* synchrocheck) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.synchrocheck_);
  }
  if (synchrocheck) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(synchrocheck));
    if (message_arena != submessage_arena) {
      synchrocheck = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, synchrocheck, submessage_arena);
    }

  } else {

  }
  _impl_.synchrocheck_ = synchrocheck;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CheckConditions.synchroCheck)
}

// -------------------------------------------------------------------

// ClearingTime

// uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ClearingTime::clear_seconds() {
  _impl_.seconds_ = ::uint64_t{0u};
}
inline ::uint64_t ClearingTime::seconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.ClearingTime.seconds)
  return _internal_seconds();
}
inline void ClearingTime::set_seconds(::uint64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.ClearingTime.seconds)
}
inline ::uint64_t ClearingTime::_internal_seconds() const {
  return _impl_.seconds_;
}
inline void ClearingTime::_internal_set_seconds(::uint64_t value) {
  ;
  _impl_.seconds_ = value;
}

// uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ClearingTime::clear_nanoseconds() {
  _impl_.nanoseconds_ = 0u;
}
inline ::uint32_t ClearingTime::nanoseconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.ClearingTime.nanoseconds)
  return _internal_nanoseconds();
}
inline void ClearingTime::set_nanoseconds(::uint32_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.ClearingTime.nanoseconds)
}
inline ::uint32_t ClearingTime::_internal_nanoseconds() const {
  return _impl_.nanoseconds_;
}
inline void ClearingTime::_internal_set_nanoseconds(::uint32_t value) {
  ;
  _impl_.nanoseconds_ = value;
}

// -------------------------------------------------------------------

// Vector

// .google.protobuf.DoubleValue ang = 1;
inline bool Vector::_internal_has_ang() const {
  return this != internal_default_instance() && _impl_.ang_ != nullptr;
}
inline bool Vector::has_ang() const {
  return _internal_has_ang();
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vector::_internal_ang() const {
  const ::PROTOBUF_NAMESPACE_ID::DoubleValue* p = _impl_.ang_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      ::PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::DoubleValue& Vector::ang() const {
  // @@protoc_insertion_point(field_get:commonmodule.Vector.ang)
  return _internal_ang();
}
inline void Vector::unsafe_arena_set_allocated_ang(
    ::PROTOBUF_NAMESPACE_ID::DoubleValue* ang) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ang_);
  }
  _impl_.ang_ = ang;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.Vector.ang)
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vector::release_ang() {
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.ang_;
  _impl_.ang_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vector::unsafe_arena_release_ang() {
  // @@protoc_insertion_point(field_release:commonmodule.Vector.ang)
  
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* temp = _impl_.ang_;
  _impl_.ang_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vector::_internal_mutable_ang() {
  
  if (_impl_.ang_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    _impl_.ang_ = p;
  }
  return _impl_.ang_;
}
inline ::PROTOBUF_NAMESPACE_ID::DoubleValue* Vector::mutable_ang() {
  ::PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_ang();
  // @@protoc_insertion_point(field_mutable:commonmodule.Vector.ang)
  return _msg;
}
inline void Vector::set_allocated_ang(::PROTOBUF_NAMESPACE_ID::DoubleValue* ang) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ang_);
  }
  if (ang) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ang));
    if (message_arena != submessage_arena) {
      ang = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ang, submessage_arena);
    }

  } else {

  }
  _impl_.ang_ = ang;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Vector.ang)
}

// double mag = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void Vector::clear_mag() {
  _impl_.mag_ = 0;
}
inline double Vector::mag() const {
  // @@protoc_insertion_point(field_get:commonmodule.Vector.mag)
  return _internal_mag();
}
inline void Vector::set_mag(double value) {
  _internal_set_mag(value);
  // @@protoc_insertion_point(field_set:commonmodule.Vector.mag)
}
inline double Vector::_internal_mag() const {
  return _impl_.mag_;
}
inline void Vector::_internal_set_mag(double value) {
  ;
  _impl_.mag_ = value;
}

// -------------------------------------------------------------------

// CMV

// .commonmodule.Vector cVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CMV::_internal_has_cval() const {
  return this != internal_default_instance() && _impl_.cval_ != nullptr;
}
inline bool CMV::has_cval() const {
  return _internal_has_cval();
}
inline void CMV::clear_cval() {
  if (GetArenaForAllocation() == nullptr && _impl_.cval_ != nullptr) {
    delete _impl_.cval_;
  }
  _impl_.cval_ = nullptr;
}
inline const ::commonmodule::Vector& CMV::_internal_cval() const {
  const ::commonmodule::Vector* p = _impl_.cval_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Vector&>(
      ::commonmodule::_Vector_default_instance_);
}
inline const ::commonmodule::Vector& CMV::cval() const {
  // @@protoc_insertion_point(field_get:commonmodule.CMV.cVal)
  return _internal_cval();
}
inline void CMV::unsafe_arena_set_allocated_cval(
    ::commonmodule::Vector* cval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cval_);
  }
  _impl_.cval_ = cval;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.CMV.cVal)
}
inline ::commonmodule::Vector* CMV::release_cval() {
  
  ::commonmodule::Vector* temp = _impl_.cval_;
  _impl_.cval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Vector* CMV::unsafe_arena_release_cval() {
  // @@protoc_insertion_point(field_release:commonmodule.CMV.cVal)
  
  ::commonmodule::Vector* temp = _impl_.cval_;
  _impl_.cval_ = nullptr;
  return temp;
}
inline ::commonmodule::Vector* CMV::_internal_mutable_cval() {
  
  if (_impl_.cval_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Vector>(GetArenaForAllocation());
    _impl_.cval_ = p;
  }
  return _impl_.cval_;
}
inline ::commonmodule::Vector* CMV::mutable_cval() {
  ::commonmodule::Vector* _msg = _internal_mutable_cval();
  // @@protoc_insertion_point(field_mutable:commonmodule.CMV.cVal)
  return _msg;
}
inline void CMV::set_allocated_cval(::commonmodule::Vector* cval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cval_;
  }
  if (cval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cval);
    if (message_arena != submessage_arena) {
      cval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cval, submessage_arena);
    }

  } else {

  }
  _impl_.cval_ = cval;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CMV.cVal)
}

// .commonmodule.Quality q = 2;
inline bool CMV::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool CMV::has_q() const {
  return _internal_has_q();
}
inline void CMV::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& CMV::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& CMV::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.CMV.q)
  return _internal_q();
}
inline void CMV::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.CMV.q)
}
inline ::commonmodule::Quality* CMV::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* CMV::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.CMV.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* CMV::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* CMV::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.CMV.q)
  return _msg;
}
inline void CMV::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CMV.q)
}

// .commonmodule.Timestamp t = 3;
inline bool CMV::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool CMV::has_t() const {
  return _internal_has_t();
}
inline void CMV::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& CMV::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& CMV::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.CMV.t)
  return _internal_t();
}
inline void CMV::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.CMV.t)
}
inline ::commonmodule::Timestamp* CMV::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* CMV::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.CMV.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* CMV::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* CMV::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.CMV.t)
  return _msg;
}
inline void CMV::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.CMV.t)
}

// -------------------------------------------------------------------

// ConductingEquipment

// .commonmodule.NamedObject namedObject = 1 [(.uml.option_parent_message) = true];
inline bool ConductingEquipment::_internal_has_namedobject() const {
  return this != internal_default_instance() && _impl_.namedobject_ != nullptr;
}
inline bool ConductingEquipment::has_namedobject() const {
  return _internal_has_namedobject();
}
inline void ConductingEquipment::clear_namedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.namedobject_ != nullptr) {
    delete _impl_.namedobject_;
  }
  _impl_.namedobject_ = nullptr;
}
inline const ::commonmodule::NamedObject& ConductingEquipment::_internal_namedobject() const {
  const ::commonmodule::NamedObject* p = _impl_.namedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::NamedObject&>(
      ::commonmodule::_NamedObject_default_instance_);
}
inline const ::commonmodule::NamedObject& ConductingEquipment::namedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.ConductingEquipment.namedObject)
  return _internal_namedobject();
}
inline void ConductingEquipment::unsafe_arena_set_allocated_namedobject(
    ::commonmodule::NamedObject* namedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.namedobject_);
  }
  _impl_.namedobject_ = namedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ConductingEquipment.namedObject)
}
inline ::commonmodule::NamedObject* ConductingEquipment::release_namedobject() {
  
  ::commonmodule::NamedObject* temp = _impl_.namedobject_;
  _impl_.namedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::NamedObject* ConductingEquipment::unsafe_arena_release_namedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ConductingEquipment.namedObject)
  
  ::commonmodule::NamedObject* temp = _impl_.namedobject_;
  _impl_.namedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::NamedObject* ConductingEquipment::_internal_mutable_namedobject() {
  
  if (_impl_.namedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::NamedObject>(GetArenaForAllocation());
    _impl_.namedobject_ = p;
  }
  return _impl_.namedobject_;
}
inline ::commonmodule::NamedObject* ConductingEquipment::mutable_namedobject() {
  ::commonmodule::NamedObject* _msg = _internal_mutable_namedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.ConductingEquipment.namedObject)
  return _msg;
}
inline void ConductingEquipment::set_allocated_namedobject(::commonmodule::NamedObject* namedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.namedobject_;
  }
  if (namedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(namedobject);
    if (message_arena != submessage_arena) {
      namedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namedobject, submessage_arena);
    }

  } else {

  }
  _impl_.namedobject_ = namedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ConductingEquipment.namedObject)
}

// string mRID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_uuid) = true, (.uml.option_key) = true];
inline void ConductingEquipment::clear_mrid() {
  _impl_.mrid_.ClearToEmpty();
}
inline const std::string& ConductingEquipment::mrid() const {
  // @@protoc_insertion_point(field_get:commonmodule.ConductingEquipment.mRID)
  return _internal_mrid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConductingEquipment::set_mrid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mrid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commonmodule.ConductingEquipment.mRID)
}
inline std::string* ConductingEquipment::mutable_mrid() {
  std::string* _s = _internal_mutable_mrid();
  // @@protoc_insertion_point(field_mutable:commonmodule.ConductingEquipment.mRID)
  return _s;
}
inline const std::string& ConductingEquipment::_internal_mrid() const {
  return _impl_.mrid_.Get();
}
inline void ConductingEquipment::_internal_set_mrid(const std::string& value) {
  ;


  _impl_.mrid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConductingEquipment::_internal_mutable_mrid() {
  ;
  return _impl_.mrid_.Mutable( GetArenaForAllocation());
}
inline std::string* ConductingEquipment::release_mrid() {
  // @@protoc_insertion_point(field_release:commonmodule.ConductingEquipment.mRID)
  return _impl_.mrid_.Release();
}
inline void ConductingEquipment::set_allocated_mrid(std::string* value) {
  _impl_.mrid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mrid_.IsDefault()) {
          _impl_.mrid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ConductingEquipment.mRID)
}

// -------------------------------------------------------------------

// Terminal

// .commonmodule.ACDCTerminal aCDCTerminal = 1 [(.uml.option_parent_message) = true];
inline bool Terminal::_internal_has_acdcterminal() const {
  return this != internal_default_instance() && _impl_.acdcterminal_ != nullptr;
}
inline bool Terminal::has_acdcterminal() const {
  return _internal_has_acdcterminal();
}
inline void Terminal::clear_acdcterminal() {
  if (GetArenaForAllocation() == nullptr && _impl_.acdcterminal_ != nullptr) {
    delete _impl_.acdcterminal_;
  }
  _impl_.acdcterminal_ = nullptr;
}
inline const ::commonmodule::ACDCTerminal& Terminal::_internal_acdcterminal() const {
  const ::commonmodule::ACDCTerminal* p = _impl_.acdcterminal_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ACDCTerminal&>(
      ::commonmodule::_ACDCTerminal_default_instance_);
}
inline const ::commonmodule::ACDCTerminal& Terminal::acdcterminal() const {
  // @@protoc_insertion_point(field_get:commonmodule.Terminal.aCDCTerminal)
  return _internal_acdcterminal();
}
inline void Terminal::unsafe_arena_set_allocated_acdcterminal(
    ::commonmodule::ACDCTerminal* acdcterminal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acdcterminal_);
  }
  _impl_.acdcterminal_ = acdcterminal;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.Terminal.aCDCTerminal)
}
inline ::commonmodule::ACDCTerminal* Terminal::release_acdcterminal() {
  
  ::commonmodule::ACDCTerminal* temp = _impl_.acdcterminal_;
  _impl_.acdcterminal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ACDCTerminal* Terminal::unsafe_arena_release_acdcterminal() {
  // @@protoc_insertion_point(field_release:commonmodule.Terminal.aCDCTerminal)
  
  ::commonmodule::ACDCTerminal* temp = _impl_.acdcterminal_;
  _impl_.acdcterminal_ = nullptr;
  return temp;
}
inline ::commonmodule::ACDCTerminal* Terminal::_internal_mutable_acdcterminal() {
  
  if (_impl_.acdcterminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ACDCTerminal>(GetArenaForAllocation());
    _impl_.acdcterminal_ = p;
  }
  return _impl_.acdcterminal_;
}
inline ::commonmodule::ACDCTerminal* Terminal::mutable_acdcterminal() {
  ::commonmodule::ACDCTerminal* _msg = _internal_mutable_acdcterminal();
  // @@protoc_insertion_point(field_mutable:commonmodule.Terminal.aCDCTerminal)
  return _msg;
}
inline void Terminal::set_allocated_acdcterminal(::commonmodule::ACDCTerminal* acdcterminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.acdcterminal_;
  }
  if (acdcterminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acdcterminal);
    if (message_arena != submessage_arena) {
      acdcterminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acdcterminal, submessage_arena);
    }

  } else {

  }
  _impl_.acdcterminal_ = acdcterminal;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Terminal.aCDCTerminal)
}

// .commonmodule.Optional_PhaseCodeKind phases = 2;
inline bool Terminal::_internal_has_phases() const {
  return this != internal_default_instance() && _impl_.phases_ != nullptr;
}
inline bool Terminal::has_phases() const {
  return _internal_has_phases();
}
inline void Terminal::clear_phases() {
  if (GetArenaForAllocation() == nullptr && _impl_.phases_ != nullptr) {
    delete _impl_.phases_;
  }
  _impl_.phases_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& Terminal::_internal_phases() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = _impl_.phases_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind&>(
      ::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseCodeKind& Terminal::phases() const {
  // @@protoc_insertion_point(field_get:commonmodule.Terminal.phases)
  return _internal_phases();
}
inline void Terminal::unsafe_arena_set_allocated_phases(
    ::commonmodule::Optional_PhaseCodeKind* phases) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phases_);
  }
  _impl_.phases_ = phases;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.Terminal.phases)
}
inline ::commonmodule::Optional_PhaseCodeKind* Terminal::release_phases() {
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phases_;
  _impl_.phases_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* Terminal::unsafe_arena_release_phases() {
  // @@protoc_insertion_point(field_release:commonmodule.Terminal.phases)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phases_;
  _impl_.phases_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* Terminal::_internal_mutable_phases() {
  
  if (_impl_.phases_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaForAllocation());
    _impl_.phases_ = p;
  }
  return _impl_.phases_;
}
inline ::commonmodule::Optional_PhaseCodeKind* Terminal::mutable_phases() {
  ::commonmodule::Optional_PhaseCodeKind* _msg = _internal_mutable_phases();
  // @@protoc_insertion_point(field_mutable:commonmodule.Terminal.phases)
  return _msg;
}
inline void Terminal::set_allocated_phases(::commonmodule::Optional_PhaseCodeKind* phases) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phases_;
  }
  if (phases) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phases);
    if (message_arena != submessage_arena) {
      phases = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phases, submessage_arena);
    }

  } else {

  }
  _impl_.phases_ = phases;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Terminal.phases)
}

// -------------------------------------------------------------------

// ConductingEquipmentTerminalReading

// .commonmodule.Terminal terminal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ConductingEquipmentTerminalReading::_internal_has_terminal() const {
  return this != internal_default_instance() && _impl_.terminal_ != nullptr;
}
inline bool ConductingEquipmentTerminalReading::has_terminal() const {
  return _internal_has_terminal();
}
inline void ConductingEquipmentTerminalReading::clear_terminal() {
  if (GetArenaForAllocation() == nullptr && _impl_.terminal_ != nullptr) {
    delete _impl_.terminal_;
  }
  _impl_.terminal_ = nullptr;
}
inline const ::commonmodule::Terminal& ConductingEquipmentTerminalReading::_internal_terminal() const {
  const ::commonmodule::Terminal* p = _impl_.terminal_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Terminal&>(
      ::commonmodule::_Terminal_default_instance_);
}
inline const ::commonmodule::Terminal& ConductingEquipmentTerminalReading::terminal() const {
  // @@protoc_insertion_point(field_get:commonmodule.ConductingEquipmentTerminalReading.terminal)
  return _internal_terminal();
}
inline void ConductingEquipmentTerminalReading::unsafe_arena_set_allocated_terminal(
    ::commonmodule::Terminal* terminal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terminal_);
  }
  _impl_.terminal_ = terminal;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ConductingEquipmentTerminalReading.terminal)
}
inline ::commonmodule::Terminal* ConductingEquipmentTerminalReading::release_terminal() {
  
  ::commonmodule::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Terminal* ConductingEquipmentTerminalReading::unsafe_arena_release_terminal() {
  // @@protoc_insertion_point(field_release:commonmodule.ConductingEquipmentTerminalReading.terminal)
  
  ::commonmodule::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
  return temp;
}
inline ::commonmodule::Terminal* ConductingEquipmentTerminalReading::_internal_mutable_terminal() {
  
  if (_impl_.terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Terminal>(GetArenaForAllocation());
    _impl_.terminal_ = p;
  }
  return _impl_.terminal_;
}
inline ::commonmodule::Terminal* ConductingEquipmentTerminalReading::mutable_terminal() {
  ::commonmodule::Terminal* _msg = _internal_mutable_terminal();
  // @@protoc_insertion_point(field_mutable:commonmodule.ConductingEquipmentTerminalReading.terminal)
  return _msg;
}
inline void ConductingEquipmentTerminalReading::set_allocated_terminal(::commonmodule::Terminal* terminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terminal_;
  }
  if (terminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terminal);
    if (message_arena != submessage_arena) {
      terminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }

  } else {

  }
  _impl_.terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ConductingEquipmentTerminalReading.terminal)
}

// -------------------------------------------------------------------

// ControlAPC

// double ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlAPC::clear_ctlval() {
  _impl_.ctlval_ = 0;
}
inline double ControlAPC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlAPC.ctlVal)
  return _internal_ctlval();
}
inline void ControlAPC::set_ctlval(double value) {
  _internal_set_ctlval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlAPC.ctlVal)
}
inline double ControlAPC::_internal_ctlval() const {
  return _impl_.ctlval_;
}
inline void ControlAPC::_internal_set_ctlval(double value) {
  ;
  _impl_.ctlval_ = value;
}

// -------------------------------------------------------------------

// ControlDPC

// bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlDPC::clear_ctlval() {
  _impl_.ctlval_ = false;
}
inline bool ControlDPC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlDPC.ctlVal)
  return _internal_ctlval();
}
inline void ControlDPC::set_ctlval(bool value) {
  _internal_set_ctlval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlDPC.ctlVal)
}
inline bool ControlDPC::_internal_ctlval() const {
  return _impl_.ctlval_;
}
inline void ControlDPC::_internal_set_ctlval(bool value) {
  ;
  _impl_.ctlval_ = value;
}

// -------------------------------------------------------------------

// ControlTimestamp

// uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlTimestamp::clear_seconds() {
  _impl_.seconds_ = ::uint64_t{0u};
}
inline ::uint64_t ControlTimestamp::seconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlTimestamp.seconds)
  return _internal_seconds();
}
inline void ControlTimestamp::set_seconds(::uint64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlTimestamp.seconds)
}
inline ::uint64_t ControlTimestamp::_internal_seconds() const {
  return _impl_.seconds_;
}
inline void ControlTimestamp::_internal_set_seconds(::uint64_t value) {
  ;
  _impl_.seconds_ = value;
}

// uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlTimestamp::clear_nanoseconds() {
  _impl_.nanoseconds_ = 0u;
}
inline ::uint32_t ControlTimestamp::nanoseconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlTimestamp.nanoseconds)
  return _internal_nanoseconds();
}
inline void ControlTimestamp::set_nanoseconds(::uint32_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlTimestamp.nanoseconds)
}
inline ::uint32_t ControlTimestamp::_internal_nanoseconds() const {
  return _impl_.nanoseconds_;
}
inline void ControlTimestamp::_internal_set_nanoseconds(::uint32_t value) {
  ;
  _impl_.nanoseconds_ = value;
}

// -------------------------------------------------------------------

// Optional_ScheduleParameterKind

// .commonmodule.ScheduleParameterKind value = 1;
inline void Optional_ScheduleParameterKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::ScheduleParameterKind Optional_ScheduleParameterKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_ScheduleParameterKind.value)
  return _internal_value();
}
inline void Optional_ScheduleParameterKind::set_value(::commonmodule::ScheduleParameterKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_ScheduleParameterKind.value)
}
inline ::commonmodule::ScheduleParameterKind Optional_ScheduleParameterKind::_internal_value() const {
  return static_cast<::commonmodule::ScheduleParameterKind>(_impl_.value_);
}
inline void Optional_ScheduleParameterKind::_internal_set_value(::commonmodule::ScheduleParameterKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENG_ScheduleParameter

// .commonmodule.ScheduleParameterKind scheduleParameterType = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_ScheduleParameter::clear_scheduleparametertype() {
  _impl_.scheduleparametertype_ = 0;
}
inline ::commonmodule::ScheduleParameterKind ENG_ScheduleParameter::scheduleparametertype() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_ScheduleParameter.scheduleParameterType)
  return _internal_scheduleparametertype();
}
inline void ENG_ScheduleParameter::set_scheduleparametertype(::commonmodule::ScheduleParameterKind value) {
   _internal_set_scheduleparametertype(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENG_ScheduleParameter.scheduleParameterType)
}
inline ::commonmodule::ScheduleParameterKind ENG_ScheduleParameter::_internal_scheduleparametertype() const {
  return static_cast<::commonmodule::ScheduleParameterKind>(_impl_.scheduleparametertype_);
}
inline void ENG_ScheduleParameter::_internal_set_scheduleparametertype(::commonmodule::ScheduleParameterKind value) {
  ;
  _impl_.scheduleparametertype_ = value;
}

// double value = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_ScheduleParameter::clear_value() {
  _impl_.value_ = 0;
}
inline double ENG_ScheduleParameter::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_ScheduleParameter.value)
  return _internal_value();
}
inline void ENG_ScheduleParameter::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENG_ScheduleParameter.value)
}
inline double ENG_ScheduleParameter::_internal_value() const {
  return _impl_.value_;
}
inline void ENG_ScheduleParameter::_internal_set_value(double value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SchedulePoint

// repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int SchedulePoint::_internal_scheduleparameter_size() const {
  return _impl_.scheduleparameter_.size();
}
inline int SchedulePoint::scheduleparameter_size() const {
  return _internal_scheduleparameter_size();
}
inline void SchedulePoint::clear_scheduleparameter() {
  _impl_.scheduleparameter_.Clear();
}
inline ::commonmodule::ENG_ScheduleParameter* SchedulePoint::mutable_scheduleparameter(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.SchedulePoint.scheduleParameter)
  return _impl_.scheduleparameter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >*
SchedulePoint::mutable_scheduleparameter() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.SchedulePoint.scheduleParameter)
  return &_impl_.scheduleparameter_;
}
inline const ::commonmodule::ENG_ScheduleParameter& SchedulePoint::_internal_scheduleparameter(int index) const {
  return _impl_.scheduleparameter_.Get(index);
}
inline const ::commonmodule::ENG_ScheduleParameter& SchedulePoint::scheduleparameter(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.SchedulePoint.scheduleParameter)
  return _internal_scheduleparameter(index);
}
inline ::commonmodule::ENG_ScheduleParameter* SchedulePoint::_internal_add_scheduleparameter() {
  return _impl_.scheduleparameter_.Add();
}
inline ::commonmodule::ENG_ScheduleParameter* SchedulePoint::add_scheduleparameter() {
  ::commonmodule::ENG_ScheduleParameter* _add = _internal_add_scheduleparameter();
  // @@protoc_insertion_point(field_add:commonmodule.SchedulePoint.scheduleParameter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::ENG_ScheduleParameter >&
SchedulePoint::scheduleparameter() const {
  // @@protoc_insertion_point(field_list:commonmodule.SchedulePoint.scheduleParameter)
  return _impl_.scheduleparameter_;
}

// .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SchedulePoint::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool SchedulePoint::has_starttime() const {
  return _internal_has_starttime();
}
inline void SchedulePoint::clear_starttime() {
  if (GetArenaForAllocation() == nullptr && _impl_.starttime_ != nullptr) {
    delete _impl_.starttime_;
  }
  _impl_.starttime_ = nullptr;
}
inline const ::commonmodule::ControlTimestamp& SchedulePoint::_internal_starttime() const {
  const ::commonmodule::ControlTimestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlTimestamp&>(
      ::commonmodule::_ControlTimestamp_default_instance_);
}
inline const ::commonmodule::ControlTimestamp& SchedulePoint::starttime() const {
  // @@protoc_insertion_point(field_get:commonmodule.SchedulePoint.startTime)
  return _internal_starttime();
}
inline void SchedulePoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::ControlTimestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SchedulePoint.startTime)
}
inline ::commonmodule::ControlTimestamp* SchedulePoint::release_starttime() {
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlTimestamp* SchedulePoint::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:commonmodule.SchedulePoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* SchedulePoint::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::commonmodule::ControlTimestamp* SchedulePoint::mutable_starttime() {
  ::commonmodule::ControlTimestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:commonmodule.SchedulePoint.startTime)
  return _msg;
}
inline void SchedulePoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.starttime_;
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(starttime);
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }

  } else {

  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SchedulePoint.startTime)
}

// -------------------------------------------------------------------

// ScheduleCSG

// repeated .commonmodule.SchedulePoint schPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int ScheduleCSG::_internal_schpts_size() const {
  return _impl_.schpts_.size();
}
inline int ScheduleCSG::schpts_size() const {
  return _internal_schpts_size();
}
inline void ScheduleCSG::clear_schpts() {
  _impl_.schpts_.Clear();
}
inline ::commonmodule::SchedulePoint* ScheduleCSG::mutable_schpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.ScheduleCSG.schPts)
  return _impl_.schpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SchedulePoint >*
ScheduleCSG::mutable_schpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.ScheduleCSG.schPts)
  return &_impl_.schpts_;
}
inline const ::commonmodule::SchedulePoint& ScheduleCSG::_internal_schpts(int index) const {
  return _impl_.schpts_.Get(index);
}
inline const ::commonmodule::SchedulePoint& ScheduleCSG::schpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.ScheduleCSG.schPts)
  return _internal_schpts(index);
}
inline ::commonmodule::SchedulePoint* ScheduleCSG::_internal_add_schpts() {
  return _impl_.schpts_.Add();
}
inline ::commonmodule::SchedulePoint* ScheduleCSG::add_schpts() {
  ::commonmodule::SchedulePoint* _add = _internal_add_schpts();
  // @@protoc_insertion_point(field_add:commonmodule.ScheduleCSG.schPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SchedulePoint >&
ScheduleCSG::schpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.ScheduleCSG.schPts)
  return _impl_.schpts_;
}

// -------------------------------------------------------------------

// ControlScheduleFSCH

// .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ControlScheduleFSCH::_internal_has_valacsg() const {
  return this != internal_default_instance() && _impl_.valacsg_ != nullptr;
}
inline bool ControlScheduleFSCH::has_valacsg() const {
  return _internal_has_valacsg();
}
inline void ControlScheduleFSCH::clear_valacsg() {
  if (GetArenaForAllocation() == nullptr && _impl_.valacsg_ != nullptr) {
    delete _impl_.valacsg_;
  }
  _impl_.valacsg_ = nullptr;
}
inline const ::commonmodule::ScheduleCSG& ControlScheduleFSCH::_internal_valacsg() const {
  const ::commonmodule::ScheduleCSG* p = _impl_.valacsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ScheduleCSG&>(
      ::commonmodule::_ScheduleCSG_default_instance_);
}
inline const ::commonmodule::ScheduleCSG& ControlScheduleFSCH::valacsg() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlScheduleFSCH.ValACSG)
  return _internal_valacsg();
}
inline void ControlScheduleFSCH::unsafe_arena_set_allocated_valacsg(
    ::commonmodule::ScheduleCSG* valacsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valacsg_);
  }
  _impl_.valacsg_ = valacsg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlScheduleFSCH.ValACSG)
}
inline ::commonmodule::ScheduleCSG* ControlScheduleFSCH::release_valacsg() {
  
  ::commonmodule::ScheduleCSG* temp = _impl_.valacsg_;
  _impl_.valacsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ScheduleCSG* ControlScheduleFSCH::unsafe_arena_release_valacsg() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlScheduleFSCH.ValACSG)
  
  ::commonmodule::ScheduleCSG* temp = _impl_.valacsg_;
  _impl_.valacsg_ = nullptr;
  return temp;
}
inline ::commonmodule::ScheduleCSG* ControlScheduleFSCH::_internal_mutable_valacsg() {
  
  if (_impl_.valacsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ScheduleCSG>(GetArenaForAllocation());
    _impl_.valacsg_ = p;
  }
  return _impl_.valacsg_;
}
inline ::commonmodule::ScheduleCSG* ControlScheduleFSCH::mutable_valacsg() {
  ::commonmodule::ScheduleCSG* _msg = _internal_mutable_valacsg();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlScheduleFSCH.ValACSG)
  return _msg;
}
inline void ControlScheduleFSCH::set_allocated_valacsg(::commonmodule::ScheduleCSG* valacsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.valacsg_;
  }
  if (valacsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(valacsg);
    if (message_arena != submessage_arena) {
      valacsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valacsg, submessage_arena);
    }

  } else {

  }
  _impl_.valacsg_ = valacsg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlScheduleFSCH.ValACSG)
}

// -------------------------------------------------------------------

// LogicalNodeForControl

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool LogicalNodeForControl::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool LogicalNodeForControl::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void LogicalNodeForControl::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& LogicalNodeForControl::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& LogicalNodeForControl::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForControl.logicalNode)
  return _internal_logicalnode();
}
inline void LogicalNodeForControl::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LogicalNodeForControl.logicalNode)
}
inline ::commonmodule::LogicalNode* LogicalNodeForControl::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* LogicalNodeForControl::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForControl.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* LogicalNodeForControl::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* LogicalNodeForControl::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForControl.logicalNode)
  return _msg;
}
inline void LogicalNodeForControl::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForControl.logicalNode)
}

// -------------------------------------------------------------------

// ControlFSCC

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool ControlFSCC::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && _impl_.logicalnodeforcontrol_ != nullptr;
}
inline bool ControlFSCC::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline void ControlFSCC::clear_logicalnodeforcontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnodeforcontrol_ != nullptr) {
    delete _impl_.logicalnodeforcontrol_;
  }
  _impl_.logicalnodeforcontrol_ = nullptr;
}
inline const ::commonmodule::LogicalNodeForControl& ControlFSCC::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& ControlFSCC::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlFSCC.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void ControlFSCC::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlFSCC.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* ControlFSCC::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* ControlFSCC::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlFSCC.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* ControlFSCC::_internal_mutable_logicalnodeforcontrol() {
  
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaForAllocation());
    _impl_.logicalnodeforcontrol_ = p;
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* ControlFSCC::mutable_logicalnodeforcontrol() {
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlFSCC.logicalNodeForControl)
  return _msg;
}
inline void ControlFSCC::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnodeforcontrol_;
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnodeforcontrol);
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlFSCC.logicalNodeForControl)
}

// .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;
inline bool ControlFSCC::_internal_has_controlschedulefsch() const {
  return this != internal_default_instance() && _impl_.controlschedulefsch_ != nullptr;
}
inline bool ControlFSCC::has_controlschedulefsch() const {
  return _internal_has_controlschedulefsch();
}
inline void ControlFSCC::clear_controlschedulefsch() {
  if (GetArenaForAllocation() == nullptr && _impl_.controlschedulefsch_ != nullptr) {
    delete _impl_.controlschedulefsch_;
  }
  _impl_.controlschedulefsch_ = nullptr;
}
inline const ::commonmodule::ControlScheduleFSCH& ControlFSCC::_internal_controlschedulefsch() const {
  const ::commonmodule::ControlScheduleFSCH* p = _impl_.controlschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlScheduleFSCH&>(
      ::commonmodule::_ControlScheduleFSCH_default_instance_);
}
inline const ::commonmodule::ControlScheduleFSCH& ControlFSCC::controlschedulefsch() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlFSCC.controlScheduleFSCH)
  return _internal_controlschedulefsch();
}
inline void ControlFSCC::unsafe_arena_set_allocated_controlschedulefsch(
    ::commonmodule::ControlScheduleFSCH* controlschedulefsch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlschedulefsch_);
  }
  _impl_.controlschedulefsch_ = controlschedulefsch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlFSCC.controlScheduleFSCH)
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::release_controlschedulefsch() {
  
  ::commonmodule::ControlScheduleFSCH* temp = _impl_.controlschedulefsch_;
  _impl_.controlschedulefsch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::unsafe_arena_release_controlschedulefsch() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlFSCC.controlScheduleFSCH)
  
  ::commonmodule::ControlScheduleFSCH* temp = _impl_.controlschedulefsch_;
  _impl_.controlschedulefsch_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::_internal_mutable_controlschedulefsch() {
  
  if (_impl_.controlschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlScheduleFSCH>(GetArenaForAllocation());
    _impl_.controlschedulefsch_ = p;
  }
  return _impl_.controlschedulefsch_;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::mutable_controlschedulefsch() {
  ::commonmodule::ControlScheduleFSCH* _msg = _internal_mutable_controlschedulefsch();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlFSCC.controlScheduleFSCH)
  return _msg;
}
inline void ControlFSCC::set_allocated_controlschedulefsch(::commonmodule::ControlScheduleFSCH* controlschedulefsch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.controlschedulefsch_;
  }
  if (controlschedulefsch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(controlschedulefsch);
    if (message_arena != submessage_arena) {
      controlschedulefsch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlschedulefsch, submessage_arena);
    }

  } else {

  }
  _impl_.controlschedulefsch_ = controlschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlFSCC.controlScheduleFSCH)
}

// .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;
inline bool ControlFSCC::_internal_has_islandcontrolschedulefsch() const {
  return this != internal_default_instance() && _impl_.islandcontrolschedulefsch_ != nullptr;
}
inline bool ControlFSCC::has_islandcontrolschedulefsch() const {
  return _internal_has_islandcontrolschedulefsch();
}
inline void ControlFSCC::clear_islandcontrolschedulefsch() {
  if (GetArenaForAllocation() == nullptr && _impl_.islandcontrolschedulefsch_ != nullptr) {
    delete _impl_.islandcontrolschedulefsch_;
  }
  _impl_.islandcontrolschedulefsch_ = nullptr;
}
inline const ::commonmodule::ControlScheduleFSCH& ControlFSCC::_internal_islandcontrolschedulefsch() const {
  const ::commonmodule::ControlScheduleFSCH* p = _impl_.islandcontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlScheduleFSCH&>(
      ::commonmodule::_ControlScheduleFSCH_default_instance_);
}
inline const ::commonmodule::ControlScheduleFSCH& ControlFSCC::islandcontrolschedulefsch() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlFSCC.islandControlScheduleFSCH)
  return _internal_islandcontrolschedulefsch();
}
inline void ControlFSCC::unsafe_arena_set_allocated_islandcontrolschedulefsch(
    ::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.islandcontrolschedulefsch_);
  }
  _impl_.islandcontrolschedulefsch_ = islandcontrolschedulefsch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlFSCC.islandControlScheduleFSCH)
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::release_islandcontrolschedulefsch() {
  
  ::commonmodule::ControlScheduleFSCH* temp = _impl_.islandcontrolschedulefsch_;
  _impl_.islandcontrolschedulefsch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::unsafe_arena_release_islandcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlFSCC.islandControlScheduleFSCH)
  
  ::commonmodule::ControlScheduleFSCH* temp = _impl_.islandcontrolschedulefsch_;
  _impl_.islandcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::_internal_mutable_islandcontrolschedulefsch() {
  
  if (_impl_.islandcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlScheduleFSCH>(GetArenaForAllocation());
    _impl_.islandcontrolschedulefsch_ = p;
  }
  return _impl_.islandcontrolschedulefsch_;
}
inline ::commonmodule::ControlScheduleFSCH* ControlFSCC::mutable_islandcontrolschedulefsch() {
  ::commonmodule::ControlScheduleFSCH* _msg = _internal_mutable_islandcontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlFSCC.islandControlScheduleFSCH)
  return _msg;
}
inline void ControlFSCC::set_allocated_islandcontrolschedulefsch(::commonmodule::ControlScheduleFSCH* islandcontrolschedulefsch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.islandcontrolschedulefsch_;
  }
  if (islandcontrolschedulefsch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(islandcontrolschedulefsch);
    if (message_arena != submessage_arena) {
      islandcontrolschedulefsch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, islandcontrolschedulefsch, submessage_arena);
    }

  } else {

  }
  _impl_.islandcontrolschedulefsch_ = islandcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlFSCC.islandControlScheduleFSCH)
}

// -------------------------------------------------------------------

// ControlINC

// int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlINC::clear_ctlval() {
  _impl_.ctlval_ = 0;
}
inline ::int32_t ControlINC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlINC.ctlVal)
  return _internal_ctlval();
}
inline void ControlINC::set_ctlval(::int32_t value) {
  _internal_set_ctlval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlINC.ctlVal)
}
inline ::int32_t ControlINC::_internal_ctlval() const {
  return _impl_.ctlval_;
}
inline void ControlINC::_internal_set_ctlval(::int32_t value) {
  ;
  _impl_.ctlval_ = value;
}

// -------------------------------------------------------------------

// ControlING

// int32 setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlING::clear_setval() {
  _impl_.setval_ = 0;
}
inline ::int32_t ControlING::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlING.setVal)
  return _internal_setval();
}
inline void ControlING::set_setval(::int32_t value) {
  _internal_set_setval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlING.setVal)
}
inline ::int32_t ControlING::_internal_setval() const {
  return _impl_.setval_;
}
inline void ControlING::_internal_set_setval(::int32_t value) {
  ;
  _impl_.setval_ = value;
}

// .commonmodule.Unit units = 2;
inline bool ControlING::_internal_has_units() const {
  return this != internal_default_instance() && _impl_.units_ != nullptr;
}
inline bool ControlING::has_units() const {
  return _internal_has_units();
}
inline void ControlING::clear_units() {
  if (GetArenaForAllocation() == nullptr && _impl_.units_ != nullptr) {
    delete _impl_.units_;
  }
  _impl_.units_ = nullptr;
}
inline const ::commonmodule::Unit& ControlING::_internal_units() const {
  const ::commonmodule::Unit* p = _impl_.units_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Unit&>(
      ::commonmodule::_Unit_default_instance_);
}
inline const ::commonmodule::Unit& ControlING::units() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlING.units)
  return _internal_units();
}
inline void ControlING::unsafe_arena_set_allocated_units(
    ::commonmodule::Unit* units) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.units_);
  }
  _impl_.units_ = units;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlING.units)
}
inline ::commonmodule::Unit* ControlING::release_units() {
  
  ::commonmodule::Unit* temp = _impl_.units_;
  _impl_.units_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Unit* ControlING::unsafe_arena_release_units() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlING.units)
  
  ::commonmodule::Unit* temp = _impl_.units_;
  _impl_.units_ = nullptr;
  return temp;
}
inline ::commonmodule::Unit* ControlING::_internal_mutable_units() {
  
  if (_impl_.units_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Unit>(GetArenaForAllocation());
    _impl_.units_ = p;
  }
  return _impl_.units_;
}
inline ::commonmodule::Unit* ControlING::mutable_units() {
  ::commonmodule::Unit* _msg = _internal_mutable_units();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlING.units)
  return _msg;
}
inline void ControlING::set_allocated_units(::commonmodule::Unit* units) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.units_;
  }
  if (units) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(units);
    if (message_arena != submessage_arena) {
      units = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, units, submessage_arena);
    }

  } else {

  }
  _impl_.units_ = units;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlING.units)
}

// -------------------------------------------------------------------

// ControlISC

// int32 ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlISC::clear_ctlval() {
  _impl_.ctlval_ = 0;
}
inline ::int32_t ControlISC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlISC.ctlVal)
  return _internal_ctlval();
}
inline void ControlISC::set_ctlval(::int32_t value) {
  _internal_set_ctlval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlISC.ctlVal)
}
inline ::int32_t ControlISC::_internal_ctlval() const {
  return _impl_.ctlval_;
}
inline void ControlISC::_internal_set_ctlval(::int32_t value) {
  ;
  _impl_.ctlval_ = value;
}

// -------------------------------------------------------------------

// ControlMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ControlMessageInfo::_internal_has_messageinfo() const {
  return this != internal_default_instance() && _impl_.messageinfo_ != nullptr;
}
inline bool ControlMessageInfo::has_messageinfo() const {
  return _internal_has_messageinfo();
}
inline void ControlMessageInfo::clear_messageinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& ControlMessageInfo::_internal_messageinfo() const {
  const ::commonmodule::MessageInfo* p = _impl_.messageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MessageInfo&>(
      ::commonmodule::_MessageInfo_default_instance_);
}
inline const ::commonmodule::MessageInfo& ControlMessageInfo::messageinfo() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlMessageInfo.messageInfo)
  return _internal_messageinfo();
}
inline void ControlMessageInfo::unsafe_arena_set_allocated_messageinfo(
    ::commonmodule::MessageInfo* messageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageinfo_);
  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlMessageInfo.messageInfo)
}
inline ::commonmodule::MessageInfo* ControlMessageInfo::release_messageinfo() {
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MessageInfo* ControlMessageInfo::unsafe_arena_release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* ControlMessageInfo::_internal_mutable_messageinfo() {
  
  if (_impl_.messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaForAllocation());
    _impl_.messageinfo_ = p;
  }
  return _impl_.messageinfo_;
}
inline ::commonmodule::MessageInfo* ControlMessageInfo::mutable_messageinfo() {
  ::commonmodule::MessageInfo* _msg = _internal_mutable_messageinfo();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlMessageInfo.messageInfo)
  return _msg;
}
inline void ControlMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messageinfo_;
  }
  if (messageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messageinfo);
    if (message_arena != submessage_arena) {
      messageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// ControlSPC

// bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ControlSPC::clear_ctlval() {
  _impl_.ctlval_ = false;
}
inline bool ControlSPC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlSPC.ctlVal)
  return _internal_ctlval();
}
inline void ControlSPC::set_ctlval(bool value) {
  _internal_set_ctlval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ControlSPC.ctlVal)
}
inline bool ControlSPC::_internal_ctlval() const {
  return _impl_.ctlval_;
}
inline void ControlSPC::_internal_set_ctlval(bool value) {
  ;
  _impl_.ctlval_ = value;
}

// -------------------------------------------------------------------

// ControlValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ControlValue::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool ControlValue::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void ControlValue::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ControlValue::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& ControlValue::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlValue.identifiedObject)
  return _internal_identifiedobject();
}
inline void ControlValue::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlValue.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* ControlValue::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* ControlValue::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ControlValue::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* ControlValue::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlValue.identifiedObject)
  return _msg;
}
inline void ControlValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlValue.identifiedObject)
}

// .google.protobuf.BoolValue modBlk = 3;
inline bool ControlValue::_internal_has_modblk() const {
  return this != internal_default_instance() && _impl_.modblk_ != nullptr;
}
inline bool ControlValue::has_modblk() const {
  return _internal_has_modblk();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ControlValue::_internal_modblk() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.modblk_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ControlValue::modblk() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlValue.modBlk)
  return _internal_modblk();
}
inline void ControlValue::unsafe_arena_set_allocated_modblk(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modblk_);
  }
  _impl_.modblk_ = modblk;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlValue.modBlk)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::release_modblk() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.modblk_;
  _impl_.modblk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::unsafe_arena_release_modblk() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlValue.modBlk)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.modblk_;
  _impl_.modblk_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::_internal_mutable_modblk() {
  
  if (_impl_.modblk_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.modblk_ = p;
  }
  return _impl_.modblk_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::mutable_modblk() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_modblk();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlValue.modBlk)
  return _msg;
}
inline void ControlValue::set_allocated_modblk(::PROTOBUF_NAMESPACE_ID::BoolValue* modblk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modblk_);
  }
  if (modblk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modblk));
    if (message_arena != submessage_arena) {
      modblk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modblk, submessage_arena);
    }

  } else {

  }
  _impl_.modblk_ = modblk;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlValue.modBlk)
}

// .google.protobuf.BoolValue reset = 4;
inline bool ControlValue::_internal_has_reset() const {
  return this != internal_default_instance() && _impl_.reset_ != nullptr;
}
inline bool ControlValue::has_reset() const {
  return _internal_has_reset();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ControlValue::_internal_reset() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.reset_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ControlValue::reset() const {
  // @@protoc_insertion_point(field_get:commonmodule.ControlValue.reset)
  return _internal_reset();
}
inline void ControlValue::unsafe_arena_set_allocated_reset(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* reset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ControlValue.reset)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::release_reset() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::unsafe_arena_release_reset() {
  // @@protoc_insertion_point(field_release:commonmodule.ControlValue.reset)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::_internal_mutable_reset() {
  
  if (_impl_.reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.reset_ = p;
  }
  return _impl_.reset_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ControlValue::mutable_reset() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_reset();
  // @@protoc_insertion_point(field_mutable:commonmodule.ControlValue.reset)
  return _msg;
}
inline void ControlValue::set_allocated_reset(::PROTOBUF_NAMESPACE_ID::BoolValue* reset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  if (reset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reset));
    if (message_arena != submessage_arena) {
      reset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }

  } else {

  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ControlValue.reset)
}

// -------------------------------------------------------------------

// CumulativeTime

// uint64 seconds = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void CumulativeTime::clear_seconds() {
  _impl_.seconds_ = ::uint64_t{0u};
}
inline ::uint64_t CumulativeTime::seconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.CumulativeTime.seconds)
  return _internal_seconds();
}
inline void CumulativeTime::set_seconds(::uint64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.CumulativeTime.seconds)
}
inline ::uint64_t CumulativeTime::_internal_seconds() const {
  return _impl_.seconds_;
}
inline void CumulativeTime::_internal_set_seconds(::uint64_t value) {
  ;
  _impl_.seconds_ = value;
}

// uint32 nanoseconds = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void CumulativeTime::clear_nanoseconds() {
  _impl_.nanoseconds_ = 0u;
}
inline ::uint32_t CumulativeTime::nanoseconds() const {
  // @@protoc_insertion_point(field_get:commonmodule.CumulativeTime.nanoseconds)
  return _internal_nanoseconds();
}
inline void CumulativeTime::set_nanoseconds(::uint32_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:commonmodule.CumulativeTime.nanoseconds)
}
inline ::uint32_t CumulativeTime::_internal_nanoseconds() const {
  return _impl_.nanoseconds_;
}
inline void CumulativeTime::_internal_set_nanoseconds(::uint32_t value) {
  ;
  _impl_.nanoseconds_ = value;
}

// -------------------------------------------------------------------

// DateTimeInterval

// .google.protobuf.Int64Value end = 1;
inline bool DateTimeInterval::_internal_has_end() const {
  return this != internal_default_instance() && _impl_.end_ != nullptr;
}
inline bool DateTimeInterval::has_end() const {
  return _internal_has_end();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& DateTimeInterval::_internal_end() const {
  const ::PROTOBUF_NAMESPACE_ID::Int64Value* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& DateTimeInterval::end() const {
  // @@protoc_insertion_point(field_get:commonmodule.DateTimeInterval.end)
  return _internal_end();
}
inline void DateTimeInterval::unsafe_arena_set_allocated_end(
    ::PROTOBUF_NAMESPACE_ID::Int64Value* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DateTimeInterval.end)
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::release_end() {
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:commonmodule.DateTimeInterval.end)
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::_internal_mutable_end() {
  
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int64Value>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::mutable_end() {
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:commonmodule.DateTimeInterval.end)
  return _msg;
}
inline void DateTimeInterval::set_allocated_end(::PROTOBUF_NAMESPACE_ID::Int64Value* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }

  } else {

  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DateTimeInterval.end)
}

// .google.protobuf.Int64Value start = 2;
inline bool DateTimeInterval::_internal_has_start() const {
  return this != internal_default_instance() && _impl_.start_ != nullptr;
}
inline bool DateTimeInterval::has_start() const {
  return _internal_has_start();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& DateTimeInterval::_internal_start() const {
  const ::PROTOBUF_NAMESPACE_ID::Int64Value* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int64Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int64Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int64Value& DateTimeInterval::start() const {
  // @@protoc_insertion_point(field_get:commonmodule.DateTimeInterval.start)
  return _internal_start();
}
inline void DateTimeInterval::unsafe_arena_set_allocated_start(
    ::PROTOBUF_NAMESPACE_ID::Int64Value* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DateTimeInterval.start)
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::release_start() {
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:commonmodule.DateTimeInterval.start)
  
  ::PROTOBUF_NAMESPACE_ID::Int64Value* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::_internal_mutable_start() {
  
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int64Value>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int64Value* DateTimeInterval::mutable_start() {
  ::PROTOBUF_NAMESPACE_ID::Int64Value* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:commonmodule.DateTimeInterval.start)
  return _msg;
}
inline void DateTimeInterval::set_allocated_start(::PROTOBUF_NAMESPACE_ID::Int64Value* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }

  } else {

  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DateTimeInterval.start)
}

// -------------------------------------------------------------------

// DEL

// .commonmodule.CMV phsAB = 1;
inline bool DEL::_internal_has_phsab() const {
  return this != internal_default_instance() && _impl_.phsab_ != nullptr;
}
inline bool DEL::has_phsab() const {
  return _internal_has_phsab();
}
inline void DEL::clear_phsab() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsab_ != nullptr) {
    delete _impl_.phsab_;
  }
  _impl_.phsab_ = nullptr;
}
inline const ::commonmodule::CMV& DEL::_internal_phsab() const {
  const ::commonmodule::CMV* p = _impl_.phsab_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& DEL::phsab() const {
  // @@protoc_insertion_point(field_get:commonmodule.DEL.phsAB)
  return _internal_phsab();
}
inline void DEL::unsafe_arena_set_allocated_phsab(
    ::commonmodule::CMV* phsab) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsab_);
  }
  _impl_.phsab_ = phsab;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DEL.phsAB)
}
inline ::commonmodule::CMV* DEL::release_phsab() {
  
  ::commonmodule::CMV* temp = _impl_.phsab_;
  _impl_.phsab_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* DEL::unsafe_arena_release_phsab() {
  // @@protoc_insertion_point(field_release:commonmodule.DEL.phsAB)
  
  ::commonmodule::CMV* temp = _impl_.phsab_;
  _impl_.phsab_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* DEL::_internal_mutable_phsab() {
  
  if (_impl_.phsab_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.phsab_ = p;
  }
  return _impl_.phsab_;
}
inline ::commonmodule::CMV* DEL::mutable_phsab() {
  ::commonmodule::CMV* _msg = _internal_mutable_phsab();
  // @@protoc_insertion_point(field_mutable:commonmodule.DEL.phsAB)
  return _msg;
}
inline void DEL::set_allocated_phsab(::commonmodule::CMV* phsab) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsab_;
  }
  if (phsab) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsab);
    if (message_arena != submessage_arena) {
      phsab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsab, submessage_arena);
    }

  } else {

  }
  _impl_.phsab_ = phsab;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DEL.phsAB)
}

// .commonmodule.CMV phsBC = 2;
inline bool DEL::_internal_has_phsbc() const {
  return this != internal_default_instance() && _impl_.phsbc_ != nullptr;
}
inline bool DEL::has_phsbc() const {
  return _internal_has_phsbc();
}
inline void DEL::clear_phsbc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsbc_ != nullptr) {
    delete _impl_.phsbc_;
  }
  _impl_.phsbc_ = nullptr;
}
inline const ::commonmodule::CMV& DEL::_internal_phsbc() const {
  const ::commonmodule::CMV* p = _impl_.phsbc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& DEL::phsbc() const {
  // @@protoc_insertion_point(field_get:commonmodule.DEL.phsBC)
  return _internal_phsbc();
}
inline void DEL::unsafe_arena_set_allocated_phsbc(
    ::commonmodule::CMV* phsbc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsbc_);
  }
  _impl_.phsbc_ = phsbc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DEL.phsBC)
}
inline ::commonmodule::CMV* DEL::release_phsbc() {
  
  ::commonmodule::CMV* temp = _impl_.phsbc_;
  _impl_.phsbc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* DEL::unsafe_arena_release_phsbc() {
  // @@protoc_insertion_point(field_release:commonmodule.DEL.phsBC)
  
  ::commonmodule::CMV* temp = _impl_.phsbc_;
  _impl_.phsbc_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* DEL::_internal_mutable_phsbc() {
  
  if (_impl_.phsbc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.phsbc_ = p;
  }
  return _impl_.phsbc_;
}
inline ::commonmodule::CMV* DEL::mutable_phsbc() {
  ::commonmodule::CMV* _msg = _internal_mutable_phsbc();
  // @@protoc_insertion_point(field_mutable:commonmodule.DEL.phsBC)
  return _msg;
}
inline void DEL::set_allocated_phsbc(::commonmodule::CMV* phsbc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsbc_;
  }
  if (phsbc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsbc);
    if (message_arena != submessage_arena) {
      phsbc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsbc, submessage_arena);
    }

  } else {

  }
  _impl_.phsbc_ = phsbc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DEL.phsBC)
}

// .commonmodule.CMV phsCA = 3;
inline bool DEL::_internal_has_phsca() const {
  return this != internal_default_instance() && _impl_.phsca_ != nullptr;
}
inline bool DEL::has_phsca() const {
  return _internal_has_phsca();
}
inline void DEL::clear_phsca() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsca_ != nullptr) {
    delete _impl_.phsca_;
  }
  _impl_.phsca_ = nullptr;
}
inline const ::commonmodule::CMV& DEL::_internal_phsca() const {
  const ::commonmodule::CMV* p = _impl_.phsca_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& DEL::phsca() const {
  // @@protoc_insertion_point(field_get:commonmodule.DEL.phsCA)
  return _internal_phsca();
}
inline void DEL::unsafe_arena_set_allocated_phsca(
    ::commonmodule::CMV* phsca) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsca_);
  }
  _impl_.phsca_ = phsca;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DEL.phsCA)
}
inline ::commonmodule::CMV* DEL::release_phsca() {
  
  ::commonmodule::CMV* temp = _impl_.phsca_;
  _impl_.phsca_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* DEL::unsafe_arena_release_phsca() {
  // @@protoc_insertion_point(field_release:commonmodule.DEL.phsCA)
  
  ::commonmodule::CMV* temp = _impl_.phsca_;
  _impl_.phsca_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* DEL::_internal_mutable_phsca() {
  
  if (_impl_.phsca_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.phsca_ = p;
  }
  return _impl_.phsca_;
}
inline ::commonmodule::CMV* DEL::mutable_phsca() {
  ::commonmodule::CMV* _msg = _internal_mutable_phsca();
  // @@protoc_insertion_point(field_mutable:commonmodule.DEL.phsCA)
  return _msg;
}
inline void DEL::set_allocated_phsca(::commonmodule::CMV* phsca) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsca_;
  }
  if (phsca) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsca);
    if (message_arena != submessage_arena) {
      phsca = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsca, submessage_arena);
    }

  } else {

  }
  _impl_.phsca_ = phsca;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DEL.phsCA)
}

// -------------------------------------------------------------------

// PhaseDPC

// .commonmodule.ControlDPC phs3 = 1;
inline bool PhaseDPC::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseDPC::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseDPC::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::ControlDPC& PhaseDPC::_internal_phs3() const {
  const ::commonmodule::ControlDPC* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlDPC&>(
      ::commonmodule::_ControlDPC_default_instance_);
}
inline const ::commonmodule::ControlDPC& PhaseDPC::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPC.phs3)
  return _internal_phs3();
}
inline void PhaseDPC::unsafe_arena_set_allocated_phs3(
    ::commonmodule::ControlDPC* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPC.phs3)
}
inline ::commonmodule::ControlDPC* PhaseDPC::release_phs3() {
  
  ::commonmodule::ControlDPC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPC.phs3)
  
  ::commonmodule::ControlDPC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::ControlDPC* PhaseDPC::mutable_phs3() {
  ::commonmodule::ControlDPC* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPC.phs3)
  return _msg;
}
inline void PhaseDPC::set_allocated_phs3(::commonmodule::ControlDPC* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPC.phs3)
}

// .commonmodule.ControlDPC phsA = 2;
inline bool PhaseDPC::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseDPC::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseDPC::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::ControlDPC& PhaseDPC::_internal_phsa() const {
  const ::commonmodule::ControlDPC* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlDPC&>(
      ::commonmodule::_ControlDPC_default_instance_);
}
inline const ::commonmodule::ControlDPC& PhaseDPC::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPC.phsA)
  return _internal_phsa();
}
inline void PhaseDPC::unsafe_arena_set_allocated_phsa(
    ::commonmodule::ControlDPC* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPC.phsA)
}
inline ::commonmodule::ControlDPC* PhaseDPC::release_phsa() {
  
  ::commonmodule::ControlDPC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPC.phsA)
  
  ::commonmodule::ControlDPC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::ControlDPC* PhaseDPC::mutable_phsa() {
  ::commonmodule::ControlDPC* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPC.phsA)
  return _msg;
}
inline void PhaseDPC::set_allocated_phsa(::commonmodule::ControlDPC* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPC.phsA)
}

// .commonmodule.ControlDPC phsB = 3;
inline bool PhaseDPC::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseDPC::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseDPC::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::ControlDPC& PhaseDPC::_internal_phsb() const {
  const ::commonmodule::ControlDPC* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlDPC&>(
      ::commonmodule::_ControlDPC_default_instance_);
}
inline const ::commonmodule::ControlDPC& PhaseDPC::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPC.phsB)
  return _internal_phsb();
}
inline void PhaseDPC::unsafe_arena_set_allocated_phsb(
    ::commonmodule::ControlDPC* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPC.phsB)
}
inline ::commonmodule::ControlDPC* PhaseDPC::release_phsb() {
  
  ::commonmodule::ControlDPC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPC.phsB)
  
  ::commonmodule::ControlDPC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::ControlDPC* PhaseDPC::mutable_phsb() {
  ::commonmodule::ControlDPC* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPC.phsB)
  return _msg;
}
inline void PhaseDPC::set_allocated_phsb(::commonmodule::ControlDPC* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPC.phsB)
}

// .commonmodule.ControlDPC phsC = 4;
inline bool PhaseDPC::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseDPC::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseDPC::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::ControlDPC& PhaseDPC::_internal_phsc() const {
  const ::commonmodule::ControlDPC* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlDPC&>(
      ::commonmodule::_ControlDPC_default_instance_);
}
inline const ::commonmodule::ControlDPC& PhaseDPC::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPC.phsC)
  return _internal_phsc();
}
inline void PhaseDPC::unsafe_arena_set_allocated_phsc(
    ::commonmodule::ControlDPC* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPC.phsC)
}
inline ::commonmodule::ControlDPC* PhaseDPC::release_phsc() {
  
  ::commonmodule::ControlDPC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPC.phsC)
  
  ::commonmodule::ControlDPC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* PhaseDPC::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::ControlDPC* PhaseDPC::mutable_phsc() {
  ::commonmodule::ControlDPC* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPC.phsC)
  return _msg;
}
inline void PhaseDPC::set_allocated_phsc(::commonmodule::ControlDPC* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPC.phsC)
}

// -------------------------------------------------------------------

// DiscreteControlXCBR

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool DiscreteControlXCBR::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && _impl_.logicalnodeforcontrol_ != nullptr;
}
inline bool DiscreteControlXCBR::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline void DiscreteControlXCBR::clear_logicalnodeforcontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnodeforcontrol_ != nullptr) {
    delete _impl_.logicalnodeforcontrol_;
  }
  _impl_.logicalnodeforcontrol_ = nullptr;
}
inline const ::commonmodule::LogicalNodeForControl& DiscreteControlXCBR::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& DiscreteControlXCBR::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:commonmodule.DiscreteControlXCBR.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void DiscreteControlXCBR::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DiscreteControlXCBR.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* DiscreteControlXCBR::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* DiscreteControlXCBR::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:commonmodule.DiscreteControlXCBR.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* DiscreteControlXCBR::_internal_mutable_logicalnodeforcontrol() {
  
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaForAllocation());
    _impl_.logicalnodeforcontrol_ = p;
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* DiscreteControlXCBR::mutable_logicalnodeforcontrol() {
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:commonmodule.DiscreteControlXCBR.logicalNodeForControl)
  return _msg;
}
inline void DiscreteControlXCBR::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnodeforcontrol_;
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnodeforcontrol);
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DiscreteControlXCBR.logicalNodeForControl)
}

// .commonmodule.PhaseDPC Pos = 2;
inline bool DiscreteControlXCBR::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool DiscreteControlXCBR::has_pos() const {
  return _internal_has_pos();
}
inline void DiscreteControlXCBR::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::commonmodule::PhaseDPC& DiscreteControlXCBR::_internal_pos() const {
  const ::commonmodule::PhaseDPC* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseDPC&>(
      ::commonmodule::_PhaseDPC_default_instance_);
}
inline const ::commonmodule::PhaseDPC& DiscreteControlXCBR::pos() const {
  // @@protoc_insertion_point(field_get:commonmodule.DiscreteControlXCBR.Pos)
  return _internal_pos();
}
inline void DiscreteControlXCBR::unsafe_arena_set_allocated_pos(
    ::commonmodule::PhaseDPC* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DiscreteControlXCBR.Pos)
}
inline ::commonmodule::PhaseDPC* DiscreteControlXCBR::release_pos() {
  
  ::commonmodule::PhaseDPC* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseDPC* DiscreteControlXCBR::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:commonmodule.DiscreteControlXCBR.Pos)
  
  ::commonmodule::PhaseDPC* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseDPC* DiscreteControlXCBR::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseDPC>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::commonmodule::PhaseDPC* DiscreteControlXCBR::mutable_pos() {
  ::commonmodule::PhaseDPC* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:commonmodule.DiscreteControlXCBR.Pos)
  return _msg;
}
inline void DiscreteControlXCBR::set_allocated_pos(::commonmodule::PhaseDPC* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }

  } else {

  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DiscreteControlXCBR.Pos)
}

// .commonmodule.ControlINC ProtectionMode = 3;
inline bool DiscreteControlXCBR::_internal_has_protectionmode() const {
  return this != internal_default_instance() && _impl_.protectionmode_ != nullptr;
}
inline bool DiscreteControlXCBR::has_protectionmode() const {
  return _internal_has_protectionmode();
}
inline void DiscreteControlXCBR::clear_protectionmode() {
  if (GetArenaForAllocation() == nullptr && _impl_.protectionmode_ != nullptr) {
    delete _impl_.protectionmode_;
  }
  _impl_.protectionmode_ = nullptr;
}
inline const ::commonmodule::ControlINC& DiscreteControlXCBR::_internal_protectionmode() const {
  const ::commonmodule::ControlINC* p = _impl_.protectionmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlINC&>(
      ::commonmodule::_ControlINC_default_instance_);
}
inline const ::commonmodule::ControlINC& DiscreteControlXCBR::protectionmode() const {
  // @@protoc_insertion_point(field_get:commonmodule.DiscreteControlXCBR.ProtectionMode)
  return _internal_protectionmode();
}
inline void DiscreteControlXCBR::unsafe_arena_set_allocated_protectionmode(
    ::commonmodule::ControlINC* protectionmode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectionmode_);
  }
  _impl_.protectionmode_ = protectionmode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DiscreteControlXCBR.ProtectionMode)
}
inline ::commonmodule::ControlINC* DiscreteControlXCBR::release_protectionmode() {
  
  ::commonmodule::ControlINC* temp = _impl_.protectionmode_;
  _impl_.protectionmode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlINC* DiscreteControlXCBR::unsafe_arena_release_protectionmode() {
  // @@protoc_insertion_point(field_release:commonmodule.DiscreteControlXCBR.ProtectionMode)
  
  ::commonmodule::ControlINC* temp = _impl_.protectionmode_;
  _impl_.protectionmode_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlINC* DiscreteControlXCBR::_internal_mutable_protectionmode() {
  
  if (_impl_.protectionmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlINC>(GetArenaForAllocation());
    _impl_.protectionmode_ = p;
  }
  return _impl_.protectionmode_;
}
inline ::commonmodule::ControlINC* DiscreteControlXCBR::mutable_protectionmode() {
  ::commonmodule::ControlINC* _msg = _internal_mutable_protectionmode();
  // @@protoc_insertion_point(field_mutable:commonmodule.DiscreteControlXCBR.ProtectionMode)
  return _msg;
}
inline void DiscreteControlXCBR::set_allocated_protectionmode(::commonmodule::ControlINC* protectionmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protectionmode_;
  }
  if (protectionmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protectionmode);
    if (message_arena != submessage_arena) {
      protectionmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectionmode, submessage_arena);
    }

  } else {

  }
  _impl_.protectionmode_ = protectionmode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DiscreteControlXCBR.ProtectionMode)
}

// .commonmodule.ControlSPC RecloseEnabled = 4;
inline bool DiscreteControlXCBR::_internal_has_recloseenabled() const {
  return this != internal_default_instance() && _impl_.recloseenabled_ != nullptr;
}
inline bool DiscreteControlXCBR::has_recloseenabled() const {
  return _internal_has_recloseenabled();
}
inline void DiscreteControlXCBR::clear_recloseenabled() {
  if (GetArenaForAllocation() == nullptr && _impl_.recloseenabled_ != nullptr) {
    delete _impl_.recloseenabled_;
  }
  _impl_.recloseenabled_ = nullptr;
}
inline const ::commonmodule::ControlSPC& DiscreteControlXCBR::_internal_recloseenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.recloseenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& DiscreteControlXCBR::recloseenabled() const {
  // @@protoc_insertion_point(field_get:commonmodule.DiscreteControlXCBR.RecloseEnabled)
  return _internal_recloseenabled();
}
inline void DiscreteControlXCBR::unsafe_arena_set_allocated_recloseenabled(
    ::commonmodule::ControlSPC* recloseenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recloseenabled_);
  }
  _impl_.recloseenabled_ = recloseenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DiscreteControlXCBR.RecloseEnabled)
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::release_recloseenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.recloseenabled_;
  _impl_.recloseenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::unsafe_arena_release_recloseenabled() {
  // @@protoc_insertion_point(field_release:commonmodule.DiscreteControlXCBR.RecloseEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.recloseenabled_;
  _impl_.recloseenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::_internal_mutable_recloseenabled() {
  
  if (_impl_.recloseenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.recloseenabled_ = p;
  }
  return _impl_.recloseenabled_;
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::mutable_recloseenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_recloseenabled();
  // @@protoc_insertion_point(field_mutable:commonmodule.DiscreteControlXCBR.RecloseEnabled)
  return _msg;
}
inline void DiscreteControlXCBR::set_allocated_recloseenabled(::commonmodule::ControlSPC* recloseenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recloseenabled_;
  }
  if (recloseenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recloseenabled);
    if (message_arena != submessage_arena) {
      recloseenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recloseenabled, submessage_arena);
    }

  } else {

  }
  _impl_.recloseenabled_ = recloseenabled;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DiscreteControlXCBR.RecloseEnabled)
}

// .commonmodule.ControlSPC ResetProtectionPickup = 5;
inline bool DiscreteControlXCBR::_internal_has_resetprotectionpickup() const {
  return this != internal_default_instance() && _impl_.resetprotectionpickup_ != nullptr;
}
inline bool DiscreteControlXCBR::has_resetprotectionpickup() const {
  return _internal_has_resetprotectionpickup();
}
inline void DiscreteControlXCBR::clear_resetprotectionpickup() {
  if (GetArenaForAllocation() == nullptr && _impl_.resetprotectionpickup_ != nullptr) {
    delete _impl_.resetprotectionpickup_;
  }
  _impl_.resetprotectionpickup_ = nullptr;
}
inline const ::commonmodule::ControlSPC& DiscreteControlXCBR::_internal_resetprotectionpickup() const {
  const ::commonmodule::ControlSPC* p = _impl_.resetprotectionpickup_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& DiscreteControlXCBR::resetprotectionpickup() const {
  // @@protoc_insertion_point(field_get:commonmodule.DiscreteControlXCBR.ResetProtectionPickup)
  return _internal_resetprotectionpickup();
}
inline void DiscreteControlXCBR::unsafe_arena_set_allocated_resetprotectionpickup(
    ::commonmodule::ControlSPC* resetprotectionpickup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resetprotectionpickup_);
  }
  _impl_.resetprotectionpickup_ = resetprotectionpickup;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.DiscreteControlXCBR.ResetProtectionPickup)
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::release_resetprotectionpickup() {
  
  ::commonmodule::ControlSPC* temp = _impl_.resetprotectionpickup_;
  _impl_.resetprotectionpickup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::unsafe_arena_release_resetprotectionpickup() {
  // @@protoc_insertion_point(field_release:commonmodule.DiscreteControlXCBR.ResetProtectionPickup)
  
  ::commonmodule::ControlSPC* temp = _impl_.resetprotectionpickup_;
  _impl_.resetprotectionpickup_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::_internal_mutable_resetprotectionpickup() {
  
  if (_impl_.resetprotectionpickup_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.resetprotectionpickup_ = p;
  }
  return _impl_.resetprotectionpickup_;
}
inline ::commonmodule::ControlSPC* DiscreteControlXCBR::mutable_resetprotectionpickup() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_resetprotectionpickup();
  // @@protoc_insertion_point(field_mutable:commonmodule.DiscreteControlXCBR.ResetProtectionPickup)
  return _msg;
}
inline void DiscreteControlXCBR::set_allocated_resetprotectionpickup(::commonmodule::ControlSPC* resetprotectionpickup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resetprotectionpickup_;
  }
  if (resetprotectionpickup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resetprotectionpickup);
    if (message_arena != submessage_arena) {
      resetprotectionpickup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resetprotectionpickup, submessage_arena);
    }

  } else {

  }
  _impl_.resetprotectionpickup_ = resetprotectionpickup;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.DiscreteControlXCBR.ResetProtectionPickup)
}

// -------------------------------------------------------------------

// EnergyConsumer

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool EnergyConsumer::_internal_has_conductingequipment() const {
  return this != internal_default_instance() && _impl_.conductingequipment_ != nullptr;
}
inline bool EnergyConsumer::has_conductingequipment() const {
  return _internal_has_conductingequipment();
}
inline void EnergyConsumer::clear_conductingequipment() {
  if (GetArenaForAllocation() == nullptr && _impl_.conductingequipment_ != nullptr) {
    delete _impl_.conductingequipment_;
  }
  _impl_.conductingequipment_ = nullptr;
}
inline const ::commonmodule::ConductingEquipment& EnergyConsumer::_internal_conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& EnergyConsumer::conductingequipment() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnergyConsumer.conductingEquipment)
  return _internal_conductingequipment();
}
inline void EnergyConsumer::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* conductingequipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.EnergyConsumer.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* EnergyConsumer::release_conductingequipment() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* EnergyConsumer::unsafe_arena_release_conductingequipment() {
  // @@protoc_insertion_point(field_release:commonmodule.EnergyConsumer.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* EnergyConsumer::_internal_mutable_conductingequipment() {
  
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.conductingequipment_ = p;
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* EnergyConsumer::mutable_conductingequipment() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:commonmodule.EnergyConsumer.conductingEquipment)
  return _msg;
}
inline void EnergyConsumer::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conductingequipment_;
  }
  if (conductingequipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conductingequipment);
    if (message_arena != submessage_arena) {
      conductingequipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EnergyConsumer.conductingEquipment)
}

// .google.protobuf.StringValue operatingLimit = 2;
inline bool EnergyConsumer::_internal_has_operatinglimit() const {
  return this != internal_default_instance() && _impl_.operatinglimit_ != nullptr;
}
inline bool EnergyConsumer::has_operatinglimit() const {
  return _internal_has_operatinglimit();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& EnergyConsumer::_internal_operatinglimit() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.operatinglimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& EnergyConsumer::operatinglimit() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnergyConsumer.operatingLimit)
  return _internal_operatinglimit();
}
inline void EnergyConsumer::unsafe_arena_set_allocated_operatinglimit(
    ::PROTOBUF_NAMESPACE_ID::StringValue* operatinglimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operatinglimit_);
  }
  _impl_.operatinglimit_ = operatinglimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.EnergyConsumer.operatingLimit)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* EnergyConsumer::release_operatinglimit() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.operatinglimit_;
  _impl_.operatinglimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* EnergyConsumer::unsafe_arena_release_operatinglimit() {
  // @@protoc_insertion_point(field_release:commonmodule.EnergyConsumer.operatingLimit)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.operatinglimit_;
  _impl_.operatinglimit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* EnergyConsumer::_internal_mutable_operatinglimit() {
  
  if (_impl_.operatinglimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.operatinglimit_ = p;
  }
  return _impl_.operatinglimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* EnergyConsumer::mutable_operatinglimit() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_operatinglimit();
  // @@protoc_insertion_point(field_mutable:commonmodule.EnergyConsumer.operatingLimit)
  return _msg;
}
inline void EnergyConsumer::set_allocated_operatinglimit(::PROTOBUF_NAMESPACE_ID::StringValue* operatinglimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operatinglimit_);
  }
  if (operatinglimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(operatinglimit));
    if (message_arena != submessage_arena) {
      operatinglimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operatinglimit, submessage_arena);
    }

  } else {

  }
  _impl_.operatinglimit_ = operatinglimit;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EnergyConsumer.operatingLimit)
}

// -------------------------------------------------------------------

// Optional_CalcMethodKind

// .commonmodule.CalcMethodKind value = 1;
inline void Optional_CalcMethodKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::CalcMethodKind Optional_CalcMethodKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_CalcMethodKind.value)
  return _internal_value();
}
inline void Optional_CalcMethodKind::set_value(::commonmodule::CalcMethodKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_CalcMethodKind.value)
}
inline ::commonmodule::CalcMethodKind Optional_CalcMethodKind::_internal_value() const {
  return static_cast<::commonmodule::CalcMethodKind>(_impl_.value_);
}
inline void Optional_CalcMethodKind::_internal_set_value(::commonmodule::CalcMethodKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENG_CalcMethodKind

// .commonmodule.CalcMethodKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_CalcMethodKind::clear_setval() {
  _impl_.setval_ = 0;
}
inline ::commonmodule::CalcMethodKind ENG_CalcMethodKind::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_CalcMethodKind.setVal)
  return _internal_setval();
}
inline void ENG_CalcMethodKind::set_setval(::commonmodule::CalcMethodKind value) {
   _internal_set_setval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENG_CalcMethodKind.setVal)
}
inline ::commonmodule::CalcMethodKind ENG_CalcMethodKind::_internal_setval() const {
  return static_cast<::commonmodule::CalcMethodKind>(_impl_.setval_);
}
inline void ENG_CalcMethodKind::_internal_set_setval(::commonmodule::CalcMethodKind value) {
  ;
  _impl_.setval_ = value;
}

// -------------------------------------------------------------------

// Optional_GridConnectModeKind

// .commonmodule.GridConnectModeKind value = 1;
inline void Optional_GridConnectModeKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::GridConnectModeKind Optional_GridConnectModeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_GridConnectModeKind.value)
  return _internal_value();
}
inline void Optional_GridConnectModeKind::set_value(::commonmodule::GridConnectModeKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_GridConnectModeKind.value)
}
inline ::commonmodule::GridConnectModeKind Optional_GridConnectModeKind::_internal_value() const {
  return static_cast<::commonmodule::GridConnectModeKind>(_impl_.value_);
}
inline void Optional_GridConnectModeKind::_internal_set_value(::commonmodule::GridConnectModeKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENG_GridConnectModeKind

// .commonmodule.GridConnectModeKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_GridConnectModeKind::clear_setval() {
  _impl_.setval_ = 0;
}
inline ::commonmodule::GridConnectModeKind ENG_GridConnectModeKind::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_GridConnectModeKind.setVal)
  return _internal_setval();
}
inline void ENG_GridConnectModeKind::set_setval(::commonmodule::GridConnectModeKind value) {
   _internal_set_setval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENG_GridConnectModeKind.setVal)
}
inline ::commonmodule::GridConnectModeKind ENG_GridConnectModeKind::_internal_setval() const {
  return static_cast<::commonmodule::GridConnectModeKind>(_impl_.setval_);
}
inline void ENG_GridConnectModeKind::_internal_set_setval(::commonmodule::GridConnectModeKind value) {
  ;
  _impl_.setval_ = value;
}

// .google.protobuf.StringValue setValExtension = 2;
inline bool ENG_GridConnectModeKind::_internal_has_setvalextension() const {
  return this != internal_default_instance() && _impl_.setvalextension_ != nullptr;
}
inline bool ENG_GridConnectModeKind::has_setvalextension() const {
  return _internal_has_setvalextension();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& ENG_GridConnectModeKind::_internal_setvalextension() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.setvalextension_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& ENG_GridConnectModeKind::setvalextension() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_GridConnectModeKind.setValExtension)
  return _internal_setvalextension();
}
inline void ENG_GridConnectModeKind::unsafe_arena_set_allocated_setvalextension(
    ::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setvalextension_);
  }
  _impl_.setvalextension_ = setvalextension;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENG_GridConnectModeKind.setValExtension)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_GridConnectModeKind::release_setvalextension() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.setvalextension_;
  _impl_.setvalextension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_GridConnectModeKind::unsafe_arena_release_setvalextension() {
  // @@protoc_insertion_point(field_release:commonmodule.ENG_GridConnectModeKind.setValExtension)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.setvalextension_;
  _impl_.setvalextension_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_GridConnectModeKind::_internal_mutable_setvalextension() {
  
  if (_impl_.setvalextension_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.setvalextension_ = p;
  }
  return _impl_.setvalextension_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENG_GridConnectModeKind::mutable_setvalextension() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_setvalextension();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENG_GridConnectModeKind.setValExtension)
  return _msg;
}
inline void ENG_GridConnectModeKind::set_allocated_setvalextension(::PROTOBUF_NAMESPACE_ID::StringValue* setvalextension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setvalextension_);
  }
  if (setvalextension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setvalextension));
    if (message_arena != submessage_arena) {
      setvalextension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setvalextension, submessage_arena);
    }

  } else {

  }
  _impl_.setvalextension_ = setvalextension;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENG_GridConnectModeKind.setValExtension)
}

// -------------------------------------------------------------------

// Optional_PFSignKind

// .commonmodule.PFSignKind value = 1;
inline void Optional_PFSignKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::PFSignKind Optional_PFSignKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_PFSignKind.value)
  return _internal_value();
}
inline void Optional_PFSignKind::set_value(::commonmodule::PFSignKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_PFSignKind.value)
}
inline ::commonmodule::PFSignKind Optional_PFSignKind::_internal_value() const {
  return static_cast<::commonmodule::PFSignKind>(_impl_.value_);
}
inline void Optional_PFSignKind::_internal_set_value(::commonmodule::PFSignKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENG_PFSignKind

// .commonmodule.PFSignKind setVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENG_PFSignKind::clear_setval() {
  _impl_.setval_ = 0;
}
inline ::commonmodule::PFSignKind ENG_PFSignKind::setval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENG_PFSignKind.setVal)
  return _internal_setval();
}
inline void ENG_PFSignKind::set_setval(::commonmodule::PFSignKind value) {
   _internal_set_setval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENG_PFSignKind.setVal)
}
inline ::commonmodule::PFSignKind ENG_PFSignKind::_internal_setval() const {
  return static_cast<::commonmodule::PFSignKind>(_impl_.setval_);
}
inline void ENG_PFSignKind::_internal_set_setval(::commonmodule::PFSignKind value) {
  ;
  _impl_.setval_ = value;
}

// -------------------------------------------------------------------

// Optional_BehaviourModeKind

// .commonmodule.BehaviourModeKind value = 1;
inline void Optional_BehaviourModeKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::BehaviourModeKind Optional_BehaviourModeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_BehaviourModeKind.value)
  return _internal_value();
}
inline void Optional_BehaviourModeKind::set_value(::commonmodule::BehaviourModeKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_BehaviourModeKind.value)
}
inline ::commonmodule::BehaviourModeKind Optional_BehaviourModeKind::_internal_value() const {
  return static_cast<::commonmodule::BehaviourModeKind>(_impl_.value_);
}
inline void Optional_BehaviourModeKind::_internal_set_value(::commonmodule::BehaviourModeKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_BehaviourModeKind

// .commonmodule.Quality q = 1;
inline bool ENS_BehaviourModeKind::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool ENS_BehaviourModeKind::has_q() const {
  return _internal_has_q();
}
inline void ENS_BehaviourModeKind::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& ENS_BehaviourModeKind::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_BehaviourModeKind::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_BehaviourModeKind.q)
  return _internal_q();
}
inline void ENS_BehaviourModeKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_BehaviourModeKind.q)
}
inline ::commonmodule::Quality* ENS_BehaviourModeKind::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* ENS_BehaviourModeKind::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_BehaviourModeKind.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* ENS_BehaviourModeKind::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* ENS_BehaviourModeKind::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_BehaviourModeKind.q)
  return _msg;
}
inline void ENS_BehaviourModeKind::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_BehaviourModeKind.q)
}

// .commonmodule.BehaviourModeKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_BehaviourModeKind::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::commonmodule::BehaviourModeKind ENS_BehaviourModeKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_BehaviourModeKind.stVal)
  return _internal_stval();
}
inline void ENS_BehaviourModeKind::set_stval(::commonmodule::BehaviourModeKind value) {
   _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENS_BehaviourModeKind.stVal)
}
inline ::commonmodule::BehaviourModeKind ENS_BehaviourModeKind::_internal_stval() const {
  return static_cast<::commonmodule::BehaviourModeKind>(_impl_.stval_);
}
inline void ENS_BehaviourModeKind::_internal_set_stval(::commonmodule::BehaviourModeKind value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_BehaviourModeKind::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool ENS_BehaviourModeKind::has_t() const {
  return _internal_has_t();
}
inline void ENS_BehaviourModeKind::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& ENS_BehaviourModeKind::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_BehaviourModeKind::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_BehaviourModeKind.t)
  return _internal_t();
}
inline void ENS_BehaviourModeKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_BehaviourModeKind.t)
}
inline ::commonmodule::Timestamp* ENS_BehaviourModeKind::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* ENS_BehaviourModeKind::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_BehaviourModeKind.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* ENS_BehaviourModeKind::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* ENS_BehaviourModeKind::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_BehaviourModeKind.t)
  return _msg;
}
inline void ENS_BehaviourModeKind::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_BehaviourModeKind.t)
}

// -------------------------------------------------------------------

// Optional_DERGeneratorStateKind

// .commonmodule.DERGeneratorStateKind value = 1;
inline void Optional_DERGeneratorStateKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::DERGeneratorStateKind Optional_DERGeneratorStateKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_DERGeneratorStateKind.value)
  return _internal_value();
}
inline void Optional_DERGeneratorStateKind::set_value(::commonmodule::DERGeneratorStateKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_DERGeneratorStateKind.value)
}
inline ::commonmodule::DERGeneratorStateKind Optional_DERGeneratorStateKind::_internal_value() const {
  return static_cast<::commonmodule::DERGeneratorStateKind>(_impl_.value_);
}
inline void Optional_DERGeneratorStateKind::_internal_set_value(::commonmodule::DERGeneratorStateKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_DERGeneratorStateKind

// .commonmodule.Quality q = 1;
inline bool ENS_DERGeneratorStateKind::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool ENS_DERGeneratorStateKind::has_q() const {
  return _internal_has_q();
}
inline void ENS_DERGeneratorStateKind::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& ENS_DERGeneratorStateKind::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_DERGeneratorStateKind::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DERGeneratorStateKind.q)
  return _internal_q();
}
inline void ENS_DERGeneratorStateKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_DERGeneratorStateKind.q)
}
inline ::commonmodule::Quality* ENS_DERGeneratorStateKind::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* ENS_DERGeneratorStateKind::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DERGeneratorStateKind.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* ENS_DERGeneratorStateKind::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* ENS_DERGeneratorStateKind::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DERGeneratorStateKind.q)
  return _msg;
}
inline void ENS_DERGeneratorStateKind::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DERGeneratorStateKind.q)
}

// .commonmodule.DERGeneratorStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_DERGeneratorStateKind::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::commonmodule::DERGeneratorStateKind ENS_DERGeneratorStateKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DERGeneratorStateKind.stVal)
  return _internal_stval();
}
inline void ENS_DERGeneratorStateKind::set_stval(::commonmodule::DERGeneratorStateKind value) {
   _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENS_DERGeneratorStateKind.stVal)
}
inline ::commonmodule::DERGeneratorStateKind ENS_DERGeneratorStateKind::_internal_stval() const {
  return static_cast<::commonmodule::DERGeneratorStateKind>(_impl_.stval_);
}
inline void ENS_DERGeneratorStateKind::_internal_set_stval(::commonmodule::DERGeneratorStateKind value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_DERGeneratorStateKind::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool ENS_DERGeneratorStateKind::has_t() const {
  return _internal_has_t();
}
inline void ENS_DERGeneratorStateKind::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& ENS_DERGeneratorStateKind::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_DERGeneratorStateKind::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DERGeneratorStateKind.t)
  return _internal_t();
}
inline void ENS_DERGeneratorStateKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_DERGeneratorStateKind.t)
}
inline ::commonmodule::Timestamp* ENS_DERGeneratorStateKind::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* ENS_DERGeneratorStateKind::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DERGeneratorStateKind.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* ENS_DERGeneratorStateKind::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* ENS_DERGeneratorStateKind::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DERGeneratorStateKind.t)
  return _msg;
}
inline void ENS_DERGeneratorStateKind::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DERGeneratorStateKind.t)
}

// -------------------------------------------------------------------

// Optional_DynamicTestKind

// .commonmodule.DynamicTestKind value = 1;
inline void Optional_DynamicTestKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::DynamicTestKind Optional_DynamicTestKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_DynamicTestKind.value)
  return _internal_value();
}
inline void Optional_DynamicTestKind::set_value(::commonmodule::DynamicTestKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_DynamicTestKind.value)
}
inline ::commonmodule::DynamicTestKind Optional_DynamicTestKind::_internal_value() const {
  return static_cast<::commonmodule::DynamicTestKind>(_impl_.value_);
}
inline void Optional_DynamicTestKind::_internal_set_value(::commonmodule::DynamicTestKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_DynamicTestKind

// .commonmodule.Quality q = 1;
inline bool ENS_DynamicTestKind::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool ENS_DynamicTestKind::has_q() const {
  return _internal_has_q();
}
inline void ENS_DynamicTestKind::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& ENS_DynamicTestKind::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_DynamicTestKind::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DynamicTestKind.q)
  return _internal_q();
}
inline void ENS_DynamicTestKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_DynamicTestKind.q)
}
inline ::commonmodule::Quality* ENS_DynamicTestKind::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* ENS_DynamicTestKind::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DynamicTestKind.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* ENS_DynamicTestKind::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* ENS_DynamicTestKind::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DynamicTestKind.q)
  return _msg;
}
inline void ENS_DynamicTestKind::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DynamicTestKind.q)
}

// .commonmodule.DynamicTestKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_DynamicTestKind::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::commonmodule::DynamicTestKind ENS_DynamicTestKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DynamicTestKind.stVal)
  return _internal_stval();
}
inline void ENS_DynamicTestKind::set_stval(::commonmodule::DynamicTestKind value) {
   _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENS_DynamicTestKind.stVal)
}
inline ::commonmodule::DynamicTestKind ENS_DynamicTestKind::_internal_stval() const {
  return static_cast<::commonmodule::DynamicTestKind>(_impl_.stval_);
}
inline void ENS_DynamicTestKind::_internal_set_stval(::commonmodule::DynamicTestKind value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_DynamicTestKind::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool ENS_DynamicTestKind::has_t() const {
  return _internal_has_t();
}
inline void ENS_DynamicTestKind::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& ENS_DynamicTestKind::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_DynamicTestKind::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_DynamicTestKind.t)
  return _internal_t();
}
inline void ENS_DynamicTestKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_DynamicTestKind.t)
}
inline ::commonmodule::Timestamp* ENS_DynamicTestKind::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* ENS_DynamicTestKind::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_DynamicTestKind.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* ENS_DynamicTestKind::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* ENS_DynamicTestKind::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_DynamicTestKind.t)
  return _msg;
}
inline void ENS_DynamicTestKind::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_DynamicTestKind.t)
}

// -------------------------------------------------------------------

// ENS_GridConnectModeKind

// .commonmodule.GridConnectModeKind stVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_GridConnectModeKind::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::commonmodule::GridConnectModeKind ENS_GridConnectModeKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_GridConnectModeKind.stVal)
  return _internal_stval();
}
inline void ENS_GridConnectModeKind::set_stval(::commonmodule::GridConnectModeKind value) {
   _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENS_GridConnectModeKind.stVal)
}
inline ::commonmodule::GridConnectModeKind ENS_GridConnectModeKind::_internal_stval() const {
  return static_cast<::commonmodule::GridConnectModeKind>(_impl_.stval_);
}
inline void ENS_GridConnectModeKind::_internal_set_stval(::commonmodule::GridConnectModeKind value) {
  ;
  _impl_.stval_ = value;
}

// string stValExtension = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_GridConnectModeKind::clear_stvalextension() {
  _impl_.stvalextension_.ClearToEmpty();
}
inline const std::string& ENS_GridConnectModeKind::stvalextension() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_GridConnectModeKind.stValExtension)
  return _internal_stvalextension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ENS_GridConnectModeKind::set_stvalextension(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.stvalextension_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commonmodule.ENS_GridConnectModeKind.stValExtension)
}
inline std::string* ENS_GridConnectModeKind::mutable_stvalextension() {
  std::string* _s = _internal_mutable_stvalextension();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_GridConnectModeKind.stValExtension)
  return _s;
}
inline const std::string& ENS_GridConnectModeKind::_internal_stvalextension() const {
  return _impl_.stvalextension_.Get();
}
inline void ENS_GridConnectModeKind::_internal_set_stvalextension(const std::string& value) {
  ;


  _impl_.stvalextension_.Set(value, GetArenaForAllocation());
}
inline std::string* ENS_GridConnectModeKind::_internal_mutable_stvalextension() {
  ;
  return _impl_.stvalextension_.Mutable( GetArenaForAllocation());
}
inline std::string* ENS_GridConnectModeKind::release_stvalextension() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_GridConnectModeKind.stValExtension)
  return _impl_.stvalextension_.Release();
}
inline void ENS_GridConnectModeKind::set_allocated_stvalextension(std::string* value) {
  _impl_.stvalextension_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stvalextension_.IsDefault()) {
          _impl_.stvalextension_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_GridConnectModeKind.stValExtension)
}

// -------------------------------------------------------------------

// Optional_HealthKind

// .commonmodule.HealthKind value = 1;
inline void Optional_HealthKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::HealthKind Optional_HealthKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_HealthKind.value)
  return _internal_value();
}
inline void Optional_HealthKind::set_value(::commonmodule::HealthKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_HealthKind.value)
}
inline ::commonmodule::HealthKind Optional_HealthKind::_internal_value() const {
  return static_cast<::commonmodule::HealthKind>(_impl_.value_);
}
inline void Optional_HealthKind::_internal_set_value(::commonmodule::HealthKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_HealthKind

// .google.protobuf.StringValue d = 1;
inline bool ENS_HealthKind::_internal_has_d() const {
  return this != internal_default_instance() && _impl_.d_ != nullptr;
}
inline bool ENS_HealthKind::has_d() const {
  return _internal_has_d();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& ENS_HealthKind::_internal_d() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.d_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& ENS_HealthKind::d() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_HealthKind.d)
  return _internal_d();
}
inline void ENS_HealthKind::unsafe_arena_set_allocated_d(
    ::PROTOBUF_NAMESPACE_ID::StringValue* d) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.d_);
  }
  _impl_.d_ = d;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_HealthKind.d)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENS_HealthKind::release_d() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.d_;
  _impl_.d_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENS_HealthKind::unsafe_arena_release_d() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_HealthKind.d)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.d_;
  _impl_.d_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENS_HealthKind::_internal_mutable_d() {
  
  if (_impl_.d_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.d_ = p;
  }
  return _impl_.d_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* ENS_HealthKind::mutable_d() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_HealthKind.d)
  return _msg;
}
inline void ENS_HealthKind::set_allocated_d(::PROTOBUF_NAMESPACE_ID::StringValue* d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.d_);
  }
  if (d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(d));
    if (message_arena != submessage_arena) {
      d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, d, submessage_arena);
    }

  } else {

  }
  _impl_.d_ = d;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_HealthKind.d)
}

// .commonmodule.HealthKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_HealthKind::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::commonmodule::HealthKind ENS_HealthKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_HealthKind.stVal)
  return _internal_stval();
}
inline void ENS_HealthKind::set_stval(::commonmodule::HealthKind value) {
   _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENS_HealthKind.stVal)
}
inline ::commonmodule::HealthKind ENS_HealthKind::_internal_stval() const {
  return static_cast<::commonmodule::HealthKind>(_impl_.stval_);
}
inline void ENS_HealthKind::_internal_set_stval(::commonmodule::HealthKind value) {
  ;
  _impl_.stval_ = value;
}

// -------------------------------------------------------------------

// Optional_SwitchingCapabilityKind

// .commonmodule.SwitchingCapabilityKind value = 1;
inline void Optional_SwitchingCapabilityKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::SwitchingCapabilityKind Optional_SwitchingCapabilityKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_SwitchingCapabilityKind.value)
  return _internal_value();
}
inline void Optional_SwitchingCapabilityKind::set_value(::commonmodule::SwitchingCapabilityKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_SwitchingCapabilityKind.value)
}
inline ::commonmodule::SwitchingCapabilityKind Optional_SwitchingCapabilityKind::_internal_value() const {
  return static_cast<::commonmodule::SwitchingCapabilityKind>(_impl_.value_);
}
inline void Optional_SwitchingCapabilityKind::_internal_set_value(::commonmodule::SwitchingCapabilityKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_SwitchingCapabilityKind

// .google.protobuf.BoolValue blkEna = 1;
inline bool ENS_SwitchingCapabilityKind::_internal_has_blkena() const {
  return this != internal_default_instance() && _impl_.blkena_ != nullptr;
}
inline bool ENS_SwitchingCapabilityKind::has_blkena() const {
  return _internal_has_blkena();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ENS_SwitchingCapabilityKind::_internal_blkena() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.blkena_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& ENS_SwitchingCapabilityKind::blkena() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_SwitchingCapabilityKind.blkEna)
  return _internal_blkena();
}
inline void ENS_SwitchingCapabilityKind::unsafe_arena_set_allocated_blkena(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* blkena) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blkena_);
  }
  _impl_.blkena_ = blkena;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ENS_SwitchingCapabilityKind.blkEna)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ENS_SwitchingCapabilityKind::release_blkena() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.blkena_;
  _impl_.blkena_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ENS_SwitchingCapabilityKind::unsafe_arena_release_blkena() {
  // @@protoc_insertion_point(field_release:commonmodule.ENS_SwitchingCapabilityKind.blkEna)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.blkena_;
  _impl_.blkena_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ENS_SwitchingCapabilityKind::_internal_mutable_blkena() {
  
  if (_impl_.blkena_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.blkena_ = p;
  }
  return _impl_.blkena_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* ENS_SwitchingCapabilityKind::mutable_blkena() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_blkena();
  // @@protoc_insertion_point(field_mutable:commonmodule.ENS_SwitchingCapabilityKind.blkEna)
  return _msg;
}
inline void ENS_SwitchingCapabilityKind::set_allocated_blkena(::PROTOBUF_NAMESPACE_ID::BoolValue* blkena) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blkena_);
  }
  if (blkena) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blkena));
    if (message_arena != submessage_arena) {
      blkena = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blkena, submessage_arena);
    }

  } else {

  }
  _impl_.blkena_ = blkena;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ENS_SwitchingCapabilityKind.blkEna)
}

// .commonmodule.SwitchingCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_SwitchingCapabilityKind::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::commonmodule::SwitchingCapabilityKind ENS_SwitchingCapabilityKind::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.ENS_SwitchingCapabilityKind.stVal)
  return _internal_stval();
}
inline void ENS_SwitchingCapabilityKind::set_stval(::commonmodule::SwitchingCapabilityKind value) {
   _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.ENS_SwitchingCapabilityKind.stVal)
}
inline ::commonmodule::SwitchingCapabilityKind ENS_SwitchingCapabilityKind::_internal_stval() const {
  return static_cast<::commonmodule::SwitchingCapabilityKind>(_impl_.stval_);
}
inline void ENS_SwitchingCapabilityKind::_internal_set_stval(::commonmodule::SwitchingCapabilityKind value) {
  ;
  _impl_.stval_ = value;
}

// -------------------------------------------------------------------

// OperationDCTE

// .commonmodule.ControlING rndDlTmms = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDCTE::_internal_has_rnddltmms() const {
  return this != internal_default_instance() && _impl_.rnddltmms_ != nullptr;
}
inline bool OperationDCTE::has_rnddltmms() const {
  return _internal_has_rnddltmms();
}
inline void OperationDCTE::clear_rnddltmms() {
  if (GetArenaForAllocation() == nullptr && _impl_.rnddltmms_ != nullptr) {
    delete _impl_.rnddltmms_;
  }
  _impl_.rnddltmms_ = nullptr;
}
inline const ::commonmodule::ControlING& OperationDCTE::_internal_rnddltmms() const {
  const ::commonmodule::ControlING* p = _impl_.rnddltmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(
      ::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& OperationDCTE::rnddltmms() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDCTE.rndDlTmms)
  return _internal_rnddltmms();
}
inline void OperationDCTE::unsafe_arena_set_allocated_rnddltmms(
    ::commonmodule::ControlING* rnddltmms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rnddltmms_);
  }
  _impl_.rnddltmms_ = rnddltmms;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDCTE.rndDlTmms)
}
inline ::commonmodule::ControlING* OperationDCTE::release_rnddltmms() {
  
  ::commonmodule::ControlING* temp = _impl_.rnddltmms_;
  _impl_.rnddltmms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlING* OperationDCTE::unsafe_arena_release_rnddltmms() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDCTE.rndDlTmms)
  
  ::commonmodule::ControlING* temp = _impl_.rnddltmms_;
  _impl_.rnddltmms_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* OperationDCTE::_internal_mutable_rnddltmms() {
  
  if (_impl_.rnddltmms_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlING>(GetArenaForAllocation());
    _impl_.rnddltmms_ = p;
  }
  return _impl_.rnddltmms_;
}
inline ::commonmodule::ControlING* OperationDCTE::mutable_rnddltmms() {
  ::commonmodule::ControlING* _msg = _internal_mutable_rnddltmms();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDCTE.rndDlTmms)
  return _msg;
}
inline void OperationDCTE::set_allocated_rnddltmms(::commonmodule::ControlING* rnddltmms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rnddltmms_;
  }
  if (rnddltmms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rnddltmms);
    if (message_arena != submessage_arena) {
      rnddltmms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rnddltmms, submessage_arena);
    }

  } else {

  }
  _impl_.rnddltmms_ = rnddltmms;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDCTE.rndDlTmms)
}

// .commonmodule.ControlING rtnDlTmms = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDCTE::_internal_has_rtndltmms() const {
  return this != internal_default_instance() && _impl_.rtndltmms_ != nullptr;
}
inline bool OperationDCTE::has_rtndltmms() const {
  return _internal_has_rtndltmms();
}
inline void OperationDCTE::clear_rtndltmms() {
  if (GetArenaForAllocation() == nullptr && _impl_.rtndltmms_ != nullptr) {
    delete _impl_.rtndltmms_;
  }
  _impl_.rtndltmms_ = nullptr;
}
inline const ::commonmodule::ControlING& OperationDCTE::_internal_rtndltmms() const {
  const ::commonmodule::ControlING* p = _impl_.rtndltmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(
      ::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& OperationDCTE::rtndltmms() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDCTE.rtnDlTmms)
  return _internal_rtndltmms();
}
inline void OperationDCTE::unsafe_arena_set_allocated_rtndltmms(
    ::commonmodule::ControlING* rtndltmms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtndltmms_);
  }
  _impl_.rtndltmms_ = rtndltmms;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDCTE.rtnDlTmms)
}
inline ::commonmodule::ControlING* OperationDCTE::release_rtndltmms() {
  
  ::commonmodule::ControlING* temp = _impl_.rtndltmms_;
  _impl_.rtndltmms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlING* OperationDCTE::unsafe_arena_release_rtndltmms() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDCTE.rtnDlTmms)
  
  ::commonmodule::ControlING* temp = _impl_.rtndltmms_;
  _impl_.rtndltmms_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* OperationDCTE::_internal_mutable_rtndltmms() {
  
  if (_impl_.rtndltmms_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlING>(GetArenaForAllocation());
    _impl_.rtndltmms_ = p;
  }
  return _impl_.rtndltmms_;
}
inline ::commonmodule::ControlING* OperationDCTE::mutable_rtndltmms() {
  ::commonmodule::ControlING* _msg = _internal_mutable_rtndltmms();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDCTE.rtnDlTmms)
  return _msg;
}
inline void OperationDCTE::set_allocated_rtndltmms(::commonmodule::ControlING* rtndltmms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtndltmms_;
  }
  if (rtndltmms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtndltmms);
    if (message_arena != submessage_arena) {
      rtndltmms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtndltmms, submessage_arena);
    }

  } else {

  }
  _impl_.rtndltmms_ = rtndltmms;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDCTE.rtnDlTmms)
}

// .commonmodule.ControlING rtnRmpTmms = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDCTE::_internal_has_rtnrmptmms() const {
  return this != internal_default_instance() && _impl_.rtnrmptmms_ != nullptr;
}
inline bool OperationDCTE::has_rtnrmptmms() const {
  return _internal_has_rtnrmptmms();
}
inline void OperationDCTE::clear_rtnrmptmms() {
  if (GetArenaForAllocation() == nullptr && _impl_.rtnrmptmms_ != nullptr) {
    delete _impl_.rtnrmptmms_;
  }
  _impl_.rtnrmptmms_ = nullptr;
}
inline const ::commonmodule::ControlING& OperationDCTE::_internal_rtnrmptmms() const {
  const ::commonmodule::ControlING* p = _impl_.rtnrmptmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(
      ::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& OperationDCTE::rtnrmptmms() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDCTE.rtnRmpTmms)
  return _internal_rtnrmptmms();
}
inline void OperationDCTE::unsafe_arena_set_allocated_rtnrmptmms(
    ::commonmodule::ControlING* rtnrmptmms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtnrmptmms_);
  }
  _impl_.rtnrmptmms_ = rtnrmptmms;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDCTE.rtnRmpTmms)
}
inline ::commonmodule::ControlING* OperationDCTE::release_rtnrmptmms() {
  
  ::commonmodule::ControlING* temp = _impl_.rtnrmptmms_;
  _impl_.rtnrmptmms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlING* OperationDCTE::unsafe_arena_release_rtnrmptmms() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDCTE.rtnRmpTmms)
  
  ::commonmodule::ControlING* temp = _impl_.rtnrmptmms_;
  _impl_.rtnrmptmms_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* OperationDCTE::_internal_mutable_rtnrmptmms() {
  
  if (_impl_.rtnrmptmms_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlING>(GetArenaForAllocation());
    _impl_.rtnrmptmms_ = p;
  }
  return _impl_.rtnrmptmms_;
}
inline ::commonmodule::ControlING* OperationDCTE::mutable_rtnrmptmms() {
  ::commonmodule::ControlING* _msg = _internal_mutable_rtnrmptmms();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDCTE.rtnRmpTmms)
  return _msg;
}
inline void OperationDCTE::set_allocated_rtnrmptmms(::commonmodule::ControlING* rtnrmptmms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtnrmptmms_;
  }
  if (rtnrmptmms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtnrmptmms);
    if (message_arena != submessage_arena) {
      rtnrmptmms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtnrmptmms, submessage_arena);
    }

  } else {

  }
  _impl_.rtnrmptmms_ = rtnrmptmms;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDCTE.rtnRmpTmms)
}

// -------------------------------------------------------------------

// EnterServiceAPC

// .commonmodule.OperationDCTE enterServiceParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EnterServiceAPC::_internal_has_enterserviceparameter() const {
  return this != internal_default_instance() && _impl_.enterserviceparameter_ != nullptr;
}
inline bool EnterServiceAPC::has_enterserviceparameter() const {
  return _internal_has_enterserviceparameter();
}
inline void EnterServiceAPC::clear_enterserviceparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.enterserviceparameter_ != nullptr) {
    delete _impl_.enterserviceparameter_;
  }
  _impl_.enterserviceparameter_ = nullptr;
}
inline const ::commonmodule::OperationDCTE& EnterServiceAPC::_internal_enterserviceparameter() const {
  const ::commonmodule::OperationDCTE* p = _impl_.enterserviceparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDCTE&>(
      ::commonmodule::_OperationDCTE_default_instance_);
}
inline const ::commonmodule::OperationDCTE& EnterServiceAPC::enterserviceparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnterServiceAPC.enterServiceParameter)
  return _internal_enterserviceparameter();
}
inline void EnterServiceAPC::unsafe_arena_set_allocated_enterserviceparameter(
    ::commonmodule::OperationDCTE* enterserviceparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceparameter_);
  }
  _impl_.enterserviceparameter_ = enterserviceparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.EnterServiceAPC.enterServiceParameter)
}
inline ::commonmodule::OperationDCTE* EnterServiceAPC::release_enterserviceparameter() {
  
  ::commonmodule::OperationDCTE* temp = _impl_.enterserviceparameter_;
  _impl_.enterserviceparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDCTE* EnterServiceAPC::unsafe_arena_release_enterserviceparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.EnterServiceAPC.enterServiceParameter)
  
  ::commonmodule::OperationDCTE* temp = _impl_.enterserviceparameter_;
  _impl_.enterserviceparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDCTE* EnterServiceAPC::_internal_mutable_enterserviceparameter() {
  
  if (_impl_.enterserviceparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDCTE>(GetArenaForAllocation());
    _impl_.enterserviceparameter_ = p;
  }
  return _impl_.enterserviceparameter_;
}
inline ::commonmodule::OperationDCTE* EnterServiceAPC::mutable_enterserviceparameter() {
  ::commonmodule::OperationDCTE* _msg = _internal_mutable_enterserviceparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.EnterServiceAPC.enterServiceParameter)
  return _msg;
}
inline void EnterServiceAPC::set_allocated_enterserviceparameter(::commonmodule::OperationDCTE* enterserviceparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.enterserviceparameter_;
  }
  if (enterserviceparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(enterserviceparameter);
    if (message_arena != submessage_arena) {
      enterserviceparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enterserviceparameter, submessage_arena);
    }

  } else {

  }
  _impl_.enterserviceparameter_ = enterserviceparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EnterServiceAPC.enterServiceParameter)
}

// float hzHiLim = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EnterServiceAPC::clear_hzhilim() {
  _impl_.hzhilim_ = 0;
}
inline float EnterServiceAPC::hzhilim() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnterServiceAPC.hzHiLim)
  return _internal_hzhilim();
}
inline void EnterServiceAPC::set_hzhilim(float value) {
  _internal_set_hzhilim(value);
  // @@protoc_insertion_point(field_set:commonmodule.EnterServiceAPC.hzHiLim)
}
inline float EnterServiceAPC::_internal_hzhilim() const {
  return _impl_.hzhilim_;
}
inline void EnterServiceAPC::_internal_set_hzhilim(float value) {
  ;
  _impl_.hzhilim_ = value;
}

// float hzLoLim = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EnterServiceAPC::clear_hzlolim() {
  _impl_.hzlolim_ = 0;
}
inline float EnterServiceAPC::hzlolim() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnterServiceAPC.hzLoLim)
  return _internal_hzlolim();
}
inline void EnterServiceAPC::set_hzlolim(float value) {
  _internal_set_hzlolim(value);
  // @@protoc_insertion_point(field_set:commonmodule.EnterServiceAPC.hzLoLim)
}
inline float EnterServiceAPC::_internal_hzlolim() const {
  return _impl_.hzlolim_;
}
inline void EnterServiceAPC::_internal_set_hzlolim(float value) {
  ;
  _impl_.hzlolim_ = value;
}

// bool rtnSrvAuto = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EnterServiceAPC::clear_rtnsrvauto() {
  _impl_.rtnsrvauto_ = false;
}
inline bool EnterServiceAPC::rtnsrvauto() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnterServiceAPC.rtnSrvAuto)
  return _internal_rtnsrvauto();
}
inline void EnterServiceAPC::set_rtnsrvauto(bool value) {
  _internal_set_rtnsrvauto(value);
  // @@protoc_insertion_point(field_set:commonmodule.EnterServiceAPC.rtnSrvAuto)
}
inline bool EnterServiceAPC::_internal_rtnsrvauto() const {
  return _impl_.rtnsrvauto_;
}
inline void EnterServiceAPC::_internal_set_rtnsrvauto(bool value) {
  ;
  _impl_.rtnsrvauto_ = value;
}

// float vHiLim = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EnterServiceAPC::clear_vhilim() {
  _impl_.vhilim_ = 0;
}
inline float EnterServiceAPC::vhilim() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnterServiceAPC.vHiLim)
  return _internal_vhilim();
}
inline void EnterServiceAPC::set_vhilim(float value) {
  _internal_set_vhilim(value);
  // @@protoc_insertion_point(field_set:commonmodule.EnterServiceAPC.vHiLim)
}
inline float EnterServiceAPC::_internal_vhilim() const {
  return _impl_.vhilim_;
}
inline void EnterServiceAPC::_internal_set_vhilim(float value) {
  ;
  _impl_.vhilim_ = value;
}

// float vLoLim = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EnterServiceAPC::clear_vlolim() {
  _impl_.vlolim_ = 0;
}
inline float EnterServiceAPC::vlolim() const {
  // @@protoc_insertion_point(field_get:commonmodule.EnterServiceAPC.vLoLim)
  return _internal_vlolim();
}
inline void EnterServiceAPC::set_vlolim(float value) {
  _internal_set_vlolim(value);
  // @@protoc_insertion_point(field_set:commonmodule.EnterServiceAPC.vLoLim)
}
inline float EnterServiceAPC::_internal_vlolim() const {
  return _impl_.vlolim_;
}
inline void EnterServiceAPC::_internal_set_vlolim(float value) {
  ;
  _impl_.vlolim_ = value;
}

// -------------------------------------------------------------------

// ESS

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool ESS::_internal_has_conductingequipment() const {
  return this != internal_default_instance() && _impl_.conductingequipment_ != nullptr;
}
inline bool ESS::has_conductingequipment() const {
  return _internal_has_conductingequipment();
}
inline void ESS::clear_conductingequipment() {
  if (GetArenaForAllocation() == nullptr && _impl_.conductingequipment_ != nullptr) {
    delete _impl_.conductingequipment_;
  }
  _impl_.conductingequipment_ = nullptr;
}
inline const ::commonmodule::ConductingEquipment& ESS::_internal_conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& ESS::conductingequipment() const {
  // @@protoc_insertion_point(field_get:commonmodule.ESS.conductingEquipment)
  return _internal_conductingequipment();
}
inline void ESS::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* conductingequipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ESS.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* ESS::release_conductingequipment() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* ESS::unsafe_arena_release_conductingequipment() {
  // @@protoc_insertion_point(field_release:commonmodule.ESS.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* ESS::_internal_mutable_conductingequipment() {
  
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.conductingequipment_ = p;
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* ESS::mutable_conductingequipment() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:commonmodule.ESS.conductingEquipment)
  return _msg;
}
inline void ESS::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conductingequipment_;
  }
  if (conductingequipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conductingequipment);
    if (message_arena != submessage_arena) {
      conductingequipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ESS.conductingEquipment)
}

// -------------------------------------------------------------------

// EventMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EventMessageInfo::_internal_has_messageinfo() const {
  return this != internal_default_instance() && _impl_.messageinfo_ != nullptr;
}
inline bool EventMessageInfo::has_messageinfo() const {
  return _internal_has_messageinfo();
}
inline void EventMessageInfo::clear_messageinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& EventMessageInfo::_internal_messageinfo() const {
  const ::commonmodule::MessageInfo* p = _impl_.messageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MessageInfo&>(
      ::commonmodule::_MessageInfo_default_instance_);
}
inline const ::commonmodule::MessageInfo& EventMessageInfo::messageinfo() const {
  // @@protoc_insertion_point(field_get:commonmodule.EventMessageInfo.messageInfo)
  return _internal_messageinfo();
}
inline void EventMessageInfo::unsafe_arena_set_allocated_messageinfo(
    ::commonmodule::MessageInfo* messageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageinfo_);
  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.EventMessageInfo.messageInfo)
}
inline ::commonmodule::MessageInfo* EventMessageInfo::release_messageinfo() {
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MessageInfo* EventMessageInfo::unsafe_arena_release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.EventMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* EventMessageInfo::_internal_mutable_messageinfo() {
  
  if (_impl_.messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaForAllocation());
    _impl_.messageinfo_ = p;
  }
  return _impl_.messageinfo_;
}
inline ::commonmodule::MessageInfo* EventMessageInfo::mutable_messageinfo() {
  ::commonmodule::MessageInfo* _msg = _internal_mutable_messageinfo();
  // @@protoc_insertion_point(field_mutable:commonmodule.EventMessageInfo.messageInfo)
  return _msg;
}
inline void EventMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messageinfo_;
  }
  if (messageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messageinfo);
    if (message_arena != submessage_arena) {
      messageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EventMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// EventValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool EventValue::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool EventValue::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void EventValue::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& EventValue::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& EventValue::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.EventValue.identifiedObject)
  return _internal_identifiedobject();
}
inline void EventValue::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.EventValue.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* EventValue::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* EventValue::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.EventValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* EventValue::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* EventValue::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.EventValue.identifiedObject)
  return _msg;
}
inline void EventValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EventValue.identifiedObject)
}

// .google.protobuf.BoolValue modBlk = 2;
inline bool EventValue::_internal_has_modblk() const {
  return this != internal_default_instance() && _impl_.modblk_ != nullptr;
}
inline bool EventValue::has_modblk() const {
  return _internal_has_modblk();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& EventValue::_internal_modblk() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.modblk_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& EventValue::modblk() const {
  // @@protoc_insertion_point(field_get:commonmodule.EventValue.modBlk)
  return _internal_modblk();
}
inline void EventValue::unsafe_arena_set_allocated_modblk(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modblk_);
  }
  _impl_.modblk_ = modblk;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.EventValue.modBlk)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* EventValue::release_modblk() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.modblk_;
  _impl_.modblk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* EventValue::unsafe_arena_release_modblk() {
  // @@protoc_insertion_point(field_release:commonmodule.EventValue.modBlk)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.modblk_;
  _impl_.modblk_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* EventValue::_internal_mutable_modblk() {
  
  if (_impl_.modblk_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.modblk_ = p;
  }
  return _impl_.modblk_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* EventValue::mutable_modblk() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_modblk();
  // @@protoc_insertion_point(field_mutable:commonmodule.EventValue.modBlk)
  return _msg;
}
inline void EventValue::set_allocated_modblk(::PROTOBUF_NAMESPACE_ID::BoolValue* modblk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modblk_);
  }
  if (modblk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modblk));
    if (message_arena != submessage_arena) {
      modblk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modblk, submessage_arena);
    }

  } else {

  }
  _impl_.modblk_ = modblk;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.EventValue.modBlk)
}

// -------------------------------------------------------------------

// ForecastValueSource

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ForecastValueSource::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool ForecastValueSource::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void ForecastValueSource::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ForecastValueSource::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& ForecastValueSource::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.ForecastValueSource.identifiedObject)
  return _internal_identifiedobject();
}
inline void ForecastValueSource::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ForecastValueSource.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* ForecastValueSource::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* ForecastValueSource::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastValueSource.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ForecastValueSource::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* ForecastValueSource::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastValueSource.identifiedObject)
  return _msg;
}
inline void ForecastValueSource::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastValueSource.identifiedObject)
}

// -------------------------------------------------------------------

// ForecastIED

// .commonmodule.ForecastValueSource forecastValueSource = 1 [(.uml.option_parent_message) = true];
inline bool ForecastIED::_internal_has_forecastvaluesource() const {
  return this != internal_default_instance() && _impl_.forecastvaluesource_ != nullptr;
}
inline bool ForecastIED::has_forecastvaluesource() const {
  return _internal_has_forecastvaluesource();
}
inline void ForecastIED::clear_forecastvaluesource() {
  if (GetArenaForAllocation() == nullptr && _impl_.forecastvaluesource_ != nullptr) {
    delete _impl_.forecastvaluesource_;
  }
  _impl_.forecastvaluesource_ = nullptr;
}
inline const ::commonmodule::ForecastValueSource& ForecastIED::_internal_forecastvaluesource() const {
  const ::commonmodule::ForecastValueSource* p = _impl_.forecastvaluesource_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ForecastValueSource&>(
      ::commonmodule::_ForecastValueSource_default_instance_);
}
inline const ::commonmodule::ForecastValueSource& ForecastIED::forecastvaluesource() const {
  // @@protoc_insertion_point(field_get:commonmodule.ForecastIED.forecastValueSource)
  return _internal_forecastvaluesource();
}
inline void ForecastIED::unsafe_arena_set_allocated_forecastvaluesource(
    ::commonmodule::ForecastValueSource* forecastvaluesource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.forecastvaluesource_);
  }
  _impl_.forecastvaluesource_ = forecastvaluesource;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ForecastIED.forecastValueSource)
}
inline ::commonmodule::ForecastValueSource* ForecastIED::release_forecastvaluesource() {
  
  ::commonmodule::ForecastValueSource* temp = _impl_.forecastvaluesource_;
  _impl_.forecastvaluesource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ForecastValueSource* ForecastIED::unsafe_arena_release_forecastvaluesource() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastIED.forecastValueSource)
  
  ::commonmodule::ForecastValueSource* temp = _impl_.forecastvaluesource_;
  _impl_.forecastvaluesource_ = nullptr;
  return temp;
}
inline ::commonmodule::ForecastValueSource* ForecastIED::_internal_mutable_forecastvaluesource() {
  
  if (_impl_.forecastvaluesource_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ForecastValueSource>(GetArenaForAllocation());
    _impl_.forecastvaluesource_ = p;
  }
  return _impl_.forecastvaluesource_;
}
inline ::commonmodule::ForecastValueSource* ForecastIED::mutable_forecastvaluesource() {
  ::commonmodule::ForecastValueSource* _msg = _internal_mutable_forecastvaluesource();
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastIED.forecastValueSource)
  return _msg;
}
inline void ForecastIED::set_allocated_forecastvaluesource(::commonmodule::ForecastValueSource* forecastvaluesource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.forecastvaluesource_;
  }
  if (forecastvaluesource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forecastvaluesource);
    if (message_arena != submessage_arena) {
      forecastvaluesource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forecastvaluesource, submessage_arena);
    }

  } else {

  }
  _impl_.forecastvaluesource_ = forecastvaluesource;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastIED.forecastValueSource)
}

// string sourceApplicationID = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ForecastIED::clear_sourceapplicationid() {
  _impl_.sourceapplicationid_.ClearToEmpty();
}
inline const std::string& ForecastIED::sourceapplicationid() const {
  // @@protoc_insertion_point(field_get:commonmodule.ForecastIED.sourceApplicationID)
  return _internal_sourceapplicationid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForecastIED::set_sourceapplicationid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sourceapplicationid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commonmodule.ForecastIED.sourceApplicationID)
}
inline std::string* ForecastIED::mutable_sourceapplicationid() {
  std::string* _s = _internal_mutable_sourceapplicationid();
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastIED.sourceApplicationID)
  return _s;
}
inline const std::string& ForecastIED::_internal_sourceapplicationid() const {
  return _impl_.sourceapplicationid_.Get();
}
inline void ForecastIED::_internal_set_sourceapplicationid(const std::string& value) {
  ;


  _impl_.sourceapplicationid_.Set(value, GetArenaForAllocation());
}
inline std::string* ForecastIED::_internal_mutable_sourceapplicationid() {
  ;
  return _impl_.sourceapplicationid_.Mutable( GetArenaForAllocation());
}
inline std::string* ForecastIED::release_sourceapplicationid() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastIED.sourceApplicationID)
  return _impl_.sourceapplicationid_.Release();
}
inline void ForecastIED::set_allocated_sourceapplicationid(std::string* value) {
  _impl_.sourceapplicationid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sourceapplicationid_.IsDefault()) {
          _impl_.sourceapplicationid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastIED.sourceApplicationID)
}

// int64 sourceDateTime = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ForecastIED::clear_sourcedatetime() {
  _impl_.sourcedatetime_ = ::int64_t{0};
}
inline ::int64_t ForecastIED::sourcedatetime() const {
  // @@protoc_insertion_point(field_get:commonmodule.ForecastIED.sourceDateTime)
  return _internal_sourcedatetime();
}
inline void ForecastIED::set_sourcedatetime(::int64_t value) {
  _internal_set_sourcedatetime(value);
  // @@protoc_insertion_point(field_set:commonmodule.ForecastIED.sourceDateTime)
}
inline ::int64_t ForecastIED::_internal_sourcedatetime() const {
  return _impl_.sourcedatetime_;
}
inline void ForecastIED::_internal_set_sourcedatetime(::int64_t value) {
  ;
  _impl_.sourcedatetime_ = value;
}

// -------------------------------------------------------------------

// ForecastValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool ForecastValue::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool ForecastValue::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void ForecastValue::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& ForecastValue::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& ForecastValue::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.ForecastValue.identifiedObject)
  return _internal_identifiedobject();
}
inline void ForecastValue::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ForecastValue.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* ForecastValue::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* ForecastValue::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.ForecastValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* ForecastValue::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* ForecastValue::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.ForecastValue.identifiedObject)
  return _msg;
}
inline void ForecastValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ForecastValue.identifiedObject)
}

// -------------------------------------------------------------------

// OperationDHFW

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDHFW::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDHFW::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDHFW.modEna)
  return _internal_modena();
}
inline void OperationDHFW::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDHFW.modEna)
}
inline bool OperationDHFW::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDHFW::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDHFW::_internal_has_opltmmsmax() const {
  return this != internal_default_instance() && _impl_.opltmmsmax_ != nullptr;
}
inline bool OperationDHFW::has_opltmmsmax() const {
  return _internal_has_opltmmsmax();
}
inline void OperationDHFW::clear_opltmmsmax() {
  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
}
inline const ::commonmodule::ClearingTime& OperationDHFW::_internal_opltmmsmax() const {
  const ::commonmodule::ClearingTime* p = _impl_.opltmmsmax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ClearingTime&>(
      ::commonmodule::_ClearingTime_default_instance_);
}
inline const ::commonmodule::ClearingTime& OperationDHFW::opltmmsmax() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDHFW.OplTmmsMax)
  return _internal_opltmmsmax();
}
inline void OperationDHFW::unsafe_arena_set_allocated_opltmmsmax(
    ::commonmodule::ClearingTime* opltmmsmax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opltmmsmax_);
  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDHFW.OplTmmsMax)
}
inline ::commonmodule::ClearingTime* OperationDHFW::release_opltmmsmax() {
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDHFW::unsafe_arena_release_opltmmsmax() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDHFW.OplTmmsMax)
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDHFW::_internal_mutable_opltmmsmax() {
  
  if (_impl_.opltmmsmax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ClearingTime>(GetArenaForAllocation());
    _impl_.opltmmsmax_ = p;
  }
  return _impl_.opltmmsmax_;
}
inline ::commonmodule::ClearingTime* OperationDHFW::mutable_opltmmsmax() {
  ::commonmodule::ClearingTime* _msg = _internal_mutable_opltmmsmax();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDHFW.OplTmmsMax)
  return _msg;
}
inline void OperationDHFW::set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opltmmsmax_;
  }
  if (opltmmsmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opltmmsmax);
    if (message_arena != submessage_arena) {
      opltmmsmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opltmmsmax, submessage_arena);
    }

  } else {

  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDHFW.OplTmmsMax)
}

// -------------------------------------------------------------------

// OperationDLFW

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDLFW::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDLFW::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDLFW.modEna)
  return _internal_modena();
}
inline void OperationDLFW::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDLFW.modEna)
}
inline bool OperationDLFW::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDLFW::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDLFW::_internal_has_opltmmsmax() const {
  return this != internal_default_instance() && _impl_.opltmmsmax_ != nullptr;
}
inline bool OperationDLFW::has_opltmmsmax() const {
  return _internal_has_opltmmsmax();
}
inline void OperationDLFW::clear_opltmmsmax() {
  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
}
inline const ::commonmodule::ClearingTime& OperationDLFW::_internal_opltmmsmax() const {
  const ::commonmodule::ClearingTime* p = _impl_.opltmmsmax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ClearingTime&>(
      ::commonmodule::_ClearingTime_default_instance_);
}
inline const ::commonmodule::ClearingTime& OperationDLFW::opltmmsmax() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDLFW.OplTmmsMax)
  return _internal_opltmmsmax();
}
inline void OperationDLFW::unsafe_arena_set_allocated_opltmmsmax(
    ::commonmodule::ClearingTime* opltmmsmax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opltmmsmax_);
  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDLFW.OplTmmsMax)
}
inline ::commonmodule::ClearingTime* OperationDLFW::release_opltmmsmax() {
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDLFW::unsafe_arena_release_opltmmsmax() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDLFW.OplTmmsMax)
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDLFW::_internal_mutable_opltmmsmax() {
  
  if (_impl_.opltmmsmax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ClearingTime>(GetArenaForAllocation());
    _impl_.opltmmsmax_ = p;
  }
  return _impl_.opltmmsmax_;
}
inline ::commonmodule::ClearingTime* OperationDLFW::mutable_opltmmsmax() {
  ::commonmodule::ClearingTime* _msg = _internal_mutable_opltmmsmax();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDLFW.OplTmmsMax)
  return _msg;
}
inline void OperationDLFW::set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opltmmsmax_;
  }
  if (opltmmsmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opltmmsmax);
    if (message_arena != submessage_arena) {
      opltmmsmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opltmmsmax, submessage_arena);
    }

  } else {

  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDLFW.OplTmmsMax)
}

// -------------------------------------------------------------------

// HzWPoint

// float deadbandHzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void HzWPoint::clear_deadbandhzval() {
  _impl_.deadbandhzval_ = 0;
}
inline float HzWPoint::deadbandhzval() const {
  // @@protoc_insertion_point(field_get:commonmodule.HzWPoint.deadbandHzVal)
  return _internal_deadbandhzval();
}
inline void HzWPoint::set_deadbandhzval(float value) {
  _internal_set_deadbandhzval(value);
  // @@protoc_insertion_point(field_set:commonmodule.HzWPoint.deadbandHzVal)
}
inline float HzWPoint::_internal_deadbandhzval() const {
  return _impl_.deadbandhzval_;
}
inline void HzWPoint::_internal_set_deadbandhzval(float value) {
  ;
  _impl_.deadbandhzval_ = value;
}

// float slopeVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void HzWPoint::clear_slopeval() {
  _impl_.slopeval_ = 0;
}
inline float HzWPoint::slopeval() const {
  // @@protoc_insertion_point(field_get:commonmodule.HzWPoint.slopeVal)
  return _internal_slopeval();
}
inline void HzWPoint::set_slopeval(float value) {
  _internal_set_slopeval(value);
  // @@protoc_insertion_point(field_set:commonmodule.HzWPoint.slopeVal)
}
inline float HzWPoint::_internal_slopeval() const {
  return _impl_.slopeval_;
}
inline void HzWPoint::_internal_set_slopeval(float value) {
  ;
  _impl_.slopeval_ = value;
}

// -------------------------------------------------------------------

// HzWAPC

// .commonmodule.HzWPoint overHzWPt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool HzWAPC::_internal_has_overhzwpt() const {
  return this != internal_default_instance() && _impl_.overhzwpt_ != nullptr;
}
inline bool HzWAPC::has_overhzwpt() const {
  return _internal_has_overhzwpt();
}
inline void HzWAPC::clear_overhzwpt() {
  if (GetArenaForAllocation() == nullptr && _impl_.overhzwpt_ != nullptr) {
    delete _impl_.overhzwpt_;
  }
  _impl_.overhzwpt_ = nullptr;
}
inline const ::commonmodule::HzWPoint& HzWAPC::_internal_overhzwpt() const {
  const ::commonmodule::HzWPoint* p = _impl_.overhzwpt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWPoint&>(
      ::commonmodule::_HzWPoint_default_instance_);
}
inline const ::commonmodule::HzWPoint& HzWAPC::overhzwpt() const {
  // @@protoc_insertion_point(field_get:commonmodule.HzWAPC.overHzWPt)
  return _internal_overhzwpt();
}
inline void HzWAPC::unsafe_arena_set_allocated_overhzwpt(
    ::commonmodule::HzWPoint* overhzwpt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overhzwpt_);
  }
  _impl_.overhzwpt_ = overhzwpt;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.HzWAPC.overHzWPt)
}
inline ::commonmodule::HzWPoint* HzWAPC::release_overhzwpt() {
  
  ::commonmodule::HzWPoint* temp = _impl_.overhzwpt_;
  _impl_.overhzwpt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::HzWPoint* HzWAPC::unsafe_arena_release_overhzwpt() {
  // @@protoc_insertion_point(field_release:commonmodule.HzWAPC.overHzWPt)
  
  ::commonmodule::HzWPoint* temp = _impl_.overhzwpt_;
  _impl_.overhzwpt_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWPoint* HzWAPC::_internal_mutable_overhzwpt() {
  
  if (_impl_.overhzwpt_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::HzWPoint>(GetArenaForAllocation());
    _impl_.overhzwpt_ = p;
  }
  return _impl_.overhzwpt_;
}
inline ::commonmodule::HzWPoint* HzWAPC::mutable_overhzwpt() {
  ::commonmodule::HzWPoint* _msg = _internal_mutable_overhzwpt();
  // @@protoc_insertion_point(field_mutable:commonmodule.HzWAPC.overHzWPt)
  return _msg;
}
inline void HzWAPC::set_allocated_overhzwpt(::commonmodule::HzWPoint* overhzwpt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.overhzwpt_;
  }
  if (overhzwpt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(overhzwpt);
    if (message_arena != submessage_arena) {
      overhzwpt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overhzwpt, submessage_arena);
    }

  } else {

  }
  _impl_.overhzwpt_ = overhzwpt;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.HzWAPC.overHzWPt)
}

// .commonmodule.OperationDHFW overHzWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool HzWAPC::_internal_has_overhzwparameter() const {
  return this != internal_default_instance() && _impl_.overhzwparameter_ != nullptr;
}
inline bool HzWAPC::has_overhzwparameter() const {
  return _internal_has_overhzwparameter();
}
inline void HzWAPC::clear_overhzwparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.overhzwparameter_ != nullptr) {
    delete _impl_.overhzwparameter_;
  }
  _impl_.overhzwparameter_ = nullptr;
}
inline const ::commonmodule::OperationDHFW& HzWAPC::_internal_overhzwparameter() const {
  const ::commonmodule::OperationDHFW* p = _impl_.overhzwparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDHFW&>(
      ::commonmodule::_OperationDHFW_default_instance_);
}
inline const ::commonmodule::OperationDHFW& HzWAPC::overhzwparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.HzWAPC.overHzWParameter)
  return _internal_overhzwparameter();
}
inline void HzWAPC::unsafe_arena_set_allocated_overhzwparameter(
    ::commonmodule::OperationDHFW* overhzwparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overhzwparameter_);
  }
  _impl_.overhzwparameter_ = overhzwparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.HzWAPC.overHzWParameter)
}
inline ::commonmodule::OperationDHFW* HzWAPC::release_overhzwparameter() {
  
  ::commonmodule::OperationDHFW* temp = _impl_.overhzwparameter_;
  _impl_.overhzwparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDHFW* HzWAPC::unsafe_arena_release_overhzwparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.HzWAPC.overHzWParameter)
  
  ::commonmodule::OperationDHFW* temp = _impl_.overhzwparameter_;
  _impl_.overhzwparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDHFW* HzWAPC::_internal_mutable_overhzwparameter() {
  
  if (_impl_.overhzwparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDHFW>(GetArenaForAllocation());
    _impl_.overhzwparameter_ = p;
  }
  return _impl_.overhzwparameter_;
}
inline ::commonmodule::OperationDHFW* HzWAPC::mutable_overhzwparameter() {
  ::commonmodule::OperationDHFW* _msg = _internal_mutable_overhzwparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.HzWAPC.overHzWParameter)
  return _msg;
}
inline void HzWAPC::set_allocated_overhzwparameter(::commonmodule::OperationDHFW* overhzwparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.overhzwparameter_;
  }
  if (overhzwparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(overhzwparameter);
    if (message_arena != submessage_arena) {
      overhzwparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overhzwparameter, submessage_arena);
    }

  } else {

  }
  _impl_.overhzwparameter_ = overhzwparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.HzWAPC.overHzWParameter)
}

// .commonmodule.HzWPoint underHzWPt = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool HzWAPC::_internal_has_underhzwpt() const {
  return this != internal_default_instance() && _impl_.underhzwpt_ != nullptr;
}
inline bool HzWAPC::has_underhzwpt() const {
  return _internal_has_underhzwpt();
}
inline void HzWAPC::clear_underhzwpt() {
  if (GetArenaForAllocation() == nullptr && _impl_.underhzwpt_ != nullptr) {
    delete _impl_.underhzwpt_;
  }
  _impl_.underhzwpt_ = nullptr;
}
inline const ::commonmodule::HzWPoint& HzWAPC::_internal_underhzwpt() const {
  const ::commonmodule::HzWPoint* p = _impl_.underhzwpt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWPoint&>(
      ::commonmodule::_HzWPoint_default_instance_);
}
inline const ::commonmodule::HzWPoint& HzWAPC::underhzwpt() const {
  // @@protoc_insertion_point(field_get:commonmodule.HzWAPC.underHzWPt)
  return _internal_underhzwpt();
}
inline void HzWAPC::unsafe_arena_set_allocated_underhzwpt(
    ::commonmodule::HzWPoint* underhzwpt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.underhzwpt_);
  }
  _impl_.underhzwpt_ = underhzwpt;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.HzWAPC.underHzWPt)
}
inline ::commonmodule::HzWPoint* HzWAPC::release_underhzwpt() {
  
  ::commonmodule::HzWPoint* temp = _impl_.underhzwpt_;
  _impl_.underhzwpt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::HzWPoint* HzWAPC::unsafe_arena_release_underhzwpt() {
  // @@protoc_insertion_point(field_release:commonmodule.HzWAPC.underHzWPt)
  
  ::commonmodule::HzWPoint* temp = _impl_.underhzwpt_;
  _impl_.underhzwpt_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWPoint* HzWAPC::_internal_mutable_underhzwpt() {
  
  if (_impl_.underhzwpt_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::HzWPoint>(GetArenaForAllocation());
    _impl_.underhzwpt_ = p;
  }
  return _impl_.underhzwpt_;
}
inline ::commonmodule::HzWPoint* HzWAPC::mutable_underhzwpt() {
  ::commonmodule::HzWPoint* _msg = _internal_mutable_underhzwpt();
  // @@protoc_insertion_point(field_mutable:commonmodule.HzWAPC.underHzWPt)
  return _msg;
}
inline void HzWAPC::set_allocated_underhzwpt(::commonmodule::HzWPoint* underhzwpt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.underhzwpt_;
  }
  if (underhzwpt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(underhzwpt);
    if (message_arena != submessage_arena) {
      underhzwpt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, underhzwpt, submessage_arena);
    }

  } else {

  }
  _impl_.underhzwpt_ = underhzwpt;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.HzWAPC.underHzWPt)
}

// .commonmodule.OperationDLFW underHzWParameter = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool HzWAPC::_internal_has_underhzwparameter() const {
  return this != internal_default_instance() && _impl_.underhzwparameter_ != nullptr;
}
inline bool HzWAPC::has_underhzwparameter() const {
  return _internal_has_underhzwparameter();
}
inline void HzWAPC::clear_underhzwparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.underhzwparameter_ != nullptr) {
    delete _impl_.underhzwparameter_;
  }
  _impl_.underhzwparameter_ = nullptr;
}
inline const ::commonmodule::OperationDLFW& HzWAPC::_internal_underhzwparameter() const {
  const ::commonmodule::OperationDLFW* p = _impl_.underhzwparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDLFW&>(
      ::commonmodule::_OperationDLFW_default_instance_);
}
inline const ::commonmodule::OperationDLFW& HzWAPC::underhzwparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.HzWAPC.underHzWParameter)
  return _internal_underhzwparameter();
}
inline void HzWAPC::unsafe_arena_set_allocated_underhzwparameter(
    ::commonmodule::OperationDLFW* underhzwparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.underhzwparameter_);
  }
  _impl_.underhzwparameter_ = underhzwparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.HzWAPC.underHzWParameter)
}
inline ::commonmodule::OperationDLFW* HzWAPC::release_underhzwparameter() {
  
  ::commonmodule::OperationDLFW* temp = _impl_.underhzwparameter_;
  _impl_.underhzwparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDLFW* HzWAPC::unsafe_arena_release_underhzwparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.HzWAPC.underHzWParameter)
  
  ::commonmodule::OperationDLFW* temp = _impl_.underhzwparameter_;
  _impl_.underhzwparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDLFW* HzWAPC::_internal_mutable_underhzwparameter() {
  
  if (_impl_.underhzwparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDLFW>(GetArenaForAllocation());
    _impl_.underhzwparameter_ = p;
  }
  return _impl_.underhzwparameter_;
}
inline ::commonmodule::OperationDLFW* HzWAPC::mutable_underhzwparameter() {
  ::commonmodule::OperationDLFW* _msg = _internal_mutable_underhzwparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.HzWAPC.underHzWParameter)
  return _msg;
}
inline void HzWAPC::set_allocated_underhzwparameter(::commonmodule::OperationDLFW* underhzwparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.underhzwparameter_;
  }
  if (underhzwparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(underhzwparameter);
    if (message_arena != submessage_arena) {
      underhzwparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, underhzwparameter, submessage_arena);
    }

  } else {

  }
  _impl_.underhzwparameter_ = underhzwparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.HzWAPC.underHzWParameter)
}

// -------------------------------------------------------------------

// StatusINS

// .commonmodule.Quality q = 1;
inline bool StatusINS::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool StatusINS::has_q() const {
  return _internal_has_q();
}
inline void StatusINS::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusINS::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& StatusINS::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusINS.q)
  return _internal_q();
}
inline void StatusINS::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusINS.q)
}
inline ::commonmodule::Quality* StatusINS::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* StatusINS::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusINS.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusINS::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* StatusINS::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusINS.q)
  return _msg;
}
inline void StatusINS::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusINS.q)
}

// int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusINS::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::int32_t StatusINS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusINS.stVal)
  return _internal_stval();
}
inline void StatusINS::set_stval(::int32_t value) {
  _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.StatusINS.stVal)
}
inline ::int32_t StatusINS::_internal_stval() const {
  return _impl_.stval_;
}
inline void StatusINS::_internal_set_stval(::int32_t value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool StatusINS::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool StatusINS::has_t() const {
  return _internal_has_t();
}
inline void StatusINS::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusINS::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& StatusINS::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusINS.t)
  return _internal_t();
}
inline void StatusINS::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusINS.t)
}
inline ::commonmodule::Timestamp* StatusINS::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* StatusINS::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusINS.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusINS::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* StatusINS::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusINS.t)
  return _msg;
}
inline void StatusINS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusINS.t)
}

// -------------------------------------------------------------------

// IntegerEventAndStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool IntegerEventAndStatusGGIO::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool IntegerEventAndStatusGGIO::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void IntegerEventAndStatusGGIO::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& IntegerEventAndStatusGGIO::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& IntegerEventAndStatusGGIO::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.IntegerEventAndStatusGGIO.logicalNode)
  return _internal_logicalnode();
}
inline void IntegerEventAndStatusGGIO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.IntegerEventAndStatusGGIO.logicalNode)
}
inline ::commonmodule::LogicalNode* IntegerEventAndStatusGGIO::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* IntegerEventAndStatusGGIO::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.IntegerEventAndStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* IntegerEventAndStatusGGIO::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* IntegerEventAndStatusGGIO::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.IntegerEventAndStatusGGIO.logicalNode)
  return _msg;
}
inline void IntegerEventAndStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IntegerEventAndStatusGGIO.logicalNode)
}

// .commonmodule.StatusINS IntIn = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool IntegerEventAndStatusGGIO::_internal_has_intin() const {
  return this != internal_default_instance() && _impl_.intin_ != nullptr;
}
inline bool IntegerEventAndStatusGGIO::has_intin() const {
  return _internal_has_intin();
}
inline void IntegerEventAndStatusGGIO::clear_intin() {
  if (GetArenaForAllocation() == nullptr && _impl_.intin_ != nullptr) {
    delete _impl_.intin_;
  }
  _impl_.intin_ = nullptr;
}
inline const ::commonmodule::StatusINS& IntegerEventAndStatusGGIO::_internal_intin() const {
  const ::commonmodule::StatusINS* p = _impl_.intin_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINS&>(
      ::commonmodule::_StatusINS_default_instance_);
}
inline const ::commonmodule::StatusINS& IntegerEventAndStatusGGIO::intin() const {
  // @@protoc_insertion_point(field_get:commonmodule.IntegerEventAndStatusGGIO.IntIn)
  return _internal_intin();
}
inline void IntegerEventAndStatusGGIO::unsafe_arena_set_allocated_intin(
    ::commonmodule::StatusINS* intin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intin_);
  }
  _impl_.intin_ = intin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.IntegerEventAndStatusGGIO.IntIn)
}
inline ::commonmodule::StatusINS* IntegerEventAndStatusGGIO::release_intin() {
  
  ::commonmodule::StatusINS* temp = _impl_.intin_;
  _impl_.intin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusINS* IntegerEventAndStatusGGIO::unsafe_arena_release_intin() {
  // @@protoc_insertion_point(field_release:commonmodule.IntegerEventAndStatusGGIO.IntIn)
  
  ::commonmodule::StatusINS* temp = _impl_.intin_;
  _impl_.intin_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINS* IntegerEventAndStatusGGIO::_internal_mutable_intin() {
  
  if (_impl_.intin_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINS>(GetArenaForAllocation());
    _impl_.intin_ = p;
  }
  return _impl_.intin_;
}
inline ::commonmodule::StatusINS* IntegerEventAndStatusGGIO::mutable_intin() {
  ::commonmodule::StatusINS* _msg = _internal_mutable_intin();
  // @@protoc_insertion_point(field_mutable:commonmodule.IntegerEventAndStatusGGIO.IntIn)
  return _msg;
}
inline void IntegerEventAndStatusGGIO::set_allocated_intin(::commonmodule::StatusINS* intin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intin_;
  }
  if (intin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intin);
    if (message_arena != submessage_arena) {
      intin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intin, submessage_arena);
    }

  } else {

  }
  _impl_.intin_ = intin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IntegerEventAndStatusGGIO.IntIn)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 3;
inline bool IntegerEventAndStatusGGIO::_internal_has_phase() const {
  return this != internal_default_instance() && _impl_.phase_ != nullptr;
}
inline bool IntegerEventAndStatusGGIO::has_phase() const {
  return _internal_has_phase();
}
inline void IntegerEventAndStatusGGIO::clear_phase() {
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& IntegerEventAndStatusGGIO::_internal_phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = _impl_.phase_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind&>(
      ::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseCodeKind& IntegerEventAndStatusGGIO::phase() const {
  // @@protoc_insertion_point(field_get:commonmodule.IntegerEventAndStatusGGIO.Phase)
  return _internal_phase();
}
inline void IntegerEventAndStatusGGIO::unsafe_arena_set_allocated_phase(
    ::commonmodule::Optional_PhaseCodeKind* phase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phase_);
  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.IntegerEventAndStatusGGIO.Phase)
}
inline ::commonmodule::Optional_PhaseCodeKind* IntegerEventAndStatusGGIO::release_phase() {
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* IntegerEventAndStatusGGIO::unsafe_arena_release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.IntegerEventAndStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* IntegerEventAndStatusGGIO::_internal_mutable_phase() {
  
  if (_impl_.phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaForAllocation());
    _impl_.phase_ = p;
  }
  return _impl_.phase_;
}
inline ::commonmodule::Optional_PhaseCodeKind* IntegerEventAndStatusGGIO::mutable_phase() {
  ::commonmodule::Optional_PhaseCodeKind* _msg = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:commonmodule.IntegerEventAndStatusGGIO.Phase)
  return _msg;
}
inline void IntegerEventAndStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phase_;
  }
  if (phase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phase);
    if (message_arena != submessage_arena) {
      phase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }

  } else {

  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.IntegerEventAndStatusGGIO.Phase)
}

// -------------------------------------------------------------------

// OperationDWMX

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDWMX::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDWMX::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDWMX.modEna)
  return _internal_modena();
}
inline void OperationDWMX::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDWMX.modEna)
}
inline bool OperationDWMX::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDWMX::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// -------------------------------------------------------------------

// OperationDWMN

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDWMN::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDWMN::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDWMN.modEna)
  return _internal_modena();
}
inline void OperationDWMN::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDWMN.modEna)
}
inline bool OperationDWMN::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDWMN::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// -------------------------------------------------------------------

// LimitWAPC

// .commonmodule.OperationDWMX maxLimParameter = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LimitWAPC::_internal_has_maxlimparameter() const {
  return this != internal_default_instance() && _impl_.maxlimparameter_ != nullptr;
}
inline bool LimitWAPC::has_maxlimparameter() const {
  return _internal_has_maxlimparameter();
}
inline void LimitWAPC::clear_maxlimparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.maxlimparameter_ != nullptr) {
    delete _impl_.maxlimparameter_;
  }
  _impl_.maxlimparameter_ = nullptr;
}
inline const ::commonmodule::OperationDWMX& LimitWAPC::_internal_maxlimparameter() const {
  const ::commonmodule::OperationDWMX* p = _impl_.maxlimparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDWMX&>(
      ::commonmodule::_OperationDWMX_default_instance_);
}
inline const ::commonmodule::OperationDWMX& LimitWAPC::maxlimparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.LimitWAPC.maxLimParameter)
  return _internal_maxlimparameter();
}
inline void LimitWAPC::unsafe_arena_set_allocated_maxlimparameter(
    ::commonmodule::OperationDWMX* maxlimparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maxlimparameter_);
  }
  _impl_.maxlimparameter_ = maxlimparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LimitWAPC.maxLimParameter)
}
inline ::commonmodule::OperationDWMX* LimitWAPC::release_maxlimparameter() {
  
  ::commonmodule::OperationDWMX* temp = _impl_.maxlimparameter_;
  _impl_.maxlimparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDWMX* LimitWAPC::unsafe_arena_release_maxlimparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.LimitWAPC.maxLimParameter)
  
  ::commonmodule::OperationDWMX* temp = _impl_.maxlimparameter_;
  _impl_.maxlimparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDWMX* LimitWAPC::_internal_mutable_maxlimparameter() {
  
  if (_impl_.maxlimparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDWMX>(GetArenaForAllocation());
    _impl_.maxlimparameter_ = p;
  }
  return _impl_.maxlimparameter_;
}
inline ::commonmodule::OperationDWMX* LimitWAPC::mutable_maxlimparameter() {
  ::commonmodule::OperationDWMX* _msg = _internal_mutable_maxlimparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.LimitWAPC.maxLimParameter)
  return _msg;
}
inline void LimitWAPC::set_allocated_maxlimparameter(::commonmodule::OperationDWMX* maxlimparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maxlimparameter_;
  }
  if (maxlimparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maxlimparameter);
    if (message_arena != submessage_arena) {
      maxlimparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxlimparameter, submessage_arena);
    }

  } else {

  }
  _impl_.maxlimparameter_ = maxlimparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LimitWAPC.maxLimParameter)
}

// .commonmodule.OperationDWMN minLimParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LimitWAPC::_internal_has_minlimparameter() const {
  return this != internal_default_instance() && _impl_.minlimparameter_ != nullptr;
}
inline bool LimitWAPC::has_minlimparameter() const {
  return _internal_has_minlimparameter();
}
inline void LimitWAPC::clear_minlimparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.minlimparameter_ != nullptr) {
    delete _impl_.minlimparameter_;
  }
  _impl_.minlimparameter_ = nullptr;
}
inline const ::commonmodule::OperationDWMN& LimitWAPC::_internal_minlimparameter() const {
  const ::commonmodule::OperationDWMN* p = _impl_.minlimparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDWMN&>(
      ::commonmodule::_OperationDWMN_default_instance_);
}
inline const ::commonmodule::OperationDWMN& LimitWAPC::minlimparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.LimitWAPC.minLimParameter)
  return _internal_minlimparameter();
}
inline void LimitWAPC::unsafe_arena_set_allocated_minlimparameter(
    ::commonmodule::OperationDWMN* minlimparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minlimparameter_);
  }
  _impl_.minlimparameter_ = minlimparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LimitWAPC.minLimParameter)
}
inline ::commonmodule::OperationDWMN* LimitWAPC::release_minlimparameter() {
  
  ::commonmodule::OperationDWMN* temp = _impl_.minlimparameter_;
  _impl_.minlimparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDWMN* LimitWAPC::unsafe_arena_release_minlimparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.LimitWAPC.minLimParameter)
  
  ::commonmodule::OperationDWMN* temp = _impl_.minlimparameter_;
  _impl_.minlimparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDWMN* LimitWAPC::_internal_mutable_minlimparameter() {
  
  if (_impl_.minlimparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDWMN>(GetArenaForAllocation());
    _impl_.minlimparameter_ = p;
  }
  return _impl_.minlimparameter_;
}
inline ::commonmodule::OperationDWMN* LimitWAPC::mutable_minlimparameter() {
  ::commonmodule::OperationDWMN* _msg = _internal_mutable_minlimparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.LimitWAPC.minLimParameter)
  return _msg;
}
inline void LimitWAPC::set_allocated_minlimparameter(::commonmodule::OperationDWMN* minlimparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.minlimparameter_;
  }
  if (minlimparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(minlimparameter);
    if (message_arena != submessage_arena) {
      minlimparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minlimparameter, submessage_arena);
    }

  } else {

  }
  _impl_.minlimparameter_ = minlimparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LimitWAPC.minLimParameter)
}

// float wMaxSptVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void LimitWAPC::clear_wmaxsptval() {
  _impl_.wmaxsptval_ = 0;
}
inline float LimitWAPC::wmaxsptval() const {
  // @@protoc_insertion_point(field_get:commonmodule.LimitWAPC.wMaxSptVal)
  return _internal_wmaxsptval();
}
inline void LimitWAPC::set_wmaxsptval(float value) {
  _internal_set_wmaxsptval(value);
  // @@protoc_insertion_point(field_set:commonmodule.LimitWAPC.wMaxSptVal)
}
inline float LimitWAPC::_internal_wmaxsptval() const {
  return _impl_.wmaxsptval_;
}
inline void LimitWAPC::_internal_set_wmaxsptval(float value) {
  ;
  _impl_.wmaxsptval_ = value;
}

// float wMinSptVal = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void LimitWAPC::clear_wminsptval() {
  _impl_.wminsptval_ = 0;
}
inline float LimitWAPC::wminsptval() const {
  // @@protoc_insertion_point(field_get:commonmodule.LimitWAPC.wMinSptVal)
  return _internal_wminsptval();
}
inline void LimitWAPC::set_wminsptval(float value) {
  _internal_set_wminsptval(value);
  // @@protoc_insertion_point(field_set:commonmodule.LimitWAPC.wMinSptVal)
}
inline float LimitWAPC::_internal_wminsptval() const {
  return _impl_.wminsptval_;
}
inline void LimitWAPC::_internal_set_wminsptval(float value) {
  ;
  _impl_.wminsptval_ = value;
}

// -------------------------------------------------------------------

// LogicalNodeForEventAndStatus

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool LogicalNodeForEventAndStatus::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool LogicalNodeForEventAndStatus::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void LogicalNodeForEventAndStatus::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& LogicalNodeForEventAndStatus::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& LogicalNodeForEventAndStatus::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
  return _internal_logicalnode();
}
inline void LogicalNodeForEventAndStatus::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
}
inline ::commonmodule::LogicalNode* LogicalNodeForEventAndStatus::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* LogicalNodeForEventAndStatus::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* LogicalNodeForEventAndStatus::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* LogicalNodeForEventAndStatus::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
  return _msg;
}
inline void LogicalNodeForEventAndStatus::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.logicalNode)
}

// .commonmodule.ENS_BehaviourModeKind Beh = 2;
inline bool LogicalNodeForEventAndStatus::_internal_has_beh() const {
  return this != internal_default_instance() && _impl_.beh_ != nullptr;
}
inline bool LogicalNodeForEventAndStatus::has_beh() const {
  return _internal_has_beh();
}
inline void LogicalNodeForEventAndStatus::clear_beh() {
  if (GetArenaForAllocation() == nullptr && _impl_.beh_ != nullptr) {
    delete _impl_.beh_;
  }
  _impl_.beh_ = nullptr;
}
inline const ::commonmodule::ENS_BehaviourModeKind& LogicalNodeForEventAndStatus::_internal_beh() const {
  const ::commonmodule::ENS_BehaviourModeKind* p = _impl_.beh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_BehaviourModeKind&>(
      ::commonmodule::_ENS_BehaviourModeKind_default_instance_);
}
inline const ::commonmodule::ENS_BehaviourModeKind& LogicalNodeForEventAndStatus::beh() const {
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.Beh)
  return _internal_beh();
}
inline void LogicalNodeForEventAndStatus::unsafe_arena_set_allocated_beh(
    ::commonmodule::ENS_BehaviourModeKind* beh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.beh_);
  }
  _impl_.beh_ = beh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LogicalNodeForEventAndStatus.Beh)
}
inline ::commonmodule::ENS_BehaviourModeKind* LogicalNodeForEventAndStatus::release_beh() {
  
  ::commonmodule::ENS_BehaviourModeKind* temp = _impl_.beh_;
  _impl_.beh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_BehaviourModeKind* LogicalNodeForEventAndStatus::unsafe_arena_release_beh() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.Beh)
  
  ::commonmodule::ENS_BehaviourModeKind* temp = _impl_.beh_;
  _impl_.beh_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_BehaviourModeKind* LogicalNodeForEventAndStatus::_internal_mutable_beh() {
  
  if (_impl_.beh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_BehaviourModeKind>(GetArenaForAllocation());
    _impl_.beh_ = p;
  }
  return _impl_.beh_;
}
inline ::commonmodule::ENS_BehaviourModeKind* LogicalNodeForEventAndStatus::mutable_beh() {
  ::commonmodule::ENS_BehaviourModeKind* _msg = _internal_mutable_beh();
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.Beh)
  return _msg;
}
inline void LogicalNodeForEventAndStatus::set_allocated_beh(::commonmodule::ENS_BehaviourModeKind* beh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.beh_;
  }
  if (beh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(beh);
    if (message_arena != submessage_arena) {
      beh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, beh, submessage_arena);
    }

  } else {

  }
  _impl_.beh_ = beh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.Beh)
}

// .commonmodule.ENS_HealthKind EEHealth = 3;
inline bool LogicalNodeForEventAndStatus::_internal_has_eehealth() const {
  return this != internal_default_instance() && _impl_.eehealth_ != nullptr;
}
inline bool LogicalNodeForEventAndStatus::has_eehealth() const {
  return _internal_has_eehealth();
}
inline void LogicalNodeForEventAndStatus::clear_eehealth() {
  if (GetArenaForAllocation() == nullptr && _impl_.eehealth_ != nullptr) {
    delete _impl_.eehealth_;
  }
  _impl_.eehealth_ = nullptr;
}
inline const ::commonmodule::ENS_HealthKind& LogicalNodeForEventAndStatus::_internal_eehealth() const {
  const ::commonmodule::ENS_HealthKind* p = _impl_.eehealth_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_HealthKind&>(
      ::commonmodule::_ENS_HealthKind_default_instance_);
}
inline const ::commonmodule::ENS_HealthKind& LogicalNodeForEventAndStatus::eehealth() const {
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
  return _internal_eehealth();
}
inline void LogicalNodeForEventAndStatus::unsafe_arena_set_allocated_eehealth(
    ::commonmodule::ENS_HealthKind* eehealth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eehealth_);
  }
  _impl_.eehealth_ = eehealth;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
}
inline ::commonmodule::ENS_HealthKind* LogicalNodeForEventAndStatus::release_eehealth() {
  
  ::commonmodule::ENS_HealthKind* temp = _impl_.eehealth_;
  _impl_.eehealth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_HealthKind* LogicalNodeForEventAndStatus::unsafe_arena_release_eehealth() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
  
  ::commonmodule::ENS_HealthKind* temp = _impl_.eehealth_;
  _impl_.eehealth_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_HealthKind* LogicalNodeForEventAndStatus::_internal_mutable_eehealth() {
  
  if (_impl_.eehealth_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_HealthKind>(GetArenaForAllocation());
    _impl_.eehealth_ = p;
  }
  return _impl_.eehealth_;
}
inline ::commonmodule::ENS_HealthKind* LogicalNodeForEventAndStatus::mutable_eehealth() {
  ::commonmodule::ENS_HealthKind* _msg = _internal_mutable_eehealth();
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
  return _msg;
}
inline void LogicalNodeForEventAndStatus::set_allocated_eehealth(::commonmodule::ENS_HealthKind* eehealth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.eehealth_;
  }
  if (eehealth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eehealth);
    if (message_arena != submessage_arena) {
      eehealth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eehealth, submessage_arena);
    }

  } else {

  }
  _impl_.eehealth_ = eehealth;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.EEHealth)
}

// .commonmodule.StatusSPS HotLineTag = 4;
inline bool LogicalNodeForEventAndStatus::_internal_has_hotlinetag() const {
  return this != internal_default_instance() && _impl_.hotlinetag_ != nullptr;
}
inline bool LogicalNodeForEventAndStatus::has_hotlinetag() const {
  return _internal_has_hotlinetag();
}
inline void LogicalNodeForEventAndStatus::clear_hotlinetag() {
  if (GetArenaForAllocation() == nullptr && _impl_.hotlinetag_ != nullptr) {
    delete _impl_.hotlinetag_;
  }
  _impl_.hotlinetag_ = nullptr;
}
inline const ::commonmodule::StatusSPS& LogicalNodeForEventAndStatus::_internal_hotlinetag() const {
  const ::commonmodule::StatusSPS* p = _impl_.hotlinetag_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& LogicalNodeForEventAndStatus::hotlinetag() const {
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.HotLineTag)
  return _internal_hotlinetag();
}
inline void LogicalNodeForEventAndStatus::unsafe_arena_set_allocated_hotlinetag(
    ::commonmodule::StatusSPS* hotlinetag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hotlinetag_);
  }
  _impl_.hotlinetag_ = hotlinetag;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LogicalNodeForEventAndStatus.HotLineTag)
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::release_hotlinetag() {
  
  ::commonmodule::StatusSPS* temp = _impl_.hotlinetag_;
  _impl_.hotlinetag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::unsafe_arena_release_hotlinetag() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.HotLineTag)
  
  ::commonmodule::StatusSPS* temp = _impl_.hotlinetag_;
  _impl_.hotlinetag_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::_internal_mutable_hotlinetag() {
  
  if (_impl_.hotlinetag_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.hotlinetag_ = p;
  }
  return _impl_.hotlinetag_;
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::mutable_hotlinetag() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_hotlinetag();
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.HotLineTag)
  return _msg;
}
inline void LogicalNodeForEventAndStatus::set_allocated_hotlinetag(::commonmodule::StatusSPS* hotlinetag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hotlinetag_;
  }
  if (hotlinetag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hotlinetag);
    if (message_arena != submessage_arena) {
      hotlinetag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hotlinetag, submessage_arena);
    }

  } else {

  }
  _impl_.hotlinetag_ = hotlinetag;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.HotLineTag)
}

// .commonmodule.StatusSPS RemoteBlk = 5;
inline bool LogicalNodeForEventAndStatus::_internal_has_remoteblk() const {
  return this != internal_default_instance() && _impl_.remoteblk_ != nullptr;
}
inline bool LogicalNodeForEventAndStatus::has_remoteblk() const {
  return _internal_has_remoteblk();
}
inline void LogicalNodeForEventAndStatus::clear_remoteblk() {
  if (GetArenaForAllocation() == nullptr && _impl_.remoteblk_ != nullptr) {
    delete _impl_.remoteblk_;
  }
  _impl_.remoteblk_ = nullptr;
}
inline const ::commonmodule::StatusSPS& LogicalNodeForEventAndStatus::_internal_remoteblk() const {
  const ::commonmodule::StatusSPS* p = _impl_.remoteblk_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& LogicalNodeForEventAndStatus::remoteblk() const {
  // @@protoc_insertion_point(field_get:commonmodule.LogicalNodeForEventAndStatus.RemoteBlk)
  return _internal_remoteblk();
}
inline void LogicalNodeForEventAndStatus::unsafe_arena_set_allocated_remoteblk(
    ::commonmodule::StatusSPS* remoteblk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remoteblk_);
  }
  _impl_.remoteblk_ = remoteblk;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.LogicalNodeForEventAndStatus.RemoteBlk)
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::release_remoteblk() {
  
  ::commonmodule::StatusSPS* temp = _impl_.remoteblk_;
  _impl_.remoteblk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::unsafe_arena_release_remoteblk() {
  // @@protoc_insertion_point(field_release:commonmodule.LogicalNodeForEventAndStatus.RemoteBlk)
  
  ::commonmodule::StatusSPS* temp = _impl_.remoteblk_;
  _impl_.remoteblk_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::_internal_mutable_remoteblk() {
  
  if (_impl_.remoteblk_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.remoteblk_ = p;
  }
  return _impl_.remoteblk_;
}
inline ::commonmodule::StatusSPS* LogicalNodeForEventAndStatus::mutable_remoteblk() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_remoteblk();
  // @@protoc_insertion_point(field_mutable:commonmodule.LogicalNodeForEventAndStatus.RemoteBlk)
  return _msg;
}
inline void LogicalNodeForEventAndStatus::set_allocated_remoteblk(::commonmodule::StatusSPS* remoteblk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remoteblk_;
  }
  if (remoteblk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remoteblk);
    if (message_arena != submessage_arena) {
      remoteblk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remoteblk, submessage_arena);
    }

  } else {

  }
  _impl_.remoteblk_ = remoteblk;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.LogicalNodeForEventAndStatus.RemoteBlk)
}

// -------------------------------------------------------------------

// MeasurementValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool MeasurementValue::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool MeasurementValue::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void MeasurementValue::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& MeasurementValue::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& MeasurementValue::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.MeasurementValue.identifiedObject)
  return _internal_identifiedobject();
}
inline void MeasurementValue::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.MeasurementValue.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* MeasurementValue::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* MeasurementValue::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.MeasurementValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* MeasurementValue::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* MeasurementValue::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.MeasurementValue.identifiedObject)
  return _msg;
}
inline void MeasurementValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.MeasurementValue.identifiedObject)
}

// -------------------------------------------------------------------

// Meter

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool Meter::_internal_has_conductingequipment() const {
  return this != internal_default_instance() && _impl_.conductingequipment_ != nullptr;
}
inline bool Meter::has_conductingequipment() const {
  return _internal_has_conductingequipment();
}
inline void Meter::clear_conductingequipment() {
  if (GetArenaForAllocation() == nullptr && _impl_.conductingequipment_ != nullptr) {
    delete _impl_.conductingequipment_;
  }
  _impl_.conductingequipment_ = nullptr;
}
inline const ::commonmodule::ConductingEquipment& Meter::_internal_conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& Meter::conductingequipment() const {
  // @@protoc_insertion_point(field_get:commonmodule.Meter.conductingEquipment)
  return _internal_conductingequipment();
}
inline void Meter::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* conductingequipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.Meter.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* Meter::release_conductingequipment() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* Meter::unsafe_arena_release_conductingequipment() {
  // @@protoc_insertion_point(field_release:commonmodule.Meter.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* Meter::_internal_mutable_conductingequipment() {
  
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.conductingequipment_ = p;
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* Meter::mutable_conductingequipment() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:commonmodule.Meter.conductingEquipment)
  return _msg;
}
inline void Meter::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conductingequipment_;
  }
  if (conductingequipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conductingequipment);
    if (message_arena != submessage_arena) {
      conductingequipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.Meter.conductingEquipment)
}

// -------------------------------------------------------------------

// NameplateValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool NameplateValue::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool NameplateValue::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void NameplateValue::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& NameplateValue::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& NameplateValue::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.NameplateValue.identifiedObject)
  return _internal_identifiedobject();
}
inline void NameplateValue::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.NameplateValue.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* NameplateValue::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* NameplateValue::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.NameplateValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* NameplateValue::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* NameplateValue::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.NameplateValue.identifiedObject)
  return _msg;
}
inline void NameplateValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NameplateValue.identifiedObject)
}

// .google.protobuf.StringValue model = 2;
inline bool NameplateValue::_internal_has_model() const {
  return this != internal_default_instance() && _impl_.model_ != nullptr;
}
inline bool NameplateValue::has_model() const {
  return _internal_has_model();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::_internal_model() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::model() const {
  // @@protoc_insertion_point(field_get:commonmodule.NameplateValue.model)
  return _internal_model();
}
inline void NameplateValue::unsafe_arena_set_allocated_model(
    ::PROTOBUF_NAMESPACE_ID::StringValue* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = model;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.NameplateValue.model)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::release_model() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:commonmodule.NameplateValue.model)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::_internal_mutable_model() {
  
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.model_ = p;
  }
  return _impl_.model_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::mutable_model() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:commonmodule.NameplateValue.model)
  return _msg;
}
inline void NameplateValue::set_allocated_model(::PROTOBUF_NAMESPACE_ID::StringValue* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model));
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }

  } else {

  }
  _impl_.model_ = model;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NameplateValue.model)
}

// .google.protobuf.StringValue sernum = 3;
inline bool NameplateValue::_internal_has_sernum() const {
  return this != internal_default_instance() && _impl_.sernum_ != nullptr;
}
inline bool NameplateValue::has_sernum() const {
  return _internal_has_sernum();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::_internal_sernum() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.sernum_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::sernum() const {
  // @@protoc_insertion_point(field_get:commonmodule.NameplateValue.sernum)
  return _internal_sernum();
}
inline void NameplateValue::unsafe_arena_set_allocated_sernum(
    ::PROTOBUF_NAMESPACE_ID::StringValue* sernum) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sernum_);
  }
  _impl_.sernum_ = sernum;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.NameplateValue.sernum)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::release_sernum() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.sernum_;
  _impl_.sernum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::unsafe_arena_release_sernum() {
  // @@protoc_insertion_point(field_release:commonmodule.NameplateValue.sernum)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.sernum_;
  _impl_.sernum_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::_internal_mutable_sernum() {
  
  if (_impl_.sernum_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.sernum_ = p;
  }
  return _impl_.sernum_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::mutable_sernum() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_sernum();
  // @@protoc_insertion_point(field_mutable:commonmodule.NameplateValue.sernum)
  return _msg;
}
inline void NameplateValue::set_allocated_sernum(::PROTOBUF_NAMESPACE_ID::StringValue* sernum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sernum_);
  }
  if (sernum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sernum));
    if (message_arena != submessage_arena) {
      sernum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sernum, submessage_arena);
    }

  } else {

  }
  _impl_.sernum_ = sernum;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NameplateValue.sernum)
}

// .google.protobuf.StringValue swRev = 4;
inline bool NameplateValue::_internal_has_swrev() const {
  return this != internal_default_instance() && _impl_.swrev_ != nullptr;
}
inline bool NameplateValue::has_swrev() const {
  return _internal_has_swrev();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::_internal_swrev() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.swrev_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::swrev() const {
  // @@protoc_insertion_point(field_get:commonmodule.NameplateValue.swRev)
  return _internal_swrev();
}
inline void NameplateValue::unsafe_arena_set_allocated_swrev(
    ::PROTOBUF_NAMESPACE_ID::StringValue* swrev) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.swrev_);
  }
  _impl_.swrev_ = swrev;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.NameplateValue.swRev)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::release_swrev() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.swrev_;
  _impl_.swrev_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::unsafe_arena_release_swrev() {
  // @@protoc_insertion_point(field_release:commonmodule.NameplateValue.swRev)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.swrev_;
  _impl_.swrev_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::_internal_mutable_swrev() {
  
  if (_impl_.swrev_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.swrev_ = p;
  }
  return _impl_.swrev_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::mutable_swrev() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_swrev();
  // @@protoc_insertion_point(field_mutable:commonmodule.NameplateValue.swRev)
  return _msg;
}
inline void NameplateValue::set_allocated_swrev(::PROTOBUF_NAMESPACE_ID::StringValue* swrev) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.swrev_);
  }
  if (swrev) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(swrev));
    if (message_arena != submessage_arena) {
      swrev = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, swrev, submessage_arena);
    }

  } else {

  }
  _impl_.swrev_ = swrev;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NameplateValue.swRev)
}

// .google.protobuf.StringValue vendor = 5;
inline bool NameplateValue::_internal_has_vendor() const {
  return this != internal_default_instance() && _impl_.vendor_ != nullptr;
}
inline bool NameplateValue::has_vendor() const {
  return _internal_has_vendor();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::_internal_vendor() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.vendor_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& NameplateValue::vendor() const {
  // @@protoc_insertion_point(field_get:commonmodule.NameplateValue.vendor)
  return _internal_vendor();
}
inline void NameplateValue::unsafe_arena_set_allocated_vendor(
    ::PROTOBUF_NAMESPACE_ID::StringValue* vendor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vendor_);
  }
  _impl_.vendor_ = vendor;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.NameplateValue.vendor)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::release_vendor() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.vendor_;
  _impl_.vendor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::unsafe_arena_release_vendor() {
  // @@protoc_insertion_point(field_release:commonmodule.NameplateValue.vendor)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.vendor_;
  _impl_.vendor_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::_internal_mutable_vendor() {
  
  if (_impl_.vendor_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.vendor_ = p;
  }
  return _impl_.vendor_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* NameplateValue::mutable_vendor() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:commonmodule.NameplateValue.vendor)
  return _msg;
}
inline void NameplateValue::set_allocated_vendor(::PROTOBUF_NAMESPACE_ID::StringValue* vendor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vendor_);
  }
  if (vendor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vendor));
    if (message_arena != submessage_arena) {
      vendor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vendor, submessage_arena);
    }

  } else {

  }
  _impl_.vendor_ = vendor;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.NameplateValue.vendor)
}

// -------------------------------------------------------------------

// OperationDFPF

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDFPF::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDFPF::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDFPF.modEna)
  return _internal_modena();
}
inline void OperationDFPF::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDFPF.modEna)
}
inline bool OperationDFPF::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDFPF::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// bool pFExtSet = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDFPF::clear_pfextset() {
  _impl_.pfextset_ = false;
}
inline bool OperationDFPF::pfextset() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDFPF.pFExtSet)
  return _internal_pfextset();
}
inline void OperationDFPF::set_pfextset(bool value) {
  _internal_set_pfextset(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDFPF.pFExtSet)
}
inline bool OperationDFPF::_internal_pfextset() const {
  return _impl_.pfextset_;
}
inline void OperationDFPF::_internal_set_pfextset(bool value) {
  ;
  _impl_.pfextset_ = value;
}

// float pFGnTgtMxVal = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDFPF::clear_pfgntgtmxval() {
  _impl_.pfgntgtmxval_ = 0;
}
inline float OperationDFPF::pfgntgtmxval() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDFPF.pFGnTgtMxVal)
  return _internal_pfgntgtmxval();
}
inline void OperationDFPF::set_pfgntgtmxval(float value) {
  _internal_set_pfgntgtmxval(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDFPF.pFGnTgtMxVal)
}
inline float OperationDFPF::_internal_pfgntgtmxval() const {
  return _impl_.pfgntgtmxval_;
}
inline void OperationDFPF::_internal_set_pfgntgtmxval(float value) {
  ;
  _impl_.pfgntgtmxval_ = value;
}

// -------------------------------------------------------------------

// OperationDVAR

// float varTgtSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDVAR::clear_vartgtspt() {
  _impl_.vartgtspt_ = 0;
}
inline float OperationDVAR::vartgtspt() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVAR.varTgtSpt)
  return _internal_vartgtspt();
}
inline void OperationDVAR::set_vartgtspt(float value) {
  _internal_set_vartgtspt(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDVAR.varTgtSpt)
}
inline float OperationDVAR::_internal_vartgtspt() const {
  return _impl_.vartgtspt_;
}
inline void OperationDVAR::_internal_set_vartgtspt(float value) {
  ;
  _impl_.vartgtspt_ = value;
}

// -------------------------------------------------------------------

// OperationDVVR

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDVVR::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDVVR::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVVR.modEna)
  return _internal_modena();
}
inline void OperationDVVR::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDVVR.modEna)
}
inline bool OperationDVVR::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDVVR::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDVVR::_internal_has_opltmmsmax() const {
  return this != internal_default_instance() && _impl_.opltmmsmax_ != nullptr;
}
inline bool OperationDVVR::has_opltmmsmax() const {
  return _internal_has_opltmmsmax();
}
inline void OperationDVVR::clear_opltmmsmax() {
  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
}
inline const ::commonmodule::ClearingTime& OperationDVVR::_internal_opltmmsmax() const {
  const ::commonmodule::ClearingTime* p = _impl_.opltmmsmax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ClearingTime&>(
      ::commonmodule::_ClearingTime_default_instance_);
}
inline const ::commonmodule::ClearingTime& OperationDVVR::opltmmsmax() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVVR.OplTmmsMax)
  return _internal_opltmmsmax();
}
inline void OperationDVVR::unsafe_arena_set_allocated_opltmmsmax(
    ::commonmodule::ClearingTime* opltmmsmax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opltmmsmax_);
  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDVVR.OplTmmsMax)
}
inline ::commonmodule::ClearingTime* OperationDVVR::release_opltmmsmax() {
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDVVR::unsafe_arena_release_opltmmsmax() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDVVR.OplTmmsMax)
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDVVR::_internal_mutable_opltmmsmax() {
  
  if (_impl_.opltmmsmax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ClearingTime>(GetArenaForAllocation());
    _impl_.opltmmsmax_ = p;
  }
  return _impl_.opltmmsmax_;
}
inline ::commonmodule::ClearingTime* OperationDVVR::mutable_opltmmsmax() {
  ::commonmodule::ClearingTime* _msg = _internal_mutable_opltmmsmax();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDVVR.OplTmmsMax)
  return _msg;
}
inline void OperationDVVR::set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opltmmsmax_;
  }
  if (opltmmsmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opltmmsmax);
    if (message_arena != submessage_arena) {
      opltmmsmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opltmmsmax, submessage_arena);
    }

  } else {

  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDVVR.OplTmmsMax)
}

// float VRef = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDVVR::clear_vref() {
  _impl_.vref_ = 0;
}
inline float OperationDVVR::vref() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVVR.VRef)
  return _internal_vref();
}
inline void OperationDVVR::set_vref(float value) {
  _internal_set_vref(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDVVR.VRef)
}
inline float OperationDVVR::_internal_vref() const {
  return _impl_.vref_;
}
inline void OperationDVVR::_internal_set_vref(float value) {
  ;
  _impl_.vref_ = value;
}

// bool VRefAdjEna = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDVVR::clear_vrefadjena() {
  _impl_.vrefadjena_ = false;
}
inline bool OperationDVVR::vrefadjena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVVR.VRefAdjEna)
  return _internal_vrefadjena();
}
inline void OperationDVVR::set_vrefadjena(bool value) {
  _internal_set_vrefadjena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDVVR.VRefAdjEna)
}
inline bool OperationDVVR::_internal_vrefadjena() const {
  return _impl_.vrefadjena_;
}
inline void OperationDVVR::_internal_set_vrefadjena(bool value) {
  ;
  _impl_.vrefadjena_ = value;
}

// .commonmodule.ControlING VRefTmms = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDVVR::_internal_has_vreftmms() const {
  return this != internal_default_instance() && _impl_.vreftmms_ != nullptr;
}
inline bool OperationDVVR::has_vreftmms() const {
  return _internal_has_vreftmms();
}
inline void OperationDVVR::clear_vreftmms() {
  if (GetArenaForAllocation() == nullptr && _impl_.vreftmms_ != nullptr) {
    delete _impl_.vreftmms_;
  }
  _impl_.vreftmms_ = nullptr;
}
inline const ::commonmodule::ControlING& OperationDVVR::_internal_vreftmms() const {
  const ::commonmodule::ControlING* p = _impl_.vreftmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(
      ::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& OperationDVVR::vreftmms() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVVR.VRefTmms)
  return _internal_vreftmms();
}
inline void OperationDVVR::unsafe_arena_set_allocated_vreftmms(
    ::commonmodule::ControlING* vreftmms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vreftmms_);
  }
  _impl_.vreftmms_ = vreftmms;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDVVR.VRefTmms)
}
inline ::commonmodule::ControlING* OperationDVVR::release_vreftmms() {
  
  ::commonmodule::ControlING* temp = _impl_.vreftmms_;
  _impl_.vreftmms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlING* OperationDVVR::unsafe_arena_release_vreftmms() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDVVR.VRefTmms)
  
  ::commonmodule::ControlING* temp = _impl_.vreftmms_;
  _impl_.vreftmms_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* OperationDVVR::_internal_mutable_vreftmms() {
  
  if (_impl_.vreftmms_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlING>(GetArenaForAllocation());
    _impl_.vreftmms_ = p;
  }
  return _impl_.vreftmms_;
}
inline ::commonmodule::ControlING* OperationDVVR::mutable_vreftmms() {
  ::commonmodule::ControlING* _msg = _internal_mutable_vreftmms();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDVVR.VRefTmms)
  return _msg;
}
inline void OperationDVVR::set_allocated_vreftmms(::commonmodule::ControlING* vreftmms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vreftmms_;
  }
  if (vreftmms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vreftmms);
    if (message_arena != submessage_arena) {
      vreftmms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vreftmms, submessage_arena);
    }

  } else {

  }
  _impl_.vreftmms_ = vreftmms;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDVVR.VRefTmms)
}

// -------------------------------------------------------------------

// OperationDVWC

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDVWC::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDVWC::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVWC.modEna)
  return _internal_modena();
}
inline void OperationDVWC::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDVWC.modEna)
}
inline bool OperationDVWC::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDVWC::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// .commonmodule.ClearingTime OplTmmsMax = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool OperationDVWC::_internal_has_opltmmsmax() const {
  return this != internal_default_instance() && _impl_.opltmmsmax_ != nullptr;
}
inline bool OperationDVWC::has_opltmmsmax() const {
  return _internal_has_opltmmsmax();
}
inline void OperationDVWC::clear_opltmmsmax() {
  if (GetArenaForAllocation() == nullptr && _impl_.opltmmsmax_ != nullptr) {
    delete _impl_.opltmmsmax_;
  }
  _impl_.opltmmsmax_ = nullptr;
}
inline const ::commonmodule::ClearingTime& OperationDVWC::_internal_opltmmsmax() const {
  const ::commonmodule::ClearingTime* p = _impl_.opltmmsmax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ClearingTime&>(
      ::commonmodule::_ClearingTime_default_instance_);
}
inline const ::commonmodule::ClearingTime& OperationDVWC::opltmmsmax() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDVWC.OplTmmsMax)
  return _internal_opltmmsmax();
}
inline void OperationDVWC::unsafe_arena_set_allocated_opltmmsmax(
    ::commonmodule::ClearingTime* opltmmsmax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opltmmsmax_);
  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OperationDVWC.OplTmmsMax)
}
inline ::commonmodule::ClearingTime* OperationDVWC::release_opltmmsmax() {
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDVWC::unsafe_arena_release_opltmmsmax() {
  // @@protoc_insertion_point(field_release:commonmodule.OperationDVWC.OplTmmsMax)
  
  ::commonmodule::ClearingTime* temp = _impl_.opltmmsmax_;
  _impl_.opltmmsmax_ = nullptr;
  return temp;
}
inline ::commonmodule::ClearingTime* OperationDVWC::_internal_mutable_opltmmsmax() {
  
  if (_impl_.opltmmsmax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ClearingTime>(GetArenaForAllocation());
    _impl_.opltmmsmax_ = p;
  }
  return _impl_.opltmmsmax_;
}
inline ::commonmodule::ClearingTime* OperationDVWC::mutable_opltmmsmax() {
  ::commonmodule::ClearingTime* _msg = _internal_mutable_opltmmsmax();
  // @@protoc_insertion_point(field_mutable:commonmodule.OperationDVWC.OplTmmsMax)
  return _msg;
}
inline void OperationDVWC::set_allocated_opltmmsmax(::commonmodule::ClearingTime* opltmmsmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opltmmsmax_;
  }
  if (opltmmsmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opltmmsmax);
    if (message_arena != submessage_arena) {
      opltmmsmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opltmmsmax, submessage_arena);
    }

  } else {

  }
  _impl_.opltmmsmax_ = opltmmsmax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OperationDVWC.OplTmmsMax)
}

// -------------------------------------------------------------------

// OperationDWGC

// float wSpt = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDWGC::clear_wspt() {
  _impl_.wspt_ = 0;
}
inline float OperationDWGC::wspt() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDWGC.wSpt)
  return _internal_wspt();
}
inline void OperationDWGC::set_wspt(float value) {
  _internal_set_wspt(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDWGC.wSpt)
}
inline float OperationDWGC::_internal_wspt() const {
  return _impl_.wspt_;
}
inline void OperationDWGC::_internal_set_wspt(float value) {
  ;
  _impl_.wspt_ = value;
}

// -------------------------------------------------------------------

// OperationDWVR

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void OperationDWVR::clear_modena() {
  _impl_.modena_ = false;
}
inline bool OperationDWVR::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.OperationDWVR.modEna)
  return _internal_modena();
}
inline void OperationDWVR::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.OperationDWVR.modEna)
}
inline bool OperationDWVR::_internal_modena() const {
  return _impl_.modena_;
}
inline void OperationDWVR::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// -------------------------------------------------------------------

// OptimizationMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool OptimizationMessageInfo::_internal_has_messageinfo() const {
  return this != internal_default_instance() && _impl_.messageinfo_ != nullptr;
}
inline bool OptimizationMessageInfo::has_messageinfo() const {
  return _internal_has_messageinfo();
}
inline void OptimizationMessageInfo::clear_messageinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& OptimizationMessageInfo::_internal_messageinfo() const {
  const ::commonmodule::MessageInfo* p = _impl_.messageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MessageInfo&>(
      ::commonmodule::_MessageInfo_default_instance_);
}
inline const ::commonmodule::MessageInfo& OptimizationMessageInfo::messageinfo() const {
  // @@protoc_insertion_point(field_get:commonmodule.OptimizationMessageInfo.messageInfo)
  return _internal_messageinfo();
}
inline void OptimizationMessageInfo::unsafe_arena_set_allocated_messageinfo(
    ::commonmodule::MessageInfo* messageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageinfo_);
  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.OptimizationMessageInfo.messageInfo)
}
inline ::commonmodule::MessageInfo* OptimizationMessageInfo::release_messageinfo() {
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MessageInfo* OptimizationMessageInfo::unsafe_arena_release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.OptimizationMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* OptimizationMessageInfo::_internal_mutable_messageinfo() {
  
  if (_impl_.messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaForAllocation());
    _impl_.messageinfo_ = p;
  }
  return _impl_.messageinfo_;
}
inline ::commonmodule::MessageInfo* OptimizationMessageInfo::mutable_messageinfo() {
  ::commonmodule::MessageInfo* _msg = _internal_mutable_messageinfo();
  // @@protoc_insertion_point(field_mutable:commonmodule.OptimizationMessageInfo.messageInfo)
  return _msg;
}
inline void OptimizationMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messageinfo_;
  }
  if (messageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messageinfo);
    if (message_arena != submessage_arena) {
      messageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.OptimizationMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// PFSPC

// bool ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void PFSPC::clear_ctlval() {
  _impl_.ctlval_ = false;
}
inline bool PFSPC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.PFSPC.ctlVal)
  return _internal_ctlval();
}
inline void PFSPC::set_ctlval(bool value) {
  _internal_set_ctlval(value);
  // @@protoc_insertion_point(field_set:commonmodule.PFSPC.ctlVal)
}
inline bool PFSPC::_internal_ctlval() const {
  return _impl_.ctlval_;
}
inline void PFSPC::_internal_set_ctlval(bool value) {
  ;
  _impl_.ctlval_ = value;
}

// .commonmodule.OperationDFPF pFParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool PFSPC::_internal_has_pfparameter() const {
  return this != internal_default_instance() && _impl_.pfparameter_ != nullptr;
}
inline bool PFSPC::has_pfparameter() const {
  return _internal_has_pfparameter();
}
inline void PFSPC::clear_pfparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.pfparameter_ != nullptr) {
    delete _impl_.pfparameter_;
  }
  _impl_.pfparameter_ = nullptr;
}
inline const ::commonmodule::OperationDFPF& PFSPC::_internal_pfparameter() const {
  const ::commonmodule::OperationDFPF* p = _impl_.pfparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDFPF&>(
      ::commonmodule::_OperationDFPF_default_instance_);
}
inline const ::commonmodule::OperationDFPF& PFSPC::pfparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.PFSPC.pFParameter)
  return _internal_pfparameter();
}
inline void PFSPC::unsafe_arena_set_allocated_pfparameter(
    ::commonmodule::OperationDFPF* pfparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfparameter_);
  }
  _impl_.pfparameter_ = pfparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PFSPC.pFParameter)
}
inline ::commonmodule::OperationDFPF* PFSPC::release_pfparameter() {
  
  ::commonmodule::OperationDFPF* temp = _impl_.pfparameter_;
  _impl_.pfparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDFPF* PFSPC::unsafe_arena_release_pfparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.PFSPC.pFParameter)
  
  ::commonmodule::OperationDFPF* temp = _impl_.pfparameter_;
  _impl_.pfparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDFPF* PFSPC::_internal_mutable_pfparameter() {
  
  if (_impl_.pfparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDFPF>(GetArenaForAllocation());
    _impl_.pfparameter_ = p;
  }
  return _impl_.pfparameter_;
}
inline ::commonmodule::OperationDFPF* PFSPC::mutable_pfparameter() {
  ::commonmodule::OperationDFPF* _msg = _internal_mutable_pfparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.PFSPC.pFParameter)
  return _msg;
}
inline void PFSPC::set_allocated_pfparameter(::commonmodule::OperationDFPF* pfparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pfparameter_;
  }
  if (pfparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pfparameter);
    if (message_arena != submessage_arena) {
      pfparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pfparameter, submessage_arena);
    }

  } else {

  }
  _impl_.pfparameter_ = pfparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PFSPC.pFParameter)
}

// -------------------------------------------------------------------

// PhaseAPC

// .commonmodule.ControlAPC phs3 = 1;
inline bool PhaseAPC::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseAPC::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseAPC::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::ControlAPC& PhaseAPC::_internal_phs3() const {
  const ::commonmodule::ControlAPC* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlAPC&>(
      ::commonmodule::_ControlAPC_default_instance_);
}
inline const ::commonmodule::ControlAPC& PhaseAPC::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseAPC.phs3)
  return _internal_phs3();
}
inline void PhaseAPC::unsafe_arena_set_allocated_phs3(
    ::commonmodule::ControlAPC* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseAPC.phs3)
}
inline ::commonmodule::ControlAPC* PhaseAPC::release_phs3() {
  
  ::commonmodule::ControlAPC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseAPC.phs3)
  
  ::commonmodule::ControlAPC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlAPC>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::ControlAPC* PhaseAPC::mutable_phs3() {
  ::commonmodule::ControlAPC* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseAPC.phs3)
  return _msg;
}
inline void PhaseAPC::set_allocated_phs3(::commonmodule::ControlAPC* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseAPC.phs3)
}

// .commonmodule.ControlAPC phsA = 2;
inline bool PhaseAPC::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseAPC::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseAPC::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::ControlAPC& PhaseAPC::_internal_phsa() const {
  const ::commonmodule::ControlAPC* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlAPC&>(
      ::commonmodule::_ControlAPC_default_instance_);
}
inline const ::commonmodule::ControlAPC& PhaseAPC::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseAPC.phsA)
  return _internal_phsa();
}
inline void PhaseAPC::unsafe_arena_set_allocated_phsa(
    ::commonmodule::ControlAPC* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseAPC.phsA)
}
inline ::commonmodule::ControlAPC* PhaseAPC::release_phsa() {
  
  ::commonmodule::ControlAPC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseAPC.phsA)
  
  ::commonmodule::ControlAPC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlAPC>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::ControlAPC* PhaseAPC::mutable_phsa() {
  ::commonmodule::ControlAPC* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseAPC.phsA)
  return _msg;
}
inline void PhaseAPC::set_allocated_phsa(::commonmodule::ControlAPC* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseAPC.phsA)
}

// .commonmodule.ControlAPC phsB = 3;
inline bool PhaseAPC::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseAPC::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseAPC::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::ControlAPC& PhaseAPC::_internal_phsb() const {
  const ::commonmodule::ControlAPC* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlAPC&>(
      ::commonmodule::_ControlAPC_default_instance_);
}
inline const ::commonmodule::ControlAPC& PhaseAPC::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseAPC.phsB)
  return _internal_phsb();
}
inline void PhaseAPC::unsafe_arena_set_allocated_phsb(
    ::commonmodule::ControlAPC* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseAPC.phsB)
}
inline ::commonmodule::ControlAPC* PhaseAPC::release_phsb() {
  
  ::commonmodule::ControlAPC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseAPC.phsB)
  
  ::commonmodule::ControlAPC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlAPC>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::ControlAPC* PhaseAPC::mutable_phsb() {
  ::commonmodule::ControlAPC* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseAPC.phsB)
  return _msg;
}
inline void PhaseAPC::set_allocated_phsb(::commonmodule::ControlAPC* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseAPC.phsB)
}

// .commonmodule.ControlAPC phsC = 4;
inline bool PhaseAPC::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseAPC::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseAPC::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::ControlAPC& PhaseAPC::_internal_phsc() const {
  const ::commonmodule::ControlAPC* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlAPC&>(
      ::commonmodule::_ControlAPC_default_instance_);
}
inline const ::commonmodule::ControlAPC& PhaseAPC::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseAPC.phsC)
  return _internal_phsc();
}
inline void PhaseAPC::unsafe_arena_set_allocated_phsc(
    ::commonmodule::ControlAPC* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseAPC.phsC)
}
inline ::commonmodule::ControlAPC* PhaseAPC::release_phsc() {
  
  ::commonmodule::ControlAPC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseAPC.phsC)
  
  ::commonmodule::ControlAPC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlAPC* PhaseAPC::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlAPC>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::ControlAPC* PhaseAPC::mutable_phsc() {
  ::commonmodule::ControlAPC* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseAPC.phsC)
  return _msg;
}
inline void PhaseAPC::set_allocated_phsc(::commonmodule::ControlAPC* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseAPC.phsC)
}

// -------------------------------------------------------------------

// Optional_DbPosKind

// .commonmodule.DbPosKind value = 1;
inline void Optional_DbPosKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::DbPosKind Optional_DbPosKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_DbPosKind.value)
  return _internal_value();
}
inline void Optional_DbPosKind::set_value(::commonmodule::DbPosKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_DbPosKind.value)
}
inline ::commonmodule::DbPosKind Optional_DbPosKind::_internal_value() const {
  return static_cast<::commonmodule::DbPosKind>(_impl_.value_);
}
inline void Optional_DbPosKind::_internal_set_value(::commonmodule::DbPosKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// StatusDPS

// .commonmodule.Quality q = 1;
inline bool StatusDPS::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool StatusDPS::has_q() const {
  return _internal_has_q();
}
inline void StatusDPS::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusDPS::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& StatusDPS::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusDPS.q)
  return _internal_q();
}
inline void StatusDPS::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusDPS.q)
}
inline ::commonmodule::Quality* StatusDPS::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* StatusDPS::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusDPS.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusDPS::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* StatusDPS::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusDPS.q)
  return _msg;
}
inline void StatusDPS::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusDPS.q)
}

// .commonmodule.DbPosKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusDPS::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::commonmodule::DbPosKind StatusDPS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusDPS.stVal)
  return _internal_stval();
}
inline void StatusDPS::set_stval(::commonmodule::DbPosKind value) {
   _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.StatusDPS.stVal)
}
inline ::commonmodule::DbPosKind StatusDPS::_internal_stval() const {
  return static_cast<::commonmodule::DbPosKind>(_impl_.stval_);
}
inline void StatusDPS::_internal_set_stval(::commonmodule::DbPosKind value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool StatusDPS::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool StatusDPS::has_t() const {
  return _internal_has_t();
}
inline void StatusDPS::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusDPS::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& StatusDPS::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusDPS.t)
  return _internal_t();
}
inline void StatusDPS::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusDPS.t)
}
inline ::commonmodule::Timestamp* StatusDPS::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* StatusDPS::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusDPS.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusDPS::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* StatusDPS::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusDPS.t)
  return _msg;
}
inline void StatusDPS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusDPS.t)
}

// -------------------------------------------------------------------

// PhaseDPS

// .commonmodule.StatusDPS phs3 = 1;
inline bool PhaseDPS::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseDPS::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseDPS::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::StatusDPS& PhaseDPS::_internal_phs3() const {
  const ::commonmodule::StatusDPS* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusDPS&>(
      ::commonmodule::_StatusDPS_default_instance_);
}
inline const ::commonmodule::StatusDPS& PhaseDPS::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPS.phs3)
  return _internal_phs3();
}
inline void PhaseDPS::unsafe_arena_set_allocated_phs3(
    ::commonmodule::StatusDPS* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPS.phs3)
}
inline ::commonmodule::StatusDPS* PhaseDPS::release_phs3() {
  
  ::commonmodule::StatusDPS* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPS.phs3)
  
  ::commonmodule::StatusDPS* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::StatusDPS* PhaseDPS::mutable_phs3() {
  ::commonmodule::StatusDPS* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPS.phs3)
  return _msg;
}
inline void PhaseDPS::set_allocated_phs3(::commonmodule::StatusDPS* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPS.phs3)
}

// .commonmodule.StatusDPS phsA = 2;
inline bool PhaseDPS::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseDPS::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseDPS::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::StatusDPS& PhaseDPS::_internal_phsa() const {
  const ::commonmodule::StatusDPS* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusDPS&>(
      ::commonmodule::_StatusDPS_default_instance_);
}
inline const ::commonmodule::StatusDPS& PhaseDPS::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPS.phsA)
  return _internal_phsa();
}
inline void PhaseDPS::unsafe_arena_set_allocated_phsa(
    ::commonmodule::StatusDPS* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPS.phsA)
}
inline ::commonmodule::StatusDPS* PhaseDPS::release_phsa() {
  
  ::commonmodule::StatusDPS* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPS.phsA)
  
  ::commonmodule::StatusDPS* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::StatusDPS* PhaseDPS::mutable_phsa() {
  ::commonmodule::StatusDPS* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPS.phsA)
  return _msg;
}
inline void PhaseDPS::set_allocated_phsa(::commonmodule::StatusDPS* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPS.phsA)
}

// .commonmodule.StatusDPS phsB = 3;
inline bool PhaseDPS::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseDPS::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseDPS::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::StatusDPS& PhaseDPS::_internal_phsb() const {
  const ::commonmodule::StatusDPS* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusDPS&>(
      ::commonmodule::_StatusDPS_default_instance_);
}
inline const ::commonmodule::StatusDPS& PhaseDPS::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPS.phsB)
  return _internal_phsb();
}
inline void PhaseDPS::unsafe_arena_set_allocated_phsb(
    ::commonmodule::StatusDPS* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPS.phsB)
}
inline ::commonmodule::StatusDPS* PhaseDPS::release_phsb() {
  
  ::commonmodule::StatusDPS* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPS.phsB)
  
  ::commonmodule::StatusDPS* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::StatusDPS* PhaseDPS::mutable_phsb() {
  ::commonmodule::StatusDPS* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPS.phsB)
  return _msg;
}
inline void PhaseDPS::set_allocated_phsb(::commonmodule::StatusDPS* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPS.phsB)
}

// .commonmodule.StatusDPS phsC = 4;
inline bool PhaseDPS::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseDPS::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseDPS::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::StatusDPS& PhaseDPS::_internal_phsc() const {
  const ::commonmodule::StatusDPS* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusDPS&>(
      ::commonmodule::_StatusDPS_default_instance_);
}
inline const ::commonmodule::StatusDPS& PhaseDPS::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseDPS.phsC)
  return _internal_phsc();
}
inline void PhaseDPS::unsafe_arena_set_allocated_phsc(
    ::commonmodule::StatusDPS* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseDPS.phsC)
}
inline ::commonmodule::StatusDPS* PhaseDPS::release_phsc() {
  
  ::commonmodule::StatusDPS* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseDPS.phsC)
  
  ::commonmodule::StatusDPS* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusDPS* PhaseDPS::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusDPS>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::StatusDPS* PhaseDPS::mutable_phsc() {
  ::commonmodule::StatusDPS* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseDPS.phsC)
  return _msg;
}
inline void PhaseDPS::set_allocated_phsc(::commonmodule::StatusDPS* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseDPS.phsC)
}

// -------------------------------------------------------------------

// PhaseINS

// .commonmodule.StatusINS phs3 = 1;
inline bool PhaseINS::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseINS::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseINS::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::StatusINS& PhaseINS::_internal_phs3() const {
  const ::commonmodule::StatusINS* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINS&>(
      ::commonmodule::_StatusINS_default_instance_);
}
inline const ::commonmodule::StatusINS& PhaseINS::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseINS.phs3)
  return _internal_phs3();
}
inline void PhaseINS::unsafe_arena_set_allocated_phs3(
    ::commonmodule::StatusINS* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseINS.phs3)
}
inline ::commonmodule::StatusINS* PhaseINS::release_phs3() {
  
  ::commonmodule::StatusINS* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseINS.phs3)
  
  ::commonmodule::StatusINS* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINS>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::StatusINS* PhaseINS::mutable_phs3() {
  ::commonmodule::StatusINS* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseINS.phs3)
  return _msg;
}
inline void PhaseINS::set_allocated_phs3(::commonmodule::StatusINS* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseINS.phs3)
}

// .commonmodule.StatusINS phsA = 2;
inline bool PhaseINS::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseINS::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseINS::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::StatusINS& PhaseINS::_internal_phsa() const {
  const ::commonmodule::StatusINS* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINS&>(
      ::commonmodule::_StatusINS_default_instance_);
}
inline const ::commonmodule::StatusINS& PhaseINS::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseINS.phsA)
  return _internal_phsa();
}
inline void PhaseINS::unsafe_arena_set_allocated_phsa(
    ::commonmodule::StatusINS* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseINS.phsA)
}
inline ::commonmodule::StatusINS* PhaseINS::release_phsa() {
  
  ::commonmodule::StatusINS* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseINS.phsA)
  
  ::commonmodule::StatusINS* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINS>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::StatusINS* PhaseINS::mutable_phsa() {
  ::commonmodule::StatusINS* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseINS.phsA)
  return _msg;
}
inline void PhaseINS::set_allocated_phsa(::commonmodule::StatusINS* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseINS.phsA)
}

// .commonmodule.StatusINS phsB = 3;
inline bool PhaseINS::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseINS::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseINS::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::StatusINS& PhaseINS::_internal_phsb() const {
  const ::commonmodule::StatusINS* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINS&>(
      ::commonmodule::_StatusINS_default_instance_);
}
inline const ::commonmodule::StatusINS& PhaseINS::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseINS.phsB)
  return _internal_phsb();
}
inline void PhaseINS::unsafe_arena_set_allocated_phsb(
    ::commonmodule::StatusINS* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseINS.phsB)
}
inline ::commonmodule::StatusINS* PhaseINS::release_phsb() {
  
  ::commonmodule::StatusINS* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseINS.phsB)
  
  ::commonmodule::StatusINS* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINS>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::StatusINS* PhaseINS::mutable_phsb() {
  ::commonmodule::StatusINS* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseINS.phsB)
  return _msg;
}
inline void PhaseINS::set_allocated_phsb(::commonmodule::StatusINS* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseINS.phsB)
}

// .commonmodule.StatusINS phsC = 4;
inline bool PhaseINS::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseINS::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseINS::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::StatusINS& PhaseINS::_internal_phsc() const {
  const ::commonmodule::StatusINS* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINS&>(
      ::commonmodule::_StatusINS_default_instance_);
}
inline const ::commonmodule::StatusINS& PhaseINS::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseINS.phsC)
  return _internal_phsc();
}
inline void PhaseINS::unsafe_arena_set_allocated_phsc(
    ::commonmodule::StatusINS* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseINS.phsC)
}
inline ::commonmodule::StatusINS* PhaseINS::release_phsc() {
  
  ::commonmodule::StatusINS* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseINS.phsC)
  
  ::commonmodule::StatusINS* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINS* PhaseINS::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINS>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::StatusINS* PhaseINS::mutable_phsc() {
  ::commonmodule::StatusINS* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseINS.phsC)
  return _msg;
}
inline void PhaseINS::set_allocated_phsc(::commonmodule::StatusINS* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseINS.phsC)
}

// -------------------------------------------------------------------

// PhaseISC

// .commonmodule.ControlISC phs3 = 1;
inline bool PhaseISC::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseISC::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseISC::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::ControlISC& PhaseISC::_internal_phs3() const {
  const ::commonmodule::ControlISC* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlISC&>(
      ::commonmodule::_ControlISC_default_instance_);
}
inline const ::commonmodule::ControlISC& PhaseISC::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseISC.phs3)
  return _internal_phs3();
}
inline void PhaseISC::unsafe_arena_set_allocated_phs3(
    ::commonmodule::ControlISC* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseISC.phs3)
}
inline ::commonmodule::ControlISC* PhaseISC::release_phs3() {
  
  ::commonmodule::ControlISC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseISC.phs3)
  
  ::commonmodule::ControlISC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlISC>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::ControlISC* PhaseISC::mutable_phs3() {
  ::commonmodule::ControlISC* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseISC.phs3)
  return _msg;
}
inline void PhaseISC::set_allocated_phs3(::commonmodule::ControlISC* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseISC.phs3)
}

// .commonmodule.ControlISC phsA = 2;
inline bool PhaseISC::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseISC::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseISC::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::ControlISC& PhaseISC::_internal_phsa() const {
  const ::commonmodule::ControlISC* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlISC&>(
      ::commonmodule::_ControlISC_default_instance_);
}
inline const ::commonmodule::ControlISC& PhaseISC::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseISC.phsA)
  return _internal_phsa();
}
inline void PhaseISC::unsafe_arena_set_allocated_phsa(
    ::commonmodule::ControlISC* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseISC.phsA)
}
inline ::commonmodule::ControlISC* PhaseISC::release_phsa() {
  
  ::commonmodule::ControlISC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseISC.phsA)
  
  ::commonmodule::ControlISC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlISC>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::ControlISC* PhaseISC::mutable_phsa() {
  ::commonmodule::ControlISC* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseISC.phsA)
  return _msg;
}
inline void PhaseISC::set_allocated_phsa(::commonmodule::ControlISC* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseISC.phsA)
}

// .commonmodule.ControlISC phsB = 3;
inline bool PhaseISC::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseISC::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseISC::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::ControlISC& PhaseISC::_internal_phsb() const {
  const ::commonmodule::ControlISC* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlISC&>(
      ::commonmodule::_ControlISC_default_instance_);
}
inline const ::commonmodule::ControlISC& PhaseISC::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseISC.phsB)
  return _internal_phsb();
}
inline void PhaseISC::unsafe_arena_set_allocated_phsb(
    ::commonmodule::ControlISC* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseISC.phsB)
}
inline ::commonmodule::ControlISC* PhaseISC::release_phsb() {
  
  ::commonmodule::ControlISC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseISC.phsB)
  
  ::commonmodule::ControlISC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlISC>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::ControlISC* PhaseISC::mutable_phsb() {
  ::commonmodule::ControlISC* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseISC.phsB)
  return _msg;
}
inline void PhaseISC::set_allocated_phsb(::commonmodule::ControlISC* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseISC.phsB)
}

// .commonmodule.ControlISC phsC = 4;
inline bool PhaseISC::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseISC::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseISC::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::ControlISC& PhaseISC::_internal_phsc() const {
  const ::commonmodule::ControlISC* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlISC&>(
      ::commonmodule::_ControlISC_default_instance_);
}
inline const ::commonmodule::ControlISC& PhaseISC::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseISC.phsC)
  return _internal_phsc();
}
inline void PhaseISC::unsafe_arena_set_allocated_phsc(
    ::commonmodule::ControlISC* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseISC.phsC)
}
inline ::commonmodule::ControlISC* PhaseISC::release_phsc() {
  
  ::commonmodule::ControlISC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseISC.phsC)
  
  ::commonmodule::ControlISC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlISC* PhaseISC::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlISC>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::ControlISC* PhaseISC::mutable_phsc() {
  ::commonmodule::ControlISC* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseISC.phsC)
  return _msg;
}
inline void PhaseISC::set_allocated_phsc(::commonmodule::ControlISC* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseISC.phsC)
}

// -------------------------------------------------------------------

// ReadingMMTN

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMMTN::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool ReadingMMTN::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void ReadingMMTN::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& ReadingMMTN::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& ReadingMMTN::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.logicalNode)
  return _internal_logicalnode();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.logicalNode)
}
inline ::commonmodule::LogicalNode* ReadingMMTN::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMTN::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMTN::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* ReadingMMTN::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.logicalNode)
  return _msg;
}
inline void ReadingMMTN::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.logicalNode)
}

// .commonmodule.BCR DmdVAh = 2;
inline bool ReadingMMTN::_internal_has_dmdvah() const {
  return this != internal_default_instance() && _impl_.dmdvah_ != nullptr;
}
inline bool ReadingMMTN::has_dmdvah() const {
  return _internal_has_dmdvah();
}
inline void ReadingMMTN::clear_dmdvah() {
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvah_ != nullptr) {
    delete _impl_.dmdvah_;
  }
  _impl_.dmdvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_dmdvah() const {
  const ::commonmodule::BCR* p = _impl_.dmdvah_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::dmdvah() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.DmdVAh)
  return _internal_dmdvah();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_dmdvah(
    ::commonmodule::BCR* dmdvah) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dmdvah_);
  }
  _impl_.dmdvah_ = dmdvah;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.DmdVAh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_dmdvah() {
  
  ::commonmodule::BCR* temp = _impl_.dmdvah_;
  _impl_.dmdvah_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_dmdvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.DmdVAh)
  
  ::commonmodule::BCR* temp = _impl_.dmdvah_;
  _impl_.dmdvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_dmdvah() {
  
  if (_impl_.dmdvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.dmdvah_ = p;
  }
  return _impl_.dmdvah_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_dmdvah() {
  ::commonmodule::BCR* _msg = _internal_mutable_dmdvah();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.DmdVAh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_dmdvah(::commonmodule::BCR* dmdvah) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dmdvah_;
  }
  if (dmdvah) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dmdvah);
    if (message_arena != submessage_arena) {
      dmdvah = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dmdvah, submessage_arena);
    }

  } else {

  }
  _impl_.dmdvah_ = dmdvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.DmdVAh)
}

// .commonmodule.BCR DmdVArh = 3;
inline bool ReadingMMTN::_internal_has_dmdvarh() const {
  return this != internal_default_instance() && _impl_.dmdvarh_ != nullptr;
}
inline bool ReadingMMTN::has_dmdvarh() const {
  return _internal_has_dmdvarh();
}
inline void ReadingMMTN::clear_dmdvarh() {
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvarh_ != nullptr) {
    delete _impl_.dmdvarh_;
  }
  _impl_.dmdvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_dmdvarh() const {
  const ::commonmodule::BCR* p = _impl_.dmdvarh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::dmdvarh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.DmdVArh)
  return _internal_dmdvarh();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_dmdvarh(
    ::commonmodule::BCR* dmdvarh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dmdvarh_);
  }
  _impl_.dmdvarh_ = dmdvarh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.DmdVArh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_dmdvarh() {
  
  ::commonmodule::BCR* temp = _impl_.dmdvarh_;
  _impl_.dmdvarh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_dmdvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.DmdVArh)
  
  ::commonmodule::BCR* temp = _impl_.dmdvarh_;
  _impl_.dmdvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_dmdvarh() {
  
  if (_impl_.dmdvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.dmdvarh_ = p;
  }
  return _impl_.dmdvarh_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_dmdvarh() {
  ::commonmodule::BCR* _msg = _internal_mutable_dmdvarh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.DmdVArh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dmdvarh_;
  }
  if (dmdvarh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dmdvarh);
    if (message_arena != submessage_arena) {
      dmdvarh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dmdvarh, submessage_arena);
    }

  } else {

  }
  _impl_.dmdvarh_ = dmdvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.DmdVArh)
}

// .commonmodule.BCR DmdWh = 4;
inline bool ReadingMMTN::_internal_has_dmdwh() const {
  return this != internal_default_instance() && _impl_.dmdwh_ != nullptr;
}
inline bool ReadingMMTN::has_dmdwh() const {
  return _internal_has_dmdwh();
}
inline void ReadingMMTN::clear_dmdwh() {
  if (GetArenaForAllocation() == nullptr && _impl_.dmdwh_ != nullptr) {
    delete _impl_.dmdwh_;
  }
  _impl_.dmdwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_dmdwh() const {
  const ::commonmodule::BCR* p = _impl_.dmdwh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::dmdwh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.DmdWh)
  return _internal_dmdwh();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_dmdwh(
    ::commonmodule::BCR* dmdwh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dmdwh_);
  }
  _impl_.dmdwh_ = dmdwh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.DmdWh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_dmdwh() {
  
  ::commonmodule::BCR* temp = _impl_.dmdwh_;
  _impl_.dmdwh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_dmdwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.DmdWh)
  
  ::commonmodule::BCR* temp = _impl_.dmdwh_;
  _impl_.dmdwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_dmdwh() {
  
  if (_impl_.dmdwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.dmdwh_ = p;
  }
  return _impl_.dmdwh_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_dmdwh() {
  ::commonmodule::BCR* _msg = _internal_mutable_dmdwh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.DmdWh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_dmdwh(::commonmodule::BCR* dmdwh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dmdwh_;
  }
  if (dmdwh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dmdwh);
    if (message_arena != submessage_arena) {
      dmdwh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dmdwh, submessage_arena);
    }

  } else {

  }
  _impl_.dmdwh_ = dmdwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.DmdWh)
}

// .commonmodule.BCR SupVAh = 5;
inline bool ReadingMMTN::_internal_has_supvah() const {
  return this != internal_default_instance() && _impl_.supvah_ != nullptr;
}
inline bool ReadingMMTN::has_supvah() const {
  return _internal_has_supvah();
}
inline void ReadingMMTN::clear_supvah() {
  if (GetArenaForAllocation() == nullptr && _impl_.supvah_ != nullptr) {
    delete _impl_.supvah_;
  }
  _impl_.supvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_supvah() const {
  const ::commonmodule::BCR* p = _impl_.supvah_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::supvah() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.SupVAh)
  return _internal_supvah();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_supvah(
    ::commonmodule::BCR* supvah) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supvah_);
  }
  _impl_.supvah_ = supvah;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.SupVAh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_supvah() {
  
  ::commonmodule::BCR* temp = _impl_.supvah_;
  _impl_.supvah_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_supvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.SupVAh)
  
  ::commonmodule::BCR* temp = _impl_.supvah_;
  _impl_.supvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_supvah() {
  
  if (_impl_.supvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.supvah_ = p;
  }
  return _impl_.supvah_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_supvah() {
  ::commonmodule::BCR* _msg = _internal_mutable_supvah();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.SupVAh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_supvah(::commonmodule::BCR* supvah) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supvah_;
  }
  if (supvah) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supvah);
    if (message_arena != submessage_arena) {
      supvah = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supvah, submessage_arena);
    }

  } else {

  }
  _impl_.supvah_ = supvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.SupVAh)
}

// .commonmodule.BCR SupVArh = 6;
inline bool ReadingMMTN::_internal_has_supvarh() const {
  return this != internal_default_instance() && _impl_.supvarh_ != nullptr;
}
inline bool ReadingMMTN::has_supvarh() const {
  return _internal_has_supvarh();
}
inline void ReadingMMTN::clear_supvarh() {
  if (GetArenaForAllocation() == nullptr && _impl_.supvarh_ != nullptr) {
    delete _impl_.supvarh_;
  }
  _impl_.supvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_supvarh() const {
  const ::commonmodule::BCR* p = _impl_.supvarh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::supvarh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.SupVArh)
  return _internal_supvarh();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_supvarh(
    ::commonmodule::BCR* supvarh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supvarh_);
  }
  _impl_.supvarh_ = supvarh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.SupVArh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_supvarh() {
  
  ::commonmodule::BCR* temp = _impl_.supvarh_;
  _impl_.supvarh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_supvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.SupVArh)
  
  ::commonmodule::BCR* temp = _impl_.supvarh_;
  _impl_.supvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_supvarh() {
  
  if (_impl_.supvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.supvarh_ = p;
  }
  return _impl_.supvarh_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_supvarh() {
  ::commonmodule::BCR* _msg = _internal_mutable_supvarh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.SupVArh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_supvarh(::commonmodule::BCR* supvarh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supvarh_;
  }
  if (supvarh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supvarh);
    if (message_arena != submessage_arena) {
      supvarh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supvarh, submessage_arena);
    }

  } else {

  }
  _impl_.supvarh_ = supvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.SupVArh)
}

// .commonmodule.BCR SupWh = 7;
inline bool ReadingMMTN::_internal_has_supwh() const {
  return this != internal_default_instance() && _impl_.supwh_ != nullptr;
}
inline bool ReadingMMTN::has_supwh() const {
  return _internal_has_supwh();
}
inline void ReadingMMTN::clear_supwh() {
  if (GetArenaForAllocation() == nullptr && _impl_.supwh_ != nullptr) {
    delete _impl_.supwh_;
  }
  _impl_.supwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_supwh() const {
  const ::commonmodule::BCR* p = _impl_.supwh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::supwh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.SupWh)
  return _internal_supwh();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_supwh(
    ::commonmodule::BCR* supwh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supwh_);
  }
  _impl_.supwh_ = supwh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.SupWh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_supwh() {
  
  ::commonmodule::BCR* temp = _impl_.supwh_;
  _impl_.supwh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_supwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.SupWh)
  
  ::commonmodule::BCR* temp = _impl_.supwh_;
  _impl_.supwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_supwh() {
  
  if (_impl_.supwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.supwh_ = p;
  }
  return _impl_.supwh_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_supwh() {
  ::commonmodule::BCR* _msg = _internal_mutable_supwh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.SupWh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_supwh(::commonmodule::BCR* supwh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supwh_;
  }
  if (supwh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supwh);
    if (message_arena != submessage_arena) {
      supwh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supwh, submessage_arena);
    }

  } else {

  }
  _impl_.supwh_ = supwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.SupWh)
}

// .commonmodule.BCR TotVAh = 8;
inline bool ReadingMMTN::_internal_has_totvah() const {
  return this != internal_default_instance() && _impl_.totvah_ != nullptr;
}
inline bool ReadingMMTN::has_totvah() const {
  return _internal_has_totvah();
}
inline void ReadingMMTN::clear_totvah() {
  if (GetArenaForAllocation() == nullptr && _impl_.totvah_ != nullptr) {
    delete _impl_.totvah_;
  }
  _impl_.totvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_totvah() const {
  const ::commonmodule::BCR* p = _impl_.totvah_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::totvah() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.TotVAh)
  return _internal_totvah();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_totvah(
    ::commonmodule::BCR* totvah) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.totvah_);
  }
  _impl_.totvah_ = totvah;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.TotVAh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_totvah() {
  
  ::commonmodule::BCR* temp = _impl_.totvah_;
  _impl_.totvah_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_totvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.TotVAh)
  
  ::commonmodule::BCR* temp = _impl_.totvah_;
  _impl_.totvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_totvah() {
  
  if (_impl_.totvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.totvah_ = p;
  }
  return _impl_.totvah_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_totvah() {
  ::commonmodule::BCR* _msg = _internal_mutable_totvah();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.TotVAh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_totvah(::commonmodule::BCR* totvah) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.totvah_;
  }
  if (totvah) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(totvah);
    if (message_arena != submessage_arena) {
      totvah = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totvah, submessage_arena);
    }

  } else {

  }
  _impl_.totvah_ = totvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.TotVAh)
}

// .commonmodule.BCR TotVArh = 9;
inline bool ReadingMMTN::_internal_has_totvarh() const {
  return this != internal_default_instance() && _impl_.totvarh_ != nullptr;
}
inline bool ReadingMMTN::has_totvarh() const {
  return _internal_has_totvarh();
}
inline void ReadingMMTN::clear_totvarh() {
  if (GetArenaForAllocation() == nullptr && _impl_.totvarh_ != nullptr) {
    delete _impl_.totvarh_;
  }
  _impl_.totvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_totvarh() const {
  const ::commonmodule::BCR* p = _impl_.totvarh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::totvarh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.TotVArh)
  return _internal_totvarh();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_totvarh(
    ::commonmodule::BCR* totvarh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.totvarh_);
  }
  _impl_.totvarh_ = totvarh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.TotVArh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_totvarh() {
  
  ::commonmodule::BCR* temp = _impl_.totvarh_;
  _impl_.totvarh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_totvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.TotVArh)
  
  ::commonmodule::BCR* temp = _impl_.totvarh_;
  _impl_.totvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_totvarh() {
  
  if (_impl_.totvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.totvarh_ = p;
  }
  return _impl_.totvarh_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_totvarh() {
  ::commonmodule::BCR* _msg = _internal_mutable_totvarh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.TotVArh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_totvarh(::commonmodule::BCR* totvarh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.totvarh_;
  }
  if (totvarh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(totvarh);
    if (message_arena != submessage_arena) {
      totvarh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totvarh, submessage_arena);
    }

  } else {

  }
  _impl_.totvarh_ = totvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.TotVArh)
}

// .commonmodule.BCR TotWh = 10;
inline bool ReadingMMTN::_internal_has_totwh() const {
  return this != internal_default_instance() && _impl_.totwh_ != nullptr;
}
inline bool ReadingMMTN::has_totwh() const {
  return _internal_has_totwh();
}
inline void ReadingMMTN::clear_totwh() {
  if (GetArenaForAllocation() == nullptr && _impl_.totwh_ != nullptr) {
    delete _impl_.totwh_;
  }
  _impl_.totwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTN::_internal_totwh() const {
  const ::commonmodule::BCR* p = _impl_.totwh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTN::totwh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTN.TotWh)
  return _internal_totwh();
}
inline void ReadingMMTN::unsafe_arena_set_allocated_totwh(
    ::commonmodule::BCR* totwh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.totwh_);
  }
  _impl_.totwh_ = totwh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTN.TotWh)
}
inline ::commonmodule::BCR* ReadingMMTN::release_totwh() {
  
  ::commonmodule::BCR* temp = _impl_.totwh_;
  _impl_.totwh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::unsafe_arena_release_totwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTN.TotWh)
  
  ::commonmodule::BCR* temp = _impl_.totwh_;
  _impl_.totwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTN::_internal_mutable_totwh() {
  
  if (_impl_.totwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.totwh_ = p;
  }
  return _impl_.totwh_;
}
inline ::commonmodule::BCR* ReadingMMTN::mutable_totwh() {
  ::commonmodule::BCR* _msg = _internal_mutable_totwh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTN.TotWh)
  return _msg;
}
inline void ReadingMMTN::set_allocated_totwh(::commonmodule::BCR* totwh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.totwh_;
  }
  if (totwh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(totwh);
    if (message_arena != submessage_arena) {
      totwh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totwh, submessage_arena);
    }

  } else {

  }
  _impl_.totwh_ = totwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTN.TotWh)
}

// -------------------------------------------------------------------

// PhaseMMTN

// .commonmodule.ReadingMMTN phsA = 1;
inline bool PhaseMMTN::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseMMTN::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseMMTN::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::_internal_phsa() const {
  const ::commonmodule::ReadingMMTN* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTN&>(
      ::commonmodule::_ReadingMMTN_default_instance_);
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsA)
  return _internal_phsa();
}
inline void PhaseMMTN::unsafe_arena_set_allocated_phsa(
    ::commonmodule::ReadingMMTN* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseMMTN.phsA)
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsa() {
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsA)
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsa() {
  ::commonmodule::ReadingMMTN* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsA)
  return _msg;
}
inline void PhaseMMTN::set_allocated_phsa(::commonmodule::ReadingMMTN* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsA)
}

// .commonmodule.ReadingMMTN phsAB = 2;
inline bool PhaseMMTN::_internal_has_phsab() const {
  return this != internal_default_instance() && _impl_.phsab_ != nullptr;
}
inline bool PhaseMMTN::has_phsab() const {
  return _internal_has_phsab();
}
inline void PhaseMMTN::clear_phsab() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsab_ != nullptr) {
    delete _impl_.phsab_;
  }
  _impl_.phsab_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::_internal_phsab() const {
  const ::commonmodule::ReadingMMTN* p = _impl_.phsab_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTN&>(
      ::commonmodule::_ReadingMMTN_default_instance_);
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsab() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsAB)
  return _internal_phsab();
}
inline void PhaseMMTN::unsafe_arena_set_allocated_phsab(
    ::commonmodule::ReadingMMTN* phsab) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsab_);
  }
  _impl_.phsab_ = phsab;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseMMTN.phsAB)
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsab() {
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsab_;
  _impl_.phsab_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::unsafe_arena_release_phsab() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsAB)
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsab_;
  _impl_.phsab_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::_internal_mutable_phsab() {
  
  if (_impl_.phsab_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaForAllocation());
    _impl_.phsab_ = p;
  }
  return _impl_.phsab_;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsab() {
  ::commonmodule::ReadingMMTN* _msg = _internal_mutable_phsab();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsAB)
  return _msg;
}
inline void PhaseMMTN::set_allocated_phsab(::commonmodule::ReadingMMTN* phsab) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsab_;
  }
  if (phsab) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsab);
    if (message_arena != submessage_arena) {
      phsab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsab, submessage_arena);
    }

  } else {

  }
  _impl_.phsab_ = phsab;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsAB)
}

// .commonmodule.ReadingMMTN phsB = 3;
inline bool PhaseMMTN::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseMMTN::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseMMTN::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::_internal_phsb() const {
  const ::commonmodule::ReadingMMTN* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTN&>(
      ::commonmodule::_ReadingMMTN_default_instance_);
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsB)
  return _internal_phsb();
}
inline void PhaseMMTN::unsafe_arena_set_allocated_phsb(
    ::commonmodule::ReadingMMTN* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseMMTN.phsB)
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsb() {
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsB)
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsb() {
  ::commonmodule::ReadingMMTN* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsB)
  return _msg;
}
inline void PhaseMMTN::set_allocated_phsb(::commonmodule::ReadingMMTN* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsB)
}

// .commonmodule.ReadingMMTN phsBC = 4;
inline bool PhaseMMTN::_internal_has_phsbc() const {
  return this != internal_default_instance() && _impl_.phsbc_ != nullptr;
}
inline bool PhaseMMTN::has_phsbc() const {
  return _internal_has_phsbc();
}
inline void PhaseMMTN::clear_phsbc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsbc_ != nullptr) {
    delete _impl_.phsbc_;
  }
  _impl_.phsbc_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::_internal_phsbc() const {
  const ::commonmodule::ReadingMMTN* p = _impl_.phsbc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTN&>(
      ::commonmodule::_ReadingMMTN_default_instance_);
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsbc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsBC)
  return _internal_phsbc();
}
inline void PhaseMMTN::unsafe_arena_set_allocated_phsbc(
    ::commonmodule::ReadingMMTN* phsbc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsbc_);
  }
  _impl_.phsbc_ = phsbc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseMMTN.phsBC)
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsbc() {
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsbc_;
  _impl_.phsbc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::unsafe_arena_release_phsbc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsBC)
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsbc_;
  _impl_.phsbc_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::_internal_mutable_phsbc() {
  
  if (_impl_.phsbc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaForAllocation());
    _impl_.phsbc_ = p;
  }
  return _impl_.phsbc_;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsbc() {
  ::commonmodule::ReadingMMTN* _msg = _internal_mutable_phsbc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsBC)
  return _msg;
}
inline void PhaseMMTN::set_allocated_phsbc(::commonmodule::ReadingMMTN* phsbc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsbc_;
  }
  if (phsbc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsbc);
    if (message_arena != submessage_arena) {
      phsbc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsbc, submessage_arena);
    }

  } else {

  }
  _impl_.phsbc_ = phsbc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsBC)
}

// .commonmodule.ReadingMMTN phsC = 5;
inline bool PhaseMMTN::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseMMTN::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseMMTN::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::_internal_phsc() const {
  const ::commonmodule::ReadingMMTN* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTN&>(
      ::commonmodule::_ReadingMMTN_default_instance_);
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsC)
  return _internal_phsc();
}
inline void PhaseMMTN::unsafe_arena_set_allocated_phsc(
    ::commonmodule::ReadingMMTN* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseMMTN.phsC)
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsc() {
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsC)
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsc() {
  ::commonmodule::ReadingMMTN* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsC)
  return _msg;
}
inline void PhaseMMTN::set_allocated_phsc(::commonmodule::ReadingMMTN* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsC)
}

// .commonmodule.ReadingMMTN phsCA = 6;
inline bool PhaseMMTN::_internal_has_phsca() const {
  return this != internal_default_instance() && _impl_.phsca_ != nullptr;
}
inline bool PhaseMMTN::has_phsca() const {
  return _internal_has_phsca();
}
inline void PhaseMMTN::clear_phsca() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsca_ != nullptr) {
    delete _impl_.phsca_;
  }
  _impl_.phsca_ = nullptr;
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::_internal_phsca() const {
  const ::commonmodule::ReadingMMTN* p = _impl_.phsca_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTN&>(
      ::commonmodule::_ReadingMMTN_default_instance_);
}
inline const ::commonmodule::ReadingMMTN& PhaseMMTN::phsca() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseMMTN.phsCA)
  return _internal_phsca();
}
inline void PhaseMMTN::unsafe_arena_set_allocated_phsca(
    ::commonmodule::ReadingMMTN* phsca) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsca_);
  }
  _impl_.phsca_ = phsca;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseMMTN.phsCA)
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::release_phsca() {
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsca_;
  _impl_.phsca_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::unsafe_arena_release_phsca() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseMMTN.phsCA)
  
  ::commonmodule::ReadingMMTN* temp = _impl_.phsca_;
  _impl_.phsca_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::_internal_mutable_phsca() {
  
  if (_impl_.phsca_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTN>(GetArenaForAllocation());
    _impl_.phsca_ = p;
  }
  return _impl_.phsca_;
}
inline ::commonmodule::ReadingMMTN* PhaseMMTN::mutable_phsca() {
  ::commonmodule::ReadingMMTN* _msg = _internal_mutable_phsca();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseMMTN.phsCA)
  return _msg;
}
inline void PhaseMMTN::set_allocated_phsca(::commonmodule::ReadingMMTN* phsca) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsca_;
  }
  if (phsca) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsca);
    if (message_arena != submessage_arena) {
      phsca = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsca, submessage_arena);
    }

  } else {

  }
  _impl_.phsca_ = phsca;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseMMTN.phsCA)
}

// -------------------------------------------------------------------

// Optional_RecloseActionKind

// .commonmodule.RecloseActionKind value = 1;
inline void Optional_RecloseActionKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::RecloseActionKind Optional_RecloseActionKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_RecloseActionKind.value)
  return _internal_value();
}
inline void Optional_RecloseActionKind::set_value(::commonmodule::RecloseActionKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_RecloseActionKind.value)
}
inline ::commonmodule::RecloseActionKind Optional_RecloseActionKind::_internal_value() const {
  return static_cast<::commonmodule::RecloseActionKind>(_impl_.value_);
}
inline void Optional_RecloseActionKind::_internal_set_value(::commonmodule::RecloseActionKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// PhaseRecloseAction

// .commonmodule.Optional_RecloseActionKind phs3 = 1;
inline bool PhaseRecloseAction::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseRecloseAction::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseRecloseAction::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::_internal_phs3() const {
  const ::commonmodule::Optional_RecloseActionKind* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_RecloseActionKind&>(
      ::commonmodule::_Optional_RecloseActionKind_default_instance_);
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseRecloseAction.phs3)
  return _internal_phs3();
}
inline void PhaseRecloseAction::unsafe_arena_set_allocated_phs3(
    ::commonmodule::Optional_RecloseActionKind* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseRecloseAction.phs3)
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::release_phs3() {
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseRecloseAction.phs3)
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_RecloseActionKind>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::mutable_phs3() {
  ::commonmodule::Optional_RecloseActionKind* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseRecloseAction.phs3)
  return _msg;
}
inline void PhaseRecloseAction::set_allocated_phs3(::commonmodule::Optional_RecloseActionKind* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseRecloseAction.phs3)
}

// .commonmodule.Optional_RecloseActionKind phsA = 2;
inline bool PhaseRecloseAction::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseRecloseAction::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseRecloseAction::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::_internal_phsa() const {
  const ::commonmodule::Optional_RecloseActionKind* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_RecloseActionKind&>(
      ::commonmodule::_Optional_RecloseActionKind_default_instance_);
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseRecloseAction.phsA)
  return _internal_phsa();
}
inline void PhaseRecloseAction::unsafe_arena_set_allocated_phsa(
    ::commonmodule::Optional_RecloseActionKind* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseRecloseAction.phsA)
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::release_phsa() {
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseRecloseAction.phsA)
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_RecloseActionKind>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::mutable_phsa() {
  ::commonmodule::Optional_RecloseActionKind* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseRecloseAction.phsA)
  return _msg;
}
inline void PhaseRecloseAction::set_allocated_phsa(::commonmodule::Optional_RecloseActionKind* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseRecloseAction.phsA)
}

// .commonmodule.Optional_RecloseActionKind phsB = 3;
inline bool PhaseRecloseAction::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseRecloseAction::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseRecloseAction::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::_internal_phsb() const {
  const ::commonmodule::Optional_RecloseActionKind* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_RecloseActionKind&>(
      ::commonmodule::_Optional_RecloseActionKind_default_instance_);
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseRecloseAction.phsB)
  return _internal_phsb();
}
inline void PhaseRecloseAction::unsafe_arena_set_allocated_phsb(
    ::commonmodule::Optional_RecloseActionKind* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseRecloseAction.phsB)
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::release_phsb() {
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseRecloseAction.phsB)
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_RecloseActionKind>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::mutable_phsb() {
  ::commonmodule::Optional_RecloseActionKind* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseRecloseAction.phsB)
  return _msg;
}
inline void PhaseRecloseAction::set_allocated_phsb(::commonmodule::Optional_RecloseActionKind* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseRecloseAction.phsB)
}

// .commonmodule.Optional_RecloseActionKind phsC = 4;
inline bool PhaseRecloseAction::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseRecloseAction::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseRecloseAction::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::_internal_phsc() const {
  const ::commonmodule::Optional_RecloseActionKind* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_RecloseActionKind&>(
      ::commonmodule::_Optional_RecloseActionKind_default_instance_);
}
inline const ::commonmodule::Optional_RecloseActionKind& PhaseRecloseAction::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseRecloseAction.phsC)
  return _internal_phsc();
}
inline void PhaseRecloseAction::unsafe_arena_set_allocated_phsc(
    ::commonmodule::Optional_RecloseActionKind* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseRecloseAction.phsC)
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::release_phsc() {
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseRecloseAction.phsC)
  
  ::commonmodule::Optional_RecloseActionKind* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_RecloseActionKind>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::Optional_RecloseActionKind* PhaseRecloseAction::mutable_phsc() {
  ::commonmodule::Optional_RecloseActionKind* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseRecloseAction.phsC)
  return _msg;
}
inline void PhaseRecloseAction::set_allocated_phsc(::commonmodule::Optional_RecloseActionKind* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseRecloseAction.phsC)
}

// -------------------------------------------------------------------

// PhaseSPC

// .commonmodule.ControlSPC phs3 = 1;
inline bool PhaseSPC::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseSPC::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseSPC::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::ControlSPC& PhaseSPC::_internal_phs3() const {
  const ::commonmodule::ControlSPC* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& PhaseSPC::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPC.phs3)
  return _internal_phs3();
}
inline void PhaseSPC::unsafe_arena_set_allocated_phs3(
    ::commonmodule::ControlSPC* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPC.phs3)
}
inline ::commonmodule::ControlSPC* PhaseSPC::release_phs3() {
  
  ::commonmodule::ControlSPC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPC.phs3)
  
  ::commonmodule::ControlSPC* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::ControlSPC* PhaseSPC::mutable_phs3() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPC.phs3)
  return _msg;
}
inline void PhaseSPC::set_allocated_phs3(::commonmodule::ControlSPC* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPC.phs3)
}

// .commonmodule.ControlSPC phsA = 2;
inline bool PhaseSPC::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseSPC::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseSPC::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::ControlSPC& PhaseSPC::_internal_phsa() const {
  const ::commonmodule::ControlSPC* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& PhaseSPC::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPC.phsA)
  return _internal_phsa();
}
inline void PhaseSPC::unsafe_arena_set_allocated_phsa(
    ::commonmodule::ControlSPC* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPC.phsA)
}
inline ::commonmodule::ControlSPC* PhaseSPC::release_phsa() {
  
  ::commonmodule::ControlSPC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPC.phsA)
  
  ::commonmodule::ControlSPC* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::ControlSPC* PhaseSPC::mutable_phsa() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPC.phsA)
  return _msg;
}
inline void PhaseSPC::set_allocated_phsa(::commonmodule::ControlSPC* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPC.phsA)
}

// .commonmodule.ControlSPC phsB = 3;
inline bool PhaseSPC::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseSPC::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseSPC::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::ControlSPC& PhaseSPC::_internal_phsb() const {
  const ::commonmodule::ControlSPC* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& PhaseSPC::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPC.phsB)
  return _internal_phsb();
}
inline void PhaseSPC::unsafe_arena_set_allocated_phsb(
    ::commonmodule::ControlSPC* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPC.phsB)
}
inline ::commonmodule::ControlSPC* PhaseSPC::release_phsb() {
  
  ::commonmodule::ControlSPC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPC.phsB)
  
  ::commonmodule::ControlSPC* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::ControlSPC* PhaseSPC::mutable_phsb() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPC.phsB)
  return _msg;
}
inline void PhaseSPC::set_allocated_phsb(::commonmodule::ControlSPC* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPC.phsB)
}

// .commonmodule.ControlSPC phsC = 4;
inline bool PhaseSPC::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseSPC::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseSPC::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::ControlSPC& PhaseSPC::_internal_phsc() const {
  const ::commonmodule::ControlSPC* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& PhaseSPC::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPC.phsC)
  return _internal_phsc();
}
inline void PhaseSPC::unsafe_arena_set_allocated_phsc(
    ::commonmodule::ControlSPC* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPC.phsC)
}
inline ::commonmodule::ControlSPC* PhaseSPC::release_phsc() {
  
  ::commonmodule::ControlSPC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPC.phsC)
  
  ::commonmodule::ControlSPC* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* PhaseSPC::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::ControlSPC* PhaseSPC::mutable_phsc() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPC.phsC)
  return _msg;
}
inline void PhaseSPC::set_allocated_phsc(::commonmodule::ControlSPC* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPC.phsC)
}

// -------------------------------------------------------------------

// PhaseSPS

// .commonmodule.StatusSPS phs3 = 1;
inline bool PhaseSPS::_internal_has_phs3() const {
  return this != internal_default_instance() && _impl_.phs3_ != nullptr;
}
inline bool PhaseSPS::has_phs3() const {
  return _internal_has_phs3();
}
inline void PhaseSPS::clear_phs3() {
  if (GetArenaForAllocation() == nullptr && _impl_.phs3_ != nullptr) {
    delete _impl_.phs3_;
  }
  _impl_.phs3_ = nullptr;
}
inline const ::commonmodule::StatusSPS& PhaseSPS::_internal_phs3() const {
  const ::commonmodule::StatusSPS* p = _impl_.phs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& PhaseSPS::phs3() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPS.phs3)
  return _internal_phs3();
}
inline void PhaseSPS::unsafe_arena_set_allocated_phs3(
    ::commonmodule::StatusSPS* phs3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phs3_);
  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPS.phs3)
}
inline ::commonmodule::StatusSPS* PhaseSPS::release_phs3() {
  
  ::commonmodule::StatusSPS* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::unsafe_arena_release_phs3() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPS.phs3)
  
  ::commonmodule::StatusSPS* temp = _impl_.phs3_;
  _impl_.phs3_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::_internal_mutable_phs3() {
  
  if (_impl_.phs3_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.phs3_ = p;
  }
  return _impl_.phs3_;
}
inline ::commonmodule::StatusSPS* PhaseSPS::mutable_phs3() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_phs3();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPS.phs3)
  return _msg;
}
inline void PhaseSPS::set_allocated_phs3(::commonmodule::StatusSPS* phs3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phs3_;
  }
  if (phs3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phs3);
    if (message_arena != submessage_arena) {
      phs3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phs3, submessage_arena);
    }

  } else {

  }
  _impl_.phs3_ = phs3;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPS.phs3)
}

// .commonmodule.StatusSPS phsA = 2;
inline bool PhaseSPS::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PhaseSPS::has_phsa() const {
  return _internal_has_phsa();
}
inline void PhaseSPS::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::StatusSPS& PhaseSPS::_internal_phsa() const {
  const ::commonmodule::StatusSPS* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& PhaseSPS::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPS.phsA)
  return _internal_phsa();
}
inline void PhaseSPS::unsafe_arena_set_allocated_phsa(
    ::commonmodule::StatusSPS* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPS.phsA)
}
inline ::commonmodule::StatusSPS* PhaseSPS::release_phsa() {
  
  ::commonmodule::StatusSPS* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPS.phsA)
  
  ::commonmodule::StatusSPS* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::StatusSPS* PhaseSPS::mutable_phsa() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPS.phsA)
  return _msg;
}
inline void PhaseSPS::set_allocated_phsa(::commonmodule::StatusSPS* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPS.phsA)
}

// .commonmodule.StatusSPS phsB = 3;
inline bool PhaseSPS::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PhaseSPS::has_phsb() const {
  return _internal_has_phsb();
}
inline void PhaseSPS::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::StatusSPS& PhaseSPS::_internal_phsb() const {
  const ::commonmodule::StatusSPS* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& PhaseSPS::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPS.phsB)
  return _internal_phsb();
}
inline void PhaseSPS::unsafe_arena_set_allocated_phsb(
    ::commonmodule::StatusSPS* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPS.phsB)
}
inline ::commonmodule::StatusSPS* PhaseSPS::release_phsb() {
  
  ::commonmodule::StatusSPS* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPS.phsB)
  
  ::commonmodule::StatusSPS* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::StatusSPS* PhaseSPS::mutable_phsb() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPS.phsB)
  return _msg;
}
inline void PhaseSPS::set_allocated_phsb(::commonmodule::StatusSPS* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPS.phsB)
}

// .commonmodule.StatusSPS phsC = 4;
inline bool PhaseSPS::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PhaseSPS::has_phsc() const {
  return _internal_has_phsc();
}
inline void PhaseSPS::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::StatusSPS& PhaseSPS::_internal_phsc() const {
  const ::commonmodule::StatusSPS* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& PhaseSPS::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PhaseSPS.phsC)
  return _internal_phsc();
}
inline void PhaseSPS::unsafe_arena_set_allocated_phsc(
    ::commonmodule::StatusSPS* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PhaseSPS.phsC)
}
inline ::commonmodule::StatusSPS* PhaseSPS::release_phsc() {
  
  ::commonmodule::StatusSPS* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PhaseSPS.phsC)
  
  ::commonmodule::StatusSPS* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PhaseSPS::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::StatusSPS* PhaseSPS::mutable_phsc() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PhaseSPS.phsC)
  return _msg;
}
inline void PhaseSPS::set_allocated_phsc(::commonmodule::StatusSPS* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PhaseSPS.phsC)
}

// -------------------------------------------------------------------

// PMG

// .commonmodule.MV net = 1;
inline bool PMG::_internal_has_net() const {
  return this != internal_default_instance() && _impl_.net_ != nullptr;
}
inline bool PMG::has_net() const {
  return _internal_has_net();
}
inline void PMG::clear_net() {
  if (GetArenaForAllocation() == nullptr && _impl_.net_ != nullptr) {
    delete _impl_.net_;
  }
  _impl_.net_ = nullptr;
}
inline const ::commonmodule::MV& PMG::_internal_net() const {
  const ::commonmodule::MV* p = _impl_.net_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& PMG::net() const {
  // @@protoc_insertion_point(field_get:commonmodule.PMG.net)
  return _internal_net();
}
inline void PMG::unsafe_arena_set_allocated_net(
    ::commonmodule::MV* net) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.net_);
  }
  _impl_.net_ = net;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PMG.net)
}
inline ::commonmodule::MV* PMG::release_net() {
  
  ::commonmodule::MV* temp = _impl_.net_;
  _impl_.net_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* PMG::unsafe_arena_release_net() {
  // @@protoc_insertion_point(field_release:commonmodule.PMG.net)
  
  ::commonmodule::MV* temp = _impl_.net_;
  _impl_.net_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PMG::_internal_mutable_net() {
  
  if (_impl_.net_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.net_ = p;
  }
  return _impl_.net_;
}
inline ::commonmodule::MV* PMG::mutable_net() {
  ::commonmodule::MV* _msg = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:commonmodule.PMG.net)
  return _msg;
}
inline void PMG::set_allocated_net(::commonmodule::MV* net) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.net_;
  }
  if (net) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(net);
    if (message_arena != submessage_arena) {
      net = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, net, submessage_arena);
    }

  } else {

  }
  _impl_.net_ = net;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PMG.net)
}

// .commonmodule.MV phsA = 2;
inline bool PMG::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool PMG::has_phsa() const {
  return _internal_has_phsa();
}
inline void PMG::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::MV& PMG::_internal_phsa() const {
  const ::commonmodule::MV* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& PMG::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.PMG.phsA)
  return _internal_phsa();
}
inline void PMG::unsafe_arena_set_allocated_phsa(
    ::commonmodule::MV* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PMG.phsA)
}
inline ::commonmodule::MV* PMG::release_phsa() {
  
  ::commonmodule::MV* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* PMG::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.PMG.phsA)
  
  ::commonmodule::MV* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PMG::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::MV* PMG::mutable_phsa() {
  ::commonmodule::MV* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.PMG.phsA)
  return _msg;
}
inline void PMG::set_allocated_phsa(::commonmodule::MV* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PMG.phsA)
}

// .commonmodule.MV phsB = 3;
inline bool PMG::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool PMG::has_phsb() const {
  return _internal_has_phsb();
}
inline void PMG::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::MV& PMG::_internal_phsb() const {
  const ::commonmodule::MV* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& PMG::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.PMG.phsB)
  return _internal_phsb();
}
inline void PMG::unsafe_arena_set_allocated_phsb(
    ::commonmodule::MV* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PMG.phsB)
}
inline ::commonmodule::MV* PMG::release_phsb() {
  
  ::commonmodule::MV* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* PMG::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.PMG.phsB)
  
  ::commonmodule::MV* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PMG::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::MV* PMG::mutable_phsb() {
  ::commonmodule::MV* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.PMG.phsB)
  return _msg;
}
inline void PMG::set_allocated_phsb(::commonmodule::MV* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PMG.phsB)
}

// .commonmodule.MV phsC = 4;
inline bool PMG::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool PMG::has_phsc() const {
  return _internal_has_phsc();
}
inline void PMG::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::MV& PMG::_internal_phsc() const {
  const ::commonmodule::MV* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& PMG::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.PMG.phsC)
  return _internal_phsc();
}
inline void PMG::unsafe_arena_set_allocated_phsc(
    ::commonmodule::MV* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.PMG.phsC)
}
inline ::commonmodule::MV* PMG::release_phsc() {
  
  ::commonmodule::MV* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* PMG::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.PMG.phsC)
  
  ::commonmodule::MV* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PMG::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::MV* PMG::mutable_phsc() {
  ::commonmodule::MV* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.PMG.phsC)
  return _msg;
}
inline void PMG::set_allocated_phsc(::commonmodule::MV* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.PMG.phsC)
}

// -------------------------------------------------------------------

// RampRate

// .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;
inline bool RampRate::_internal_has_negativereactivepowerkvarpermin() const {
  return this != internal_default_instance() && _impl_.negativereactivepowerkvarpermin_ != nullptr;
}
inline bool RampRate::has_negativereactivepowerkvarpermin() const {
  return _internal_has_negativereactivepowerkvarpermin();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::_internal_negativereactivepowerkvarpermin() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.negativereactivepowerkvarpermin_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::negativereactivepowerkvarpermin() const {
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
  return _internal_negativereactivepowerkvarpermin();
}
inline void RampRate::unsafe_arena_set_allocated_negativereactivepowerkvarpermin(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* negativereactivepowerkvarpermin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.negativereactivepowerkvarpermin_);
  }
  _impl_.negativereactivepowerkvarpermin_ = negativereactivepowerkvarpermin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::release_negativereactivepowerkvarpermin() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.negativereactivepowerkvarpermin_;
  _impl_.negativereactivepowerkvarpermin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::unsafe_arena_release_negativereactivepowerkvarpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.negativereactivepowerkvarpermin_;
  _impl_.negativereactivepowerkvarpermin_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::_internal_mutable_negativereactivepowerkvarpermin() {
  
  if (_impl_.negativereactivepowerkvarpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.negativereactivepowerkvarpermin_ = p;
  }
  return _impl_.negativereactivepowerkvarpermin_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::mutable_negativereactivepowerkvarpermin() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_negativereactivepowerkvarpermin();
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
  return _msg;
}
inline void RampRate::set_allocated_negativereactivepowerkvarpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* negativereactivepowerkvarpermin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.negativereactivepowerkvarpermin_);
  }
  if (negativereactivepowerkvarpermin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(negativereactivepowerkvarpermin));
    if (message_arena != submessage_arena) {
      negativereactivepowerkvarpermin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negativereactivepowerkvarpermin, submessage_arena);
    }

  } else {

  }
  _impl_.negativereactivepowerkvarpermin_ = negativereactivepowerkvarpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.negativeReactivePowerKVArPerMin)
}

// .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;
inline bool RampRate::_internal_has_negativerealpowerkwpermin() const {
  return this != internal_default_instance() && _impl_.negativerealpowerkwpermin_ != nullptr;
}
inline bool RampRate::has_negativerealpowerkwpermin() const {
  return _internal_has_negativerealpowerkwpermin();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::_internal_negativerealpowerkwpermin() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.negativerealpowerkwpermin_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::negativerealpowerkwpermin() const {
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.negativeRealPowerKWPerMin)
  return _internal_negativerealpowerkwpermin();
}
inline void RampRate::unsafe_arena_set_allocated_negativerealpowerkwpermin(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* negativerealpowerkwpermin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.negativerealpowerkwpermin_);
  }
  _impl_.negativerealpowerkwpermin_ = negativerealpowerkwpermin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.RampRate.negativeRealPowerKWPerMin)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::release_negativerealpowerkwpermin() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.negativerealpowerkwpermin_;
  _impl_.negativerealpowerkwpermin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::unsafe_arena_release_negativerealpowerkwpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.negativeRealPowerKWPerMin)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.negativerealpowerkwpermin_;
  _impl_.negativerealpowerkwpermin_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::_internal_mutable_negativerealpowerkwpermin() {
  
  if (_impl_.negativerealpowerkwpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.negativerealpowerkwpermin_ = p;
  }
  return _impl_.negativerealpowerkwpermin_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::mutable_negativerealpowerkwpermin() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_negativerealpowerkwpermin();
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.negativeRealPowerKWPerMin)
  return _msg;
}
inline void RampRate::set_allocated_negativerealpowerkwpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* negativerealpowerkwpermin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.negativerealpowerkwpermin_);
  }
  if (negativerealpowerkwpermin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(negativerealpowerkwpermin));
    if (message_arena != submessage_arena) {
      negativerealpowerkwpermin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negativerealpowerkwpermin, submessage_arena);
    }

  } else {

  }
  _impl_.negativerealpowerkwpermin_ = negativerealpowerkwpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.negativeRealPowerKWPerMin)
}

// .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;
inline bool RampRate::_internal_has_positivereactivepowerkvarpermin() const {
  return this != internal_default_instance() && _impl_.positivereactivepowerkvarpermin_ != nullptr;
}
inline bool RampRate::has_positivereactivepowerkvarpermin() const {
  return _internal_has_positivereactivepowerkvarpermin();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::_internal_positivereactivepowerkvarpermin() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.positivereactivepowerkvarpermin_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::positivereactivepowerkvarpermin() const {
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
  return _internal_positivereactivepowerkvarpermin();
}
inline void RampRate::unsafe_arena_set_allocated_positivereactivepowerkvarpermin(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* positivereactivepowerkvarpermin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positivereactivepowerkvarpermin_);
  }
  _impl_.positivereactivepowerkvarpermin_ = positivereactivepowerkvarpermin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::release_positivereactivepowerkvarpermin() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.positivereactivepowerkvarpermin_;
  _impl_.positivereactivepowerkvarpermin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::unsafe_arena_release_positivereactivepowerkvarpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.positivereactivepowerkvarpermin_;
  _impl_.positivereactivepowerkvarpermin_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::_internal_mutable_positivereactivepowerkvarpermin() {
  
  if (_impl_.positivereactivepowerkvarpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.positivereactivepowerkvarpermin_ = p;
  }
  return _impl_.positivereactivepowerkvarpermin_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::mutable_positivereactivepowerkvarpermin() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_positivereactivepowerkvarpermin();
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
  return _msg;
}
inline void RampRate::set_allocated_positivereactivepowerkvarpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* positivereactivepowerkvarpermin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positivereactivepowerkvarpermin_);
  }
  if (positivereactivepowerkvarpermin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positivereactivepowerkvarpermin));
    if (message_arena != submessage_arena) {
      positivereactivepowerkvarpermin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positivereactivepowerkvarpermin, submessage_arena);
    }

  } else {

  }
  _impl_.positivereactivepowerkvarpermin_ = positivereactivepowerkvarpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.positiveReactivePowerKVArPerMin)
}

// .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;
inline bool RampRate::_internal_has_positiverealpowerkwpermin() const {
  return this != internal_default_instance() && _impl_.positiverealpowerkwpermin_ != nullptr;
}
inline bool RampRate::has_positiverealpowerkwpermin() const {
  return _internal_has_positiverealpowerkwpermin();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::_internal_positiverealpowerkwpermin() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.positiverealpowerkwpermin_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& RampRate::positiverealpowerkwpermin() const {
  // @@protoc_insertion_point(field_get:commonmodule.RampRate.positiveRealPowerKWPerMin)
  return _internal_positiverealpowerkwpermin();
}
inline void RampRate::unsafe_arena_set_allocated_positiverealpowerkwpermin(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* positiverealpowerkwpermin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positiverealpowerkwpermin_);
  }
  _impl_.positiverealpowerkwpermin_ = positiverealpowerkwpermin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.RampRate.positiveRealPowerKWPerMin)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::release_positiverealpowerkwpermin() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.positiverealpowerkwpermin_;
  _impl_.positiverealpowerkwpermin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::unsafe_arena_release_positiverealpowerkwpermin() {
  // @@protoc_insertion_point(field_release:commonmodule.RampRate.positiveRealPowerKWPerMin)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.positiverealpowerkwpermin_;
  _impl_.positiverealpowerkwpermin_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::_internal_mutable_positiverealpowerkwpermin() {
  
  if (_impl_.positiverealpowerkwpermin_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.positiverealpowerkwpermin_ = p;
  }
  return _impl_.positiverealpowerkwpermin_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* RampRate::mutable_positiverealpowerkwpermin() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_positiverealpowerkwpermin();
  // @@protoc_insertion_point(field_mutable:commonmodule.RampRate.positiveRealPowerKWPerMin)
  return _msg;
}
inline void RampRate::set_allocated_positiverealpowerkwpermin(::PROTOBUF_NAMESPACE_ID::FloatValue* positiverealpowerkwpermin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positiverealpowerkwpermin_);
  }
  if (positiverealpowerkwpermin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positiverealpowerkwpermin));
    if (message_arena != submessage_arena) {
      positiverealpowerkwpermin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positiverealpowerkwpermin, submessage_arena);
    }

  } else {

  }
  _impl_.positiverealpowerkwpermin_ = positiverealpowerkwpermin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.RampRate.positiveRealPowerKWPerMin)
}

// -------------------------------------------------------------------

// ReadingMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMessageInfo::_internal_has_messageinfo() const {
  return this != internal_default_instance() && _impl_.messageinfo_ != nullptr;
}
inline bool ReadingMessageInfo::has_messageinfo() const {
  return _internal_has_messageinfo();
}
inline void ReadingMessageInfo::clear_messageinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& ReadingMessageInfo::_internal_messageinfo() const {
  const ::commonmodule::MessageInfo* p = _impl_.messageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MessageInfo&>(
      ::commonmodule::_MessageInfo_default_instance_);
}
inline const ::commonmodule::MessageInfo& ReadingMessageInfo::messageinfo() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMessageInfo.messageInfo)
  return _internal_messageinfo();
}
inline void ReadingMessageInfo::unsafe_arena_set_allocated_messageinfo(
    ::commonmodule::MessageInfo* messageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageinfo_);
  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMessageInfo.messageInfo)
}
inline ::commonmodule::MessageInfo* ReadingMessageInfo::release_messageinfo() {
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MessageInfo* ReadingMessageInfo::unsafe_arena_release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* ReadingMessageInfo::_internal_mutable_messageinfo() {
  
  if (_impl_.messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaForAllocation());
    _impl_.messageinfo_ = p;
  }
  return _impl_.messageinfo_;
}
inline ::commonmodule::MessageInfo* ReadingMessageInfo::mutable_messageinfo() {
  ::commonmodule::MessageInfo* _msg = _internal_mutable_messageinfo();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMessageInfo.messageInfo)
  return _msg;
}
inline void ReadingMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messageinfo_;
  }
  if (messageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messageinfo);
    if (message_arena != submessage_arena) {
      messageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// ReadingMMTR

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMMTR::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool ReadingMMTR::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void ReadingMMTR::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& ReadingMMTR::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& ReadingMMTR::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.logicalNode)
  return _internal_logicalnode();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.logicalNode)
}
inline ::commonmodule::LogicalNode* ReadingMMTR::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMTR::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMTR::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* ReadingMMTR::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.logicalNode)
  return _msg;
}
inline void ReadingMMTR::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.logicalNode)
}

// .commonmodule.BCR DmdVAh = 2;
inline bool ReadingMMTR::_internal_has_dmdvah() const {
  return this != internal_default_instance() && _impl_.dmdvah_ != nullptr;
}
inline bool ReadingMMTR::has_dmdvah() const {
  return _internal_has_dmdvah();
}
inline void ReadingMMTR::clear_dmdvah() {
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvah_ != nullptr) {
    delete _impl_.dmdvah_;
  }
  _impl_.dmdvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_dmdvah() const {
  const ::commonmodule::BCR* p = _impl_.dmdvah_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::dmdvah() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.DmdVAh)
  return _internal_dmdvah();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_dmdvah(
    ::commonmodule::BCR* dmdvah) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dmdvah_);
  }
  _impl_.dmdvah_ = dmdvah;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.DmdVAh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_dmdvah() {
  
  ::commonmodule::BCR* temp = _impl_.dmdvah_;
  _impl_.dmdvah_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_dmdvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.DmdVAh)
  
  ::commonmodule::BCR* temp = _impl_.dmdvah_;
  _impl_.dmdvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_dmdvah() {
  
  if (_impl_.dmdvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.dmdvah_ = p;
  }
  return _impl_.dmdvah_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_dmdvah() {
  ::commonmodule::BCR* _msg = _internal_mutable_dmdvah();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.DmdVAh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_dmdvah(::commonmodule::BCR* dmdvah) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dmdvah_;
  }
  if (dmdvah) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dmdvah);
    if (message_arena != submessage_arena) {
      dmdvah = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dmdvah, submessage_arena);
    }

  } else {

  }
  _impl_.dmdvah_ = dmdvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.DmdVAh)
}

// .commonmodule.BCR DmdVArh = 3;
inline bool ReadingMMTR::_internal_has_dmdvarh() const {
  return this != internal_default_instance() && _impl_.dmdvarh_ != nullptr;
}
inline bool ReadingMMTR::has_dmdvarh() const {
  return _internal_has_dmdvarh();
}
inline void ReadingMMTR::clear_dmdvarh() {
  if (GetArenaForAllocation() == nullptr && _impl_.dmdvarh_ != nullptr) {
    delete _impl_.dmdvarh_;
  }
  _impl_.dmdvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_dmdvarh() const {
  const ::commonmodule::BCR* p = _impl_.dmdvarh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::dmdvarh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.DmdVArh)
  return _internal_dmdvarh();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_dmdvarh(
    ::commonmodule::BCR* dmdvarh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dmdvarh_);
  }
  _impl_.dmdvarh_ = dmdvarh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.DmdVArh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_dmdvarh() {
  
  ::commonmodule::BCR* temp = _impl_.dmdvarh_;
  _impl_.dmdvarh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_dmdvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.DmdVArh)
  
  ::commonmodule::BCR* temp = _impl_.dmdvarh_;
  _impl_.dmdvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_dmdvarh() {
  
  if (_impl_.dmdvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.dmdvarh_ = p;
  }
  return _impl_.dmdvarh_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_dmdvarh() {
  ::commonmodule::BCR* _msg = _internal_mutable_dmdvarh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.DmdVArh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_dmdvarh(::commonmodule::BCR* dmdvarh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dmdvarh_;
  }
  if (dmdvarh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dmdvarh);
    if (message_arena != submessage_arena) {
      dmdvarh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dmdvarh, submessage_arena);
    }

  } else {

  }
  _impl_.dmdvarh_ = dmdvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.DmdVArh)
}

// .commonmodule.BCR DmdWh = 4;
inline bool ReadingMMTR::_internal_has_dmdwh() const {
  return this != internal_default_instance() && _impl_.dmdwh_ != nullptr;
}
inline bool ReadingMMTR::has_dmdwh() const {
  return _internal_has_dmdwh();
}
inline void ReadingMMTR::clear_dmdwh() {
  if (GetArenaForAllocation() == nullptr && _impl_.dmdwh_ != nullptr) {
    delete _impl_.dmdwh_;
  }
  _impl_.dmdwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_dmdwh() const {
  const ::commonmodule::BCR* p = _impl_.dmdwh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::dmdwh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.DmdWh)
  return _internal_dmdwh();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_dmdwh(
    ::commonmodule::BCR* dmdwh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dmdwh_);
  }
  _impl_.dmdwh_ = dmdwh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.DmdWh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_dmdwh() {
  
  ::commonmodule::BCR* temp = _impl_.dmdwh_;
  _impl_.dmdwh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_dmdwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.DmdWh)
  
  ::commonmodule::BCR* temp = _impl_.dmdwh_;
  _impl_.dmdwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_dmdwh() {
  
  if (_impl_.dmdwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.dmdwh_ = p;
  }
  return _impl_.dmdwh_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_dmdwh() {
  ::commonmodule::BCR* _msg = _internal_mutable_dmdwh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.DmdWh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_dmdwh(::commonmodule::BCR* dmdwh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dmdwh_;
  }
  if (dmdwh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dmdwh);
    if (message_arena != submessage_arena) {
      dmdwh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dmdwh, submessage_arena);
    }

  } else {

  }
  _impl_.dmdwh_ = dmdwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.DmdWh)
}

// .commonmodule.BCR SupVAh = 5;
inline bool ReadingMMTR::_internal_has_supvah() const {
  return this != internal_default_instance() && _impl_.supvah_ != nullptr;
}
inline bool ReadingMMTR::has_supvah() const {
  return _internal_has_supvah();
}
inline void ReadingMMTR::clear_supvah() {
  if (GetArenaForAllocation() == nullptr && _impl_.supvah_ != nullptr) {
    delete _impl_.supvah_;
  }
  _impl_.supvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_supvah() const {
  const ::commonmodule::BCR* p = _impl_.supvah_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::supvah() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.SupVAh)
  return _internal_supvah();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_supvah(
    ::commonmodule::BCR* supvah) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supvah_);
  }
  _impl_.supvah_ = supvah;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.SupVAh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_supvah() {
  
  ::commonmodule::BCR* temp = _impl_.supvah_;
  _impl_.supvah_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_supvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.SupVAh)
  
  ::commonmodule::BCR* temp = _impl_.supvah_;
  _impl_.supvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_supvah() {
  
  if (_impl_.supvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.supvah_ = p;
  }
  return _impl_.supvah_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_supvah() {
  ::commonmodule::BCR* _msg = _internal_mutable_supvah();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.SupVAh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_supvah(::commonmodule::BCR* supvah) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supvah_;
  }
  if (supvah) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supvah);
    if (message_arena != submessage_arena) {
      supvah = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supvah, submessage_arena);
    }

  } else {

  }
  _impl_.supvah_ = supvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.SupVAh)
}

// .commonmodule.BCR SupVArh = 6;
inline bool ReadingMMTR::_internal_has_supvarh() const {
  return this != internal_default_instance() && _impl_.supvarh_ != nullptr;
}
inline bool ReadingMMTR::has_supvarh() const {
  return _internal_has_supvarh();
}
inline void ReadingMMTR::clear_supvarh() {
  if (GetArenaForAllocation() == nullptr && _impl_.supvarh_ != nullptr) {
    delete _impl_.supvarh_;
  }
  _impl_.supvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_supvarh() const {
  const ::commonmodule::BCR* p = _impl_.supvarh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::supvarh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.SupVArh)
  return _internal_supvarh();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_supvarh(
    ::commonmodule::BCR* supvarh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supvarh_);
  }
  _impl_.supvarh_ = supvarh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.SupVArh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_supvarh() {
  
  ::commonmodule::BCR* temp = _impl_.supvarh_;
  _impl_.supvarh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_supvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.SupVArh)
  
  ::commonmodule::BCR* temp = _impl_.supvarh_;
  _impl_.supvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_supvarh() {
  
  if (_impl_.supvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.supvarh_ = p;
  }
  return _impl_.supvarh_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_supvarh() {
  ::commonmodule::BCR* _msg = _internal_mutable_supvarh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.SupVArh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_supvarh(::commonmodule::BCR* supvarh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supvarh_;
  }
  if (supvarh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supvarh);
    if (message_arena != submessage_arena) {
      supvarh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supvarh, submessage_arena);
    }

  } else {

  }
  _impl_.supvarh_ = supvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.SupVArh)
}

// .commonmodule.BCR SupWh = 7;
inline bool ReadingMMTR::_internal_has_supwh() const {
  return this != internal_default_instance() && _impl_.supwh_ != nullptr;
}
inline bool ReadingMMTR::has_supwh() const {
  return _internal_has_supwh();
}
inline void ReadingMMTR::clear_supwh() {
  if (GetArenaForAllocation() == nullptr && _impl_.supwh_ != nullptr) {
    delete _impl_.supwh_;
  }
  _impl_.supwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_supwh() const {
  const ::commonmodule::BCR* p = _impl_.supwh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::supwh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.SupWh)
  return _internal_supwh();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_supwh(
    ::commonmodule::BCR* supwh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supwh_);
  }
  _impl_.supwh_ = supwh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.SupWh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_supwh() {
  
  ::commonmodule::BCR* temp = _impl_.supwh_;
  _impl_.supwh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_supwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.SupWh)
  
  ::commonmodule::BCR* temp = _impl_.supwh_;
  _impl_.supwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_supwh() {
  
  if (_impl_.supwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.supwh_ = p;
  }
  return _impl_.supwh_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_supwh() {
  ::commonmodule::BCR* _msg = _internal_mutable_supwh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.SupWh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_supwh(::commonmodule::BCR* supwh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supwh_;
  }
  if (supwh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supwh);
    if (message_arena != submessage_arena) {
      supwh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supwh, submessage_arena);
    }

  } else {

  }
  _impl_.supwh_ = supwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.SupWh)
}

// .commonmodule.BCR TotVAh = 8;
inline bool ReadingMMTR::_internal_has_totvah() const {
  return this != internal_default_instance() && _impl_.totvah_ != nullptr;
}
inline bool ReadingMMTR::has_totvah() const {
  return _internal_has_totvah();
}
inline void ReadingMMTR::clear_totvah() {
  if (GetArenaForAllocation() == nullptr && _impl_.totvah_ != nullptr) {
    delete _impl_.totvah_;
  }
  _impl_.totvah_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_totvah() const {
  const ::commonmodule::BCR* p = _impl_.totvah_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::totvah() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.TotVAh)
  return _internal_totvah();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_totvah(
    ::commonmodule::BCR* totvah) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.totvah_);
  }
  _impl_.totvah_ = totvah;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.TotVAh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_totvah() {
  
  ::commonmodule::BCR* temp = _impl_.totvah_;
  _impl_.totvah_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_totvah() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.TotVAh)
  
  ::commonmodule::BCR* temp = _impl_.totvah_;
  _impl_.totvah_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_totvah() {
  
  if (_impl_.totvah_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.totvah_ = p;
  }
  return _impl_.totvah_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_totvah() {
  ::commonmodule::BCR* _msg = _internal_mutable_totvah();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.TotVAh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_totvah(::commonmodule::BCR* totvah) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.totvah_;
  }
  if (totvah) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(totvah);
    if (message_arena != submessage_arena) {
      totvah = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totvah, submessage_arena);
    }

  } else {

  }
  _impl_.totvah_ = totvah;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.TotVAh)
}

// .commonmodule.BCR TotVArh = 9;
inline bool ReadingMMTR::_internal_has_totvarh() const {
  return this != internal_default_instance() && _impl_.totvarh_ != nullptr;
}
inline bool ReadingMMTR::has_totvarh() const {
  return _internal_has_totvarh();
}
inline void ReadingMMTR::clear_totvarh() {
  if (GetArenaForAllocation() == nullptr && _impl_.totvarh_ != nullptr) {
    delete _impl_.totvarh_;
  }
  _impl_.totvarh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_totvarh() const {
  const ::commonmodule::BCR* p = _impl_.totvarh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::totvarh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.TotVArh)
  return _internal_totvarh();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_totvarh(
    ::commonmodule::BCR* totvarh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.totvarh_);
  }
  _impl_.totvarh_ = totvarh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.TotVArh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_totvarh() {
  
  ::commonmodule::BCR* temp = _impl_.totvarh_;
  _impl_.totvarh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_totvarh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.TotVArh)
  
  ::commonmodule::BCR* temp = _impl_.totvarh_;
  _impl_.totvarh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_totvarh() {
  
  if (_impl_.totvarh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.totvarh_ = p;
  }
  return _impl_.totvarh_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_totvarh() {
  ::commonmodule::BCR* _msg = _internal_mutable_totvarh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.TotVArh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_totvarh(::commonmodule::BCR* totvarh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.totvarh_;
  }
  if (totvarh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(totvarh);
    if (message_arena != submessage_arena) {
      totvarh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totvarh, submessage_arena);
    }

  } else {

  }
  _impl_.totvarh_ = totvarh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.TotVArh)
}

// .commonmodule.BCR TotWh = 10;
inline bool ReadingMMTR::_internal_has_totwh() const {
  return this != internal_default_instance() && _impl_.totwh_ != nullptr;
}
inline bool ReadingMMTR::has_totwh() const {
  return _internal_has_totwh();
}
inline void ReadingMMTR::clear_totwh() {
  if (GetArenaForAllocation() == nullptr && _impl_.totwh_ != nullptr) {
    delete _impl_.totwh_;
  }
  _impl_.totwh_ = nullptr;
}
inline const ::commonmodule::BCR& ReadingMMTR::_internal_totwh() const {
  const ::commonmodule::BCR* p = _impl_.totwh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::BCR&>(
      ::commonmodule::_BCR_default_instance_);
}
inline const ::commonmodule::BCR& ReadingMMTR::totwh() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMTR.TotWh)
  return _internal_totwh();
}
inline void ReadingMMTR::unsafe_arena_set_allocated_totwh(
    ::commonmodule::BCR* totwh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.totwh_);
  }
  _impl_.totwh_ = totwh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMTR.TotWh)
}
inline ::commonmodule::BCR* ReadingMMTR::release_totwh() {
  
  ::commonmodule::BCR* temp = _impl_.totwh_;
  _impl_.totwh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::unsafe_arena_release_totwh() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMTR.TotWh)
  
  ::commonmodule::BCR* temp = _impl_.totwh_;
  _impl_.totwh_ = nullptr;
  return temp;
}
inline ::commonmodule::BCR* ReadingMMTR::_internal_mutable_totwh() {
  
  if (_impl_.totwh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::BCR>(GetArenaForAllocation());
    _impl_.totwh_ = p;
  }
  return _impl_.totwh_;
}
inline ::commonmodule::BCR* ReadingMMTR::mutable_totwh() {
  ::commonmodule::BCR* _msg = _internal_mutable_totwh();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMTR.TotWh)
  return _msg;
}
inline void ReadingMMTR::set_allocated_totwh(::commonmodule::BCR* totwh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.totwh_;
  }
  if (totwh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(totwh);
    if (message_arena != submessage_arena) {
      totwh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totwh, submessage_arena);
    }

  } else {

  }
  _impl_.totwh_ = totwh;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMTR.TotWh)
}

// -------------------------------------------------------------------

// WYE

// .commonmodule.CMV net = 1;
inline bool WYE::_internal_has_net() const {
  return this != internal_default_instance() && _impl_.net_ != nullptr;
}
inline bool WYE::has_net() const {
  return _internal_has_net();
}
inline void WYE::clear_net() {
  if (GetArenaForAllocation() == nullptr && _impl_.net_ != nullptr) {
    delete _impl_.net_;
  }
  _impl_.net_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::_internal_net() const {
  const ::commonmodule::CMV* p = _impl_.net_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& WYE::net() const {
  // @@protoc_insertion_point(field_get:commonmodule.WYE.net)
  return _internal_net();
}
inline void WYE::unsafe_arena_set_allocated_net(
    ::commonmodule::CMV* net) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.net_);
  }
  _impl_.net_ = net;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WYE.net)
}
inline ::commonmodule::CMV* WYE::release_net() {
  
  ::commonmodule::CMV* temp = _impl_.net_;
  _impl_.net_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* WYE::unsafe_arena_release_net() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.net)
  
  ::commonmodule::CMV* temp = _impl_.net_;
  _impl_.net_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::_internal_mutable_net() {
  
  if (_impl_.net_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.net_ = p;
  }
  return _impl_.net_;
}
inline ::commonmodule::CMV* WYE::mutable_net() {
  ::commonmodule::CMV* _msg = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.net)
  return _msg;
}
inline void WYE::set_allocated_net(::commonmodule::CMV* net) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.net_;
  }
  if (net) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(net);
    if (message_arena != submessage_arena) {
      net = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, net, submessage_arena);
    }

  } else {

  }
  _impl_.net_ = net;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.net)
}

// .commonmodule.CMV neut = 2;
inline bool WYE::_internal_has_neut() const {
  return this != internal_default_instance() && _impl_.neut_ != nullptr;
}
inline bool WYE::has_neut() const {
  return _internal_has_neut();
}
inline void WYE::clear_neut() {
  if (GetArenaForAllocation() == nullptr && _impl_.neut_ != nullptr) {
    delete _impl_.neut_;
  }
  _impl_.neut_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::_internal_neut() const {
  const ::commonmodule::CMV* p = _impl_.neut_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& WYE::neut() const {
  // @@protoc_insertion_point(field_get:commonmodule.WYE.neut)
  return _internal_neut();
}
inline void WYE::unsafe_arena_set_allocated_neut(
    ::commonmodule::CMV* neut) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.neut_);
  }
  _impl_.neut_ = neut;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WYE.neut)
}
inline ::commonmodule::CMV* WYE::release_neut() {
  
  ::commonmodule::CMV* temp = _impl_.neut_;
  _impl_.neut_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* WYE::unsafe_arena_release_neut() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.neut)
  
  ::commonmodule::CMV* temp = _impl_.neut_;
  _impl_.neut_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::_internal_mutable_neut() {
  
  if (_impl_.neut_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.neut_ = p;
  }
  return _impl_.neut_;
}
inline ::commonmodule::CMV* WYE::mutable_neut() {
  ::commonmodule::CMV* _msg = _internal_mutable_neut();
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.neut)
  return _msg;
}
inline void WYE::set_allocated_neut(::commonmodule::CMV* neut) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.neut_;
  }
  if (neut) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neut);
    if (message_arena != submessage_arena) {
      neut = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neut, submessage_arena);
    }

  } else {

  }
  _impl_.neut_ = neut;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.neut)
}

// .commonmodule.CMV phsA = 3;
inline bool WYE::_internal_has_phsa() const {
  return this != internal_default_instance() && _impl_.phsa_ != nullptr;
}
inline bool WYE::has_phsa() const {
  return _internal_has_phsa();
}
inline void WYE::clear_phsa() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsa_ != nullptr) {
    delete _impl_.phsa_;
  }
  _impl_.phsa_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::_internal_phsa() const {
  const ::commonmodule::CMV* p = _impl_.phsa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& WYE::phsa() const {
  // @@protoc_insertion_point(field_get:commonmodule.WYE.phsA)
  return _internal_phsa();
}
inline void WYE::unsafe_arena_set_allocated_phsa(
    ::commonmodule::CMV* phsa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsa_);
  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WYE.phsA)
}
inline ::commonmodule::CMV* WYE::release_phsa() {
  
  ::commonmodule::CMV* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* WYE::unsafe_arena_release_phsa() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.phsA)
  
  ::commonmodule::CMV* temp = _impl_.phsa_;
  _impl_.phsa_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::_internal_mutable_phsa() {
  
  if (_impl_.phsa_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.phsa_ = p;
  }
  return _impl_.phsa_;
}
inline ::commonmodule::CMV* WYE::mutable_phsa() {
  ::commonmodule::CMV* _msg = _internal_mutable_phsa();
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.phsA)
  return _msg;
}
inline void WYE::set_allocated_phsa(::commonmodule::CMV* phsa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsa_;
  }
  if (phsa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsa);
    if (message_arena != submessage_arena) {
      phsa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsa, submessage_arena);
    }

  } else {

  }
  _impl_.phsa_ = phsa;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.phsA)
}

// .commonmodule.CMV phsB = 4;
inline bool WYE::_internal_has_phsb() const {
  return this != internal_default_instance() && _impl_.phsb_ != nullptr;
}
inline bool WYE::has_phsb() const {
  return _internal_has_phsb();
}
inline void WYE::clear_phsb() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsb_ != nullptr) {
    delete _impl_.phsb_;
  }
  _impl_.phsb_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::_internal_phsb() const {
  const ::commonmodule::CMV* p = _impl_.phsb_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& WYE::phsb() const {
  // @@protoc_insertion_point(field_get:commonmodule.WYE.phsB)
  return _internal_phsb();
}
inline void WYE::unsafe_arena_set_allocated_phsb(
    ::commonmodule::CMV* phsb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsb_);
  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WYE.phsB)
}
inline ::commonmodule::CMV* WYE::release_phsb() {
  
  ::commonmodule::CMV* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* WYE::unsafe_arena_release_phsb() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.phsB)
  
  ::commonmodule::CMV* temp = _impl_.phsb_;
  _impl_.phsb_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::_internal_mutable_phsb() {
  
  if (_impl_.phsb_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.phsb_ = p;
  }
  return _impl_.phsb_;
}
inline ::commonmodule::CMV* WYE::mutable_phsb() {
  ::commonmodule::CMV* _msg = _internal_mutable_phsb();
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.phsB)
  return _msg;
}
inline void WYE::set_allocated_phsb(::commonmodule::CMV* phsb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsb_;
  }
  if (phsb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsb);
    if (message_arena != submessage_arena) {
      phsb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsb, submessage_arena);
    }

  } else {

  }
  _impl_.phsb_ = phsb;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.phsB)
}

// .commonmodule.CMV phsC = 5;
inline bool WYE::_internal_has_phsc() const {
  return this != internal_default_instance() && _impl_.phsc_ != nullptr;
}
inline bool WYE::has_phsc() const {
  return _internal_has_phsc();
}
inline void WYE::clear_phsc() {
  if (GetArenaForAllocation() == nullptr && _impl_.phsc_ != nullptr) {
    delete _impl_.phsc_;
  }
  _impl_.phsc_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::_internal_phsc() const {
  const ::commonmodule::CMV* p = _impl_.phsc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& WYE::phsc() const {
  // @@protoc_insertion_point(field_get:commonmodule.WYE.phsC)
  return _internal_phsc();
}
inline void WYE::unsafe_arena_set_allocated_phsc(
    ::commonmodule::CMV* phsc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phsc_);
  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WYE.phsC)
}
inline ::commonmodule::CMV* WYE::release_phsc() {
  
  ::commonmodule::CMV* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* WYE::unsafe_arena_release_phsc() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.phsC)
  
  ::commonmodule::CMV* temp = _impl_.phsc_;
  _impl_.phsc_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::_internal_mutable_phsc() {
  
  if (_impl_.phsc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.phsc_ = p;
  }
  return _impl_.phsc_;
}
inline ::commonmodule::CMV* WYE::mutable_phsc() {
  ::commonmodule::CMV* _msg = _internal_mutable_phsc();
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.phsC)
  return _msg;
}
inline void WYE::set_allocated_phsc(::commonmodule::CMV* phsc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phsc_;
  }
  if (phsc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phsc);
    if (message_arena != submessage_arena) {
      phsc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phsc, submessage_arena);
    }

  } else {

  }
  _impl_.phsc_ = phsc;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.phsC)
}

// .commonmodule.CMV res = 6;
inline bool WYE::_internal_has_res() const {
  return this != internal_default_instance() && _impl_.res_ != nullptr;
}
inline bool WYE::has_res() const {
  return _internal_has_res();
}
inline void WYE::clear_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.res_ != nullptr) {
    delete _impl_.res_;
  }
  _impl_.res_ = nullptr;
}
inline const ::commonmodule::CMV& WYE::_internal_res() const {
  const ::commonmodule::CMV* p = _impl_.res_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CMV&>(
      ::commonmodule::_CMV_default_instance_);
}
inline const ::commonmodule::CMV& WYE::res() const {
  // @@protoc_insertion_point(field_get:commonmodule.WYE.res)
  return _internal_res();
}
inline void WYE::unsafe_arena_set_allocated_res(
    ::commonmodule::CMV* res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.res_);
  }
  _impl_.res_ = res;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WYE.res)
}
inline ::commonmodule::CMV* WYE::release_res() {
  
  ::commonmodule::CMV* temp = _impl_.res_;
  _impl_.res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CMV* WYE::unsafe_arena_release_res() {
  // @@protoc_insertion_point(field_release:commonmodule.WYE.res)
  
  ::commonmodule::CMV* temp = _impl_.res_;
  _impl_.res_ = nullptr;
  return temp;
}
inline ::commonmodule::CMV* WYE::_internal_mutable_res() {
  
  if (_impl_.res_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CMV>(GetArenaForAllocation());
    _impl_.res_ = p;
  }
  return _impl_.res_;
}
inline ::commonmodule::CMV* WYE::mutable_res() {
  ::commonmodule::CMV* _msg = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:commonmodule.WYE.res)
  return _msg;
}
inline void WYE::set_allocated_res(::commonmodule::CMV* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(res);
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }

  } else {

  }
  _impl_.res_ = res;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WYE.res)
}

// -------------------------------------------------------------------

// ReadingMMXU

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingMMXU::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool ReadingMMXU::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void ReadingMMXU::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& ReadingMMXU::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& ReadingMMXU::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.logicalNode)
  return _internal_logicalnode();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.logicalNode)
}
inline ::commonmodule::LogicalNode* ReadingMMXU::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMXU::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* ReadingMMXU::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* ReadingMMXU::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.logicalNode)
  return _msg;
}
inline void ReadingMMXU::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.logicalNode)
}

// .commonmodule.WYE A = 2;
inline bool ReadingMMXU::_internal_has_a() const {
  return this != internal_default_instance() && _impl_.a_ != nullptr;
}
inline bool ReadingMMXU::has_a() const {
  return _internal_has_a();
}
inline void ReadingMMXU::clear_a() {
  if (GetArenaForAllocation() == nullptr && _impl_.a_ != nullptr) {
    delete _impl_.a_;
  }
  _impl_.a_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::_internal_a() const {
  const ::commonmodule::WYE* p = _impl_.a_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WYE&>(
      ::commonmodule::_WYE_default_instance_);
}
inline const ::commonmodule::WYE& ReadingMMXU::a() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.A)
  return _internal_a();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_a(
    ::commonmodule::WYE* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a_);
  }
  _impl_.a_ = a;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.A)
}
inline ::commonmodule::WYE* ReadingMMXU::release_a() {
  
  ::commonmodule::WYE* temp = _impl_.a_;
  _impl_.a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.A)
  
  ::commonmodule::WYE* temp = _impl_.a_;
  _impl_.a_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::_internal_mutable_a() {
  
  if (_impl_.a_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaForAllocation());
    _impl_.a_ = p;
  }
  return _impl_.a_;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_a() {
  ::commonmodule::WYE* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.A)
  return _msg;
}
inline void ReadingMMXU::set_allocated_a(::commonmodule::WYE* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.a_;
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(a);
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }

  } else {

  }
  _impl_.a_ = a;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.A)
}

// .commonmodule.ENG_CalcMethodKind ClcMth = 3;
inline bool ReadingMMXU::_internal_has_clcmth() const {
  return this != internal_default_instance() && _impl_.clcmth_ != nullptr;
}
inline bool ReadingMMXU::has_clcmth() const {
  return _internal_has_clcmth();
}
inline void ReadingMMXU::clear_clcmth() {
  if (GetArenaForAllocation() == nullptr && _impl_.clcmth_ != nullptr) {
    delete _impl_.clcmth_;
  }
  _impl_.clcmth_ = nullptr;
}
inline const ::commonmodule::ENG_CalcMethodKind& ReadingMMXU::_internal_clcmth() const {
  const ::commonmodule::ENG_CalcMethodKind* p = _impl_.clcmth_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_CalcMethodKind&>(
      ::commonmodule::_ENG_CalcMethodKind_default_instance_);
}
inline const ::commonmodule::ENG_CalcMethodKind& ReadingMMXU::clcmth() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.ClcMth)
  return _internal_clcmth();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_clcmth(
    ::commonmodule::ENG_CalcMethodKind* clcmth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clcmth_);
  }
  _impl_.clcmth_ = clcmth;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.ClcMth)
}
inline ::commonmodule::ENG_CalcMethodKind* ReadingMMXU::release_clcmth() {
  
  ::commonmodule::ENG_CalcMethodKind* temp = _impl_.clcmth_;
  _impl_.clcmth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_CalcMethodKind* ReadingMMXU::unsafe_arena_release_clcmth() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.ClcMth)
  
  ::commonmodule::ENG_CalcMethodKind* temp = _impl_.clcmth_;
  _impl_.clcmth_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_CalcMethodKind* ReadingMMXU::_internal_mutable_clcmth() {
  
  if (_impl_.clcmth_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_CalcMethodKind>(GetArenaForAllocation());
    _impl_.clcmth_ = p;
  }
  return _impl_.clcmth_;
}
inline ::commonmodule::ENG_CalcMethodKind* ReadingMMXU::mutable_clcmth() {
  ::commonmodule::ENG_CalcMethodKind* _msg = _internal_mutable_clcmth();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.ClcMth)
  return _msg;
}
inline void ReadingMMXU::set_allocated_clcmth(::commonmodule::ENG_CalcMethodKind* clcmth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clcmth_;
  }
  if (clcmth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clcmth);
    if (message_arena != submessage_arena) {
      clcmth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clcmth, submessage_arena);
    }

  } else {

  }
  _impl_.clcmth_ = clcmth;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.ClcMth)
}

// .commonmodule.MV Hz = 4;
inline bool ReadingMMXU::_internal_has_hz() const {
  return this != internal_default_instance() && _impl_.hz_ != nullptr;
}
inline bool ReadingMMXU::has_hz() const {
  return _internal_has_hz();
}
inline void ReadingMMXU::clear_hz() {
  if (GetArenaForAllocation() == nullptr && _impl_.hz_ != nullptr) {
    delete _impl_.hz_;
  }
  _impl_.hz_ = nullptr;
}
inline const ::commonmodule::MV& ReadingMMXU::_internal_hz() const {
  const ::commonmodule::MV* p = _impl_.hz_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& ReadingMMXU::hz() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.Hz)
  return _internal_hz();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_hz(
    ::commonmodule::MV* hz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hz_);
  }
  _impl_.hz_ = hz;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.Hz)
}
inline ::commonmodule::MV* ReadingMMXU::release_hz() {
  
  ::commonmodule::MV* temp = _impl_.hz_;
  _impl_.hz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* ReadingMMXU::unsafe_arena_release_hz() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.Hz)
  
  ::commonmodule::MV* temp = _impl_.hz_;
  _impl_.hz_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* ReadingMMXU::_internal_mutable_hz() {
  
  if (_impl_.hz_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.hz_ = p;
  }
  return _impl_.hz_;
}
inline ::commonmodule::MV* ReadingMMXU::mutable_hz() {
  ::commonmodule::MV* _msg = _internal_mutable_hz();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.Hz)
  return _msg;
}
inline void ReadingMMXU::set_allocated_hz(::commonmodule::MV* hz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hz_;
  }
  if (hz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hz);
    if (message_arena != submessage_arena) {
      hz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hz, submessage_arena);
    }

  } else {

  }
  _impl_.hz_ = hz;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.Hz)
}

// .commonmodule.WYE PF = 5;
inline bool ReadingMMXU::_internal_has_pf() const {
  return this != internal_default_instance() && _impl_.pf_ != nullptr;
}
inline bool ReadingMMXU::has_pf() const {
  return _internal_has_pf();
}
inline void ReadingMMXU::clear_pf() {
  if (GetArenaForAllocation() == nullptr && _impl_.pf_ != nullptr) {
    delete _impl_.pf_;
  }
  _impl_.pf_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::_internal_pf() const {
  const ::commonmodule::WYE* p = _impl_.pf_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WYE&>(
      ::commonmodule::_WYE_default_instance_);
}
inline const ::commonmodule::WYE& ReadingMMXU::pf() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PF)
  return _internal_pf();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_pf(
    ::commonmodule::WYE* pf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pf_);
  }
  _impl_.pf_ = pf;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.PF)
}
inline ::commonmodule::WYE* ReadingMMXU::release_pf() {
  
  ::commonmodule::WYE* temp = _impl_.pf_;
  _impl_.pf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::unsafe_arena_release_pf() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PF)
  
  ::commonmodule::WYE* temp = _impl_.pf_;
  _impl_.pf_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::_internal_mutable_pf() {
  
  if (_impl_.pf_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaForAllocation());
    _impl_.pf_ = p;
  }
  return _impl_.pf_;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_pf() {
  ::commonmodule::WYE* _msg = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PF)
  return _msg;
}
inline void ReadingMMXU::set_allocated_pf(::commonmodule::WYE* pf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pf_;
  }
  if (pf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pf);
    if (message_arena != submessage_arena) {
      pf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pf, submessage_arena);
    }

  } else {

  }
  _impl_.pf_ = pf;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PF)
}

// .commonmodule.ENG_PFSignKind PFSign = 6;
inline bool ReadingMMXU::_internal_has_pfsign() const {
  return this != internal_default_instance() && _impl_.pfsign_ != nullptr;
}
inline bool ReadingMMXU::has_pfsign() const {
  return _internal_has_pfsign();
}
inline void ReadingMMXU::clear_pfsign() {
  if (GetArenaForAllocation() == nullptr && _impl_.pfsign_ != nullptr) {
    delete _impl_.pfsign_;
  }
  _impl_.pfsign_ = nullptr;
}
inline const ::commonmodule::ENG_PFSignKind& ReadingMMXU::_internal_pfsign() const {
  const ::commonmodule::ENG_PFSignKind* p = _impl_.pfsign_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_PFSignKind&>(
      ::commonmodule::_ENG_PFSignKind_default_instance_);
}
inline const ::commonmodule::ENG_PFSignKind& ReadingMMXU::pfsign() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PFSign)
  return _internal_pfsign();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_pfsign(
    ::commonmodule::ENG_PFSignKind* pfsign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfsign_);
  }
  _impl_.pfsign_ = pfsign;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.PFSign)
}
inline ::commonmodule::ENG_PFSignKind* ReadingMMXU::release_pfsign() {
  
  ::commonmodule::ENG_PFSignKind* temp = _impl_.pfsign_;
  _impl_.pfsign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_PFSignKind* ReadingMMXU::unsafe_arena_release_pfsign() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PFSign)
  
  ::commonmodule::ENG_PFSignKind* temp = _impl_.pfsign_;
  _impl_.pfsign_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_PFSignKind* ReadingMMXU::_internal_mutable_pfsign() {
  
  if (_impl_.pfsign_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_PFSignKind>(GetArenaForAllocation());
    _impl_.pfsign_ = p;
  }
  return _impl_.pfsign_;
}
inline ::commonmodule::ENG_PFSignKind* ReadingMMXU::mutable_pfsign() {
  ::commonmodule::ENG_PFSignKind* _msg = _internal_mutable_pfsign();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PFSign)
  return _msg;
}
inline void ReadingMMXU::set_allocated_pfsign(::commonmodule::ENG_PFSignKind* pfsign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pfsign_;
  }
  if (pfsign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pfsign);
    if (message_arena != submessage_arena) {
      pfsign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pfsign, submessage_arena);
    }

  } else {

  }
  _impl_.pfsign_ = pfsign;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PFSign)
}

// .commonmodule.WYE PhV = 7;
inline bool ReadingMMXU::_internal_has_phv() const {
  return this != internal_default_instance() && _impl_.phv_ != nullptr;
}
inline bool ReadingMMXU::has_phv() const {
  return _internal_has_phv();
}
inline void ReadingMMXU::clear_phv() {
  if (GetArenaForAllocation() == nullptr && _impl_.phv_ != nullptr) {
    delete _impl_.phv_;
  }
  _impl_.phv_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::_internal_phv() const {
  const ::commonmodule::WYE* p = _impl_.phv_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WYE&>(
      ::commonmodule::_WYE_default_instance_);
}
inline const ::commonmodule::WYE& ReadingMMXU::phv() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PhV)
  return _internal_phv();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_phv(
    ::commonmodule::WYE* phv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phv_);
  }
  _impl_.phv_ = phv;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.PhV)
}
inline ::commonmodule::WYE* ReadingMMXU::release_phv() {
  
  ::commonmodule::WYE* temp = _impl_.phv_;
  _impl_.phv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::unsafe_arena_release_phv() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PhV)
  
  ::commonmodule::WYE* temp = _impl_.phv_;
  _impl_.phv_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::_internal_mutable_phv() {
  
  if (_impl_.phv_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaForAllocation());
    _impl_.phv_ = p;
  }
  return _impl_.phv_;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_phv() {
  ::commonmodule::WYE* _msg = _internal_mutable_phv();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PhV)
  return _msg;
}
inline void ReadingMMXU::set_allocated_phv(::commonmodule::WYE* phv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phv_;
  }
  if (phv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phv);
    if (message_arena != submessage_arena) {
      phv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phv, submessage_arena);
    }

  } else {

  }
  _impl_.phv_ = phv;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PhV)
}

// .commonmodule.DEL PPV = 8;
inline bool ReadingMMXU::_internal_has_ppv() const {
  return this != internal_default_instance() && _impl_.ppv_ != nullptr;
}
inline bool ReadingMMXU::has_ppv() const {
  return _internal_has_ppv();
}
inline void ReadingMMXU::clear_ppv() {
  if (GetArenaForAllocation() == nullptr && _impl_.ppv_ != nullptr) {
    delete _impl_.ppv_;
  }
  _impl_.ppv_ = nullptr;
}
inline const ::commonmodule::DEL& ReadingMMXU::_internal_ppv() const {
  const ::commonmodule::DEL* p = _impl_.ppv_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::DEL&>(
      ::commonmodule::_DEL_default_instance_);
}
inline const ::commonmodule::DEL& ReadingMMXU::ppv() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.PPV)
  return _internal_ppv();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_ppv(
    ::commonmodule::DEL* ppv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ppv_);
  }
  _impl_.ppv_ = ppv;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.PPV)
}
inline ::commonmodule::DEL* ReadingMMXU::release_ppv() {
  
  ::commonmodule::DEL* temp = _impl_.ppv_;
  _impl_.ppv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::DEL* ReadingMMXU::unsafe_arena_release_ppv() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.PPV)
  
  ::commonmodule::DEL* temp = _impl_.ppv_;
  _impl_.ppv_ = nullptr;
  return temp;
}
inline ::commonmodule::DEL* ReadingMMXU::_internal_mutable_ppv() {
  
  if (_impl_.ppv_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::DEL>(GetArenaForAllocation());
    _impl_.ppv_ = p;
  }
  return _impl_.ppv_;
}
inline ::commonmodule::DEL* ReadingMMXU::mutable_ppv() {
  ::commonmodule::DEL* _msg = _internal_mutable_ppv();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.PPV)
  return _msg;
}
inline void ReadingMMXU::set_allocated_ppv(::commonmodule::DEL* ppv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ppv_;
  }
  if (ppv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ppv);
    if (message_arena != submessage_arena) {
      ppv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ppv, submessage_arena);
    }

  } else {

  }
  _impl_.ppv_ = ppv;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.PPV)
}

// .commonmodule.WYE VA = 9;
inline bool ReadingMMXU::_internal_has_va() const {
  return this != internal_default_instance() && _impl_.va_ != nullptr;
}
inline bool ReadingMMXU::has_va() const {
  return _internal_has_va();
}
inline void ReadingMMXU::clear_va() {
  if (GetArenaForAllocation() == nullptr && _impl_.va_ != nullptr) {
    delete _impl_.va_;
  }
  _impl_.va_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::_internal_va() const {
  const ::commonmodule::WYE* p = _impl_.va_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WYE&>(
      ::commonmodule::_WYE_default_instance_);
}
inline const ::commonmodule::WYE& ReadingMMXU::va() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.VA)
  return _internal_va();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_va(
    ::commonmodule::WYE* va) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.va_);
  }
  _impl_.va_ = va;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.VA)
}
inline ::commonmodule::WYE* ReadingMMXU::release_va() {
  
  ::commonmodule::WYE* temp = _impl_.va_;
  _impl_.va_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::unsafe_arena_release_va() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.VA)
  
  ::commonmodule::WYE* temp = _impl_.va_;
  _impl_.va_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::_internal_mutable_va() {
  
  if (_impl_.va_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaForAllocation());
    _impl_.va_ = p;
  }
  return _impl_.va_;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_va() {
  ::commonmodule::WYE* _msg = _internal_mutable_va();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.VA)
  return _msg;
}
inline void ReadingMMXU::set_allocated_va(::commonmodule::WYE* va) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.va_;
  }
  if (va) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(va);
    if (message_arena != submessage_arena) {
      va = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, va, submessage_arena);
    }

  } else {

  }
  _impl_.va_ = va;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.VA)
}

// .commonmodule.WYE VAr = 10;
inline bool ReadingMMXU::_internal_has_var() const {
  return this != internal_default_instance() && _impl_.var_ != nullptr;
}
inline bool ReadingMMXU::has_var() const {
  return _internal_has_var();
}
inline void ReadingMMXU::clear_var() {
  if (GetArenaForAllocation() == nullptr && _impl_.var_ != nullptr) {
    delete _impl_.var_;
  }
  _impl_.var_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::_internal_var() const {
  const ::commonmodule::WYE* p = _impl_.var_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WYE&>(
      ::commonmodule::_WYE_default_instance_);
}
inline const ::commonmodule::WYE& ReadingMMXU::var() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.VAr)
  return _internal_var();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_var(
    ::commonmodule::WYE* var) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.var_);
  }
  _impl_.var_ = var;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.VAr)
}
inline ::commonmodule::WYE* ReadingMMXU::release_var() {
  
  ::commonmodule::WYE* temp = _impl_.var_;
  _impl_.var_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.VAr)
  
  ::commonmodule::WYE* temp = _impl_.var_;
  _impl_.var_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::_internal_mutable_var() {
  
  if (_impl_.var_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaForAllocation());
    _impl_.var_ = p;
  }
  return _impl_.var_;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_var() {
  ::commonmodule::WYE* _msg = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.VAr)
  return _msg;
}
inline void ReadingMMXU::set_allocated_var(::commonmodule::WYE* var) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.var_;
  }
  if (var) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(var);
    if (message_arena != submessage_arena) {
      var = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, var, submessage_arena);
    }

  } else {

  }
  _impl_.var_ = var;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.VAr)
}

// .commonmodule.WYE W = 11;
inline bool ReadingMMXU::_internal_has_w() const {
  return this != internal_default_instance() && _impl_.w_ != nullptr;
}
inline bool ReadingMMXU::has_w() const {
  return _internal_has_w();
}
inline void ReadingMMXU::clear_w() {
  if (GetArenaForAllocation() == nullptr && _impl_.w_ != nullptr) {
    delete _impl_.w_;
  }
  _impl_.w_ = nullptr;
}
inline const ::commonmodule::WYE& ReadingMMXU::_internal_w() const {
  const ::commonmodule::WYE* p = _impl_.w_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WYE&>(
      ::commonmodule::_WYE_default_instance_);
}
inline const ::commonmodule::WYE& ReadingMMXU::w() const {
  // @@protoc_insertion_point(field_get:commonmodule.ReadingMMXU.W)
  return _internal_w();
}
inline void ReadingMMXU::unsafe_arena_set_allocated_w(
    ::commonmodule::WYE* w) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.w_);
  }
  _impl_.w_ = w;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.ReadingMMXU.W)
}
inline ::commonmodule::WYE* ReadingMMXU::release_w() {
  
  ::commonmodule::WYE* temp = _impl_.w_;
  _impl_.w_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::unsafe_arena_release_w() {
  // @@protoc_insertion_point(field_release:commonmodule.ReadingMMXU.W)
  
  ::commonmodule::WYE* temp = _impl_.w_;
  _impl_.w_ = nullptr;
  return temp;
}
inline ::commonmodule::WYE* ReadingMMXU::_internal_mutable_w() {
  
  if (_impl_.w_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WYE>(GetArenaForAllocation());
    _impl_.w_ = p;
  }
  return _impl_.w_;
}
inline ::commonmodule::WYE* ReadingMMXU::mutable_w() {
  ::commonmodule::WYE* _msg = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:commonmodule.ReadingMMXU.W)
  return _msg;
}
inline void ReadingMMXU::set_allocated_w(::commonmodule::WYE* w) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.w_;
  }
  if (w) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(w);
    if (message_arena != submessage_arena) {
      w = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, w, submessage_arena);
    }

  } else {

  }
  _impl_.w_ = w;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.ReadingMMXU.W)
}

// -------------------------------------------------------------------

// SourceCapabilityConfiguration

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool SourceCapabilityConfiguration::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void SourceCapabilityConfiguration::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& SourceCapabilityConfiguration::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& SourceCapabilityConfiguration::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.logicalNode)
  return _internal_logicalnode();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.logicalNode)
}
inline ::commonmodule::LogicalNode* SourceCapabilityConfiguration::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* SourceCapabilityConfiguration::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* SourceCapabilityConfiguration::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* SourceCapabilityConfiguration::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.logicalNode)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.logicalNode)
}

// .commonmodule.ASG AMax = 2;
inline bool SourceCapabilityConfiguration::_internal_has_amax() const {
  return this != internal_default_instance() && _impl_.amax_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_amax() const {
  return _internal_has_amax();
}
inline void SourceCapabilityConfiguration::clear_amax() {
  if (GetArenaForAllocation() == nullptr && _impl_.amax_ != nullptr) {
    delete _impl_.amax_;
  }
  _impl_.amax_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_amax() const {
  const ::commonmodule::ASG* p = _impl_.amax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::amax() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.AMax)
  return _internal_amax();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_amax(
    ::commonmodule::ASG* amax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amax_);
  }
  _impl_.amax_ = amax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.AMax)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_amax() {
  
  ::commonmodule::ASG* temp = _impl_.amax_;
  _impl_.amax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_amax() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.AMax)
  
  ::commonmodule::ASG* temp = _impl_.amax_;
  _impl_.amax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_amax() {
  
  if (_impl_.amax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.amax_ = p;
  }
  return _impl_.amax_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_amax() {
  ::commonmodule::ASG* _msg = _internal_mutable_amax();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.AMax)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_amax(::commonmodule::ASG* amax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amax_;
  }
  if (amax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amax);
    if (message_arena != submessage_arena) {
      amax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amax, submessage_arena);
    }

  } else {

  }
  _impl_.amax_ = amax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.AMax)
}

// .commonmodule.ASG VAMax = 3;
inline bool SourceCapabilityConfiguration::_internal_has_vamax() const {
  return this != internal_default_instance() && _impl_.vamax_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_vamax() const {
  return _internal_has_vamax();
}
inline void SourceCapabilityConfiguration::clear_vamax() {
  if (GetArenaForAllocation() == nullptr && _impl_.vamax_ != nullptr) {
    delete _impl_.vamax_;
  }
  _impl_.vamax_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_vamax() const {
  const ::commonmodule::ASG* p = _impl_.vamax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::vamax() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.VAMax)
  return _internal_vamax();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_vamax(
    ::commonmodule::ASG* vamax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vamax_);
  }
  _impl_.vamax_ = vamax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.VAMax)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_vamax() {
  
  ::commonmodule::ASG* temp = _impl_.vamax_;
  _impl_.vamax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_vamax() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.VAMax)
  
  ::commonmodule::ASG* temp = _impl_.vamax_;
  _impl_.vamax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_vamax() {
  
  if (_impl_.vamax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vamax_ = p;
  }
  return _impl_.vamax_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_vamax() {
  ::commonmodule::ASG* _msg = _internal_mutable_vamax();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.VAMax)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_vamax(::commonmodule::ASG* vamax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vamax_;
  }
  if (vamax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vamax);
    if (message_arena != submessage_arena) {
      vamax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vamax, submessage_arena);
    }

  } else {

  }
  _impl_.vamax_ = vamax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.VAMax)
}

// .commonmodule.ASG VarMaxAbs = 4;
inline bool SourceCapabilityConfiguration::_internal_has_varmaxabs() const {
  return this != internal_default_instance() && _impl_.varmaxabs_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_varmaxabs() const {
  return _internal_has_varmaxabs();
}
inline void SourceCapabilityConfiguration::clear_varmaxabs() {
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxabs_ != nullptr) {
    delete _impl_.varmaxabs_;
  }
  _impl_.varmaxabs_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_varmaxabs() const {
  const ::commonmodule::ASG* p = _impl_.varmaxabs_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::varmaxabs() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.VarMaxAbs)
  return _internal_varmaxabs();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_varmaxabs(
    ::commonmodule::ASG* varmaxabs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varmaxabs_);
  }
  _impl_.varmaxabs_ = varmaxabs;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.VarMaxAbs)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_varmaxabs() {
  
  ::commonmodule::ASG* temp = _impl_.varmaxabs_;
  _impl_.varmaxabs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_varmaxabs() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.VarMaxAbs)
  
  ::commonmodule::ASG* temp = _impl_.varmaxabs_;
  _impl_.varmaxabs_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_varmaxabs() {
  
  if (_impl_.varmaxabs_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.varmaxabs_ = p;
  }
  return _impl_.varmaxabs_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_varmaxabs() {
  ::commonmodule::ASG* _msg = _internal_mutable_varmaxabs();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.VarMaxAbs)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_varmaxabs(::commonmodule::ASG* varmaxabs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.varmaxabs_;
  }
  if (varmaxabs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varmaxabs);
    if (message_arena != submessage_arena) {
      varmaxabs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varmaxabs, submessage_arena);
    }

  } else {

  }
  _impl_.varmaxabs_ = varmaxabs;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.VarMaxAbs)
}

// .commonmodule.ASG VarMaxInj = 5;
inline bool SourceCapabilityConfiguration::_internal_has_varmaxinj() const {
  return this != internal_default_instance() && _impl_.varmaxinj_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_varmaxinj() const {
  return _internal_has_varmaxinj();
}
inline void SourceCapabilityConfiguration::clear_varmaxinj() {
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxinj_ != nullptr) {
    delete _impl_.varmaxinj_;
  }
  _impl_.varmaxinj_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_varmaxinj() const {
  const ::commonmodule::ASG* p = _impl_.varmaxinj_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::varmaxinj() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.VarMaxInj)
  return _internal_varmaxinj();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_varmaxinj(
    ::commonmodule::ASG* varmaxinj) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varmaxinj_);
  }
  _impl_.varmaxinj_ = varmaxinj;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.VarMaxInj)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_varmaxinj() {
  
  ::commonmodule::ASG* temp = _impl_.varmaxinj_;
  _impl_.varmaxinj_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_varmaxinj() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.VarMaxInj)
  
  ::commonmodule::ASG* temp = _impl_.varmaxinj_;
  _impl_.varmaxinj_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_varmaxinj() {
  
  if (_impl_.varmaxinj_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.varmaxinj_ = p;
  }
  return _impl_.varmaxinj_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_varmaxinj() {
  ::commonmodule::ASG* _msg = _internal_mutable_varmaxinj();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.VarMaxInj)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_varmaxinj(::commonmodule::ASG* varmaxinj) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.varmaxinj_;
  }
  if (varmaxinj) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varmaxinj);
    if (message_arena != submessage_arena) {
      varmaxinj = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varmaxinj, submessage_arena);
    }

  } else {

  }
  _impl_.varmaxinj_ = varmaxinj;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.VarMaxInj)
}

// .commonmodule.ASG VMax = 6;
inline bool SourceCapabilityConfiguration::_internal_has_vmax() const {
  return this != internal_default_instance() && _impl_.vmax_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_vmax() const {
  return _internal_has_vmax();
}
inline void SourceCapabilityConfiguration::clear_vmax() {
  if (GetArenaForAllocation() == nullptr && _impl_.vmax_ != nullptr) {
    delete _impl_.vmax_;
  }
  _impl_.vmax_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_vmax() const {
  const ::commonmodule::ASG* p = _impl_.vmax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::vmax() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.VMax)
  return _internal_vmax();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_vmax(
    ::commonmodule::ASG* vmax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vmax_);
  }
  _impl_.vmax_ = vmax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.VMax)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_vmax() {
  
  ::commonmodule::ASG* temp = _impl_.vmax_;
  _impl_.vmax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_vmax() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.VMax)
  
  ::commonmodule::ASG* temp = _impl_.vmax_;
  _impl_.vmax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_vmax() {
  
  if (_impl_.vmax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vmax_ = p;
  }
  return _impl_.vmax_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_vmax() {
  ::commonmodule::ASG* _msg = _internal_mutable_vmax();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.VMax)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_vmax(::commonmodule::ASG* vmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vmax_;
  }
  if (vmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vmax);
    if (message_arena != submessage_arena) {
      vmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vmax, submessage_arena);
    }

  } else {

  }
  _impl_.vmax_ = vmax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.VMax)
}

// .commonmodule.ASG VMin = 7;
inline bool SourceCapabilityConfiguration::_internal_has_vmin() const {
  return this != internal_default_instance() && _impl_.vmin_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_vmin() const {
  return _internal_has_vmin();
}
inline void SourceCapabilityConfiguration::clear_vmin() {
  if (GetArenaForAllocation() == nullptr && _impl_.vmin_ != nullptr) {
    delete _impl_.vmin_;
  }
  _impl_.vmin_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_vmin() const {
  const ::commonmodule::ASG* p = _impl_.vmin_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::vmin() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.VMin)
  return _internal_vmin();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_vmin(
    ::commonmodule::ASG* vmin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vmin_);
  }
  _impl_.vmin_ = vmin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.VMin)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_vmin() {
  
  ::commonmodule::ASG* temp = _impl_.vmin_;
  _impl_.vmin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_vmin() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.VMin)
  
  ::commonmodule::ASG* temp = _impl_.vmin_;
  _impl_.vmin_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_vmin() {
  
  if (_impl_.vmin_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vmin_ = p;
  }
  return _impl_.vmin_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_vmin() {
  ::commonmodule::ASG* _msg = _internal_mutable_vmin();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.VMin)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_vmin(::commonmodule::ASG* vmin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vmin_;
  }
  if (vmin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vmin);
    if (message_arena != submessage_arena) {
      vmin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vmin, submessage_arena);
    }

  } else {

  }
  _impl_.vmin_ = vmin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.VMin)
}

// .commonmodule.ASG VNom = 8;
inline bool SourceCapabilityConfiguration::_internal_has_vnom() const {
  return this != internal_default_instance() && _impl_.vnom_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_vnom() const {
  return _internal_has_vnom();
}
inline void SourceCapabilityConfiguration::clear_vnom() {
  if (GetArenaForAllocation() == nullptr && _impl_.vnom_ != nullptr) {
    delete _impl_.vnom_;
  }
  _impl_.vnom_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_vnom() const {
  const ::commonmodule::ASG* p = _impl_.vnom_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::vnom() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.VNom)
  return _internal_vnom();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_vnom(
    ::commonmodule::ASG* vnom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vnom_);
  }
  _impl_.vnom_ = vnom;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.VNom)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_vnom() {
  
  ::commonmodule::ASG* temp = _impl_.vnom_;
  _impl_.vnom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_vnom() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.VNom)
  
  ::commonmodule::ASG* temp = _impl_.vnom_;
  _impl_.vnom_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_vnom() {
  
  if (_impl_.vnom_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vnom_ = p;
  }
  return _impl_.vnom_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_vnom() {
  ::commonmodule::ASG* _msg = _internal_mutable_vnom();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.VNom)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_vnom(::commonmodule::ASG* vnom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vnom_;
  }
  if (vnom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vnom);
    if (message_arena != submessage_arena) {
      vnom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vnom, submessage_arena);
    }

  } else {

  }
  _impl_.vnom_ = vnom;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.VNom)
}

// .commonmodule.ASG WMax = 9;
inline bool SourceCapabilityConfiguration::_internal_has_wmax() const {
  return this != internal_default_instance() && _impl_.wmax_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_wmax() const {
  return _internal_has_wmax();
}
inline void SourceCapabilityConfiguration::clear_wmax() {
  if (GetArenaForAllocation() == nullptr && _impl_.wmax_ != nullptr) {
    delete _impl_.wmax_;
  }
  _impl_.wmax_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_wmax() const {
  const ::commonmodule::ASG* p = _impl_.wmax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::wmax() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.WMax)
  return _internal_wmax();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_wmax(
    ::commonmodule::ASG* wmax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wmax_);
  }
  _impl_.wmax_ = wmax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.WMax)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_wmax() {
  
  ::commonmodule::ASG* temp = _impl_.wmax_;
  _impl_.wmax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_wmax() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.WMax)
  
  ::commonmodule::ASG* temp = _impl_.wmax_;
  _impl_.wmax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_wmax() {
  
  if (_impl_.wmax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wmax_ = p;
  }
  return _impl_.wmax_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_wmax() {
  ::commonmodule::ASG* _msg = _internal_mutable_wmax();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.WMax)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_wmax(::commonmodule::ASG* wmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wmax_;
  }
  if (wmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wmax);
    if (message_arena != submessage_arena) {
      wmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wmax, submessage_arena);
    }

  } else {

  }
  _impl_.wmax_ = wmax;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.WMax)
}

// .commonmodule.ASG WOvrExt = 10;
inline bool SourceCapabilityConfiguration::_internal_has_wovrext() const {
  return this != internal_default_instance() && _impl_.wovrext_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_wovrext() const {
  return _internal_has_wovrext();
}
inline void SourceCapabilityConfiguration::clear_wovrext() {
  if (GetArenaForAllocation() == nullptr && _impl_.wovrext_ != nullptr) {
    delete _impl_.wovrext_;
  }
  _impl_.wovrext_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_wovrext() const {
  const ::commonmodule::ASG* p = _impl_.wovrext_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::wovrext() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.WOvrExt)
  return _internal_wovrext();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_wovrext(
    ::commonmodule::ASG* wovrext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wovrext_);
  }
  _impl_.wovrext_ = wovrext;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.WOvrExt)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_wovrext() {
  
  ::commonmodule::ASG* temp = _impl_.wovrext_;
  _impl_.wovrext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_wovrext() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.WOvrExt)
  
  ::commonmodule::ASG* temp = _impl_.wovrext_;
  _impl_.wovrext_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_wovrext() {
  
  if (_impl_.wovrext_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wovrext_ = p;
  }
  return _impl_.wovrext_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_wovrext() {
  ::commonmodule::ASG* _msg = _internal_mutable_wovrext();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.WOvrExt)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_wovrext(::commonmodule::ASG* wovrext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wovrext_;
  }
  if (wovrext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wovrext);
    if (message_arena != submessage_arena) {
      wovrext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wovrext, submessage_arena);
    }

  } else {

  }
  _impl_.wovrext_ = wovrext;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.WOvrExt)
}

// .commonmodule.ASG WOvrExtPF = 11;
inline bool SourceCapabilityConfiguration::_internal_has_wovrextpf() const {
  return this != internal_default_instance() && _impl_.wovrextpf_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_wovrextpf() const {
  return _internal_has_wovrextpf();
}
inline void SourceCapabilityConfiguration::clear_wovrextpf() {
  if (GetArenaForAllocation() == nullptr && _impl_.wovrextpf_ != nullptr) {
    delete _impl_.wovrextpf_;
  }
  _impl_.wovrextpf_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_wovrextpf() const {
  const ::commonmodule::ASG* p = _impl_.wovrextpf_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::wovrextpf() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.WOvrExtPF)
  return _internal_wovrextpf();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_wovrextpf(
    ::commonmodule::ASG* wovrextpf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wovrextpf_);
  }
  _impl_.wovrextpf_ = wovrextpf;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.WOvrExtPF)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_wovrextpf() {
  
  ::commonmodule::ASG* temp = _impl_.wovrextpf_;
  _impl_.wovrextpf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_wovrextpf() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.WOvrExtPF)
  
  ::commonmodule::ASG* temp = _impl_.wovrextpf_;
  _impl_.wovrextpf_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_wovrextpf() {
  
  if (_impl_.wovrextpf_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wovrextpf_ = p;
  }
  return _impl_.wovrextpf_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_wovrextpf() {
  ::commonmodule::ASG* _msg = _internal_mutable_wovrextpf();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.WOvrExtPF)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_wovrextpf(::commonmodule::ASG* wovrextpf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wovrextpf_;
  }
  if (wovrextpf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wovrextpf);
    if (message_arena != submessage_arena) {
      wovrextpf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wovrextpf, submessage_arena);
    }

  } else {

  }
  _impl_.wovrextpf_ = wovrextpf;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.WOvrExtPF)
}

// .commonmodule.ASG WUndExt = 12;
inline bool SourceCapabilityConfiguration::_internal_has_wundext() const {
  return this != internal_default_instance() && _impl_.wundext_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_wundext() const {
  return _internal_has_wundext();
}
inline void SourceCapabilityConfiguration::clear_wundext() {
  if (GetArenaForAllocation() == nullptr && _impl_.wundext_ != nullptr) {
    delete _impl_.wundext_;
  }
  _impl_.wundext_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_wundext() const {
  const ::commonmodule::ASG* p = _impl_.wundext_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::wundext() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.WUndExt)
  return _internal_wundext();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_wundext(
    ::commonmodule::ASG* wundext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wundext_);
  }
  _impl_.wundext_ = wundext;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.WUndExt)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_wundext() {
  
  ::commonmodule::ASG* temp = _impl_.wundext_;
  _impl_.wundext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_wundext() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.WUndExt)
  
  ::commonmodule::ASG* temp = _impl_.wundext_;
  _impl_.wundext_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_wundext() {
  
  if (_impl_.wundext_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wundext_ = p;
  }
  return _impl_.wundext_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_wundext() {
  ::commonmodule::ASG* _msg = _internal_mutable_wundext();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.WUndExt)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_wundext(::commonmodule::ASG* wundext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wundext_;
  }
  if (wundext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wundext);
    if (message_arena != submessage_arena) {
      wundext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wundext, submessage_arena);
    }

  } else {

  }
  _impl_.wundext_ = wundext;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.WUndExt)
}

// .commonmodule.ASG WUndExtPF = 13;
inline bool SourceCapabilityConfiguration::_internal_has_wundextpf() const {
  return this != internal_default_instance() && _impl_.wundextpf_ != nullptr;
}
inline bool SourceCapabilityConfiguration::has_wundextpf() const {
  return _internal_has_wundextpf();
}
inline void SourceCapabilityConfiguration::clear_wundextpf() {
  if (GetArenaForAllocation() == nullptr && _impl_.wundextpf_ != nullptr) {
    delete _impl_.wundextpf_;
  }
  _impl_.wundextpf_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::_internal_wundextpf() const {
  const ::commonmodule::ASG* p = _impl_.wundextpf_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityConfiguration::wundextpf() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityConfiguration.WUndExtPF)
  return _internal_wundextpf();
}
inline void SourceCapabilityConfiguration::unsafe_arena_set_allocated_wundextpf(
    ::commonmodule::ASG* wundextpf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wundextpf_);
  }
  _impl_.wundextpf_ = wundextpf;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityConfiguration.WUndExtPF)
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::release_wundextpf() {
  
  ::commonmodule::ASG* temp = _impl_.wundextpf_;
  _impl_.wundextpf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::unsafe_arena_release_wundextpf() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityConfiguration.WUndExtPF)
  
  ::commonmodule::ASG* temp = _impl_.wundextpf_;
  _impl_.wundextpf_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::_internal_mutable_wundextpf() {
  
  if (_impl_.wundextpf_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wundextpf_ = p;
  }
  return _impl_.wundextpf_;
}
inline ::commonmodule::ASG* SourceCapabilityConfiguration::mutable_wundextpf() {
  ::commonmodule::ASG* _msg = _internal_mutable_wundextpf();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityConfiguration.WUndExtPF)
  return _msg;
}
inline void SourceCapabilityConfiguration::set_allocated_wundextpf(::commonmodule::ASG* wundextpf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wundextpf_;
  }
  if (wundextpf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wundextpf);
    if (message_arena != submessage_arena) {
      wundextpf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wundextpf, submessage_arena);
    }

  } else {

  }
  _impl_.wundextpf_ = wundextpf;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityConfiguration.WUndExtPF)
}

// -------------------------------------------------------------------

// Optional_NorOpCatKind

// .commonmodule.NorOpCatKind value = 1;
inline void Optional_NorOpCatKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::NorOpCatKind Optional_NorOpCatKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_NorOpCatKind.value)
  return _internal_value();
}
inline void Optional_NorOpCatKind::set_value(::commonmodule::NorOpCatKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_NorOpCatKind.value)
}
inline ::commonmodule::NorOpCatKind Optional_NorOpCatKind::_internal_value() const {
  return static_cast<::commonmodule::NorOpCatKind>(_impl_.value_);
}
inline void Optional_NorOpCatKind::_internal_set_value(::commonmodule::NorOpCatKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_AbnOpCatKind

// .commonmodule.AbnOpCatKind value = 1;
inline void Optional_AbnOpCatKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::AbnOpCatKind Optional_AbnOpCatKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_AbnOpCatKind.value)
  return _internal_value();
}
inline void Optional_AbnOpCatKind::set_value(::commonmodule::AbnOpCatKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_AbnOpCatKind.value)
}
inline ::commonmodule::AbnOpCatKind Optional_AbnOpCatKind::_internal_value() const {
  return static_cast<::commonmodule::AbnOpCatKind>(_impl_.value_);
}
inline void Optional_AbnOpCatKind::_internal_set_value(::commonmodule::AbnOpCatKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SourceCapabilityRatings

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool SourceCapabilityRatings::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool SourceCapabilityRatings::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void SourceCapabilityRatings::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& SourceCapabilityRatings::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& SourceCapabilityRatings::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.logicalNode)
  return _internal_logicalnode();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.logicalNode)
}
inline ::commonmodule::LogicalNode* SourceCapabilityRatings::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* SourceCapabilityRatings::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* SourceCapabilityRatings::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* SourceCapabilityRatings::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.logicalNode)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.logicalNode)
}

// .commonmodule.AbnOpCatKind AbnOpCatRtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void SourceCapabilityRatings::clear_abnopcatrtg() {
  _impl_.abnopcatrtg_ = 0;
}
inline ::commonmodule::AbnOpCatKind SourceCapabilityRatings::abnopcatrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.AbnOpCatRtg)
  return _internal_abnopcatrtg();
}
inline void SourceCapabilityRatings::set_abnopcatrtg(::commonmodule::AbnOpCatKind value) {
   _internal_set_abnopcatrtg(value);
  // @@protoc_insertion_point(field_set:commonmodule.SourceCapabilityRatings.AbnOpCatRtg)
}
inline ::commonmodule::AbnOpCatKind SourceCapabilityRatings::_internal_abnopcatrtg() const {
  return static_cast<::commonmodule::AbnOpCatKind>(_impl_.abnopcatrtg_);
}
inline void SourceCapabilityRatings::_internal_set_abnopcatrtg(::commonmodule::AbnOpCatKind value) {
  ;
  _impl_.abnopcatrtg_ = value;
}

// .commonmodule.ASG AMaxRtg = 3;
inline bool SourceCapabilityRatings::_internal_has_amaxrtg() const {
  return this != internal_default_instance() && _impl_.amaxrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_amaxrtg() const {
  return _internal_has_amaxrtg();
}
inline void SourceCapabilityRatings::clear_amaxrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.amaxrtg_ != nullptr) {
    delete _impl_.amaxrtg_;
  }
  _impl_.amaxrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_amaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.amaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::amaxrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.AMaxRtg)
  return _internal_amaxrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_amaxrtg(
    ::commonmodule::ASG* amaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amaxrtg_);
  }
  _impl_.amaxrtg_ = amaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.AMaxRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_amaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.amaxrtg_;
  _impl_.amaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_amaxrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.AMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.amaxrtg_;
  _impl_.amaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_amaxrtg() {
  
  if (_impl_.amaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.amaxrtg_ = p;
  }
  return _impl_.amaxrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_amaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_amaxrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.AMaxRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_amaxrtg(::commonmodule::ASG* amaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amaxrtg_;
  }
  if (amaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amaxrtg);
    if (message_arena != submessage_arena) {
      amaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.amaxrtg_ = amaxrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.AMaxRtg)
}

// .commonmodule.ASG FreqNomRtg = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_freqnomrtg() const {
  return this != internal_default_instance() && _impl_.freqnomrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_freqnomrtg() const {
  return _internal_has_freqnomrtg();
}
inline void SourceCapabilityRatings::clear_freqnomrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.freqnomrtg_ != nullptr) {
    delete _impl_.freqnomrtg_;
  }
  _impl_.freqnomrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_freqnomrtg() const {
  const ::commonmodule::ASG* p = _impl_.freqnomrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::freqnomrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.FreqNomRtg)
  return _internal_freqnomrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_freqnomrtg(
    ::commonmodule::ASG* freqnomrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.freqnomrtg_);
  }
  _impl_.freqnomrtg_ = freqnomrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.FreqNomRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_freqnomrtg() {
  
  ::commonmodule::ASG* temp = _impl_.freqnomrtg_;
  _impl_.freqnomrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_freqnomrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.FreqNomRtg)
  
  ::commonmodule::ASG* temp = _impl_.freqnomrtg_;
  _impl_.freqnomrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_freqnomrtg() {
  
  if (_impl_.freqnomrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.freqnomrtg_ = p;
  }
  return _impl_.freqnomrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_freqnomrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_freqnomrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.FreqNomRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_freqnomrtg(::commonmodule::ASG* freqnomrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.freqnomrtg_;
  }
  if (freqnomrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(freqnomrtg);
    if (message_arena != submessage_arena) {
      freqnomrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freqnomrtg, submessage_arena);
    }

  } else {

  }
  _impl_.freqnomrtg_ = freqnomrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.FreqNomRtg)
}

// .commonmodule.NorOpCatKind NorOpCatRtg = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void SourceCapabilityRatings::clear_noropcatrtg() {
  _impl_.noropcatrtg_ = 0;
}
inline ::commonmodule::NorOpCatKind SourceCapabilityRatings::noropcatrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.NorOpCatRtg)
  return _internal_noropcatrtg();
}
inline void SourceCapabilityRatings::set_noropcatrtg(::commonmodule::NorOpCatKind value) {
   _internal_set_noropcatrtg(value);
  // @@protoc_insertion_point(field_set:commonmodule.SourceCapabilityRatings.NorOpCatRtg)
}
inline ::commonmodule::NorOpCatKind SourceCapabilityRatings::_internal_noropcatrtg() const {
  return static_cast<::commonmodule::NorOpCatKind>(_impl_.noropcatrtg_);
}
inline void SourceCapabilityRatings::_internal_set_noropcatrtg(::commonmodule::NorOpCatKind value) {
  ;
  _impl_.noropcatrtg_ = value;
}

// .commonmodule.ASG ReactSusceptRtg = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_reactsusceptrtg() const {
  return this != internal_default_instance() && _impl_.reactsusceptrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_reactsusceptrtg() const {
  return _internal_has_reactsusceptrtg();
}
inline void SourceCapabilityRatings::clear_reactsusceptrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.reactsusceptrtg_ != nullptr) {
    delete _impl_.reactsusceptrtg_;
  }
  _impl_.reactsusceptrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_reactsusceptrtg() const {
  const ::commonmodule::ASG* p = _impl_.reactsusceptrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::reactsusceptrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.ReactSusceptRtg)
  return _internal_reactsusceptrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_reactsusceptrtg(
    ::commonmodule::ASG* reactsusceptrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactsusceptrtg_);
  }
  _impl_.reactsusceptrtg_ = reactsusceptrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.ReactSusceptRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_reactsusceptrtg() {
  
  ::commonmodule::ASG* temp = _impl_.reactsusceptrtg_;
  _impl_.reactsusceptrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_reactsusceptrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.ReactSusceptRtg)
  
  ::commonmodule::ASG* temp = _impl_.reactsusceptrtg_;
  _impl_.reactsusceptrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_reactsusceptrtg() {
  
  if (_impl_.reactsusceptrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.reactsusceptrtg_ = p;
  }
  return _impl_.reactsusceptrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_reactsusceptrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_reactsusceptrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.ReactSusceptRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_reactsusceptrtg(::commonmodule::ASG* reactsusceptrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reactsusceptrtg_;
  }
  if (reactsusceptrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reactsusceptrtg);
    if (message_arena != submessage_arena) {
      reactsusceptrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reactsusceptrtg, submessage_arena);
    }

  } else {

  }
  _impl_.reactsusceptrtg_ = reactsusceptrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.ReactSusceptRtg)
}

// .commonmodule.ASG VAMaxRtg = 7 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_vamaxrtg() const {
  return this != internal_default_instance() && _impl_.vamaxrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_vamaxrtg() const {
  return _internal_has_vamaxrtg();
}
inline void SourceCapabilityRatings::clear_vamaxrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.vamaxrtg_ != nullptr) {
    delete _impl_.vamaxrtg_;
  }
  _impl_.vamaxrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_vamaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.vamaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::vamaxrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.VAMaxRtg)
  return _internal_vamaxrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_vamaxrtg(
    ::commonmodule::ASG* vamaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vamaxrtg_);
  }
  _impl_.vamaxrtg_ = vamaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.VAMaxRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_vamaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.vamaxrtg_;
  _impl_.vamaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_vamaxrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.VAMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.vamaxrtg_;
  _impl_.vamaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_vamaxrtg() {
  
  if (_impl_.vamaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vamaxrtg_ = p;
  }
  return _impl_.vamaxrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_vamaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_vamaxrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.VAMaxRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_vamaxrtg(::commonmodule::ASG* vamaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vamaxrtg_;
  }
  if (vamaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vamaxrtg);
    if (message_arena != submessage_arena) {
      vamaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vamaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.vamaxrtg_ = vamaxrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.VAMaxRtg)
}

// .commonmodule.ASG VarMaxAbsRtg = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_varmaxabsrtg() const {
  return this != internal_default_instance() && _impl_.varmaxabsrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_varmaxabsrtg() const {
  return _internal_has_varmaxabsrtg();
}
inline void SourceCapabilityRatings::clear_varmaxabsrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxabsrtg_ != nullptr) {
    delete _impl_.varmaxabsrtg_;
  }
  _impl_.varmaxabsrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_varmaxabsrtg() const {
  const ::commonmodule::ASG* p = _impl_.varmaxabsrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::varmaxabsrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.VarMaxAbsRtg)
  return _internal_varmaxabsrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_varmaxabsrtg(
    ::commonmodule::ASG* varmaxabsrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varmaxabsrtg_);
  }
  _impl_.varmaxabsrtg_ = varmaxabsrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.VarMaxAbsRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_varmaxabsrtg() {
  
  ::commonmodule::ASG* temp = _impl_.varmaxabsrtg_;
  _impl_.varmaxabsrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_varmaxabsrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.VarMaxAbsRtg)
  
  ::commonmodule::ASG* temp = _impl_.varmaxabsrtg_;
  _impl_.varmaxabsrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_varmaxabsrtg() {
  
  if (_impl_.varmaxabsrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.varmaxabsrtg_ = p;
  }
  return _impl_.varmaxabsrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_varmaxabsrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_varmaxabsrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.VarMaxAbsRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_varmaxabsrtg(::commonmodule::ASG* varmaxabsrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.varmaxabsrtg_;
  }
  if (varmaxabsrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varmaxabsrtg);
    if (message_arena != submessage_arena) {
      varmaxabsrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varmaxabsrtg, submessage_arena);
    }

  } else {

  }
  _impl_.varmaxabsrtg_ = varmaxabsrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.VarMaxAbsRtg)
}

// .commonmodule.ASG VarMaxInjRtg = 9 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_varmaxinjrtg() const {
  return this != internal_default_instance() && _impl_.varmaxinjrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_varmaxinjrtg() const {
  return _internal_has_varmaxinjrtg();
}
inline void SourceCapabilityRatings::clear_varmaxinjrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.varmaxinjrtg_ != nullptr) {
    delete _impl_.varmaxinjrtg_;
  }
  _impl_.varmaxinjrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_varmaxinjrtg() const {
  const ::commonmodule::ASG* p = _impl_.varmaxinjrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::varmaxinjrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.VarMaxInjRtg)
  return _internal_varmaxinjrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_varmaxinjrtg(
    ::commonmodule::ASG* varmaxinjrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varmaxinjrtg_);
  }
  _impl_.varmaxinjrtg_ = varmaxinjrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.VarMaxInjRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_varmaxinjrtg() {
  
  ::commonmodule::ASG* temp = _impl_.varmaxinjrtg_;
  _impl_.varmaxinjrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_varmaxinjrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.VarMaxInjRtg)
  
  ::commonmodule::ASG* temp = _impl_.varmaxinjrtg_;
  _impl_.varmaxinjrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_varmaxinjrtg() {
  
  if (_impl_.varmaxinjrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.varmaxinjrtg_ = p;
  }
  return _impl_.varmaxinjrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_varmaxinjrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_varmaxinjrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.VarMaxInjRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_varmaxinjrtg(::commonmodule::ASG* varmaxinjrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.varmaxinjrtg_;
  }
  if (varmaxinjrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varmaxinjrtg);
    if (message_arena != submessage_arena) {
      varmaxinjrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varmaxinjrtg, submessage_arena);
    }

  } else {

  }
  _impl_.varmaxinjrtg_ = varmaxinjrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.VarMaxInjRtg)
}

// .commonmodule.ASG VMaxRtg = 10 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_vmaxrtg() const {
  return this != internal_default_instance() && _impl_.vmaxrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_vmaxrtg() const {
  return _internal_has_vmaxrtg();
}
inline void SourceCapabilityRatings::clear_vmaxrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.vmaxrtg_ != nullptr) {
    delete _impl_.vmaxrtg_;
  }
  _impl_.vmaxrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_vmaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.vmaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::vmaxrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.VMaxRtg)
  return _internal_vmaxrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_vmaxrtg(
    ::commonmodule::ASG* vmaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vmaxrtg_);
  }
  _impl_.vmaxrtg_ = vmaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.VMaxRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_vmaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.vmaxrtg_;
  _impl_.vmaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_vmaxrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.VMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.vmaxrtg_;
  _impl_.vmaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_vmaxrtg() {
  
  if (_impl_.vmaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vmaxrtg_ = p;
  }
  return _impl_.vmaxrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_vmaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_vmaxrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.VMaxRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_vmaxrtg(::commonmodule::ASG* vmaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vmaxrtg_;
  }
  if (vmaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vmaxrtg);
    if (message_arena != submessage_arena) {
      vmaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vmaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.vmaxrtg_ = vmaxrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.VMaxRtg)
}

// .commonmodule.ASG VMinRtg = 11 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_vminrtg() const {
  return this != internal_default_instance() && _impl_.vminrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_vminrtg() const {
  return _internal_has_vminrtg();
}
inline void SourceCapabilityRatings::clear_vminrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.vminrtg_ != nullptr) {
    delete _impl_.vminrtg_;
  }
  _impl_.vminrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_vminrtg() const {
  const ::commonmodule::ASG* p = _impl_.vminrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::vminrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.VMinRtg)
  return _internal_vminrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_vminrtg(
    ::commonmodule::ASG* vminrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vminrtg_);
  }
  _impl_.vminrtg_ = vminrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.VMinRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_vminrtg() {
  
  ::commonmodule::ASG* temp = _impl_.vminrtg_;
  _impl_.vminrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_vminrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.VMinRtg)
  
  ::commonmodule::ASG* temp = _impl_.vminrtg_;
  _impl_.vminrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_vminrtg() {
  
  if (_impl_.vminrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vminrtg_ = p;
  }
  return _impl_.vminrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_vminrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_vminrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.VMinRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_vminrtg(::commonmodule::ASG* vminrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vminrtg_;
  }
  if (vminrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vminrtg);
    if (message_arena != submessage_arena) {
      vminrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vminrtg, submessage_arena);
    }

  } else {

  }
  _impl_.vminrtg_ = vminrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.VMinRtg)
}

// .commonmodule.ASG VNomRtg = 12 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_vnomrtg() const {
  return this != internal_default_instance() && _impl_.vnomrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_vnomrtg() const {
  return _internal_has_vnomrtg();
}
inline void SourceCapabilityRatings::clear_vnomrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.vnomrtg_ != nullptr) {
    delete _impl_.vnomrtg_;
  }
  _impl_.vnomrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_vnomrtg() const {
  const ::commonmodule::ASG* p = _impl_.vnomrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::vnomrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.VNomRtg)
  return _internal_vnomrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_vnomrtg(
    ::commonmodule::ASG* vnomrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vnomrtg_);
  }
  _impl_.vnomrtg_ = vnomrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.VNomRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_vnomrtg() {
  
  ::commonmodule::ASG* temp = _impl_.vnomrtg_;
  _impl_.vnomrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_vnomrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.VNomRtg)
  
  ::commonmodule::ASG* temp = _impl_.vnomrtg_;
  _impl_.vnomrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_vnomrtg() {
  
  if (_impl_.vnomrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vnomrtg_ = p;
  }
  return _impl_.vnomrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_vnomrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_vnomrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.VNomRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_vnomrtg(::commonmodule::ASG* vnomrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vnomrtg_;
  }
  if (vnomrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vnomrtg);
    if (message_arena != submessage_arena) {
      vnomrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vnomrtg, submessage_arena);
    }

  } else {

  }
  _impl_.vnomrtg_ = vnomrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.VNomRtg)
}

// .commonmodule.ASG WMaxRtg = 13 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_wmaxrtg() const {
  return this != internal_default_instance() && _impl_.wmaxrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_wmaxrtg() const {
  return _internal_has_wmaxrtg();
}
inline void SourceCapabilityRatings::clear_wmaxrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.wmaxrtg_ != nullptr) {
    delete _impl_.wmaxrtg_;
  }
  _impl_.wmaxrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_wmaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.wmaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::wmaxrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.WMaxRtg)
  return _internal_wmaxrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_wmaxrtg(
    ::commonmodule::ASG* wmaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wmaxrtg_);
  }
  _impl_.wmaxrtg_ = wmaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.WMaxRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_wmaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.wmaxrtg_;
  _impl_.wmaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_wmaxrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.WMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.wmaxrtg_;
  _impl_.wmaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_wmaxrtg() {
  
  if (_impl_.wmaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wmaxrtg_ = p;
  }
  return _impl_.wmaxrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_wmaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_wmaxrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.WMaxRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_wmaxrtg(::commonmodule::ASG* wmaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wmaxrtg_;
  }
  if (wmaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wmaxrtg);
    if (message_arena != submessage_arena) {
      wmaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wmaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.wmaxrtg_ = wmaxrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.WMaxRtg)
}

// .commonmodule.ASG WOvrExtRtg = 14 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_wovrextrtg() const {
  return this != internal_default_instance() && _impl_.wovrextrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_wovrextrtg() const {
  return _internal_has_wovrextrtg();
}
inline void SourceCapabilityRatings::clear_wovrextrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.wovrextrtg_ != nullptr) {
    delete _impl_.wovrextrtg_;
  }
  _impl_.wovrextrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_wovrextrtg() const {
  const ::commonmodule::ASG* p = _impl_.wovrextrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::wovrextrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.WOvrExtRtg)
  return _internal_wovrextrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_wovrextrtg(
    ::commonmodule::ASG* wovrextrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wovrextrtg_);
  }
  _impl_.wovrextrtg_ = wovrextrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.WOvrExtRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_wovrextrtg() {
  
  ::commonmodule::ASG* temp = _impl_.wovrextrtg_;
  _impl_.wovrextrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_wovrextrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.WOvrExtRtg)
  
  ::commonmodule::ASG* temp = _impl_.wovrextrtg_;
  _impl_.wovrextrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_wovrextrtg() {
  
  if (_impl_.wovrextrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wovrextrtg_ = p;
  }
  return _impl_.wovrextrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_wovrextrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_wovrextrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.WOvrExtRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_wovrextrtg(::commonmodule::ASG* wovrextrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wovrextrtg_;
  }
  if (wovrextrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wovrextrtg);
    if (message_arena != submessage_arena) {
      wovrextrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wovrextrtg, submessage_arena);
    }

  } else {

  }
  _impl_.wovrextrtg_ = wovrextrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.WOvrExtRtg)
}

// .commonmodule.ASG WOvrExtRtgPF = 15 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_wovrextrtgpf() const {
  return this != internal_default_instance() && _impl_.wovrextrtgpf_ != nullptr;
}
inline bool SourceCapabilityRatings::has_wovrextrtgpf() const {
  return _internal_has_wovrextrtgpf();
}
inline void SourceCapabilityRatings::clear_wovrextrtgpf() {
  if (GetArenaForAllocation() == nullptr && _impl_.wovrextrtgpf_ != nullptr) {
    delete _impl_.wovrextrtgpf_;
  }
  _impl_.wovrextrtgpf_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_wovrextrtgpf() const {
  const ::commonmodule::ASG* p = _impl_.wovrextrtgpf_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::wovrextrtgpf() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.WOvrExtRtgPF)
  return _internal_wovrextrtgpf();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_wovrextrtgpf(
    ::commonmodule::ASG* wovrextrtgpf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wovrextrtgpf_);
  }
  _impl_.wovrextrtgpf_ = wovrextrtgpf;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.WOvrExtRtgPF)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_wovrextrtgpf() {
  
  ::commonmodule::ASG* temp = _impl_.wovrextrtgpf_;
  _impl_.wovrextrtgpf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_wovrextrtgpf() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.WOvrExtRtgPF)
  
  ::commonmodule::ASG* temp = _impl_.wovrextrtgpf_;
  _impl_.wovrextrtgpf_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_wovrextrtgpf() {
  
  if (_impl_.wovrextrtgpf_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wovrextrtgpf_ = p;
  }
  return _impl_.wovrextrtgpf_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_wovrextrtgpf() {
  ::commonmodule::ASG* _msg = _internal_mutable_wovrextrtgpf();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.WOvrExtRtgPF)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_wovrextrtgpf(::commonmodule::ASG* wovrextrtgpf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wovrextrtgpf_;
  }
  if (wovrextrtgpf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wovrextrtgpf);
    if (message_arena != submessage_arena) {
      wovrextrtgpf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wovrextrtgpf, submessage_arena);
    }

  } else {

  }
  _impl_.wovrextrtgpf_ = wovrextrtgpf;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.WOvrExtRtgPF)
}

// .commonmodule.ASG WUndExtRtg = 16 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_wundextrtg() const {
  return this != internal_default_instance() && _impl_.wundextrtg_ != nullptr;
}
inline bool SourceCapabilityRatings::has_wundextrtg() const {
  return _internal_has_wundextrtg();
}
inline void SourceCapabilityRatings::clear_wundextrtg() {
  if (GetArenaForAllocation() == nullptr && _impl_.wundextrtg_ != nullptr) {
    delete _impl_.wundextrtg_;
  }
  _impl_.wundextrtg_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_wundextrtg() const {
  const ::commonmodule::ASG* p = _impl_.wundextrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::wundextrtg() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.WUndExtRtg)
  return _internal_wundextrtg();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_wundextrtg(
    ::commonmodule::ASG* wundextrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wundextrtg_);
  }
  _impl_.wundextrtg_ = wundextrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.WUndExtRtg)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_wundextrtg() {
  
  ::commonmodule::ASG* temp = _impl_.wundextrtg_;
  _impl_.wundextrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_wundextrtg() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.WUndExtRtg)
  
  ::commonmodule::ASG* temp = _impl_.wundextrtg_;
  _impl_.wundextrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_wundextrtg() {
  
  if (_impl_.wundextrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wundextrtg_ = p;
  }
  return _impl_.wundextrtg_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_wundextrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_wundextrtg();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.WUndExtRtg)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_wundextrtg(::commonmodule::ASG* wundextrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wundextrtg_;
  }
  if (wundextrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wundextrtg);
    if (message_arena != submessage_arena) {
      wundextrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wundextrtg, submessage_arena);
    }

  } else {

  }
  _impl_.wundextrtg_ = wundextrtg;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.WUndExtRtg)
}

// .commonmodule.ASG WUndExtRtgPF = 17 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SourceCapabilityRatings::_internal_has_wundextrtgpf() const {
  return this != internal_default_instance() && _impl_.wundextrtgpf_ != nullptr;
}
inline bool SourceCapabilityRatings::has_wundextrtgpf() const {
  return _internal_has_wundextrtgpf();
}
inline void SourceCapabilityRatings::clear_wundextrtgpf() {
  if (GetArenaForAllocation() == nullptr && _impl_.wundextrtgpf_ != nullptr) {
    delete _impl_.wundextrtgpf_;
  }
  _impl_.wundextrtgpf_ = nullptr;
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::_internal_wundextrtgpf() const {
  const ::commonmodule::ASG* p = _impl_.wundextrtgpf_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& SourceCapabilityRatings::wundextrtgpf() const {
  // @@protoc_insertion_point(field_get:commonmodule.SourceCapabilityRatings.WUndExtRtgPF)
  return _internal_wundextrtgpf();
}
inline void SourceCapabilityRatings::unsafe_arena_set_allocated_wundextrtgpf(
    ::commonmodule::ASG* wundextrtgpf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wundextrtgpf_);
  }
  _impl_.wundextrtgpf_ = wundextrtgpf;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SourceCapabilityRatings.WUndExtRtgPF)
}
inline ::commonmodule::ASG* SourceCapabilityRatings::release_wundextrtgpf() {
  
  ::commonmodule::ASG* temp = _impl_.wundextrtgpf_;
  _impl_.wundextrtgpf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::unsafe_arena_release_wundextrtgpf() {
  // @@protoc_insertion_point(field_release:commonmodule.SourceCapabilityRatings.WUndExtRtgPF)
  
  ::commonmodule::ASG* temp = _impl_.wundextrtgpf_;
  _impl_.wundextrtgpf_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::_internal_mutable_wundextrtgpf() {
  
  if (_impl_.wundextrtgpf_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wundextrtgpf_ = p;
  }
  return _impl_.wundextrtgpf_;
}
inline ::commonmodule::ASG* SourceCapabilityRatings::mutable_wundextrtgpf() {
  ::commonmodule::ASG* _msg = _internal_mutable_wundextrtgpf();
  // @@protoc_insertion_point(field_mutable:commonmodule.SourceCapabilityRatings.WUndExtRtgPF)
  return _msg;
}
inline void SourceCapabilityRatings::set_allocated_wundextrtgpf(::commonmodule::ASG* wundextrtgpf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wundextrtgpf_;
  }
  if (wundextrtgpf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wundextrtgpf);
    if (message_arena != submessage_arena) {
      wundextrtgpf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wundextrtgpf, submessage_arena);
    }

  } else {

  }
  _impl_.wundextrtgpf_ = wundextrtgpf;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SourceCapabilityRatings.WUndExtRtgPF)
}

// -------------------------------------------------------------------

// StatusAndEventXCBR

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool StatusAndEventXCBR::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool StatusAndEventXCBR::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline void StatusAndEventXCBR::clear_logicalnodeforeventandstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnodeforeventandstatus_ != nullptr) {
    delete _impl_.logicalnodeforeventandstatus_;
  }
  _impl_.logicalnodeforeventandstatus_ = nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& StatusAndEventXCBR::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& StatusAndEventXCBR::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void StatusAndEventXCBR::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* StatusAndEventXCBR::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* StatusAndEventXCBR::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* StatusAndEventXCBR::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* StatusAndEventXCBR::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
  return _msg;
}
inline void StatusAndEventXCBR::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnodeforeventandstatus_;
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnodeforeventandstatus);
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool StatusAndEventXCBR::_internal_has_dynamictest() const {
  return this != internal_default_instance() && _impl_.dynamictest_ != nullptr;
}
inline bool StatusAndEventXCBR::has_dynamictest() const {
  return _internal_has_dynamictest();
}
inline void StatusAndEventXCBR::clear_dynamictest() {
  if (GetArenaForAllocation() == nullptr && _impl_.dynamictest_ != nullptr) {
    delete _impl_.dynamictest_;
  }
  _impl_.dynamictest_ = nullptr;
}
inline const ::commonmodule::ENS_DynamicTestKind& StatusAndEventXCBR::_internal_dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(
      ::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& StatusAndEventXCBR::dynamictest() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.DynamicTest)
  return _internal_dynamictest();
}
inline void StatusAndEventXCBR::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* dynamictest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusAndEventXCBR.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* StatusAndEventXCBR::release_dynamictest() {
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* StatusAndEventXCBR::unsafe_arena_release_dynamictest() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* StatusAndEventXCBR::_internal_mutable_dynamictest() {
  
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaForAllocation());
    _impl_.dynamictest_ = p;
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* StatusAndEventXCBR::mutable_dynamictest() {
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.DynamicTest)
  return _msg;
}
inline void StatusAndEventXCBR::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dynamictest_;
  }
  if (dynamictest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dynamictest);
    if (message_arena != submessage_arena) {
      dynamictest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }

  } else {

  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.DynamicTest)
}

// .commonmodule.PhaseDPS Pos = 3;
inline bool StatusAndEventXCBR::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool StatusAndEventXCBR::has_pos() const {
  return _internal_has_pos();
}
inline void StatusAndEventXCBR::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::commonmodule::PhaseDPS& StatusAndEventXCBR::_internal_pos() const {
  const ::commonmodule::PhaseDPS* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseDPS&>(
      ::commonmodule::_PhaseDPS_default_instance_);
}
inline const ::commonmodule::PhaseDPS& StatusAndEventXCBR::pos() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.Pos)
  return _internal_pos();
}
inline void StatusAndEventXCBR::unsafe_arena_set_allocated_pos(
    ::commonmodule::PhaseDPS* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusAndEventXCBR.Pos)
}
inline ::commonmodule::PhaseDPS* StatusAndEventXCBR::release_pos() {
  
  ::commonmodule::PhaseDPS* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseDPS* StatusAndEventXCBR::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.Pos)
  
  ::commonmodule::PhaseDPS* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseDPS* StatusAndEventXCBR::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseDPS>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::commonmodule::PhaseDPS* StatusAndEventXCBR::mutable_pos() {
  ::commonmodule::PhaseDPS* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.Pos)
  return _msg;
}
inline void StatusAndEventXCBR::set_allocated_pos(::commonmodule::PhaseDPS* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }

  } else {

  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.Pos)
}

// .commonmodule.ACD ProtectionPickup = 4;
inline bool StatusAndEventXCBR::_internal_has_protectionpickup() const {
  return this != internal_default_instance() && _impl_.protectionpickup_ != nullptr;
}
inline bool StatusAndEventXCBR::has_protectionpickup() const {
  return _internal_has_protectionpickup();
}
inline void StatusAndEventXCBR::clear_protectionpickup() {
  if (GetArenaForAllocation() == nullptr && _impl_.protectionpickup_ != nullptr) {
    delete _impl_.protectionpickup_;
  }
  _impl_.protectionpickup_ = nullptr;
}
inline const ::commonmodule::ACD& StatusAndEventXCBR::_internal_protectionpickup() const {
  const ::commonmodule::ACD* p = _impl_.protectionpickup_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ACD&>(
      ::commonmodule::_ACD_default_instance_);
}
inline const ::commonmodule::ACD& StatusAndEventXCBR::protectionpickup() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.ProtectionPickup)
  return _internal_protectionpickup();
}
inline void StatusAndEventXCBR::unsafe_arena_set_allocated_protectionpickup(
    ::commonmodule::ACD* protectionpickup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectionpickup_);
  }
  _impl_.protectionpickup_ = protectionpickup;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusAndEventXCBR.ProtectionPickup)
}
inline ::commonmodule::ACD* StatusAndEventXCBR::release_protectionpickup() {
  
  ::commonmodule::ACD* temp = _impl_.protectionpickup_;
  _impl_.protectionpickup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ACD* StatusAndEventXCBR::unsafe_arena_release_protectionpickup() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.ProtectionPickup)
  
  ::commonmodule::ACD* temp = _impl_.protectionpickup_;
  _impl_.protectionpickup_ = nullptr;
  return temp;
}
inline ::commonmodule::ACD* StatusAndEventXCBR::_internal_mutable_protectionpickup() {
  
  if (_impl_.protectionpickup_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ACD>(GetArenaForAllocation());
    _impl_.protectionpickup_ = p;
  }
  return _impl_.protectionpickup_;
}
inline ::commonmodule::ACD* StatusAndEventXCBR::mutable_protectionpickup() {
  ::commonmodule::ACD* _msg = _internal_mutable_protectionpickup();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.ProtectionPickup)
  return _msg;
}
inline void StatusAndEventXCBR::set_allocated_protectionpickup(::commonmodule::ACD* protectionpickup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protectionpickup_;
  }
  if (protectionpickup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protectionpickup);
    if (message_arena != submessage_arena) {
      protectionpickup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectionpickup, submessage_arena);
    }

  } else {

  }
  _impl_.protectionpickup_ = protectionpickup;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.ProtectionPickup)
}

// .commonmodule.StatusINS ProtectionMode = 5;
inline bool StatusAndEventXCBR::_internal_has_protectionmode() const {
  return this != internal_default_instance() && _impl_.protectionmode_ != nullptr;
}
inline bool StatusAndEventXCBR::has_protectionmode() const {
  return _internal_has_protectionmode();
}
inline void StatusAndEventXCBR::clear_protectionmode() {
  if (GetArenaForAllocation() == nullptr && _impl_.protectionmode_ != nullptr) {
    delete _impl_.protectionmode_;
  }
  _impl_.protectionmode_ = nullptr;
}
inline const ::commonmodule::StatusINS& StatusAndEventXCBR::_internal_protectionmode() const {
  const ::commonmodule::StatusINS* p = _impl_.protectionmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINS&>(
      ::commonmodule::_StatusINS_default_instance_);
}
inline const ::commonmodule::StatusINS& StatusAndEventXCBR::protectionmode() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.ProtectionMode)
  return _internal_protectionmode();
}
inline void StatusAndEventXCBR::unsafe_arena_set_allocated_protectionmode(
    ::commonmodule::StatusINS* protectionmode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protectionmode_);
  }
  _impl_.protectionmode_ = protectionmode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusAndEventXCBR.ProtectionMode)
}
inline ::commonmodule::StatusINS* StatusAndEventXCBR::release_protectionmode() {
  
  ::commonmodule::StatusINS* temp = _impl_.protectionmode_;
  _impl_.protectionmode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusINS* StatusAndEventXCBR::unsafe_arena_release_protectionmode() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.ProtectionMode)
  
  ::commonmodule::StatusINS* temp = _impl_.protectionmode_;
  _impl_.protectionmode_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINS* StatusAndEventXCBR::_internal_mutable_protectionmode() {
  
  if (_impl_.protectionmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINS>(GetArenaForAllocation());
    _impl_.protectionmode_ = p;
  }
  return _impl_.protectionmode_;
}
inline ::commonmodule::StatusINS* StatusAndEventXCBR::mutable_protectionmode() {
  ::commonmodule::StatusINS* _msg = _internal_mutable_protectionmode();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.ProtectionMode)
  return _msg;
}
inline void StatusAndEventXCBR::set_allocated_protectionmode(::commonmodule::StatusINS* protectionmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protectionmode_;
  }
  if (protectionmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protectionmode);
    if (message_arena != submessage_arena) {
      protectionmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protectionmode, submessage_arena);
    }

  } else {

  }
  _impl_.protectionmode_ = protectionmode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.ProtectionMode)
}

// .commonmodule.PhaseSPS RecloseEnabled = 6;
inline bool StatusAndEventXCBR::_internal_has_recloseenabled() const {
  return this != internal_default_instance() && _impl_.recloseenabled_ != nullptr;
}
inline bool StatusAndEventXCBR::has_recloseenabled() const {
  return _internal_has_recloseenabled();
}
inline void StatusAndEventXCBR::clear_recloseenabled() {
  if (GetArenaForAllocation() == nullptr && _impl_.recloseenabled_ != nullptr) {
    delete _impl_.recloseenabled_;
  }
  _impl_.recloseenabled_ = nullptr;
}
inline const ::commonmodule::PhaseSPS& StatusAndEventXCBR::_internal_recloseenabled() const {
  const ::commonmodule::PhaseSPS* p = _impl_.recloseenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& StatusAndEventXCBR::recloseenabled() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.RecloseEnabled)
  return _internal_recloseenabled();
}
inline void StatusAndEventXCBR::unsafe_arena_set_allocated_recloseenabled(
    ::commonmodule::PhaseSPS* recloseenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recloseenabled_);
  }
  _impl_.recloseenabled_ = recloseenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusAndEventXCBR.RecloseEnabled)
}
inline ::commonmodule::PhaseSPS* StatusAndEventXCBR::release_recloseenabled() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.recloseenabled_;
  _impl_.recloseenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* StatusAndEventXCBR::unsafe_arena_release_recloseenabled() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.RecloseEnabled)
  
  ::commonmodule::PhaseSPS* temp = _impl_.recloseenabled_;
  _impl_.recloseenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* StatusAndEventXCBR::_internal_mutable_recloseenabled() {
  
  if (_impl_.recloseenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.recloseenabled_ = p;
  }
  return _impl_.recloseenabled_;
}
inline ::commonmodule::PhaseSPS* StatusAndEventXCBR::mutable_recloseenabled() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_recloseenabled();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.RecloseEnabled)
  return _msg;
}
inline void StatusAndEventXCBR::set_allocated_recloseenabled(::commonmodule::PhaseSPS* recloseenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recloseenabled_;
  }
  if (recloseenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recloseenabled);
    if (message_arena != submessage_arena) {
      recloseenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recloseenabled, submessage_arena);
    }

  } else {

  }
  _impl_.recloseenabled_ = recloseenabled;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.RecloseEnabled)
}

// .commonmodule.PhaseRecloseAction ReclosingAction = 7;
inline bool StatusAndEventXCBR::_internal_has_reclosingaction() const {
  return this != internal_default_instance() && _impl_.reclosingaction_ != nullptr;
}
inline bool StatusAndEventXCBR::has_reclosingaction() const {
  return _internal_has_reclosingaction();
}
inline void StatusAndEventXCBR::clear_reclosingaction() {
  if (GetArenaForAllocation() == nullptr && _impl_.reclosingaction_ != nullptr) {
    delete _impl_.reclosingaction_;
  }
  _impl_.reclosingaction_ = nullptr;
}
inline const ::commonmodule::PhaseRecloseAction& StatusAndEventXCBR::_internal_reclosingaction() const {
  const ::commonmodule::PhaseRecloseAction* p = _impl_.reclosingaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseRecloseAction&>(
      ::commonmodule::_PhaseRecloseAction_default_instance_);
}
inline const ::commonmodule::PhaseRecloseAction& StatusAndEventXCBR::reclosingaction() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusAndEventXCBR.ReclosingAction)
  return _internal_reclosingaction();
}
inline void StatusAndEventXCBR::unsafe_arena_set_allocated_reclosingaction(
    ::commonmodule::PhaseRecloseAction* reclosingaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reclosingaction_);
  }
  _impl_.reclosingaction_ = reclosingaction;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusAndEventXCBR.ReclosingAction)
}
inline ::commonmodule::PhaseRecloseAction* StatusAndEventXCBR::release_reclosingaction() {
  
  ::commonmodule::PhaseRecloseAction* temp = _impl_.reclosingaction_;
  _impl_.reclosingaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseRecloseAction* StatusAndEventXCBR::unsafe_arena_release_reclosingaction() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusAndEventXCBR.ReclosingAction)
  
  ::commonmodule::PhaseRecloseAction* temp = _impl_.reclosingaction_;
  _impl_.reclosingaction_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseRecloseAction* StatusAndEventXCBR::_internal_mutable_reclosingaction() {
  
  if (_impl_.reclosingaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseRecloseAction>(GetArenaForAllocation());
    _impl_.reclosingaction_ = p;
  }
  return _impl_.reclosingaction_;
}
inline ::commonmodule::PhaseRecloseAction* StatusAndEventXCBR::mutable_reclosingaction() {
  ::commonmodule::PhaseRecloseAction* _msg = _internal_mutable_reclosingaction();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusAndEventXCBR.ReclosingAction)
  return _msg;
}
inline void StatusAndEventXCBR::set_allocated_reclosingaction(::commonmodule::PhaseRecloseAction* reclosingaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reclosingaction_;
  }
  if (reclosingaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reclosingaction);
    if (message_arena != submessage_arena) {
      reclosingaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reclosingaction, submessage_arena);
    }

  } else {

  }
  _impl_.reclosingaction_ = reclosingaction;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusAndEventXCBR.ReclosingAction)
}

// -------------------------------------------------------------------

// StatusINC

// .commonmodule.Quality q = 1;
inline bool StatusINC::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool StatusINC::has_q() const {
  return _internal_has_q();
}
inline void StatusINC::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusINC::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& StatusINC::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusINC.q)
  return _internal_q();
}
inline void StatusINC::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusINC.q)
}
inline ::commonmodule::Quality* StatusINC::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* StatusINC::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusINC.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusINC::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* StatusINC::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusINC.q)
  return _msg;
}
inline void StatusINC::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusINC.q)
}

// int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusINC::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::int32_t StatusINC::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusINC.stVal)
  return _internal_stval();
}
inline void StatusINC::set_stval(::int32_t value) {
  _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.StatusINC.stVal)
}
inline ::int32_t StatusINC::_internal_stval() const {
  return _impl_.stval_;
}
inline void StatusINC::_internal_set_stval(::int32_t value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool StatusINC::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool StatusINC::has_t() const {
  return _internal_has_t();
}
inline void StatusINC::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusINC::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& StatusINC::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusINC.t)
  return _internal_t();
}
inline void StatusINC::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusINC.t)
}
inline ::commonmodule::Timestamp* StatusINC::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* StatusINC::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusINC.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusINC::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* StatusINC::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusINC.t)
  return _msg;
}
inline void StatusINC::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusINC.t)
}

// -------------------------------------------------------------------

// StatusISC

// .commonmodule.Quality q = 1;
inline bool StatusISC::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool StatusISC::has_q() const {
  return _internal_has_q();
}
inline void StatusISC::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& StatusISC::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& StatusISC::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusISC.q)
  return _internal_q();
}
inline void StatusISC::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusISC.q)
}
inline ::commonmodule::Quality* StatusISC::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* StatusISC::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusISC.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* StatusISC::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* StatusISC::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusISC.q)
  return _msg;
}
inline void StatusISC::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusISC.q)
}

// int32 stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void StatusISC::clear_stval() {
  _impl_.stval_ = 0;
}
inline ::int32_t StatusISC::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusISC.stVal)
  return _internal_stval();
}
inline void StatusISC::set_stval(::int32_t value) {
  _internal_set_stval(value);
  // @@protoc_insertion_point(field_set:commonmodule.StatusISC.stVal)
}
inline ::int32_t StatusISC::_internal_stval() const {
  return _impl_.stval_;
}
inline void StatusISC::_internal_set_stval(::int32_t value) {
  ;
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool StatusISC::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool StatusISC::has_t() const {
  return _internal_has_t();
}
inline void StatusISC::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& StatusISC::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& StatusISC::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusISC.t)
  return _internal_t();
}
inline void StatusISC::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusISC.t)
}
inline ::commonmodule::Timestamp* StatusISC::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* StatusISC::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusISC.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* StatusISC::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* StatusISC::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusISC.t)
  return _msg;
}
inline void StatusISC::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusISC.t)
}

// -------------------------------------------------------------------

// StatusMessageInfo

// .commonmodule.MessageInfo messageInfo = 1 [(.uml.option_parent_message) = true];
inline bool StatusMessageInfo::_internal_has_messageinfo() const {
  return this != internal_default_instance() && _impl_.messageinfo_ != nullptr;
}
inline bool StatusMessageInfo::has_messageinfo() const {
  return _internal_has_messageinfo();
}
inline void StatusMessageInfo::clear_messageinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.messageinfo_ != nullptr) {
    delete _impl_.messageinfo_;
  }
  _impl_.messageinfo_ = nullptr;
}
inline const ::commonmodule::MessageInfo& StatusMessageInfo::_internal_messageinfo() const {
  const ::commonmodule::MessageInfo* p = _impl_.messageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MessageInfo&>(
      ::commonmodule::_MessageInfo_default_instance_);
}
inline const ::commonmodule::MessageInfo& StatusMessageInfo::messageinfo() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusMessageInfo.messageInfo)
  return _internal_messageinfo();
}
inline void StatusMessageInfo::unsafe_arena_set_allocated_messageinfo(
    ::commonmodule::MessageInfo* messageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messageinfo_);
  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusMessageInfo.messageInfo)
}
inline ::commonmodule::MessageInfo* StatusMessageInfo::release_messageinfo() {
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MessageInfo* StatusMessageInfo::unsafe_arena_release_messageinfo() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusMessageInfo.messageInfo)
  
  ::commonmodule::MessageInfo* temp = _impl_.messageinfo_;
  _impl_.messageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::MessageInfo* StatusMessageInfo::_internal_mutable_messageinfo() {
  
  if (_impl_.messageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MessageInfo>(GetArenaForAllocation());
    _impl_.messageinfo_ = p;
  }
  return _impl_.messageinfo_;
}
inline ::commonmodule::MessageInfo* StatusMessageInfo::mutable_messageinfo() {
  ::commonmodule::MessageInfo* _msg = _internal_mutable_messageinfo();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusMessageInfo.messageInfo)
  return _msg;
}
inline void StatusMessageInfo::set_allocated_messageinfo(::commonmodule::MessageInfo* messageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messageinfo_;
  }
  if (messageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messageinfo);
    if (message_arena != submessage_arena) {
      messageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.messageinfo_ = messageinfo;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusMessageInfo.messageInfo)
}

// -------------------------------------------------------------------

// StatusValue

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool StatusValue::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool StatusValue::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline void StatusValue::clear_identifiedobject() {
  if (GetArenaForAllocation() == nullptr && _impl_.identifiedobject_ != nullptr) {
    delete _impl_.identifiedobject_;
  }
  _impl_.identifiedobject_ = nullptr;
}
inline const ::commonmodule::IdentifiedObject& StatusValue::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& StatusValue::identifiedobject() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusValue.identifiedObject)
  return _internal_identifiedobject();
}
inline void StatusValue::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusValue.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* StatusValue::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* StatusValue::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusValue.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* StatusValue::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* StatusValue::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusValue.identifiedObject)
  return _msg;
}
inline void StatusValue::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifiedobject_;
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifiedobject);
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusValue.identifiedObject)
}

// .google.protobuf.BoolValue modBlk = 2;
inline bool StatusValue::_internal_has_modblk() const {
  return this != internal_default_instance() && _impl_.modblk_ != nullptr;
}
inline bool StatusValue::has_modblk() const {
  return _internal_has_modblk();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& StatusValue::_internal_modblk() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.modblk_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& StatusValue::modblk() const {
  // @@protoc_insertion_point(field_get:commonmodule.StatusValue.modBlk)
  return _internal_modblk();
}
inline void StatusValue::unsafe_arena_set_allocated_modblk(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* modblk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modblk_);
  }
  _impl_.modblk_ = modblk;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StatusValue.modBlk)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StatusValue::release_modblk() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.modblk_;
  _impl_.modblk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StatusValue::unsafe_arena_release_modblk() {
  // @@protoc_insertion_point(field_release:commonmodule.StatusValue.modBlk)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.modblk_;
  _impl_.modblk_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StatusValue::_internal_mutable_modblk() {
  
  if (_impl_.modblk_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.modblk_ = p;
  }
  return _impl_.modblk_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* StatusValue::mutable_modblk() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_modblk();
  // @@protoc_insertion_point(field_mutable:commonmodule.StatusValue.modBlk)
  return _msg;
}
inline void StatusValue::set_allocated_modblk(::PROTOBUF_NAMESPACE_ID::BoolValue* modblk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.modblk_);
  }
  if (modblk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modblk));
    if (message_arena != submessage_arena) {
      modblk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modblk, submessage_arena);
    }

  } else {

  }
  _impl_.modblk_ = modblk;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StatusValue.modBlk)
}

// -------------------------------------------------------------------

// VSS

// .commonmodule.Quality q = 1;
inline bool VSS::_internal_has_q() const {
  return this != internal_default_instance() && _impl_.q_ != nullptr;
}
inline bool VSS::has_q() const {
  return _internal_has_q();
}
inline void VSS::clear_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.q_ != nullptr) {
    delete _impl_.q_;
  }
  _impl_.q_ = nullptr;
}
inline const ::commonmodule::Quality& VSS::_internal_q() const {
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(
      ::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& VSS::q() const {
  // @@protoc_insertion_point(field_get:commonmodule.VSS.q)
  return _internal_q();
}
inline void VSS::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.VSS.q)
}
inline ::commonmodule::Quality* VSS::release_q() {
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Quality* VSS::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:commonmodule.VSS.q)
  
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* VSS::_internal_mutable_q() {
  
  if (_impl_.q_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Quality>(GetArenaForAllocation());
    _impl_.q_ = p;
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* VSS::mutable_q() {
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:commonmodule.VSS.q)
  return _msg;
}
inline void VSS::set_allocated_q(::commonmodule::Quality* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.q_;
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(q);
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }

  } else {

  }
  _impl_.q_ = q;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VSS.q)
}

// string stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VSS::clear_stval() {
  _impl_.stval_.ClearToEmpty();
}
inline const std::string& VSS::stval() const {
  // @@protoc_insertion_point(field_get:commonmodule.VSS.stVal)
  return _internal_stval();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VSS::set_stval(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.stval_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commonmodule.VSS.stVal)
}
inline std::string* VSS::mutable_stval() {
  std::string* _s = _internal_mutable_stval();
  // @@protoc_insertion_point(field_mutable:commonmodule.VSS.stVal)
  return _s;
}
inline const std::string& VSS::_internal_stval() const {
  return _impl_.stval_.Get();
}
inline void VSS::_internal_set_stval(const std::string& value) {
  ;


  _impl_.stval_.Set(value, GetArenaForAllocation());
}
inline std::string* VSS::_internal_mutable_stval() {
  ;
  return _impl_.stval_.Mutable( GetArenaForAllocation());
}
inline std::string* VSS::release_stval() {
  // @@protoc_insertion_point(field_release:commonmodule.VSS.stVal)
  return _impl_.stval_.Release();
}
inline void VSS::set_allocated_stval(std::string* value) {
  _impl_.stval_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stval_.IsDefault()) {
          _impl_.stval_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VSS.stVal)
}

// .commonmodule.Timestamp t = 3;
inline bool VSS::_internal_has_t() const {
  return this != internal_default_instance() && _impl_.t_ != nullptr;
}
inline bool VSS::has_t() const {
  return _internal_has_t();
}
inline void VSS::clear_t() {
  if (GetArenaForAllocation() == nullptr && _impl_.t_ != nullptr) {
    delete _impl_.t_;
  }
  _impl_.t_ = nullptr;
}
inline const ::commonmodule::Timestamp& VSS::_internal_t() const {
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& VSS::t() const {
  // @@protoc_insertion_point(field_get:commonmodule.VSS.t)
  return _internal_t();
}
inline void VSS::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.VSS.t)
}
inline ::commonmodule::Timestamp* VSS::release_t() {
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* VSS::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:commonmodule.VSS.t)
  
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* VSS::_internal_mutable_t() {
  
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.t_ = p;
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* VSS::mutable_t() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:commonmodule.VSS.t)
  return _msg;
}
inline void VSS::set_allocated_t(::commonmodule::Timestamp* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(t);
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }

  } else {

  }
  _impl_.t_ = t;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VSS.t)
}

// -------------------------------------------------------------------

// StringEventAndStatusGGIO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool StringEventAndStatusGGIO::_internal_has_logicalnode() const {
  return this != internal_default_instance() && _impl_.logicalnode_ != nullptr;
}
inline bool StringEventAndStatusGGIO::has_logicalnode() const {
  return _internal_has_logicalnode();
}
inline void StringEventAndStatusGGIO::clear_logicalnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.logicalnode_ != nullptr) {
    delete _impl_.logicalnode_;
  }
  _impl_.logicalnode_ = nullptr;
}
inline const ::commonmodule::LogicalNode& StringEventAndStatusGGIO::_internal_logicalnode() const {
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(
      ::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& StringEventAndStatusGGIO::logicalnode() const {
  // @@protoc_insertion_point(field_get:commonmodule.StringEventAndStatusGGIO.logicalNode)
  return _internal_logicalnode();
}
inline void StringEventAndStatusGGIO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* logicalnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StringEventAndStatusGGIO.logicalNode)
}
inline ::commonmodule::LogicalNode* StringEventAndStatusGGIO::release_logicalnode() {
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNode* StringEventAndStatusGGIO::unsafe_arena_release_logicalnode() {
  // @@protoc_insertion_point(field_release:commonmodule.StringEventAndStatusGGIO.logicalNode)
  
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* StringEventAndStatusGGIO::_internal_mutable_logicalnode() {
  
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNode>(GetArenaForAllocation());
    _impl_.logicalnode_ = p;
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* StringEventAndStatusGGIO::mutable_logicalnode() {
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:commonmodule.StringEventAndStatusGGIO.logicalNode)
  return _msg;
}
inline void StringEventAndStatusGGIO::set_allocated_logicalnode(::commonmodule::LogicalNode* logicalnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logicalnode_;
  }
  if (logicalnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logicalnode);
    if (message_arena != submessage_arena) {
      logicalnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnode, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnode_ = logicalnode;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StringEventAndStatusGGIO.logicalNode)
}

// .commonmodule.Optional_PhaseCodeKind Phase = 2;
inline bool StringEventAndStatusGGIO::_internal_has_phase() const {
  return this != internal_default_instance() && _impl_.phase_ != nullptr;
}
inline bool StringEventAndStatusGGIO::has_phase() const {
  return _internal_has_phase();
}
inline void StringEventAndStatusGGIO::clear_phase() {
  if (GetArenaForAllocation() == nullptr && _impl_.phase_ != nullptr) {
    delete _impl_.phase_;
  }
  _impl_.phase_ = nullptr;
}
inline const ::commonmodule::Optional_PhaseCodeKind& StringEventAndStatusGGIO::_internal_phase() const {
  const ::commonmodule::Optional_PhaseCodeKind* p = _impl_.phase_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_PhaseCodeKind&>(
      ::commonmodule::_Optional_PhaseCodeKind_default_instance_);
}
inline const ::commonmodule::Optional_PhaseCodeKind& StringEventAndStatusGGIO::phase() const {
  // @@protoc_insertion_point(field_get:commonmodule.StringEventAndStatusGGIO.Phase)
  return _internal_phase();
}
inline void StringEventAndStatusGGIO::unsafe_arena_set_allocated_phase(
    ::commonmodule::Optional_PhaseCodeKind* phase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phase_);
  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StringEventAndStatusGGIO.Phase)
}
inline ::commonmodule::Optional_PhaseCodeKind* StringEventAndStatusGGIO::release_phase() {
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* StringEventAndStatusGGIO::unsafe_arena_release_phase() {
  // @@protoc_insertion_point(field_release:commonmodule.StringEventAndStatusGGIO.Phase)
  
  ::commonmodule::Optional_PhaseCodeKind* temp = _impl_.phase_;
  _impl_.phase_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_PhaseCodeKind* StringEventAndStatusGGIO::_internal_mutable_phase() {
  
  if (_impl_.phase_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_PhaseCodeKind>(GetArenaForAllocation());
    _impl_.phase_ = p;
  }
  return _impl_.phase_;
}
inline ::commonmodule::Optional_PhaseCodeKind* StringEventAndStatusGGIO::mutable_phase() {
  ::commonmodule::Optional_PhaseCodeKind* _msg = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:commonmodule.StringEventAndStatusGGIO.Phase)
  return _msg;
}
inline void StringEventAndStatusGGIO::set_allocated_phase(::commonmodule::Optional_PhaseCodeKind* phase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.phase_;
  }
  if (phase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(phase);
    if (message_arena != submessage_arena) {
      phase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phase, submessage_arena);
    }

  } else {

  }
  _impl_.phase_ = phase;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StringEventAndStatusGGIO.Phase)
}

// .commonmodule.VSS StrIn = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool StringEventAndStatusGGIO::_internal_has_strin() const {
  return this != internal_default_instance() && _impl_.strin_ != nullptr;
}
inline bool StringEventAndStatusGGIO::has_strin() const {
  return _internal_has_strin();
}
inline void StringEventAndStatusGGIO::clear_strin() {
  if (GetArenaForAllocation() == nullptr && _impl_.strin_ != nullptr) {
    delete _impl_.strin_;
  }
  _impl_.strin_ = nullptr;
}
inline const ::commonmodule::VSS& StringEventAndStatusGGIO::_internal_strin() const {
  const ::commonmodule::VSS* p = _impl_.strin_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VSS&>(
      ::commonmodule::_VSS_default_instance_);
}
inline const ::commonmodule::VSS& StringEventAndStatusGGIO::strin() const {
  // @@protoc_insertion_point(field_get:commonmodule.StringEventAndStatusGGIO.StrIn)
  return _internal_strin();
}
inline void StringEventAndStatusGGIO::unsafe_arena_set_allocated_strin(
    ::commonmodule::VSS* strin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.strin_);
  }
  _impl_.strin_ = strin;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.StringEventAndStatusGGIO.StrIn)
}
inline ::commonmodule::VSS* StringEventAndStatusGGIO::release_strin() {
  
  ::commonmodule::VSS* temp = _impl_.strin_;
  _impl_.strin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VSS* StringEventAndStatusGGIO::unsafe_arena_release_strin() {
  // @@protoc_insertion_point(field_release:commonmodule.StringEventAndStatusGGIO.StrIn)
  
  ::commonmodule::VSS* temp = _impl_.strin_;
  _impl_.strin_ = nullptr;
  return temp;
}
inline ::commonmodule::VSS* StringEventAndStatusGGIO::_internal_mutable_strin() {
  
  if (_impl_.strin_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VSS>(GetArenaForAllocation());
    _impl_.strin_ = p;
  }
  return _impl_.strin_;
}
inline ::commonmodule::VSS* StringEventAndStatusGGIO::mutable_strin() {
  ::commonmodule::VSS* _msg = _internal_mutable_strin();
  // @@protoc_insertion_point(field_mutable:commonmodule.StringEventAndStatusGGIO.StrIn)
  return _msg;
}
inline void StringEventAndStatusGGIO::set_allocated_strin(::commonmodule::VSS* strin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.strin_;
  }
  if (strin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(strin);
    if (message_arena != submessage_arena) {
      strin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strin, submessage_arena);
    }

  } else {

  }
  _impl_.strin_ = strin;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.StringEventAndStatusGGIO.StrIn)
}

// -------------------------------------------------------------------

// SwitchPoint

// .commonmodule.ControlDPC Pos = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchPoint::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool SwitchPoint::has_pos() const {
  return _internal_has_pos();
}
inline void SwitchPoint::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::commonmodule::ControlDPC& SwitchPoint::_internal_pos() const {
  const ::commonmodule::ControlDPC* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlDPC&>(
      ::commonmodule::_ControlDPC_default_instance_);
}
inline const ::commonmodule::ControlDPC& SwitchPoint::pos() const {
  // @@protoc_insertion_point(field_get:commonmodule.SwitchPoint.Pos)
  return _internal_pos();
}
inline void SwitchPoint::unsafe_arena_set_allocated_pos(
    ::commonmodule::ControlDPC* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SwitchPoint.Pos)
}
inline ::commonmodule::ControlDPC* SwitchPoint::release_pos() {
  
  ::commonmodule::ControlDPC* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlDPC* SwitchPoint::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:commonmodule.SwitchPoint.Pos)
  
  ::commonmodule::ControlDPC* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* SwitchPoint::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::commonmodule::ControlDPC* SwitchPoint::mutable_pos() {
  ::commonmodule::ControlDPC* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:commonmodule.SwitchPoint.Pos)
  return _msg;
}
inline void SwitchPoint::set_allocated_pos(::commonmodule::ControlDPC* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }

  } else {

  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SwitchPoint.Pos)
}

// .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool SwitchPoint::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool SwitchPoint::has_starttime() const {
  return _internal_has_starttime();
}
inline void SwitchPoint::clear_starttime() {
  if (GetArenaForAllocation() == nullptr && _impl_.starttime_ != nullptr) {
    delete _impl_.starttime_;
  }
  _impl_.starttime_ = nullptr;
}
inline const ::commonmodule::ControlTimestamp& SwitchPoint::_internal_starttime() const {
  const ::commonmodule::ControlTimestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlTimestamp&>(
      ::commonmodule::_ControlTimestamp_default_instance_);
}
inline const ::commonmodule::ControlTimestamp& SwitchPoint::starttime() const {
  // @@protoc_insertion_point(field_get:commonmodule.SwitchPoint.startTime)
  return _internal_starttime();
}
inline void SwitchPoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::ControlTimestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.SwitchPoint.startTime)
}
inline ::commonmodule::ControlTimestamp* SwitchPoint::release_starttime() {
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlTimestamp* SwitchPoint::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:commonmodule.SwitchPoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* SwitchPoint::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::commonmodule::ControlTimestamp* SwitchPoint::mutable_starttime() {
  ::commonmodule::ControlTimestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:commonmodule.SwitchPoint.startTime)
  return _msg;
}
inline void SwitchPoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.starttime_;
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(starttime);
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }

  } else {

  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.SwitchPoint.startTime)
}

// -------------------------------------------------------------------

// SwitchCSG

// repeated .commonmodule.SwitchPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int SwitchCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int SwitchCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void SwitchCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::commonmodule::SwitchPoint* SwitchCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.SwitchCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SwitchPoint >*
SwitchCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.SwitchCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::commonmodule::SwitchPoint& SwitchCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::commonmodule::SwitchPoint& SwitchCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.SwitchCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::commonmodule::SwitchPoint* SwitchCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::commonmodule::SwitchPoint* SwitchCSG::add_crvpts() {
  ::commonmodule::SwitchPoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:commonmodule.SwitchCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::SwitchPoint >&
SwitchCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.SwitchCSG.crvPts)
  return _impl_.crvpts_;
}

// -------------------------------------------------------------------

// TmHzPoint

// float hzVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TmHzPoint::clear_hzval() {
  _impl_.hzval_ = 0;
}
inline float TmHzPoint::hzval() const {
  // @@protoc_insertion_point(field_get:commonmodule.TmHzPoint.hzVal)
  return _internal_hzval();
}
inline void TmHzPoint::set_hzval(float value) {
  _internal_set_hzval(value);
  // @@protoc_insertion_point(field_set:commonmodule.TmHzPoint.hzVal)
}
inline float TmHzPoint::_internal_hzval() const {
  return _impl_.hzval_;
}
inline void TmHzPoint::_internal_set_hzval(float value) {
  ;
  _impl_.hzval_ = value;
}

// .commonmodule.ClearingTime tmVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool TmHzPoint::_internal_has_tmval() const {
  return this != internal_default_instance() && _impl_.tmval_ != nullptr;
}
inline bool TmHzPoint::has_tmval() const {
  return _internal_has_tmval();
}
inline void TmHzPoint::clear_tmval() {
  if (GetArenaForAllocation() == nullptr && _impl_.tmval_ != nullptr) {
    delete _impl_.tmval_;
  }
  _impl_.tmval_ = nullptr;
}
inline const ::commonmodule::ClearingTime& TmHzPoint::_internal_tmval() const {
  const ::commonmodule::ClearingTime* p = _impl_.tmval_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ClearingTime&>(
      ::commonmodule::_ClearingTime_default_instance_);
}
inline const ::commonmodule::ClearingTime& TmHzPoint::tmval() const {
  // @@protoc_insertion_point(field_get:commonmodule.TmHzPoint.tmVal)
  return _internal_tmval();
}
inline void TmHzPoint::unsafe_arena_set_allocated_tmval(
    ::commonmodule::ClearingTime* tmval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmval_);
  }
  _impl_.tmval_ = tmval;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.TmHzPoint.tmVal)
}
inline ::commonmodule::ClearingTime* TmHzPoint::release_tmval() {
  
  ::commonmodule::ClearingTime* temp = _impl_.tmval_;
  _impl_.tmval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ClearingTime* TmHzPoint::unsafe_arena_release_tmval() {
  // @@protoc_insertion_point(field_release:commonmodule.TmHzPoint.tmVal)
  
  ::commonmodule::ClearingTime* temp = _impl_.tmval_;
  _impl_.tmval_ = nullptr;
  return temp;
}
inline ::commonmodule::ClearingTime* TmHzPoint::_internal_mutable_tmval() {
  
  if (_impl_.tmval_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ClearingTime>(GetArenaForAllocation());
    _impl_.tmval_ = p;
  }
  return _impl_.tmval_;
}
inline ::commonmodule::ClearingTime* TmHzPoint::mutable_tmval() {
  ::commonmodule::ClearingTime* _msg = _internal_mutable_tmval();
  // @@protoc_insertion_point(field_mutable:commonmodule.TmHzPoint.tmVal)
  return _msg;
}
inline void TmHzPoint::set_allocated_tmval(::commonmodule::ClearingTime* tmval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tmval_;
  }
  if (tmval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tmval);
    if (message_arena != submessage_arena) {
      tmval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmval, submessage_arena);
    }

  } else {

  }
  _impl_.tmval_ = tmval;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.TmHzPoint.tmVal)
}

// -------------------------------------------------------------------

// TmHzCSG

// repeated .commonmodule.TmHzPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int TmHzCSG::_internal_overcrvpts_size() const {
  return _impl_.overcrvpts_.size();
}
inline int TmHzCSG::overcrvpts_size() const {
  return _internal_overcrvpts_size();
}
inline void TmHzCSG::clear_overcrvpts() {
  _impl_.overcrvpts_.Clear();
}
inline ::commonmodule::TmHzPoint* TmHzCSG::mutable_overcrvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.TmHzCSG.overCrvPts)
  return _impl_.overcrvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >*
TmHzCSG::mutable_overcrvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.TmHzCSG.overCrvPts)
  return &_impl_.overcrvpts_;
}
inline const ::commonmodule::TmHzPoint& TmHzCSG::_internal_overcrvpts(int index) const {
  return _impl_.overcrvpts_.Get(index);
}
inline const ::commonmodule::TmHzPoint& TmHzCSG::overcrvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.TmHzCSG.overCrvPts)
  return _internal_overcrvpts(index);
}
inline ::commonmodule::TmHzPoint* TmHzCSG::_internal_add_overcrvpts() {
  return _impl_.overcrvpts_.Add();
}
inline ::commonmodule::TmHzPoint* TmHzCSG::add_overcrvpts() {
  ::commonmodule::TmHzPoint* _add = _internal_add_overcrvpts();
  // @@protoc_insertion_point(field_add:commonmodule.TmHzCSG.overCrvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >&
TmHzCSG::overcrvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.TmHzCSG.overCrvPts)
  return _impl_.overcrvpts_;
}

// repeated .commonmodule.TmHzPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int TmHzCSG::_internal_undercrvpts_size() const {
  return _impl_.undercrvpts_.size();
}
inline int TmHzCSG::undercrvpts_size() const {
  return _internal_undercrvpts_size();
}
inline void TmHzCSG::clear_undercrvpts() {
  _impl_.undercrvpts_.Clear();
}
inline ::commonmodule::TmHzPoint* TmHzCSG::mutable_undercrvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.TmHzCSG.underCrvPts)
  return _impl_.undercrvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >*
TmHzCSG::mutable_undercrvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.TmHzCSG.underCrvPts)
  return &_impl_.undercrvpts_;
}
inline const ::commonmodule::TmHzPoint& TmHzCSG::_internal_undercrvpts(int index) const {
  return _impl_.undercrvpts_.Get(index);
}
inline const ::commonmodule::TmHzPoint& TmHzCSG::undercrvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.TmHzCSG.underCrvPts)
  return _internal_undercrvpts(index);
}
inline ::commonmodule::TmHzPoint* TmHzCSG::_internal_add_undercrvpts() {
  return _impl_.undercrvpts_.Add();
}
inline ::commonmodule::TmHzPoint* TmHzCSG::add_undercrvpts() {
  ::commonmodule::TmHzPoint* _add = _internal_add_undercrvpts();
  // @@protoc_insertion_point(field_add:commonmodule.TmHzCSG.underCrvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmHzPoint >&
TmHzCSG::undercrvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.TmHzCSG.underCrvPts)
  return _impl_.undercrvpts_;
}

// -------------------------------------------------------------------

// TmVoltPoint

// .commonmodule.ClearingTime tmVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool TmVoltPoint::_internal_has_tmval() const {
  return this != internal_default_instance() && _impl_.tmval_ != nullptr;
}
inline bool TmVoltPoint::has_tmval() const {
  return _internal_has_tmval();
}
inline void TmVoltPoint::clear_tmval() {
  if (GetArenaForAllocation() == nullptr && _impl_.tmval_ != nullptr) {
    delete _impl_.tmval_;
  }
  _impl_.tmval_ = nullptr;
}
inline const ::commonmodule::ClearingTime& TmVoltPoint::_internal_tmval() const {
  const ::commonmodule::ClearingTime* p = _impl_.tmval_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ClearingTime&>(
      ::commonmodule::_ClearingTime_default_instance_);
}
inline const ::commonmodule::ClearingTime& TmVoltPoint::tmval() const {
  // @@protoc_insertion_point(field_get:commonmodule.TmVoltPoint.tmVal)
  return _internal_tmval();
}
inline void TmVoltPoint::unsafe_arena_set_allocated_tmval(
    ::commonmodule::ClearingTime* tmval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmval_);
  }
  _impl_.tmval_ = tmval;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.TmVoltPoint.tmVal)
}
inline ::commonmodule::ClearingTime* TmVoltPoint::release_tmval() {
  
  ::commonmodule::ClearingTime* temp = _impl_.tmval_;
  _impl_.tmval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ClearingTime* TmVoltPoint::unsafe_arena_release_tmval() {
  // @@protoc_insertion_point(field_release:commonmodule.TmVoltPoint.tmVal)
  
  ::commonmodule::ClearingTime* temp = _impl_.tmval_;
  _impl_.tmval_ = nullptr;
  return temp;
}
inline ::commonmodule::ClearingTime* TmVoltPoint::_internal_mutable_tmval() {
  
  if (_impl_.tmval_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ClearingTime>(GetArenaForAllocation());
    _impl_.tmval_ = p;
  }
  return _impl_.tmval_;
}
inline ::commonmodule::ClearingTime* TmVoltPoint::mutable_tmval() {
  ::commonmodule::ClearingTime* _msg = _internal_mutable_tmval();
  // @@protoc_insertion_point(field_mutable:commonmodule.TmVoltPoint.tmVal)
  return _msg;
}
inline void TmVoltPoint::set_allocated_tmval(::commonmodule::ClearingTime* tmval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tmval_;
  }
  if (tmval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tmval);
    if (message_arena != submessage_arena) {
      tmval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmval, submessage_arena);
    }

  } else {

  }
  _impl_.tmval_ = tmval;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.TmVoltPoint.tmVal)
}

// float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void TmVoltPoint::clear_voltval() {
  _impl_.voltval_ = 0;
}
inline float TmVoltPoint::voltval() const {
  // @@protoc_insertion_point(field_get:commonmodule.TmVoltPoint.voltVal)
  return _internal_voltval();
}
inline void TmVoltPoint::set_voltval(float value) {
  _internal_set_voltval(value);
  // @@protoc_insertion_point(field_set:commonmodule.TmVoltPoint.voltVal)
}
inline float TmVoltPoint::_internal_voltval() const {
  return _impl_.voltval_;
}
inline void TmVoltPoint::_internal_set_voltval(float value) {
  ;
  _impl_.voltval_ = value;
}

// -------------------------------------------------------------------

// TmVoltCSG

// repeated .commonmodule.TmVoltPoint overCrvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int TmVoltCSG::_internal_overcrvpts_size() const {
  return _impl_.overcrvpts_.size();
}
inline int TmVoltCSG::overcrvpts_size() const {
  return _internal_overcrvpts_size();
}
inline void TmVoltCSG::clear_overcrvpts() {
  _impl_.overcrvpts_.Clear();
}
inline ::commonmodule::TmVoltPoint* TmVoltCSG::mutable_overcrvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.TmVoltCSG.overCrvPts)
  return _impl_.overcrvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >*
TmVoltCSG::mutable_overcrvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.TmVoltCSG.overCrvPts)
  return &_impl_.overcrvpts_;
}
inline const ::commonmodule::TmVoltPoint& TmVoltCSG::_internal_overcrvpts(int index) const {
  return _impl_.overcrvpts_.Get(index);
}
inline const ::commonmodule::TmVoltPoint& TmVoltCSG::overcrvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.TmVoltCSG.overCrvPts)
  return _internal_overcrvpts(index);
}
inline ::commonmodule::TmVoltPoint* TmVoltCSG::_internal_add_overcrvpts() {
  return _impl_.overcrvpts_.Add();
}
inline ::commonmodule::TmVoltPoint* TmVoltCSG::add_overcrvpts() {
  ::commonmodule::TmVoltPoint* _add = _internal_add_overcrvpts();
  // @@protoc_insertion_point(field_add:commonmodule.TmVoltCSG.overCrvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >&
TmVoltCSG::overcrvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.TmVoltCSG.overCrvPts)
  return _impl_.overcrvpts_;
}

// repeated .commonmodule.TmVoltPoint underCrvPts = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int TmVoltCSG::_internal_undercrvpts_size() const {
  return _impl_.undercrvpts_.size();
}
inline int TmVoltCSG::undercrvpts_size() const {
  return _internal_undercrvpts_size();
}
inline void TmVoltCSG::clear_undercrvpts() {
  _impl_.undercrvpts_.Clear();
}
inline ::commonmodule::TmVoltPoint* TmVoltCSG::mutable_undercrvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.TmVoltCSG.underCrvPts)
  return _impl_.undercrvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >*
TmVoltCSG::mutable_undercrvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.TmVoltCSG.underCrvPts)
  return &_impl_.undercrvpts_;
}
inline const ::commonmodule::TmVoltPoint& TmVoltCSG::_internal_undercrvpts(int index) const {
  return _impl_.undercrvpts_.Get(index);
}
inline const ::commonmodule::TmVoltPoint& TmVoltCSG::undercrvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.TmVoltCSG.underCrvPts)
  return _internal_undercrvpts(index);
}
inline ::commonmodule::TmVoltPoint* TmVoltCSG::_internal_add_undercrvpts() {
  return _impl_.undercrvpts_.Add();
}
inline ::commonmodule::TmVoltPoint* TmVoltCSG::add_undercrvpts() {
  ::commonmodule::TmVoltPoint* _add = _internal_add_undercrvpts();
  // @@protoc_insertion_point(field_add:commonmodule.TmVoltCSG.underCrvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::TmVoltPoint >&
TmVoltCSG::undercrvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.TmVoltCSG.underCrvPts)
  return _impl_.undercrvpts_;
}

// -------------------------------------------------------------------

// VarSPC

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VarSPC::clear_modena() {
  _impl_.modena_ = false;
}
inline bool VarSPC::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.VarSPC.modEna)
  return _internal_modena();
}
inline void VarSPC::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.VarSPC.modEna)
}
inline bool VarSPC::_internal_modena() const {
  return _impl_.modena_;
}
inline void VarSPC::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// .commonmodule.OperationDVAR varParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool VarSPC::_internal_has_varparameter() const {
  return this != internal_default_instance() && _impl_.varparameter_ != nullptr;
}
inline bool VarSPC::has_varparameter() const {
  return _internal_has_varparameter();
}
inline void VarSPC::clear_varparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.varparameter_ != nullptr) {
    delete _impl_.varparameter_;
  }
  _impl_.varparameter_ = nullptr;
}
inline const ::commonmodule::OperationDVAR& VarSPC::_internal_varparameter() const {
  const ::commonmodule::OperationDVAR* p = _impl_.varparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDVAR&>(
      ::commonmodule::_OperationDVAR_default_instance_);
}
inline const ::commonmodule::OperationDVAR& VarSPC::varparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.VarSPC.varParameter)
  return _internal_varparameter();
}
inline void VarSPC::unsafe_arena_set_allocated_varparameter(
    ::commonmodule::OperationDVAR* varparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varparameter_);
  }
  _impl_.varparameter_ = varparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.VarSPC.varParameter)
}
inline ::commonmodule::OperationDVAR* VarSPC::release_varparameter() {
  
  ::commonmodule::OperationDVAR* temp = _impl_.varparameter_;
  _impl_.varparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDVAR* VarSPC::unsafe_arena_release_varparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.VarSPC.varParameter)
  
  ::commonmodule::OperationDVAR* temp = _impl_.varparameter_;
  _impl_.varparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDVAR* VarSPC::_internal_mutable_varparameter() {
  
  if (_impl_.varparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDVAR>(GetArenaForAllocation());
    _impl_.varparameter_ = p;
  }
  return _impl_.varparameter_;
}
inline ::commonmodule::OperationDVAR* VarSPC::mutable_varparameter() {
  ::commonmodule::OperationDVAR* _msg = _internal_mutable_varparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.VarSPC.varParameter)
  return _msg;
}
inline void VarSPC::set_allocated_varparameter(::commonmodule::OperationDVAR* varparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.varparameter_;
  }
  if (varparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(varparameter);
    if (message_arena != submessage_arena) {
      varparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varparameter, submessage_arena);
    }

  } else {

  }
  _impl_.varparameter_ = varparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VarSPC.varParameter)
}

// -------------------------------------------------------------------

// VoltVarPoint

// float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VoltVarPoint::clear_varval() {
  _impl_.varval_ = 0;
}
inline float VoltVarPoint::varval() const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltVarPoint.varVal)
  return _internal_varval();
}
inline void VoltVarPoint::set_varval(float value) {
  _internal_set_varval(value);
  // @@protoc_insertion_point(field_set:commonmodule.VoltVarPoint.varVal)
}
inline float VoltVarPoint::_internal_varval() const {
  return _impl_.varval_;
}
inline void VoltVarPoint::_internal_set_varval(float value) {
  ;
  _impl_.varval_ = value;
}

// float voltVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VoltVarPoint::clear_voltval() {
  _impl_.voltval_ = 0;
}
inline float VoltVarPoint::voltval() const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltVarPoint.voltVal)
  return _internal_voltval();
}
inline void VoltVarPoint::set_voltval(float value) {
  _internal_set_voltval(value);
  // @@protoc_insertion_point(field_set:commonmodule.VoltVarPoint.voltVal)
}
inline float VoltVarPoint::_internal_voltval() const {
  return _impl_.voltval_;
}
inline void VoltVarPoint::_internal_set_voltval(float value) {
  ;
  _impl_.voltval_ = value;
}

// -------------------------------------------------------------------

// VoltVarCSG

// repeated .commonmodule.VoltVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int VoltVarCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int VoltVarCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void VoltVarCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::commonmodule::VoltVarPoint* VoltVarCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.VoltVarCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltVarPoint >*
VoltVarCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.VoltVarCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::commonmodule::VoltVarPoint& VoltVarCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::commonmodule::VoltVarPoint& VoltVarCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltVarCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::commonmodule::VoltVarPoint* VoltVarCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::commonmodule::VoltVarPoint* VoltVarCSG::add_crvpts() {
  ::commonmodule::VoltVarPoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:commonmodule.VoltVarCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltVarPoint >&
VoltVarCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.VoltVarCSG.crvPts)
  return _impl_.crvpts_;
}

// .commonmodule.OperationDVVR vVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool VoltVarCSG::_internal_has_vvarparameter() const {
  return this != internal_default_instance() && _impl_.vvarparameter_ != nullptr;
}
inline bool VoltVarCSG::has_vvarparameter() const {
  return _internal_has_vvarparameter();
}
inline void VoltVarCSG::clear_vvarparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.vvarparameter_ != nullptr) {
    delete _impl_.vvarparameter_;
  }
  _impl_.vvarparameter_ = nullptr;
}
inline const ::commonmodule::OperationDVVR& VoltVarCSG::_internal_vvarparameter() const {
  const ::commonmodule::OperationDVVR* p = _impl_.vvarparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDVVR&>(
      ::commonmodule::_OperationDVVR_default_instance_);
}
inline const ::commonmodule::OperationDVVR& VoltVarCSG::vvarparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltVarCSG.vVarParameter)
  return _internal_vvarparameter();
}
inline void VoltVarCSG::unsafe_arena_set_allocated_vvarparameter(
    ::commonmodule::OperationDVVR* vvarparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vvarparameter_);
  }
  _impl_.vvarparameter_ = vvarparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.VoltVarCSG.vVarParameter)
}
inline ::commonmodule::OperationDVVR* VoltVarCSG::release_vvarparameter() {
  
  ::commonmodule::OperationDVVR* temp = _impl_.vvarparameter_;
  _impl_.vvarparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDVVR* VoltVarCSG::unsafe_arena_release_vvarparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.VoltVarCSG.vVarParameter)
  
  ::commonmodule::OperationDVVR* temp = _impl_.vvarparameter_;
  _impl_.vvarparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDVVR* VoltVarCSG::_internal_mutable_vvarparameter() {
  
  if (_impl_.vvarparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDVVR>(GetArenaForAllocation());
    _impl_.vvarparameter_ = p;
  }
  return _impl_.vvarparameter_;
}
inline ::commonmodule::OperationDVVR* VoltVarCSG::mutable_vvarparameter() {
  ::commonmodule::OperationDVVR* _msg = _internal_mutable_vvarparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.VoltVarCSG.vVarParameter)
  return _msg;
}
inline void VoltVarCSG::set_allocated_vvarparameter(::commonmodule::OperationDVVR* vvarparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vvarparameter_;
  }
  if (vvarparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vvarparameter);
    if (message_arena != submessage_arena) {
      vvarparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vvarparameter, submessage_arena);
    }

  } else {

  }
  _impl_.vvarparameter_ = vvarparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VoltVarCSG.vVarParameter)
}

// -------------------------------------------------------------------

// VoltWPoint

// float voltVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VoltWPoint::clear_voltval() {
  _impl_.voltval_ = 0;
}
inline float VoltWPoint::voltval() const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltWPoint.voltVal)
  return _internal_voltval();
}
inline void VoltWPoint::set_voltval(float value) {
  _internal_set_voltval(value);
  // @@protoc_insertion_point(field_set:commonmodule.VoltWPoint.voltVal)
}
inline float VoltWPoint::_internal_voltval() const {
  return _impl_.voltval_;
}
inline void VoltWPoint::_internal_set_voltval(float value) {
  ;
  _impl_.voltval_ = value;
}

// float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VoltWPoint::clear_wval() {
  _impl_.wval_ = 0;
}
inline float VoltWPoint::wval() const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltWPoint.wVal)
  return _internal_wval();
}
inline void VoltWPoint::set_wval(float value) {
  _internal_set_wval(value);
  // @@protoc_insertion_point(field_set:commonmodule.VoltWPoint.wVal)
}
inline float VoltWPoint::_internal_wval() const {
  return _impl_.wval_;
}
inline void VoltWPoint::_internal_set_wval(float value) {
  ;
  _impl_.wval_ = value;
}

// -------------------------------------------------------------------

// VoltWCSG

// repeated .commonmodule.VoltWPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int VoltWCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int VoltWCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void VoltWCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::commonmodule::VoltWPoint* VoltWCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.VoltWCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltWPoint >*
VoltWCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.VoltWCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::commonmodule::VoltWPoint& VoltWCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::commonmodule::VoltWPoint& VoltWCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltWCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::commonmodule::VoltWPoint* VoltWCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::commonmodule::VoltWPoint* VoltWCSG::add_crvpts() {
  ::commonmodule::VoltWPoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:commonmodule.VoltWCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::VoltWPoint >&
VoltWCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.VoltWCSG.crvPts)
  return _impl_.crvpts_;
}

// .commonmodule.OperationDVWC voltWParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool VoltWCSG::_internal_has_voltwparameter() const {
  return this != internal_default_instance() && _impl_.voltwparameter_ != nullptr;
}
inline bool VoltWCSG::has_voltwparameter() const {
  return _internal_has_voltwparameter();
}
inline void VoltWCSG::clear_voltwparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.voltwparameter_ != nullptr) {
    delete _impl_.voltwparameter_;
  }
  _impl_.voltwparameter_ = nullptr;
}
inline const ::commonmodule::OperationDVWC& VoltWCSG::_internal_voltwparameter() const {
  const ::commonmodule::OperationDVWC* p = _impl_.voltwparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDVWC&>(
      ::commonmodule::_OperationDVWC_default_instance_);
}
inline const ::commonmodule::OperationDVWC& VoltWCSG::voltwparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.VoltWCSG.voltWParameter)
  return _internal_voltwparameter();
}
inline void VoltWCSG::unsafe_arena_set_allocated_voltwparameter(
    ::commonmodule::OperationDVWC* voltwparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwparameter_);
  }
  _impl_.voltwparameter_ = voltwparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.VoltWCSG.voltWParameter)
}
inline ::commonmodule::OperationDVWC* VoltWCSG::release_voltwparameter() {
  
  ::commonmodule::OperationDVWC* temp = _impl_.voltwparameter_;
  _impl_.voltwparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDVWC* VoltWCSG::unsafe_arena_release_voltwparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.VoltWCSG.voltWParameter)
  
  ::commonmodule::OperationDVWC* temp = _impl_.voltwparameter_;
  _impl_.voltwparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDVWC* VoltWCSG::_internal_mutable_voltwparameter() {
  
  if (_impl_.voltwparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDVWC>(GetArenaForAllocation());
    _impl_.voltwparameter_ = p;
  }
  return _impl_.voltwparameter_;
}
inline ::commonmodule::OperationDVWC* VoltWCSG::mutable_voltwparameter() {
  ::commonmodule::OperationDVWC* _msg = _internal_mutable_voltwparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.VoltWCSG.voltWParameter)
  return _msg;
}
inline void VoltWCSG::set_allocated_voltwparameter(::commonmodule::OperationDVWC* voltwparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voltwparameter_;
  }
  if (voltwparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voltwparameter);
    if (message_arena != submessage_arena) {
      voltwparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltwparameter, submessage_arena);
    }

  } else {

  }
  _impl_.voltwparameter_ = voltwparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VoltWCSG.voltWParameter)
}

// -------------------------------------------------------------------

// VSC

// string ctlVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void VSC::clear_ctlval() {
  _impl_.ctlval_.ClearToEmpty();
}
inline const std::string& VSC::ctlval() const {
  // @@protoc_insertion_point(field_get:commonmodule.VSC.ctlVal)
  return _internal_ctlval();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VSC::set_ctlval(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ctlval_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commonmodule.VSC.ctlVal)
}
inline std::string* VSC::mutable_ctlval() {
  std::string* _s = _internal_mutable_ctlval();
  // @@protoc_insertion_point(field_mutable:commonmodule.VSC.ctlVal)
  return _s;
}
inline const std::string& VSC::_internal_ctlval() const {
  return _impl_.ctlval_.Get();
}
inline void VSC::_internal_set_ctlval(const std::string& value) {
  ;


  _impl_.ctlval_.Set(value, GetArenaForAllocation());
}
inline std::string* VSC::_internal_mutable_ctlval() {
  ;
  return _impl_.ctlval_.Mutable( GetArenaForAllocation());
}
inline std::string* VSC::release_ctlval() {
  // @@protoc_insertion_point(field_release:commonmodule.VSC.ctlVal)
  return _impl_.ctlval_.Release();
}
inline void VSC::set_allocated_ctlval(std::string* value) {
  _impl_.ctlval_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ctlval_.IsDefault()) {
          _impl_.ctlval_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commonmodule.VSC.ctlVal)
}

// -------------------------------------------------------------------

// WSPC

// bool modEna = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void WSPC::clear_modena() {
  _impl_.modena_ = false;
}
inline bool WSPC::modena() const {
  // @@protoc_insertion_point(field_get:commonmodule.WSPC.modEna)
  return _internal_modena();
}
inline void WSPC::set_modena(bool value) {
  _internal_set_modena(value);
  // @@protoc_insertion_point(field_set:commonmodule.WSPC.modEna)
}
inline bool WSPC::_internal_modena() const {
  return _impl_.modena_;
}
inline void WSPC::_internal_set_modena(bool value) {
  ;
  _impl_.modena_ = value;
}

// .commonmodule.OperationDWGC wParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool WSPC::_internal_has_wparameter() const {
  return this != internal_default_instance() && _impl_.wparameter_ != nullptr;
}
inline bool WSPC::has_wparameter() const {
  return _internal_has_wparameter();
}
inline void WSPC::clear_wparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.wparameter_ != nullptr) {
    delete _impl_.wparameter_;
  }
  _impl_.wparameter_ = nullptr;
}
inline const ::commonmodule::OperationDWGC& WSPC::_internal_wparameter() const {
  const ::commonmodule::OperationDWGC* p = _impl_.wparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDWGC&>(
      ::commonmodule::_OperationDWGC_default_instance_);
}
inline const ::commonmodule::OperationDWGC& WSPC::wparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.WSPC.wParameter)
  return _internal_wparameter();
}
inline void WSPC::unsafe_arena_set_allocated_wparameter(
    ::commonmodule::OperationDWGC* wparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wparameter_);
  }
  _impl_.wparameter_ = wparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WSPC.wParameter)
}
inline ::commonmodule::OperationDWGC* WSPC::release_wparameter() {
  
  ::commonmodule::OperationDWGC* temp = _impl_.wparameter_;
  _impl_.wparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDWGC* WSPC::unsafe_arena_release_wparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.WSPC.wParameter)
  
  ::commonmodule::OperationDWGC* temp = _impl_.wparameter_;
  _impl_.wparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDWGC* WSPC::_internal_mutable_wparameter() {
  
  if (_impl_.wparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDWGC>(GetArenaForAllocation());
    _impl_.wparameter_ = p;
  }
  return _impl_.wparameter_;
}
inline ::commonmodule::OperationDWGC* WSPC::mutable_wparameter() {
  ::commonmodule::OperationDWGC* _msg = _internal_mutable_wparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.WSPC.wParameter)
  return _msg;
}
inline void WSPC::set_allocated_wparameter(::commonmodule::OperationDWGC* wparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wparameter_;
  }
  if (wparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wparameter);
    if (message_arena != submessage_arena) {
      wparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wparameter, submessage_arena);
    }

  } else {

  }
  _impl_.wparameter_ = wparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WSPC.wParameter)
}

// -------------------------------------------------------------------

// WVarPoint

// float varVal = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void WVarPoint::clear_varval() {
  _impl_.varval_ = 0;
}
inline float WVarPoint::varval() const {
  // @@protoc_insertion_point(field_get:commonmodule.WVarPoint.varVal)
  return _internal_varval();
}
inline void WVarPoint::set_varval(float value) {
  _internal_set_varval(value);
  // @@protoc_insertion_point(field_set:commonmodule.WVarPoint.varVal)
}
inline float WVarPoint::_internal_varval() const {
  return _impl_.varval_;
}
inline void WVarPoint::_internal_set_varval(float value) {
  ;
  _impl_.varval_ = value;
}

// float wVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void WVarPoint::clear_wval() {
  _impl_.wval_ = 0;
}
inline float WVarPoint::wval() const {
  // @@protoc_insertion_point(field_get:commonmodule.WVarPoint.wVal)
  return _internal_wval();
}
inline void WVarPoint::set_wval(float value) {
  _internal_set_wval(value);
  // @@protoc_insertion_point(field_set:commonmodule.WVarPoint.wVal)
}
inline float WVarPoint::_internal_wval() const {
  return _impl_.wval_;
}
inline void WVarPoint::_internal_set_wval(float value) {
  ;
  _impl_.wval_ = value;
}

// -------------------------------------------------------------------

// WVarCSG

// repeated .commonmodule.WVarPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int WVarCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int WVarCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void WVarCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::commonmodule::WVarPoint* WVarCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:commonmodule.WVarCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::WVarPoint >*
WVarCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:commonmodule.WVarCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::commonmodule::WVarPoint& WVarCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::commonmodule::WVarPoint& WVarCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:commonmodule.WVarCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::commonmodule::WVarPoint* WVarCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::commonmodule::WVarPoint* WVarCSG::add_crvpts() {
  ::commonmodule::WVarPoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:commonmodule.WVarCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::commonmodule::WVarPoint >&
WVarCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:commonmodule.WVarCSG.crvPts)
  return _impl_.crvpts_;
}

// .commonmodule.OperationDWVR wVarParameter = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool WVarCSG::_internal_has_wvarparameter() const {
  return this != internal_default_instance() && _impl_.wvarparameter_ != nullptr;
}
inline bool WVarCSG::has_wvarparameter() const {
  return _internal_has_wvarparameter();
}
inline void WVarCSG::clear_wvarparameter() {
  if (GetArenaForAllocation() == nullptr && _impl_.wvarparameter_ != nullptr) {
    delete _impl_.wvarparameter_;
  }
  _impl_.wvarparameter_ = nullptr;
}
inline const ::commonmodule::OperationDWVR& WVarCSG::_internal_wvarparameter() const {
  const ::commonmodule::OperationDWVR* p = _impl_.wvarparameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::OperationDWVR&>(
      ::commonmodule::_OperationDWVR_default_instance_);
}
inline const ::commonmodule::OperationDWVR& WVarCSG::wvarparameter() const {
  // @@protoc_insertion_point(field_get:commonmodule.WVarCSG.wVarParameter)
  return _internal_wvarparameter();
}
inline void WVarCSG::unsafe_arena_set_allocated_wvarparameter(
    ::commonmodule::OperationDWVR* wvarparameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvarparameter_);
  }
  _impl_.wvarparameter_ = wvarparameter;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commonmodule.WVarCSG.wVarParameter)
}
inline ::commonmodule::OperationDWVR* WVarCSG::release_wvarparameter() {
  
  ::commonmodule::OperationDWVR* temp = _impl_.wvarparameter_;
  _impl_.wvarparameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::OperationDWVR* WVarCSG::unsafe_arena_release_wvarparameter() {
  // @@protoc_insertion_point(field_release:commonmodule.WVarCSG.wVarParameter)
  
  ::commonmodule::OperationDWVR* temp = _impl_.wvarparameter_;
  _impl_.wvarparameter_ = nullptr;
  return temp;
}
inline ::commonmodule::OperationDWVR* WVarCSG::_internal_mutable_wvarparameter() {
  
  if (_impl_.wvarparameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::OperationDWVR>(GetArenaForAllocation());
    _impl_.wvarparameter_ = p;
  }
  return _impl_.wvarparameter_;
}
inline ::commonmodule::OperationDWVR* WVarCSG::mutable_wvarparameter() {
  ::commonmodule::OperationDWVR* _msg = _internal_mutable_wvarparameter();
  // @@protoc_insertion_point(field_mutable:commonmodule.WVarCSG.wVarParameter)
  return _msg;
}
inline void WVarCSG::set_allocated_wvarparameter(::commonmodule::OperationDWVR* wvarparameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wvarparameter_;
  }
  if (wvarparameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wvarparameter);
    if (message_arena != submessage_arena) {
      wvarparameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wvarparameter, submessage_arena);
    }

  } else {

  }
  _impl_.wvarparameter_ = wvarparameter;
  // @@protoc_insertion_point(field_set_allocated:commonmodule.WVarCSG.wVarParameter)
}

// -------------------------------------------------------------------

// Optional_AlrmKind

// .commonmodule.AlrmKind value = 1;
inline void Optional_AlrmKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::AlrmKind Optional_AlrmKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_AlrmKind.value)
  return _internal_value();
}
inline void Optional_AlrmKind::set_value(::commonmodule::AlrmKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_AlrmKind.value)
}
inline ::commonmodule::AlrmKind Optional_AlrmKind::_internal_value() const {
  return static_cast<::commonmodule::AlrmKind>(_impl_.value_);
}
inline void Optional_AlrmKind::_internal_set_value(::commonmodule::AlrmKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_ControlModeKind

// .commonmodule.ControlModeKind value = 1;
inline void Optional_ControlModeKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::ControlModeKind Optional_ControlModeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_ControlModeKind.value)
  return _internal_value();
}
inline void Optional_ControlModeKind::set_value(::commonmodule::ControlModeKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_ControlModeKind.value)
}
inline ::commonmodule::ControlModeKind Optional_ControlModeKind::_internal_value() const {
  return static_cast<::commonmodule::ControlModeKind>(_impl_.value_);
}
inline void Optional_ControlModeKind::_internal_set_value(::commonmodule::ControlModeKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_DirectionModeKind

// .commonmodule.DirectionModeKind value = 1;
inline void Optional_DirectionModeKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::DirectionModeKind Optional_DirectionModeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_DirectionModeKind.value)
  return _internal_value();
}
inline void Optional_DirectionModeKind::set_value(::commonmodule::DirectionModeKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_DirectionModeKind.value)
}
inline ::commonmodule::DirectionModeKind Optional_DirectionModeKind::_internal_value() const {
  return static_cast<::commonmodule::DirectionModeKind>(_impl_.value_);
}
inline void Optional_DirectionModeKind::_internal_set_value(::commonmodule::DirectionModeKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_GridConnectionStateKind

// .commonmodule.GridConnectionStateKind value = 1;
inline void Optional_GridConnectionStateKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::GridConnectionStateKind Optional_GridConnectionStateKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_GridConnectionStateKind.value)
  return _internal_value();
}
inline void Optional_GridConnectionStateKind::set_value(::commonmodule::GridConnectionStateKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_GridConnectionStateKind.value)
}
inline ::commonmodule::GridConnectionStateKind Optional_GridConnectionStateKind::_internal_value() const {
  return static_cast<::commonmodule::GridConnectionStateKind>(_impl_.value_);
}
inline void Optional_GridConnectionStateKind::_internal_set_value(::commonmodule::GridConnectionStateKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_OperatingStateKind

// .commonmodule.OperatingStateKind value = 1;
inline void Optional_OperatingStateKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::OperatingStateKind Optional_OperatingStateKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_OperatingStateKind.value)
  return _internal_value();
}
inline void Optional_OperatingStateKind::set_value(::commonmodule::OperatingStateKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_OperatingStateKind.value)
}
inline ::commonmodule::OperatingStateKind Optional_OperatingStateKind::_internal_value() const {
  return static_cast<::commonmodule::OperatingStateKind>(_impl_.value_);
}
inline void Optional_OperatingStateKind::_internal_set_value(::commonmodule::OperatingStateKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_ReactivePowerControlKind

// .commonmodule.ReactivePowerControlKind value = 1;
inline void Optional_ReactivePowerControlKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::ReactivePowerControlKind Optional_ReactivePowerControlKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_ReactivePowerControlKind.value)
  return _internal_value();
}
inline void Optional_ReactivePowerControlKind::set_value(::commonmodule::ReactivePowerControlKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_ReactivePowerControlKind.value)
}
inline ::commonmodule::ReactivePowerControlKind Optional_ReactivePowerControlKind::_internal_value() const {
  return static_cast<::commonmodule::ReactivePowerControlKind>(_impl_.value_);
}
inline void Optional_ReactivePowerControlKind::_internal_set_value(::commonmodule::ReactivePowerControlKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_RealPowerControlKind

// .commonmodule.RealPowerControlKind value = 1;
inline void Optional_RealPowerControlKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::RealPowerControlKind Optional_RealPowerControlKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_RealPowerControlKind.value)
  return _internal_value();
}
inline void Optional_RealPowerControlKind::set_value(::commonmodule::RealPowerControlKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_RealPowerControlKind.value)
}
inline ::commonmodule::RealPowerControlKind Optional_RealPowerControlKind::_internal_value() const {
  return static_cast<::commonmodule::RealPowerControlKind>(_impl_.value_);
}
inline void Optional_RealPowerControlKind::_internal_set_value(::commonmodule::RealPowerControlKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_StateKind

// .commonmodule.StateKind value = 1;
inline void Optional_StateKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::StateKind Optional_StateKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_StateKind.value)
  return _internal_value();
}
inline void Optional_StateKind::set_value(::commonmodule::StateKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_StateKind.value)
}
inline ::commonmodule::StateKind Optional_StateKind::_internal_value() const {
  return static_cast<::commonmodule::StateKind>(_impl_.value_);
}
inline void Optional_StateKind::_internal_set_value(::commonmodule::StateKind value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Optional_VoltLimitModeKind

// .commonmodule.VoltLimitModeKind value = 1;
inline void Optional_VoltLimitModeKind::clear_value() {
  _impl_.value_ = 0;
}
inline ::commonmodule::VoltLimitModeKind Optional_VoltLimitModeKind::value() const {
  // @@protoc_insertion_point(field_get:commonmodule.Optional_VoltLimitModeKind.value)
  return _internal_value();
}
inline void Optional_VoltLimitModeKind::set_value(::commonmodule::VoltLimitModeKind value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:commonmodule.Optional_VoltLimitModeKind.value)
}
inline ::commonmodule::VoltLimitModeKind Optional_VoltLimitModeKind::_internal_value() const {
  return static_cast<::commonmodule::VoltLimitModeKind>(_impl_.value_);
}
inline void Optional_VoltLimitModeKind::_internal_set_value(::commonmodule::VoltLimitModeKind value) {
  ;
  _impl_.value_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace commonmodule


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::commonmodule::FaultDirectionKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::FaultDirectionKind>() {
  return ::commonmodule::FaultDirectionKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::PhaseFaultDirectionKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::PhaseFaultDirectionKind>() {
  return ::commonmodule::PhaseFaultDirectionKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::UnitSymbolKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::UnitSymbolKind>() {
  return ::commonmodule::UnitSymbolKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::UnitMultiplierKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::UnitMultiplierKind>() {
  return ::commonmodule::UnitMultiplierKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::PhaseCodeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::PhaseCodeKind>() {
  return ::commonmodule::PhaseCodeKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::ValidityKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::ValidityKind>() {
  return ::commonmodule::ValidityKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::SourceKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::SourceKind>() {
  return ::commonmodule::SourceKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::TimeAccuracyKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::TimeAccuracyKind>() {
  return ::commonmodule::TimeAccuracyKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::ScheduleParameterKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::ScheduleParameterKind>() {
  return ::commonmodule::ScheduleParameterKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::CalcMethodKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::CalcMethodKind>() {
  return ::commonmodule::CalcMethodKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::GridConnectModeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::GridConnectModeKind>() {
  return ::commonmodule::GridConnectModeKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::PFSignKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::PFSignKind>() {
  return ::commonmodule::PFSignKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::BehaviourModeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::BehaviourModeKind>() {
  return ::commonmodule::BehaviourModeKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::DERGeneratorStateKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::DERGeneratorStateKind>() {
  return ::commonmodule::DERGeneratorStateKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::DynamicTestKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::DynamicTestKind>() {
  return ::commonmodule::DynamicTestKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::HealthKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::HealthKind>() {
  return ::commonmodule::HealthKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::SwitchingCapabilityKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::SwitchingCapabilityKind>() {
  return ::commonmodule::SwitchingCapabilityKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::DbPosKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::DbPosKind>() {
  return ::commonmodule::DbPosKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::RecloseActionKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::RecloseActionKind>() {
  return ::commonmodule::RecloseActionKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::NorOpCatKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::NorOpCatKind>() {
  return ::commonmodule::NorOpCatKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::AbnOpCatKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::AbnOpCatKind>() {
  return ::commonmodule::AbnOpCatKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::AlrmKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::AlrmKind>() {
  return ::commonmodule::AlrmKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::ControlModeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::ControlModeKind>() {
  return ::commonmodule::ControlModeKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::DirectionModeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::DirectionModeKind>() {
  return ::commonmodule::DirectionModeKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::GridConnectionStateKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::GridConnectionStateKind>() {
  return ::commonmodule::GridConnectionStateKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::OperatingStateKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::OperatingStateKind>() {
  return ::commonmodule::OperatingStateKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::ReactivePowerControlKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::ReactivePowerControlKind>() {
  return ::commonmodule::ReactivePowerControlKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::RealPowerControlKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::RealPowerControlKind>() {
  return ::commonmodule::RealPowerControlKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::StateKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::StateKind>() {
  return ::commonmodule::StateKind_descriptor();
}
template <>
struct is_proto_enum<::commonmodule::VoltLimitModeKind> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::commonmodule::VoltLimitModeKind>() {
  return ::commonmodule::VoltLimitModeKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_commonmodule_2fcommonmodule_2eproto_2epb_2eh
