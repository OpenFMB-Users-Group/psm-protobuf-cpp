// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: essmodule/essmodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_essmodule_2fessmodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_essmodule_2fessmodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_essmodule_2fessmodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_essmodule_2fessmodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_essmodule_2fessmodule_2eproto;
namespace essmodule {
class CapacityFirming;
struct CapacityFirmingDefaultTypeInternal;
extern CapacityFirmingDefaultTypeInternal _CapacityFirming_default_instance_;
class ESSCSG;
struct ESSCSGDefaultTypeInternal;
extern ESSCSGDefaultTypeInternal _ESSCSG_default_instance_;
class ESSCapability;
struct ESSCapabilityDefaultTypeInternal;
extern ESSCapabilityDefaultTypeInternal _ESSCapability_default_instance_;
class ESSCapabilityConfiguration;
struct ESSCapabilityConfigurationDefaultTypeInternal;
extern ESSCapabilityConfigurationDefaultTypeInternal _ESSCapabilityConfiguration_default_instance_;
class ESSCapabilityOverride;
struct ESSCapabilityOverrideDefaultTypeInternal;
extern ESSCapabilityOverrideDefaultTypeInternal _ESSCapabilityOverride_default_instance_;
class ESSCapabilityOverrideProfile;
struct ESSCapabilityOverrideProfileDefaultTypeInternal;
extern ESSCapabilityOverrideProfileDefaultTypeInternal _ESSCapabilityOverrideProfile_default_instance_;
class ESSCapabilityProfile;
struct ESSCapabilityProfileDefaultTypeInternal;
extern ESSCapabilityProfileDefaultTypeInternal _ESSCapabilityProfile_default_instance_;
class ESSCapabilityRatings;
struct ESSCapabilityRatingsDefaultTypeInternal;
extern ESSCapabilityRatingsDefaultTypeInternal _ESSCapabilityRatings_default_instance_;
class ESSControl;
struct ESSControlDefaultTypeInternal;
extern ESSControlDefaultTypeInternal _ESSControl_default_instance_;
class ESSControlProfile;
struct ESSControlProfileDefaultTypeInternal;
extern ESSControlProfileDefaultTypeInternal _ESSControlProfile_default_instance_;
class ESSControlScheduleFSCH;
struct ESSControlScheduleFSCHDefaultTypeInternal;
extern ESSControlScheduleFSCHDefaultTypeInternal _ESSControlScheduleFSCH_default_instance_;
class ESSCurvePoint;
struct ESSCurvePointDefaultTypeInternal;
extern ESSCurvePointDefaultTypeInternal _ESSCurvePoint_default_instance_;
class ESSDiscreteControl;
struct ESSDiscreteControlDefaultTypeInternal;
extern ESSDiscreteControlDefaultTypeInternal _ESSDiscreteControl_default_instance_;
class ESSDiscreteControlDBAT;
struct ESSDiscreteControlDBATDefaultTypeInternal;
extern ESSDiscreteControlDBATDefaultTypeInternal _ESSDiscreteControlDBAT_default_instance_;
class ESSDiscreteControlProfile;
struct ESSDiscreteControlProfileDefaultTypeInternal;
extern ESSDiscreteControlProfileDefaultTypeInternal _ESSDiscreteControlProfile_default_instance_;
class ESSEvent;
struct ESSEventDefaultTypeInternal;
extern ESSEventDefaultTypeInternal _ESSEvent_default_instance_;
class ESSEventAndStatusZGEN;
struct ESSEventAndStatusZGENDefaultTypeInternal;
extern ESSEventAndStatusZGENDefaultTypeInternal _ESSEventAndStatusZGEN_default_instance_;
class ESSEventProfile;
struct ESSEventProfileDefaultTypeInternal;
extern ESSEventProfileDefaultTypeInternal _ESSEventProfile_default_instance_;
class ESSEventZGEN;
struct ESSEventZGENDefaultTypeInternal;
extern ESSEventZGENDefaultTypeInternal _ESSEventZGEN_default_instance_;
class ESSFunction;
struct ESSFunctionDefaultTypeInternal;
extern ESSFunctionDefaultTypeInternal _ESSFunction_default_instance_;
class ESSPoint;
struct ESSPointDefaultTypeInternal;
extern ESSPointDefaultTypeInternal _ESSPoint_default_instance_;
class ESSPointStatus;
struct ESSPointStatusDefaultTypeInternal;
extern ESSPointStatusDefaultTypeInternal _ESSPointStatus_default_instance_;
class ESSReading;
struct ESSReadingDefaultTypeInternal;
extern ESSReadingDefaultTypeInternal _ESSReading_default_instance_;
class ESSReadingProfile;
struct ESSReadingProfileDefaultTypeInternal;
extern ESSReadingProfileDefaultTypeInternal _ESSReadingProfile_default_instance_;
class ESSStatus;
struct ESSStatusDefaultTypeInternal;
extern ESSStatusDefaultTypeInternal _ESSStatus_default_instance_;
class ESSStatusProfile;
struct ESSStatusProfileDefaultTypeInternal;
extern ESSStatusProfileDefaultTypeInternal _ESSStatusProfile_default_instance_;
class ESSStatusZGEN;
struct ESSStatusZGENDefaultTypeInternal;
extern ESSStatusZGENDefaultTypeInternal _ESSStatusZGEN_default_instance_;
class EssControlFSCC;
struct EssControlFSCCDefaultTypeInternal;
extern EssControlFSCCDefaultTypeInternal _EssControlFSCC_default_instance_;
class EssEventZBAT;
struct EssEventZBATDefaultTypeInternal;
extern EssEventZBATDefaultTypeInternal _EssEventZBAT_default_instance_;
class EssStatusZBAT;
struct EssStatusZBATDefaultTypeInternal;
extern EssStatusZBATDefaultTypeInternal _EssStatusZBAT_default_instance_;
class FrequencyRegulation;
struct FrequencyRegulationDefaultTypeInternal;
extern FrequencyRegulationDefaultTypeInternal _FrequencyRegulation_default_instance_;
class PeakShaving;
struct PeakShavingDefaultTypeInternal;
extern PeakShavingDefaultTypeInternal _PeakShaving_default_instance_;
class SOCManagement;
struct SOCManagementDefaultTypeInternal;
extern SOCManagementDefaultTypeInternal _SOCManagement_default_instance_;
class SocLimit;
struct SocLimitDefaultTypeInternal;
extern SocLimitDefaultTypeInternal _SocLimit_default_instance_;
class VoltageDroop;
struct VoltageDroopDefaultTypeInternal;
extern VoltageDroopDefaultTypeInternal _VoltageDroop_default_instance_;
class VoltagePI;
struct VoltagePIDefaultTypeInternal;
extern VoltagePIDefaultTypeInternal _VoltagePI_default_instance_;
class VoltageRegulation;
struct VoltageRegulationDefaultTypeInternal;
extern VoltageRegulationDefaultTypeInternal _VoltageRegulation_default_instance_;
}  // namespace essmodule
PROTOBUF_NAMESPACE_OPEN
template <>
::essmodule::CapacityFirming* Arena::CreateMaybeMessage<::essmodule::CapacityFirming>(Arena*);
template <>
::essmodule::ESSCSG* Arena::CreateMaybeMessage<::essmodule::ESSCSG>(Arena*);
template <>
::essmodule::ESSCapability* Arena::CreateMaybeMessage<::essmodule::ESSCapability>(Arena*);
template <>
::essmodule::ESSCapabilityConfiguration* Arena::CreateMaybeMessage<::essmodule::ESSCapabilityConfiguration>(Arena*);
template <>
::essmodule::ESSCapabilityOverride* Arena::CreateMaybeMessage<::essmodule::ESSCapabilityOverride>(Arena*);
template <>
::essmodule::ESSCapabilityOverrideProfile* Arena::CreateMaybeMessage<::essmodule::ESSCapabilityOverrideProfile>(Arena*);
template <>
::essmodule::ESSCapabilityProfile* Arena::CreateMaybeMessage<::essmodule::ESSCapabilityProfile>(Arena*);
template <>
::essmodule::ESSCapabilityRatings* Arena::CreateMaybeMessage<::essmodule::ESSCapabilityRatings>(Arena*);
template <>
::essmodule::ESSControl* Arena::CreateMaybeMessage<::essmodule::ESSControl>(Arena*);
template <>
::essmodule::ESSControlProfile* Arena::CreateMaybeMessage<::essmodule::ESSControlProfile>(Arena*);
template <>
::essmodule::ESSControlScheduleFSCH* Arena::CreateMaybeMessage<::essmodule::ESSControlScheduleFSCH>(Arena*);
template <>
::essmodule::ESSCurvePoint* Arena::CreateMaybeMessage<::essmodule::ESSCurvePoint>(Arena*);
template <>
::essmodule::ESSDiscreteControl* Arena::CreateMaybeMessage<::essmodule::ESSDiscreteControl>(Arena*);
template <>
::essmodule::ESSDiscreteControlDBAT* Arena::CreateMaybeMessage<::essmodule::ESSDiscreteControlDBAT>(Arena*);
template <>
::essmodule::ESSDiscreteControlProfile* Arena::CreateMaybeMessage<::essmodule::ESSDiscreteControlProfile>(Arena*);
template <>
::essmodule::ESSEvent* Arena::CreateMaybeMessage<::essmodule::ESSEvent>(Arena*);
template <>
::essmodule::ESSEventAndStatusZGEN* Arena::CreateMaybeMessage<::essmodule::ESSEventAndStatusZGEN>(Arena*);
template <>
::essmodule::ESSEventProfile* Arena::CreateMaybeMessage<::essmodule::ESSEventProfile>(Arena*);
template <>
::essmodule::ESSEventZGEN* Arena::CreateMaybeMessage<::essmodule::ESSEventZGEN>(Arena*);
template <>
::essmodule::ESSFunction* Arena::CreateMaybeMessage<::essmodule::ESSFunction>(Arena*);
template <>
::essmodule::ESSPoint* Arena::CreateMaybeMessage<::essmodule::ESSPoint>(Arena*);
template <>
::essmodule::ESSPointStatus* Arena::CreateMaybeMessage<::essmodule::ESSPointStatus>(Arena*);
template <>
::essmodule::ESSReading* Arena::CreateMaybeMessage<::essmodule::ESSReading>(Arena*);
template <>
::essmodule::ESSReadingProfile* Arena::CreateMaybeMessage<::essmodule::ESSReadingProfile>(Arena*);
template <>
::essmodule::ESSStatus* Arena::CreateMaybeMessage<::essmodule::ESSStatus>(Arena*);
template <>
::essmodule::ESSStatusProfile* Arena::CreateMaybeMessage<::essmodule::ESSStatusProfile>(Arena*);
template <>
::essmodule::ESSStatusZGEN* Arena::CreateMaybeMessage<::essmodule::ESSStatusZGEN>(Arena*);
template <>
::essmodule::EssControlFSCC* Arena::CreateMaybeMessage<::essmodule::EssControlFSCC>(Arena*);
template <>
::essmodule::EssEventZBAT* Arena::CreateMaybeMessage<::essmodule::EssEventZBAT>(Arena*);
template <>
::essmodule::EssStatusZBAT* Arena::CreateMaybeMessage<::essmodule::EssStatusZBAT>(Arena*);
template <>
::essmodule::FrequencyRegulation* Arena::CreateMaybeMessage<::essmodule::FrequencyRegulation>(Arena*);
template <>
::essmodule::PeakShaving* Arena::CreateMaybeMessage<::essmodule::PeakShaving>(Arena*);
template <>
::essmodule::SOCManagement* Arena::CreateMaybeMessage<::essmodule::SOCManagement>(Arena*);
template <>
::essmodule::SocLimit* Arena::CreateMaybeMessage<::essmodule::SocLimit>(Arena*);
template <>
::essmodule::VoltageDroop* Arena::CreateMaybeMessage<::essmodule::VoltageDroop>(Arena*);
template <>
::essmodule::VoltagePI* Arena::CreateMaybeMessage<::essmodule::VoltagePI>(Arena*);
template <>
::essmodule::VoltageRegulation* Arena::CreateMaybeMessage<::essmodule::VoltageRegulation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace essmodule {

// ===================================================================


// -------------------------------------------------------------------

class ESSCapabilityConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCapabilityConfiguration) */ {
 public:
  inline ESSCapabilityConfiguration() : ESSCapabilityConfiguration(nullptr) {}
  ~ESSCapabilityConfiguration() override;
  explicit PROTOBUF_CONSTEXPR ESSCapabilityConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCapabilityConfiguration(const ESSCapabilityConfiguration& from);
  ESSCapabilityConfiguration(ESSCapabilityConfiguration&& from) noexcept
    : ESSCapabilityConfiguration() {
    *this = ::std::move(from);
  }

  inline ESSCapabilityConfiguration& operator=(const ESSCapabilityConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCapabilityConfiguration& operator=(ESSCapabilityConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCapabilityConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCapabilityConfiguration* internal_default_instance() {
    return reinterpret_cast<const ESSCapabilityConfiguration*>(
               &_ESSCapabilityConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ESSCapabilityConfiguration& a, ESSCapabilityConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCapabilityConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCapabilityConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCapabilityConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCapabilityConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCapabilityConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCapabilityConfiguration& from) {
    ESSCapabilityConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCapabilityConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCapabilityConfiguration";
  }
  protected:
  explicit ESSCapabilityConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceCapabilityConfigurationFieldNumber = 1,
    kVAChaRteMaxFieldNumber = 2,
    kVADisChaRteMaxFieldNumber = 3,
    kWChaRteMaxFieldNumber = 4,
    kWDisChaRteMaxFieldNumber = 5,
  };
  // .commonmodule.SourceCapabilityConfiguration sourceCapabilityConfiguration = 1 [(.uml.option_parent_message) = true];
  bool has_sourcecapabilityconfiguration() const;
  private:
  bool _internal_has_sourcecapabilityconfiguration() const;

  public:
  void clear_sourcecapabilityconfiguration() ;
  const ::commonmodule::SourceCapabilityConfiguration& sourcecapabilityconfiguration() const;
  PROTOBUF_NODISCARD ::commonmodule::SourceCapabilityConfiguration* release_sourcecapabilityconfiguration();
  ::commonmodule::SourceCapabilityConfiguration* mutable_sourcecapabilityconfiguration();
  void set_allocated_sourcecapabilityconfiguration(::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration);
  private:
  const ::commonmodule::SourceCapabilityConfiguration& _internal_sourcecapabilityconfiguration() const;
  ::commonmodule::SourceCapabilityConfiguration* _internal_mutable_sourcecapabilityconfiguration();
  public:
  void unsafe_arena_set_allocated_sourcecapabilityconfiguration(
      ::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration);
  ::commonmodule::SourceCapabilityConfiguration* unsafe_arena_release_sourcecapabilityconfiguration();
  // .commonmodule.ASG VAChaRteMax = 2;
  bool has_vachartemax() const;
  private:
  bool _internal_has_vachartemax() const;

  public:
  void clear_vachartemax() ;
  const ::commonmodule::ASG& vachartemax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vachartemax();
  ::commonmodule::ASG* mutable_vachartemax();
  void set_allocated_vachartemax(::commonmodule::ASG* vachartemax);
  private:
  const ::commonmodule::ASG& _internal_vachartemax() const;
  ::commonmodule::ASG* _internal_mutable_vachartemax();
  public:
  void unsafe_arena_set_allocated_vachartemax(
      ::commonmodule::ASG* vachartemax);
  ::commonmodule::ASG* unsafe_arena_release_vachartemax();
  // .commonmodule.ASG VADisChaRteMax = 3;
  bool has_vadischartemax() const;
  private:
  bool _internal_has_vadischartemax() const;

  public:
  void clear_vadischartemax() ;
  const ::commonmodule::ASG& vadischartemax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vadischartemax();
  ::commonmodule::ASG* mutable_vadischartemax();
  void set_allocated_vadischartemax(::commonmodule::ASG* vadischartemax);
  private:
  const ::commonmodule::ASG& _internal_vadischartemax() const;
  ::commonmodule::ASG* _internal_mutable_vadischartemax();
  public:
  void unsafe_arena_set_allocated_vadischartemax(
      ::commonmodule::ASG* vadischartemax);
  ::commonmodule::ASG* unsafe_arena_release_vadischartemax();
  // .commonmodule.ASG WChaRteMax = 4;
  bool has_wchartemax() const;
  private:
  bool _internal_has_wchartemax() const;

  public:
  void clear_wchartemax() ;
  const ::commonmodule::ASG& wchartemax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wchartemax();
  ::commonmodule::ASG* mutable_wchartemax();
  void set_allocated_wchartemax(::commonmodule::ASG* wchartemax);
  private:
  const ::commonmodule::ASG& _internal_wchartemax() const;
  ::commonmodule::ASG* _internal_mutable_wchartemax();
  public:
  void unsafe_arena_set_allocated_wchartemax(
      ::commonmodule::ASG* wchartemax);
  ::commonmodule::ASG* unsafe_arena_release_wchartemax();
  // .commonmodule.ASG WDisChaRteMax = 5;
  bool has_wdischartemax() const;
  private:
  bool _internal_has_wdischartemax() const;

  public:
  void clear_wdischartemax() ;
  const ::commonmodule::ASG& wdischartemax() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wdischartemax();
  ::commonmodule::ASG* mutable_wdischartemax();
  void set_allocated_wdischartemax(::commonmodule::ASG* wdischartemax);
  private:
  const ::commonmodule::ASG& _internal_wdischartemax() const;
  ::commonmodule::ASG* _internal_mutable_wdischartemax();
  public:
  void unsafe_arena_set_allocated_wdischartemax(
      ::commonmodule::ASG* wdischartemax);
  ::commonmodule::ASG* unsafe_arena_release_wdischartemax();
  // @@protoc_insertion_point(class_scope:essmodule.ESSCapabilityConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration_;
    ::commonmodule::ASG* vachartemax_;
    ::commonmodule::ASG* vadischartemax_;
    ::commonmodule::ASG* wchartemax_;
    ::commonmodule::ASG* wdischartemax_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSCapabilityOverride final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCapabilityOverride) */ {
 public:
  inline ESSCapabilityOverride() : ESSCapabilityOverride(nullptr) {}
  ~ESSCapabilityOverride() override;
  explicit PROTOBUF_CONSTEXPR ESSCapabilityOverride(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCapabilityOverride(const ESSCapabilityOverride& from);
  ESSCapabilityOverride(ESSCapabilityOverride&& from) noexcept
    : ESSCapabilityOverride() {
    *this = ::std::move(from);
  }

  inline ESSCapabilityOverride& operator=(const ESSCapabilityOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCapabilityOverride& operator=(ESSCapabilityOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCapabilityOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCapabilityOverride* internal_default_instance() {
    return reinterpret_cast<const ESSCapabilityOverride*>(
               &_ESSCapabilityOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ESSCapabilityOverride& a, ESSCapabilityOverride& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCapabilityOverride* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCapabilityOverride* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCapabilityOverride* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCapabilityOverride>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCapabilityOverride& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCapabilityOverride& from) {
    ESSCapabilityOverride::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCapabilityOverride* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCapabilityOverride";
  }
  protected:
  explicit ESSCapabilityOverride(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameplateValueFieldNumber = 1,
    kEssCapabilityConfigurationFieldNumber = 2,
  };
  // .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
  bool has_nameplatevalue() const;
  private:
  bool _internal_has_nameplatevalue() const;

  public:
  void clear_nameplatevalue() ;
  const ::commonmodule::NameplateValue& nameplatevalue() const;
  PROTOBUF_NODISCARD ::commonmodule::NameplateValue* release_nameplatevalue();
  ::commonmodule::NameplateValue* mutable_nameplatevalue();
  void set_allocated_nameplatevalue(::commonmodule::NameplateValue* nameplatevalue);
  private:
  const ::commonmodule::NameplateValue& _internal_nameplatevalue() const;
  ::commonmodule::NameplateValue* _internal_mutable_nameplatevalue();
  public:
  void unsafe_arena_set_allocated_nameplatevalue(
      ::commonmodule::NameplateValue* nameplatevalue);
  ::commonmodule::NameplateValue* unsafe_arena_release_nameplatevalue();
  // .essmodule.ESSCapabilityConfiguration essCapabilityConfiguration = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_esscapabilityconfiguration() const;
  private:
  bool _internal_has_esscapabilityconfiguration() const;

  public:
  void clear_esscapabilityconfiguration() ;
  const ::essmodule::ESSCapabilityConfiguration& esscapabilityconfiguration() const;
  PROTOBUF_NODISCARD ::essmodule::ESSCapabilityConfiguration* release_esscapabilityconfiguration();
  ::essmodule::ESSCapabilityConfiguration* mutable_esscapabilityconfiguration();
  void set_allocated_esscapabilityconfiguration(::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration);
  private:
  const ::essmodule::ESSCapabilityConfiguration& _internal_esscapabilityconfiguration() const;
  ::essmodule::ESSCapabilityConfiguration* _internal_mutable_esscapabilityconfiguration();
  public:
  void unsafe_arena_set_allocated_esscapabilityconfiguration(
      ::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration);
  ::essmodule::ESSCapabilityConfiguration* unsafe_arena_release_esscapabilityconfiguration();
  // @@protoc_insertion_point(class_scope:essmodule.ESSCapabilityOverride)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::NameplateValue* nameplatevalue_;
    ::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSCapabilityOverrideProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCapabilityOverrideProfile) */ {
 public:
  inline ESSCapabilityOverrideProfile() : ESSCapabilityOverrideProfile(nullptr) {}
  ~ESSCapabilityOverrideProfile() override;
  explicit PROTOBUF_CONSTEXPR ESSCapabilityOverrideProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCapabilityOverrideProfile(const ESSCapabilityOverrideProfile& from);
  ESSCapabilityOverrideProfile(ESSCapabilityOverrideProfile&& from) noexcept
    : ESSCapabilityOverrideProfile() {
    *this = ::std::move(from);
  }

  inline ESSCapabilityOverrideProfile& operator=(const ESSCapabilityOverrideProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCapabilityOverrideProfile& operator=(ESSCapabilityOverrideProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCapabilityOverrideProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCapabilityOverrideProfile* internal_default_instance() {
    return reinterpret_cast<const ESSCapabilityOverrideProfile*>(
               &_ESSCapabilityOverrideProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ESSCapabilityOverrideProfile& a, ESSCapabilityOverrideProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCapabilityOverrideProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCapabilityOverrideProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCapabilityOverrideProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCapabilityOverrideProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCapabilityOverrideProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCapabilityOverrideProfile& from) {
    ESSCapabilityOverrideProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCapabilityOverrideProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCapabilityOverrideProfile";
  }
  protected:
  explicit ESSCapabilityOverrideProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilityMessageInfoFieldNumber = 1,
    kEssFieldNumber = 2,
    kEssCapabilityOverrideFieldNumber = 3,
  };
  // .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_capabilitymessageinfo() const;
  private:
  bool _internal_has_capabilitymessageinfo() const;

  public:
  void clear_capabilitymessageinfo() ;
  const ::commonmodule::CapabilityMessageInfo& capabilitymessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::CapabilityMessageInfo* release_capabilitymessageinfo();
  ::commonmodule::CapabilityMessageInfo* mutable_capabilitymessageinfo();
  void set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  private:
  const ::commonmodule::CapabilityMessageInfo& _internal_capabilitymessageinfo() const;
  ::commonmodule::CapabilityMessageInfo* _internal_mutable_capabilitymessageinfo();
  public:
  void unsafe_arena_set_allocated_capabilitymessageinfo(
      ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  ::commonmodule::CapabilityMessageInfo* unsafe_arena_release_capabilitymessageinfo();
  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  private:
  bool _internal_has_ess() const;

  public:
  void clear_ess() ;
  const ::commonmodule::ESS& ess() const;
  PROTOBUF_NODISCARD ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);
  private:
  const ::commonmodule::ESS& _internal_ess() const;
  ::commonmodule::ESS* _internal_mutable_ess();
  public:
  void unsafe_arena_set_allocated_ess(
      ::commonmodule::ESS* ess);
  ::commonmodule::ESS* unsafe_arena_release_ess();
  // .essmodule.ESSCapabilityOverride essCapabilityOverride = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_esscapabilityoverride() const;
  private:
  bool _internal_has_esscapabilityoverride() const;

  public:
  void clear_esscapabilityoverride() ;
  const ::essmodule::ESSCapabilityOverride& esscapabilityoverride() const;
  PROTOBUF_NODISCARD ::essmodule::ESSCapabilityOverride* release_esscapabilityoverride();
  ::essmodule::ESSCapabilityOverride* mutable_esscapabilityoverride();
  void set_allocated_esscapabilityoverride(::essmodule::ESSCapabilityOverride* esscapabilityoverride);
  private:
  const ::essmodule::ESSCapabilityOverride& _internal_esscapabilityoverride() const;
  ::essmodule::ESSCapabilityOverride* _internal_mutable_esscapabilityoverride();
  public:
  void unsafe_arena_set_allocated_esscapabilityoverride(
      ::essmodule::ESSCapabilityOverride* esscapabilityoverride);
  ::essmodule::ESSCapabilityOverride* unsafe_arena_release_esscapabilityoverride();
  // @@protoc_insertion_point(class_scope:essmodule.ESSCapabilityOverrideProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo_;
    ::commonmodule::ESS* ess_;
    ::essmodule::ESSCapabilityOverride* esscapabilityoverride_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSCapabilityRatings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCapabilityRatings) */ {
 public:
  inline ESSCapabilityRatings() : ESSCapabilityRatings(nullptr) {}
  ~ESSCapabilityRatings() override;
  explicit PROTOBUF_CONSTEXPR ESSCapabilityRatings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCapabilityRatings(const ESSCapabilityRatings& from);
  ESSCapabilityRatings(ESSCapabilityRatings&& from) noexcept
    : ESSCapabilityRatings() {
    *this = ::std::move(from);
  }

  inline ESSCapabilityRatings& operator=(const ESSCapabilityRatings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCapabilityRatings& operator=(ESSCapabilityRatings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCapabilityRatings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCapabilityRatings* internal_default_instance() {
    return reinterpret_cast<const ESSCapabilityRatings*>(
               &_ESSCapabilityRatings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ESSCapabilityRatings& a, ESSCapabilityRatings& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCapabilityRatings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCapabilityRatings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCapabilityRatings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCapabilityRatings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCapabilityRatings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCapabilityRatings& from) {
    ESSCapabilityRatings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCapabilityRatings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCapabilityRatings";
  }
  protected:
  explicit ESSCapabilityRatings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceCapabilityRatingsFieldNumber = 1,
    kVAChaRteMaxRtgFieldNumber = 2,
    kVADisChaRteMaxRtgFieldNumber = 3,
    kWChaRteMaxRtgFieldNumber = 4,
    kWDisChaRteMaxRtgFieldNumber = 5,
    kWHRtgFieldNumber = 6,
  };
  // .commonmodule.SourceCapabilityRatings sourceCapabilityRatings = 1 [(.uml.option_parent_message) = true];
  bool has_sourcecapabilityratings() const;
  private:
  bool _internal_has_sourcecapabilityratings() const;

  public:
  void clear_sourcecapabilityratings() ;
  const ::commonmodule::SourceCapabilityRatings& sourcecapabilityratings() const;
  PROTOBUF_NODISCARD ::commonmodule::SourceCapabilityRatings* release_sourcecapabilityratings();
  ::commonmodule::SourceCapabilityRatings* mutable_sourcecapabilityratings();
  void set_allocated_sourcecapabilityratings(::commonmodule::SourceCapabilityRatings* sourcecapabilityratings);
  private:
  const ::commonmodule::SourceCapabilityRatings& _internal_sourcecapabilityratings() const;
  ::commonmodule::SourceCapabilityRatings* _internal_mutable_sourcecapabilityratings();
  public:
  void unsafe_arena_set_allocated_sourcecapabilityratings(
      ::commonmodule::SourceCapabilityRatings* sourcecapabilityratings);
  ::commonmodule::SourceCapabilityRatings* unsafe_arena_release_sourcecapabilityratings();
  // .commonmodule.ASG VAChaRteMaxRtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vachartemaxrtg() const;
  private:
  bool _internal_has_vachartemaxrtg() const;

  public:
  void clear_vachartemaxrtg() ;
  const ::commonmodule::ASG& vachartemaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vachartemaxrtg();
  ::commonmodule::ASG* mutable_vachartemaxrtg();
  void set_allocated_vachartemaxrtg(::commonmodule::ASG* vachartemaxrtg);
  private:
  const ::commonmodule::ASG& _internal_vachartemaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_vachartemaxrtg();
  public:
  void unsafe_arena_set_allocated_vachartemaxrtg(
      ::commonmodule::ASG* vachartemaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_vachartemaxrtg();
  // .commonmodule.ASG VADisChaRteMaxRtg = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_vadischartemaxrtg() const;
  private:
  bool _internal_has_vadischartemaxrtg() const;

  public:
  void clear_vadischartemaxrtg() ;
  const ::commonmodule::ASG& vadischartemaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_vadischartemaxrtg();
  ::commonmodule::ASG* mutable_vadischartemaxrtg();
  void set_allocated_vadischartemaxrtg(::commonmodule::ASG* vadischartemaxrtg);
  private:
  const ::commonmodule::ASG& _internal_vadischartemaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_vadischartemaxrtg();
  public:
  void unsafe_arena_set_allocated_vadischartemaxrtg(
      ::commonmodule::ASG* vadischartemaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_vadischartemaxrtg();
  // .commonmodule.ASG WChaRteMaxRtg = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wchartemaxrtg() const;
  private:
  bool _internal_has_wchartemaxrtg() const;

  public:
  void clear_wchartemaxrtg() ;
  const ::commonmodule::ASG& wchartemaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wchartemaxrtg();
  ::commonmodule::ASG* mutable_wchartemaxrtg();
  void set_allocated_wchartemaxrtg(::commonmodule::ASG* wchartemaxrtg);
  private:
  const ::commonmodule::ASG& _internal_wchartemaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_wchartemaxrtg();
  public:
  void unsafe_arena_set_allocated_wchartemaxrtg(
      ::commonmodule::ASG* wchartemaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_wchartemaxrtg();
  // .commonmodule.ASG WDisChaRteMaxRtg = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_wdischartemaxrtg() const;
  private:
  bool _internal_has_wdischartemaxrtg() const;

  public:
  void clear_wdischartemaxrtg() ;
  const ::commonmodule::ASG& wdischartemaxrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_wdischartemaxrtg();
  ::commonmodule::ASG* mutable_wdischartemaxrtg();
  void set_allocated_wdischartemaxrtg(::commonmodule::ASG* wdischartemaxrtg);
  private:
  const ::commonmodule::ASG& _internal_wdischartemaxrtg() const;
  ::commonmodule::ASG* _internal_mutable_wdischartemaxrtg();
  public:
  void unsafe_arena_set_allocated_wdischartemaxrtg(
      ::commonmodule::ASG* wdischartemaxrtg);
  ::commonmodule::ASG* unsafe_arena_release_wdischartemaxrtg();
  // .commonmodule.ASG WHRtg = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_whrtg() const;
  private:
  bool _internal_has_whrtg() const;

  public:
  void clear_whrtg() ;
  const ::commonmodule::ASG& whrtg() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_whrtg();
  ::commonmodule::ASG* mutable_whrtg();
  void set_allocated_whrtg(::commonmodule::ASG* whrtg);
  private:
  const ::commonmodule::ASG& _internal_whrtg() const;
  ::commonmodule::ASG* _internal_mutable_whrtg();
  public:
  void unsafe_arena_set_allocated_whrtg(
      ::commonmodule::ASG* whrtg);
  ::commonmodule::ASG* unsafe_arena_release_whrtg();
  // @@protoc_insertion_point(class_scope:essmodule.ESSCapabilityRatings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::SourceCapabilityRatings* sourcecapabilityratings_;
    ::commonmodule::ASG* vachartemaxrtg_;
    ::commonmodule::ASG* vadischartemaxrtg_;
    ::commonmodule::ASG* wchartemaxrtg_;
    ::commonmodule::ASG* wdischartemaxrtg_;
    ::commonmodule::ASG* whrtg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSCapability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCapability) */ {
 public:
  inline ESSCapability() : ESSCapability(nullptr) {}
  ~ESSCapability() override;
  explicit PROTOBUF_CONSTEXPR ESSCapability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCapability(const ESSCapability& from);
  ESSCapability(ESSCapability&& from) noexcept
    : ESSCapability() {
    *this = ::std::move(from);
  }

  inline ESSCapability& operator=(const ESSCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCapability& operator=(ESSCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCapability& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCapability* internal_default_instance() {
    return reinterpret_cast<const ESSCapability*>(
               &_ESSCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ESSCapability& a, ESSCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCapability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCapability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCapability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCapability& from) {
    ESSCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCapability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCapability";
  }
  protected:
  explicit ESSCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameplateValueFieldNumber = 1,
    kEssCapabilityRatingsFieldNumber = 2,
    kEssCapabilityConfigurationFieldNumber = 3,
  };
  // .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
  bool has_nameplatevalue() const;
  private:
  bool _internal_has_nameplatevalue() const;

  public:
  void clear_nameplatevalue() ;
  const ::commonmodule::NameplateValue& nameplatevalue() const;
  PROTOBUF_NODISCARD ::commonmodule::NameplateValue* release_nameplatevalue();
  ::commonmodule::NameplateValue* mutable_nameplatevalue();
  void set_allocated_nameplatevalue(::commonmodule::NameplateValue* nameplatevalue);
  private:
  const ::commonmodule::NameplateValue& _internal_nameplatevalue() const;
  ::commonmodule::NameplateValue* _internal_mutable_nameplatevalue();
  public:
  void unsafe_arena_set_allocated_nameplatevalue(
      ::commonmodule::NameplateValue* nameplatevalue);
  ::commonmodule::NameplateValue* unsafe_arena_release_nameplatevalue();
  // .essmodule.ESSCapabilityRatings essCapabilityRatings = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_esscapabilityratings() const;
  private:
  bool _internal_has_esscapabilityratings() const;

  public:
  void clear_esscapabilityratings() ;
  const ::essmodule::ESSCapabilityRatings& esscapabilityratings() const;
  PROTOBUF_NODISCARD ::essmodule::ESSCapabilityRatings* release_esscapabilityratings();
  ::essmodule::ESSCapabilityRatings* mutable_esscapabilityratings();
  void set_allocated_esscapabilityratings(::essmodule::ESSCapabilityRatings* esscapabilityratings);
  private:
  const ::essmodule::ESSCapabilityRatings& _internal_esscapabilityratings() const;
  ::essmodule::ESSCapabilityRatings* _internal_mutable_esscapabilityratings();
  public:
  void unsafe_arena_set_allocated_esscapabilityratings(
      ::essmodule::ESSCapabilityRatings* esscapabilityratings);
  ::essmodule::ESSCapabilityRatings* unsafe_arena_release_esscapabilityratings();
  // .essmodule.ESSCapabilityConfiguration essCapabilityConfiguration = 3;
  bool has_esscapabilityconfiguration() const;
  private:
  bool _internal_has_esscapabilityconfiguration() const;

  public:
  void clear_esscapabilityconfiguration() ;
  const ::essmodule::ESSCapabilityConfiguration& esscapabilityconfiguration() const;
  PROTOBUF_NODISCARD ::essmodule::ESSCapabilityConfiguration* release_esscapabilityconfiguration();
  ::essmodule::ESSCapabilityConfiguration* mutable_esscapabilityconfiguration();
  void set_allocated_esscapabilityconfiguration(::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration);
  private:
  const ::essmodule::ESSCapabilityConfiguration& _internal_esscapabilityconfiguration() const;
  ::essmodule::ESSCapabilityConfiguration* _internal_mutable_esscapabilityconfiguration();
  public:
  void unsafe_arena_set_allocated_esscapabilityconfiguration(
      ::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration);
  ::essmodule::ESSCapabilityConfiguration* unsafe_arena_release_esscapabilityconfiguration();
  // @@protoc_insertion_point(class_scope:essmodule.ESSCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::NameplateValue* nameplatevalue_;
    ::essmodule::ESSCapabilityRatings* esscapabilityratings_;
    ::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSCapabilityProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCapabilityProfile) */ {
 public:
  inline ESSCapabilityProfile() : ESSCapabilityProfile(nullptr) {}
  ~ESSCapabilityProfile() override;
  explicit PROTOBUF_CONSTEXPR ESSCapabilityProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCapabilityProfile(const ESSCapabilityProfile& from);
  ESSCapabilityProfile(ESSCapabilityProfile&& from) noexcept
    : ESSCapabilityProfile() {
    *this = ::std::move(from);
  }

  inline ESSCapabilityProfile& operator=(const ESSCapabilityProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCapabilityProfile& operator=(ESSCapabilityProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCapabilityProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCapabilityProfile* internal_default_instance() {
    return reinterpret_cast<const ESSCapabilityProfile*>(
               &_ESSCapabilityProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ESSCapabilityProfile& a, ESSCapabilityProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCapabilityProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCapabilityProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCapabilityProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCapabilityProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCapabilityProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCapabilityProfile& from) {
    ESSCapabilityProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCapabilityProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCapabilityProfile";
  }
  protected:
  explicit ESSCapabilityProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilityMessageInfoFieldNumber = 1,
    kEssFieldNumber = 2,
    kEssCapabilityFieldNumber = 3,
  };
  // .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_capabilitymessageinfo() const;
  private:
  bool _internal_has_capabilitymessageinfo() const;

  public:
  void clear_capabilitymessageinfo() ;
  const ::commonmodule::CapabilityMessageInfo& capabilitymessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::CapabilityMessageInfo* release_capabilitymessageinfo();
  ::commonmodule::CapabilityMessageInfo* mutable_capabilitymessageinfo();
  void set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  private:
  const ::commonmodule::CapabilityMessageInfo& _internal_capabilitymessageinfo() const;
  ::commonmodule::CapabilityMessageInfo* _internal_mutable_capabilitymessageinfo();
  public:
  void unsafe_arena_set_allocated_capabilitymessageinfo(
      ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo);
  ::commonmodule::CapabilityMessageInfo* unsafe_arena_release_capabilitymessageinfo();
  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  private:
  bool _internal_has_ess() const;

  public:
  void clear_ess() ;
  const ::commonmodule::ESS& ess() const;
  PROTOBUF_NODISCARD ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);
  private:
  const ::commonmodule::ESS& _internal_ess() const;
  ::commonmodule::ESS* _internal_mutable_ess();
  public:
  void unsafe_arena_set_allocated_ess(
      ::commonmodule::ESS* ess);
  ::commonmodule::ESS* unsafe_arena_release_ess();
  // .essmodule.ESSCapability essCapability = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_esscapability() const;
  private:
  bool _internal_has_esscapability() const;

  public:
  void clear_esscapability() ;
  const ::essmodule::ESSCapability& esscapability() const;
  PROTOBUF_NODISCARD ::essmodule::ESSCapability* release_esscapability();
  ::essmodule::ESSCapability* mutable_esscapability();
  void set_allocated_esscapability(::essmodule::ESSCapability* esscapability);
  private:
  const ::essmodule::ESSCapability& _internal_esscapability() const;
  ::essmodule::ESSCapability* _internal_mutable_esscapability();
  public:
  void unsafe_arena_set_allocated_esscapability(
      ::essmodule::ESSCapability* esscapability);
  ::essmodule::ESSCapability* unsafe_arena_release_esscapability();
  // @@protoc_insertion_point(class_scope:essmodule.ESSCapabilityProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo_;
    ::commonmodule::ESS* ess_;
    ::essmodule::ESSCapability* esscapability_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class FrequencyRegulation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.FrequencyRegulation) */ {
 public:
  inline FrequencyRegulation() : FrequencyRegulation(nullptr) {}
  ~FrequencyRegulation() override;
  explicit PROTOBUF_CONSTEXPR FrequencyRegulation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrequencyRegulation(const FrequencyRegulation& from);
  FrequencyRegulation(FrequencyRegulation&& from) noexcept
    : FrequencyRegulation() {
    *this = ::std::move(from);
  }

  inline FrequencyRegulation& operator=(const FrequencyRegulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrequencyRegulation& operator=(FrequencyRegulation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrequencyRegulation& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrequencyRegulation* internal_default_instance() {
    return reinterpret_cast<const FrequencyRegulation*>(
               &_FrequencyRegulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FrequencyRegulation& a, FrequencyRegulation& b) {
    a.Swap(&b);
  }
  inline void Swap(FrequencyRegulation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrequencyRegulation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrequencyRegulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrequencyRegulation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrequencyRegulation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrequencyRegulation& from) {
    FrequencyRegulation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrequencyRegulation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.FrequencyRegulation";
  }
  protected:
  explicit FrequencyRegulation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyDeadBandMinusFieldNumber = 1,
    kFrequencyDeadBandPlusFieldNumber = 2,
    kFrequencyRegulationCtlFieldNumber = 3,
    kFrequencySetPointFieldNumber = 4,
    kGridFrequencyStableBandMinusFieldNumber = 5,
    kGridFrequencyStableBandPlusFieldNumber = 6,
    kOverFrequencyDroopFieldNumber = 7,
    kUnderFrequencyDroopFieldNumber = 8,
  };
  // .google.protobuf.FloatValue frequencyDeadBandMinus = 1;
  bool has_frequencydeadbandminus() const;
  private:
  bool _internal_has_frequencydeadbandminus() const;

  public:
  void clear_frequencydeadbandminus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& frequencydeadbandminus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_frequencydeadbandminus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_frequencydeadbandminus();
  void set_allocated_frequencydeadbandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandminus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_frequencydeadbandminus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_frequencydeadbandminus();
  public:
  void unsafe_arena_set_allocated_frequencydeadbandminus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandminus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_frequencydeadbandminus();
  // .google.protobuf.FloatValue frequencyDeadBandPlus = 2;
  bool has_frequencydeadbandplus() const;
  private:
  bool _internal_has_frequencydeadbandplus() const;

  public:
  void clear_frequencydeadbandplus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& frequencydeadbandplus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_frequencydeadbandplus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_frequencydeadbandplus();
  void set_allocated_frequencydeadbandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandplus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_frequencydeadbandplus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_frequencydeadbandplus();
  public:
  void unsafe_arena_set_allocated_frequencydeadbandplus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandplus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_frequencydeadbandplus();
  // .google.protobuf.BoolValue frequencyRegulationCtl = 3;
  bool has_frequencyregulationctl() const;
  private:
  bool _internal_has_frequencyregulationctl() const;

  public:
  void clear_frequencyregulationctl() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& frequencyregulationctl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_frequencyregulationctl();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_frequencyregulationctl();
  void set_allocated_frequencyregulationctl(::PROTOBUF_NAMESPACE_ID::BoolValue* frequencyregulationctl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_frequencyregulationctl() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_frequencyregulationctl();
  public:
  void unsafe_arena_set_allocated_frequencyregulationctl(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* frequencyregulationctl);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_frequencyregulationctl();
  // .google.protobuf.FloatValue frequencySetPoint = 4;
  bool has_frequencysetpoint() const;
  private:
  bool _internal_has_frequencysetpoint() const;

  public:
  void clear_frequencysetpoint() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& frequencysetpoint() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_frequencysetpoint();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_frequencysetpoint();
  void set_allocated_frequencysetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* frequencysetpoint);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_frequencysetpoint() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_frequencysetpoint();
  public:
  void unsafe_arena_set_allocated_frequencysetpoint(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencysetpoint);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_frequencysetpoint();
  // .google.protobuf.FloatValue gridFrequencyStableBandMinus = 5;
  bool has_gridfrequencystablebandminus() const;
  private:
  bool _internal_has_gridfrequencystablebandminus() const;

  public:
  void clear_gridfrequencystablebandminus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& gridfrequencystablebandminus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_gridfrequencystablebandminus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_gridfrequencystablebandminus();
  void set_allocated_gridfrequencystablebandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandminus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_gridfrequencystablebandminus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_gridfrequencystablebandminus();
  public:
  void unsafe_arena_set_allocated_gridfrequencystablebandminus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandminus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_gridfrequencystablebandminus();
  // .google.protobuf.FloatValue gridFrequencyStableBandPlus = 6;
  bool has_gridfrequencystablebandplus() const;
  private:
  bool _internal_has_gridfrequencystablebandplus() const;

  public:
  void clear_gridfrequencystablebandplus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& gridfrequencystablebandplus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_gridfrequencystablebandplus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_gridfrequencystablebandplus();
  void set_allocated_gridfrequencystablebandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandplus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_gridfrequencystablebandplus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_gridfrequencystablebandplus();
  public:
  void unsafe_arena_set_allocated_gridfrequencystablebandplus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandplus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_gridfrequencystablebandplus();
  // .google.protobuf.FloatValue overFrequencyDroop = 7;
  bool has_overfrequencydroop() const;
  private:
  bool _internal_has_overfrequencydroop() const;

  public:
  void clear_overfrequencydroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& overfrequencydroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_overfrequencydroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_overfrequencydroop();
  void set_allocated_overfrequencydroop(::PROTOBUF_NAMESPACE_ID::FloatValue* overfrequencydroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_overfrequencydroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_overfrequencydroop();
  public:
  void unsafe_arena_set_allocated_overfrequencydroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* overfrequencydroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_overfrequencydroop();
  // .google.protobuf.FloatValue underFrequencyDroop = 8;
  bool has_underfrequencydroop() const;
  private:
  bool _internal_has_underfrequencydroop() const;

  public:
  void clear_underfrequencydroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& underfrequencydroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_underfrequencydroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_underfrequencydroop();
  void set_allocated_underfrequencydroop(::PROTOBUF_NAMESPACE_ID::FloatValue* underfrequencydroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_underfrequencydroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_underfrequencydroop();
  public:
  void unsafe_arena_set_allocated_underfrequencydroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* underfrequencydroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_underfrequencydroop();
  // @@protoc_insertion_point(class_scope:essmodule.FrequencyRegulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandminus_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandplus_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* frequencyregulationctl_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencysetpoint_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandminus_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandplus_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* overfrequencydroop_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* underfrequencydroop_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class PeakShaving final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.PeakShaving) */ {
 public:
  inline PeakShaving() : PeakShaving(nullptr) {}
  ~PeakShaving() override;
  explicit PROTOBUF_CONSTEXPR PeakShaving(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeakShaving(const PeakShaving& from);
  PeakShaving(PeakShaving&& from) noexcept
    : PeakShaving() {
    *this = ::std::move(from);
  }

  inline PeakShaving& operator=(const PeakShaving& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeakShaving& operator=(PeakShaving&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeakShaving& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeakShaving* internal_default_instance() {
    return reinterpret_cast<const PeakShaving*>(
               &_PeakShaving_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PeakShaving& a, PeakShaving& b) {
    a.Swap(&b);
  }
  inline void Swap(PeakShaving* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeakShaving* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeakShaving* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeakShaving>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeakShaving& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeakShaving& from) {
    PeakShaving::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeakShaving* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.PeakShaving";
  }
  protected:
  explicit PeakShaving(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseShavingLimitFieldNumber = 1,
    kPeakShavingCtlFieldNumber = 2,
    kPeakShavingLimitFieldNumber = 3,
    kSocManagementAllowedHighLimitFieldNumber = 4,
    kSocManagementAllowedLowLimitFieldNumber = 5,
  };
  // .google.protobuf.FloatValue baseShavingLimit = 1;
  bool has_baseshavinglimit() const;
  private:
  bool _internal_has_baseshavinglimit() const;

  public:
  void clear_baseshavinglimit() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& baseshavinglimit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_baseshavinglimit();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_baseshavinglimit();
  void set_allocated_baseshavinglimit(::PROTOBUF_NAMESPACE_ID::FloatValue* baseshavinglimit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_baseshavinglimit() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_baseshavinglimit();
  public:
  void unsafe_arena_set_allocated_baseshavinglimit(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* baseshavinglimit);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_baseshavinglimit();
  // .google.protobuf.BoolValue peakShavingCtl = 2;
  bool has_peakshavingctl() const;
  private:
  bool _internal_has_peakshavingctl() const;

  public:
  void clear_peakshavingctl() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& peakshavingctl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_peakshavingctl();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_peakshavingctl();
  void set_allocated_peakshavingctl(::PROTOBUF_NAMESPACE_ID::BoolValue* peakshavingctl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_peakshavingctl() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_peakshavingctl();
  public:
  void unsafe_arena_set_allocated_peakshavingctl(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* peakshavingctl);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_peakshavingctl();
  // .google.protobuf.FloatValue peakShavingLimit = 3;
  bool has_peakshavinglimit() const;
  private:
  bool _internal_has_peakshavinglimit() const;

  public:
  void clear_peakshavinglimit() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& peakshavinglimit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_peakshavinglimit();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_peakshavinglimit();
  void set_allocated_peakshavinglimit(::PROTOBUF_NAMESPACE_ID::FloatValue* peakshavinglimit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_peakshavinglimit() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_peakshavinglimit();
  public:
  void unsafe_arena_set_allocated_peakshavinglimit(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* peakshavinglimit);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_peakshavinglimit();
  // .google.protobuf.FloatValue socManagementAllowedHighLimit = 4;
  bool has_socmanagementallowedhighlimit() const;
  private:
  bool _internal_has_socmanagementallowedhighlimit() const;

  public:
  void clear_socmanagementallowedhighlimit() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& socmanagementallowedhighlimit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_socmanagementallowedhighlimit();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_socmanagementallowedhighlimit();
  void set_allocated_socmanagementallowedhighlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedhighlimit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_socmanagementallowedhighlimit() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_socmanagementallowedhighlimit();
  public:
  void unsafe_arena_set_allocated_socmanagementallowedhighlimit(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedhighlimit);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_socmanagementallowedhighlimit();
  // .google.protobuf.FloatValue socManagementAllowedLowLimit = 5;
  bool has_socmanagementallowedlowlimit() const;
  private:
  bool _internal_has_socmanagementallowedlowlimit() const;

  public:
  void clear_socmanagementallowedlowlimit() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& socmanagementallowedlowlimit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_socmanagementallowedlowlimit();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_socmanagementallowedlowlimit();
  void set_allocated_socmanagementallowedlowlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedlowlimit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_socmanagementallowedlowlimit() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_socmanagementallowedlowlimit();
  public:
  void unsafe_arena_set_allocated_socmanagementallowedlowlimit(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedlowlimit);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_socmanagementallowedlowlimit();
  // @@protoc_insertion_point(class_scope:essmodule.PeakShaving)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::FloatValue* baseshavinglimit_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* peakshavingctl_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* peakshavinglimit_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedhighlimit_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedlowlimit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class SocLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.SocLimit) */ {
 public:
  inline SocLimit() : SocLimit(nullptr) {}
  ~SocLimit() override;
  explicit PROTOBUF_CONSTEXPR SocLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SocLimit(const SocLimit& from);
  SocLimit(SocLimit&& from) noexcept
    : SocLimit() {
    *this = ::std::move(from);
  }

  inline SocLimit& operator=(const SocLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline SocLimit& operator=(SocLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SocLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const SocLimit* internal_default_instance() {
    return reinterpret_cast<const SocLimit*>(
               &_SocLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SocLimit& a, SocLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(SocLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SocLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SocLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SocLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SocLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SocLimit& from) {
    SocLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SocLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.SocLimit";
  }
  protected:
  explicit SocLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSocHighLimitFieldNumber = 1,
    kSocHighLimitHysteresisFieldNumber = 2,
    kSocLimitCtlFieldNumber = 3,
    kSocLowLimitFieldNumber = 4,
    kSocLowLimitHysteresisFieldNumber = 5,
  };
  // .google.protobuf.FloatValue socHighLimit = 1;
  bool has_sochighlimit() const;
  private:
  bool _internal_has_sochighlimit() const;

  public:
  void clear_sochighlimit() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& sochighlimit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_sochighlimit();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_sochighlimit();
  void set_allocated_sochighlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_sochighlimit() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_sochighlimit();
  public:
  void unsafe_arena_set_allocated_sochighlimit(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimit);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_sochighlimit();
  // .google.protobuf.FloatValue socHighLimitHysteresis = 2;
  bool has_sochighlimithysteresis() const;
  private:
  bool _internal_has_sochighlimithysteresis() const;

  public:
  void clear_sochighlimithysteresis() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& sochighlimithysteresis() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_sochighlimithysteresis();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_sochighlimithysteresis();
  void set_allocated_sochighlimithysteresis(::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimithysteresis);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_sochighlimithysteresis() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_sochighlimithysteresis();
  public:
  void unsafe_arena_set_allocated_sochighlimithysteresis(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimithysteresis);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_sochighlimithysteresis();
  // .google.protobuf.BoolValue socLimitCtl = 3;
  bool has_soclimitctl() const;
  private:
  bool _internal_has_soclimitctl() const;

  public:
  void clear_soclimitctl() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& soclimitctl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_soclimitctl();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_soclimitctl();
  void set_allocated_soclimitctl(::PROTOBUF_NAMESPACE_ID::BoolValue* soclimitctl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_soclimitctl() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_soclimitctl();
  public:
  void unsafe_arena_set_allocated_soclimitctl(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* soclimitctl);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_soclimitctl();
  // .google.protobuf.FloatValue socLowLimit = 4;
  bool has_soclowlimit() const;
  private:
  bool _internal_has_soclowlimit() const;

  public:
  void clear_soclowlimit() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& soclowlimit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_soclowlimit();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_soclowlimit();
  void set_allocated_soclowlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_soclowlimit() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_soclowlimit();
  public:
  void unsafe_arena_set_allocated_soclowlimit(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimit);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_soclowlimit();
  // .google.protobuf.FloatValue socLowLimitHysteresis = 5;
  bool has_soclowlimithysteresis() const;
  private:
  bool _internal_has_soclowlimithysteresis() const;

  public:
  void clear_soclowlimithysteresis() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& soclowlimithysteresis() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_soclowlimithysteresis();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_soclowlimithysteresis();
  void set_allocated_soclowlimithysteresis(::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimithysteresis);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_soclowlimithysteresis() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_soclowlimithysteresis();
  public:
  void unsafe_arena_set_allocated_soclowlimithysteresis(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimithysteresis);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_soclowlimithysteresis();
  // @@protoc_insertion_point(class_scope:essmodule.SocLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimit_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimithysteresis_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* soclimitctl_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimit_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimithysteresis_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class SOCManagement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.SOCManagement) */ {
 public:
  inline SOCManagement() : SOCManagement(nullptr) {}
  ~SOCManagement() override;
  explicit PROTOBUF_CONSTEXPR SOCManagement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SOCManagement(const SOCManagement& from);
  SOCManagement(SOCManagement&& from) noexcept
    : SOCManagement() {
    *this = ::std::move(from);
  }

  inline SOCManagement& operator=(const SOCManagement& from) {
    CopyFrom(from);
    return *this;
  }
  inline SOCManagement& operator=(SOCManagement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SOCManagement& default_instance() {
    return *internal_default_instance();
  }
  static inline const SOCManagement* internal_default_instance() {
    return reinterpret_cast<const SOCManagement*>(
               &_SOCManagement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SOCManagement& a, SOCManagement& b) {
    a.Swap(&b);
  }
  inline void Swap(SOCManagement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SOCManagement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SOCManagement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SOCManagement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SOCManagement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SOCManagement& from) {
    SOCManagement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SOCManagement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.SOCManagement";
  }
  protected:
  explicit SOCManagement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSocDeadBandMinusFieldNumber = 1,
    kSocDeadBandPlusFieldNumber = 2,
    kSocManagementCtlFieldNumber = 3,
    kSocPowerSetPointFieldNumber = 4,
    kSocSetPointFieldNumber = 5,
  };
  // .google.protobuf.FloatValue socDeadBandMinus = 1;
  bool has_socdeadbandminus() const;
  private:
  bool _internal_has_socdeadbandminus() const;

  public:
  void clear_socdeadbandminus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& socdeadbandminus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_socdeadbandminus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_socdeadbandminus();
  void set_allocated_socdeadbandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandminus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_socdeadbandminus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_socdeadbandminus();
  public:
  void unsafe_arena_set_allocated_socdeadbandminus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandminus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_socdeadbandminus();
  // .google.protobuf.FloatValue socDeadBandPlus = 2;
  bool has_socdeadbandplus() const;
  private:
  bool _internal_has_socdeadbandplus() const;

  public:
  void clear_socdeadbandplus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& socdeadbandplus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_socdeadbandplus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_socdeadbandplus();
  void set_allocated_socdeadbandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandplus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_socdeadbandplus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_socdeadbandplus();
  public:
  void unsafe_arena_set_allocated_socdeadbandplus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandplus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_socdeadbandplus();
  // .google.protobuf.BoolValue socManagementCtl = 3;
  bool has_socmanagementctl() const;
  private:
  bool _internal_has_socmanagementctl() const;

  public:
  void clear_socmanagementctl() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& socmanagementctl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_socmanagementctl();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_socmanagementctl();
  void set_allocated_socmanagementctl(::PROTOBUF_NAMESPACE_ID::BoolValue* socmanagementctl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_socmanagementctl() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_socmanagementctl();
  public:
  void unsafe_arena_set_allocated_socmanagementctl(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* socmanagementctl);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_socmanagementctl();
  // .google.protobuf.FloatValue socPowerSetPoint = 4;
  bool has_socpowersetpoint() const;
  private:
  bool _internal_has_socpowersetpoint() const;

  public:
  void clear_socpowersetpoint() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& socpowersetpoint() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_socpowersetpoint();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_socpowersetpoint();
  void set_allocated_socpowersetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* socpowersetpoint);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_socpowersetpoint() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_socpowersetpoint();
  public:
  void unsafe_arena_set_allocated_socpowersetpoint(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* socpowersetpoint);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_socpowersetpoint();
  // .google.protobuf.FloatValue socSetPoint = 5;
  bool has_socsetpoint() const;
  private:
  bool _internal_has_socsetpoint() const;

  public:
  void clear_socsetpoint() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& socsetpoint() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_socsetpoint();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_socsetpoint();
  void set_allocated_socsetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* socsetpoint);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_socsetpoint() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_socsetpoint();
  public:
  void unsafe_arena_set_allocated_socsetpoint(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* socsetpoint);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_socsetpoint();
  // @@protoc_insertion_point(class_scope:essmodule.SOCManagement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandminus_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandplus_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* socmanagementctl_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socpowersetpoint_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socsetpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class VoltageRegulation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.VoltageRegulation) */ {
 public:
  inline VoltageRegulation() : VoltageRegulation(nullptr) {}
  ~VoltageRegulation() override;
  explicit PROTOBUF_CONSTEXPR VoltageRegulation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoltageRegulation(const VoltageRegulation& from);
  VoltageRegulation(VoltageRegulation&& from) noexcept
    : VoltageRegulation() {
    *this = ::std::move(from);
  }

  inline VoltageRegulation& operator=(const VoltageRegulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoltageRegulation& operator=(VoltageRegulation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoltageRegulation& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoltageRegulation* internal_default_instance() {
    return reinterpret_cast<const VoltageRegulation*>(
               &_VoltageRegulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VoltageRegulation& a, VoltageRegulation& b) {
    a.Swap(&b);
  }
  inline void Swap(VoltageRegulation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoltageRegulation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoltageRegulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoltageRegulation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoltageRegulation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoltageRegulation& from) {
    VoltageRegulation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltageRegulation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.VoltageRegulation";
  }
  protected:
  explicit VoltageRegulation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverVoltageDroopFieldNumber = 1,
    kUnderVoltageDroopFieldNumber = 2,
    kVoltageDeadBandMinusFieldNumber = 3,
    kVoltageDeadBandPlusFieldNumber = 4,
    kVoltageSetPointFieldNumber = 5,
  };
  // .google.protobuf.FloatValue overVoltageDroop = 1;
  bool has_overvoltagedroop() const;
  private:
  bool _internal_has_overvoltagedroop() const;

  public:
  void clear_overvoltagedroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& overvoltagedroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_overvoltagedroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_overvoltagedroop();
  void set_allocated_overvoltagedroop(::PROTOBUF_NAMESPACE_ID::FloatValue* overvoltagedroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_overvoltagedroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_overvoltagedroop();
  public:
  void unsafe_arena_set_allocated_overvoltagedroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* overvoltagedroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_overvoltagedroop();
  // .google.protobuf.FloatValue underVoltageDroop = 2;
  bool has_undervoltagedroop() const;
  private:
  bool _internal_has_undervoltagedroop() const;

  public:
  void clear_undervoltagedroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& undervoltagedroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_undervoltagedroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_undervoltagedroop();
  void set_allocated_undervoltagedroop(::PROTOBUF_NAMESPACE_ID::FloatValue* undervoltagedroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_undervoltagedroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_undervoltagedroop();
  public:
  void unsafe_arena_set_allocated_undervoltagedroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* undervoltagedroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_undervoltagedroop();
  // .google.protobuf.FloatValue voltageDeadBandMinus = 3;
  bool has_voltagedeadbandminus() const;
  private:
  bool _internal_has_voltagedeadbandminus() const;

  public:
  void clear_voltagedeadbandminus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& voltagedeadbandminus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_voltagedeadbandminus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_voltagedeadbandminus();
  void set_allocated_voltagedeadbandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandminus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_voltagedeadbandminus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_voltagedeadbandminus();
  public:
  void unsafe_arena_set_allocated_voltagedeadbandminus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandminus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_voltagedeadbandminus();
  // .google.protobuf.FloatValue voltageDeadBandPlus = 4;
  bool has_voltagedeadbandplus() const;
  private:
  bool _internal_has_voltagedeadbandplus() const;

  public:
  void clear_voltagedeadbandplus() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& voltagedeadbandplus() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_voltagedeadbandplus();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_voltagedeadbandplus();
  void set_allocated_voltagedeadbandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandplus);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_voltagedeadbandplus() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_voltagedeadbandplus();
  public:
  void unsafe_arena_set_allocated_voltagedeadbandplus(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandplus);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_voltagedeadbandplus();
  // .google.protobuf.FloatValue voltageSetPoint = 5;
  bool has_voltagesetpoint() const;
  private:
  bool _internal_has_voltagesetpoint() const;

  public:
  void clear_voltagesetpoint() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& voltagesetpoint() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_voltagesetpoint();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_voltagesetpoint();
  void set_allocated_voltagesetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* voltagesetpoint);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_voltagesetpoint() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_voltagesetpoint();
  public:
  void unsafe_arena_set_allocated_voltagesetpoint(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagesetpoint);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_voltagesetpoint();
  // @@protoc_insertion_point(class_scope:essmodule.VoltageRegulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::FloatValue* overvoltagedroop_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* undervoltagedroop_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandminus_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandplus_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagesetpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class VoltageDroop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.VoltageDroop) */ {
 public:
  inline VoltageDroop() : VoltageDroop(nullptr) {}
  ~VoltageDroop() override;
  explicit PROTOBUF_CONSTEXPR VoltageDroop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoltageDroop(const VoltageDroop& from);
  VoltageDroop(VoltageDroop&& from) noexcept
    : VoltageDroop() {
    *this = ::std::move(from);
  }

  inline VoltageDroop& operator=(const VoltageDroop& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoltageDroop& operator=(VoltageDroop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoltageDroop& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoltageDroop* internal_default_instance() {
    return reinterpret_cast<const VoltageDroop*>(
               &_VoltageDroop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VoltageDroop& a, VoltageDroop& b) {
    a.Swap(&b);
  }
  inline void Swap(VoltageDroop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoltageDroop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoltageDroop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoltageDroop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoltageDroop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoltageDroop& from) {
    VoltageDroop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltageDroop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.VoltageDroop";
  }
  protected:
  explicit VoltageDroop(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoltageDroopCtlFieldNumber = 1,
    kVoltageRegulationFieldNumber = 2,
  };
  // .google.protobuf.BoolValue voltageDroopCtl = 1;
  bool has_voltagedroopctl() const;
  private:
  bool _internal_has_voltagedroopctl() const;

  public:
  void clear_voltagedroopctl() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& voltagedroopctl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_voltagedroopctl();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_voltagedroopctl();
  void set_allocated_voltagedroopctl(::PROTOBUF_NAMESPACE_ID::BoolValue* voltagedroopctl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_voltagedroopctl() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_voltagedroopctl();
  public:
  void unsafe_arena_set_allocated_voltagedroopctl(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* voltagedroopctl);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_voltagedroopctl();
  // .essmodule.VoltageRegulation voltageRegulation = 2;
  bool has_voltageregulation() const;
  private:
  bool _internal_has_voltageregulation() const;

  public:
  void clear_voltageregulation() ;
  const ::essmodule::VoltageRegulation& voltageregulation() const;
  PROTOBUF_NODISCARD ::essmodule::VoltageRegulation* release_voltageregulation();
  ::essmodule::VoltageRegulation* mutable_voltageregulation();
  void set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation);
  private:
  const ::essmodule::VoltageRegulation& _internal_voltageregulation() const;
  ::essmodule::VoltageRegulation* _internal_mutable_voltageregulation();
  public:
  void unsafe_arena_set_allocated_voltageregulation(
      ::essmodule::VoltageRegulation* voltageregulation);
  ::essmodule::VoltageRegulation* unsafe_arena_release_voltageregulation();
  // @@protoc_insertion_point(class_scope:essmodule.VoltageDroop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::BoolValue* voltagedroopctl_;
    ::essmodule::VoltageRegulation* voltageregulation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class VoltagePI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.VoltagePI) */ {
 public:
  inline VoltagePI() : VoltagePI(nullptr) {}
  ~VoltagePI() override;
  explicit PROTOBUF_CONSTEXPR VoltagePI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoltagePI(const VoltagePI& from);
  VoltagePI(VoltagePI&& from) noexcept
    : VoltagePI() {
    *this = ::std::move(from);
  }

  inline VoltagePI& operator=(const VoltagePI& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoltagePI& operator=(VoltagePI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoltagePI& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoltagePI* internal_default_instance() {
    return reinterpret_cast<const VoltagePI*>(
               &_VoltagePI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VoltagePI& a, VoltagePI& b) {
    a.Swap(&b);
  }
  inline void Swap(VoltagePI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoltagePI* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoltagePI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoltagePI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoltagePI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoltagePI& from) {
    VoltagePI::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltagePI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.VoltagePI";
  }
  protected:
  explicit VoltagePI(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoltagePICtlFieldNumber = 1,
    kVoltageRegulationFieldNumber = 2,
  };
  // .google.protobuf.BoolValue voltagePICtl = 1;
  bool has_voltagepictl() const;
  private:
  bool _internal_has_voltagepictl() const;

  public:
  void clear_voltagepictl() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& voltagepictl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_voltagepictl();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_voltagepictl();
  void set_allocated_voltagepictl(::PROTOBUF_NAMESPACE_ID::BoolValue* voltagepictl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_voltagepictl() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_voltagepictl();
  public:
  void unsafe_arena_set_allocated_voltagepictl(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* voltagepictl);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_voltagepictl();
  // .essmodule.VoltageRegulation voltageRegulation = 2;
  bool has_voltageregulation() const;
  private:
  bool _internal_has_voltageregulation() const;

  public:
  void clear_voltageregulation() ;
  const ::essmodule::VoltageRegulation& voltageregulation() const;
  PROTOBUF_NODISCARD ::essmodule::VoltageRegulation* release_voltageregulation();
  ::essmodule::VoltageRegulation* mutable_voltageregulation();
  void set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation);
  private:
  const ::essmodule::VoltageRegulation& _internal_voltageregulation() const;
  ::essmodule::VoltageRegulation* _internal_mutable_voltageregulation();
  public:
  void unsafe_arena_set_allocated_voltageregulation(
      ::essmodule::VoltageRegulation* voltageregulation);
  ::essmodule::VoltageRegulation* unsafe_arena_release_voltageregulation();
  // @@protoc_insertion_point(class_scope:essmodule.VoltagePI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::BoolValue* voltagepictl_;
    ::essmodule::VoltageRegulation* voltageregulation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class CapacityFirming final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.CapacityFirming) */ {
 public:
  inline CapacityFirming() : CapacityFirming(nullptr) {}
  ~CapacityFirming() override;
  explicit PROTOBUF_CONSTEXPR CapacityFirming(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapacityFirming(const CapacityFirming& from);
  CapacityFirming(CapacityFirming&& from) noexcept
    : CapacityFirming() {
    *this = ::std::move(from);
  }

  inline CapacityFirming& operator=(const CapacityFirming& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacityFirming& operator=(CapacityFirming&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacityFirming& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacityFirming* internal_default_instance() {
    return reinterpret_cast<const CapacityFirming*>(
               &_CapacityFirming_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CapacityFirming& a, CapacityFirming& b) {
    a.Swap(&b);
  }
  inline void Swap(CapacityFirming* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacityFirming* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacityFirming* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapacityFirming>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapacityFirming& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CapacityFirming& from) {
    CapacityFirming::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapacityFirming* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.CapacityFirming";
  }
  protected:
  explicit CapacityFirming(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityFirmingCtlFieldNumber = 1,
    kLimitNegativeDpDtFieldNumber = 2,
    kLimitPositiveDpDtFieldNumber = 3,
  };
  // .google.protobuf.BoolValue capacityFirmingCtl = 1;
  bool has_capacityfirmingctl() const;
  private:
  bool _internal_has_capacityfirmingctl() const;

  public:
  void clear_capacityfirmingctl() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& capacityfirmingctl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_capacityfirmingctl();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_capacityfirmingctl();
  void set_allocated_capacityfirmingctl(::PROTOBUF_NAMESPACE_ID::BoolValue* capacityfirmingctl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_capacityfirmingctl() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_capacityfirmingctl();
  public:
  void unsafe_arena_set_allocated_capacityfirmingctl(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* capacityfirmingctl);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_capacityfirmingctl();
  // .google.protobuf.FloatValue limitNegative_dp_dt = 2;
  bool has_limitnegative_dp_dt() const;
  private:
  bool _internal_has_limitnegative_dp_dt() const;

  public:
  void clear_limitnegative_dp_dt() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& limitnegative_dp_dt() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_limitnegative_dp_dt();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_limitnegative_dp_dt();
  void set_allocated_limitnegative_dp_dt(::PROTOBUF_NAMESPACE_ID::FloatValue* limitnegative_dp_dt);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_limitnegative_dp_dt() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_limitnegative_dp_dt();
  public:
  void unsafe_arena_set_allocated_limitnegative_dp_dt(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* limitnegative_dp_dt);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_limitnegative_dp_dt();
  // .google.protobuf.FloatValue limitPositive_dp_dt = 3;
  bool has_limitpositive_dp_dt() const;
  private:
  bool _internal_has_limitpositive_dp_dt() const;

  public:
  void clear_limitpositive_dp_dt() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& limitpositive_dp_dt() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_limitpositive_dp_dt();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_limitpositive_dp_dt();
  void set_allocated_limitpositive_dp_dt(::PROTOBUF_NAMESPACE_ID::FloatValue* limitpositive_dp_dt);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_limitpositive_dp_dt() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_limitpositive_dp_dt();
  public:
  void unsafe_arena_set_allocated_limitpositive_dp_dt(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* limitpositive_dp_dt);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_limitpositive_dp_dt();
  // @@protoc_insertion_point(class_scope:essmodule.CapacityFirming)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::BoolValue* capacityfirmingctl_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* limitnegative_dp_dt_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* limitpositive_dp_dt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSFunction) */ {
 public:
  inline ESSFunction() : ESSFunction(nullptr) {}
  ~ESSFunction() override;
  explicit PROTOBUF_CONSTEXPR ESSFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSFunction(const ESSFunction& from);
  ESSFunction(ESSFunction&& from) noexcept
    : ESSFunction() {
    *this = ::std::move(from);
  }

  inline ESSFunction& operator=(const ESSFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSFunction& operator=(ESSFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSFunction* internal_default_instance() {
    return reinterpret_cast<const ESSFunction*>(
               &_ESSFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ESSFunction& a, ESSFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSFunction& from) {
    ESSFunction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSFunction";
  }
  protected:
  explicit ESSFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityFirmingFieldNumber = 1,
    kFrequencyRegulationFieldNumber = 2,
    kPeakShavingFieldNumber = 3,
    kSocLimitFieldNumber = 4,
    kSocManagementFieldNumber = 5,
    kVoltageDroopFieldNumber = 6,
    kVoltagePIFieldNumber = 7,
  };
  // .essmodule.CapacityFirming capacityFirming = 1;
  bool has_capacityfirming() const;
  private:
  bool _internal_has_capacityfirming() const;

  public:
  void clear_capacityfirming() ;
  const ::essmodule::CapacityFirming& capacityfirming() const;
  PROTOBUF_NODISCARD ::essmodule::CapacityFirming* release_capacityfirming();
  ::essmodule::CapacityFirming* mutable_capacityfirming();
  void set_allocated_capacityfirming(::essmodule::CapacityFirming* capacityfirming);
  private:
  const ::essmodule::CapacityFirming& _internal_capacityfirming() const;
  ::essmodule::CapacityFirming* _internal_mutable_capacityfirming();
  public:
  void unsafe_arena_set_allocated_capacityfirming(
      ::essmodule::CapacityFirming* capacityfirming);
  ::essmodule::CapacityFirming* unsafe_arena_release_capacityfirming();
  // .essmodule.FrequencyRegulation frequencyRegulation = 2;
  bool has_frequencyregulation() const;
  private:
  bool _internal_has_frequencyregulation() const;

  public:
  void clear_frequencyregulation() ;
  const ::essmodule::FrequencyRegulation& frequencyregulation() const;
  PROTOBUF_NODISCARD ::essmodule::FrequencyRegulation* release_frequencyregulation();
  ::essmodule::FrequencyRegulation* mutable_frequencyregulation();
  void set_allocated_frequencyregulation(::essmodule::FrequencyRegulation* frequencyregulation);
  private:
  const ::essmodule::FrequencyRegulation& _internal_frequencyregulation() const;
  ::essmodule::FrequencyRegulation* _internal_mutable_frequencyregulation();
  public:
  void unsafe_arena_set_allocated_frequencyregulation(
      ::essmodule::FrequencyRegulation* frequencyregulation);
  ::essmodule::FrequencyRegulation* unsafe_arena_release_frequencyregulation();
  // .essmodule.PeakShaving peakShaving = 3;
  bool has_peakshaving() const;
  private:
  bool _internal_has_peakshaving() const;

  public:
  void clear_peakshaving() ;
  const ::essmodule::PeakShaving& peakshaving() const;
  PROTOBUF_NODISCARD ::essmodule::PeakShaving* release_peakshaving();
  ::essmodule::PeakShaving* mutable_peakshaving();
  void set_allocated_peakshaving(::essmodule::PeakShaving* peakshaving);
  private:
  const ::essmodule::PeakShaving& _internal_peakshaving() const;
  ::essmodule::PeakShaving* _internal_mutable_peakshaving();
  public:
  void unsafe_arena_set_allocated_peakshaving(
      ::essmodule::PeakShaving* peakshaving);
  ::essmodule::PeakShaving* unsafe_arena_release_peakshaving();
  // .essmodule.SocLimit socLimit = 4;
  bool has_soclimit() const;
  private:
  bool _internal_has_soclimit() const;

  public:
  void clear_soclimit() ;
  const ::essmodule::SocLimit& soclimit() const;
  PROTOBUF_NODISCARD ::essmodule::SocLimit* release_soclimit();
  ::essmodule::SocLimit* mutable_soclimit();
  void set_allocated_soclimit(::essmodule::SocLimit* soclimit);
  private:
  const ::essmodule::SocLimit& _internal_soclimit() const;
  ::essmodule::SocLimit* _internal_mutable_soclimit();
  public:
  void unsafe_arena_set_allocated_soclimit(
      ::essmodule::SocLimit* soclimit);
  ::essmodule::SocLimit* unsafe_arena_release_soclimit();
  // .essmodule.SOCManagement socManagement = 5;
  bool has_socmanagement() const;
  private:
  bool _internal_has_socmanagement() const;

  public:
  void clear_socmanagement() ;
  const ::essmodule::SOCManagement& socmanagement() const;
  PROTOBUF_NODISCARD ::essmodule::SOCManagement* release_socmanagement();
  ::essmodule::SOCManagement* mutable_socmanagement();
  void set_allocated_socmanagement(::essmodule::SOCManagement* socmanagement);
  private:
  const ::essmodule::SOCManagement& _internal_socmanagement() const;
  ::essmodule::SOCManagement* _internal_mutable_socmanagement();
  public:
  void unsafe_arena_set_allocated_socmanagement(
      ::essmodule::SOCManagement* socmanagement);
  ::essmodule::SOCManagement* unsafe_arena_release_socmanagement();
  // .essmodule.VoltageDroop voltageDroop = 6;
  bool has_voltagedroop() const;
  private:
  bool _internal_has_voltagedroop() const;

  public:
  void clear_voltagedroop() ;
  const ::essmodule::VoltageDroop& voltagedroop() const;
  PROTOBUF_NODISCARD ::essmodule::VoltageDroop* release_voltagedroop();
  ::essmodule::VoltageDroop* mutable_voltagedroop();
  void set_allocated_voltagedroop(::essmodule::VoltageDroop* voltagedroop);
  private:
  const ::essmodule::VoltageDroop& _internal_voltagedroop() const;
  ::essmodule::VoltageDroop* _internal_mutable_voltagedroop();
  public:
  void unsafe_arena_set_allocated_voltagedroop(
      ::essmodule::VoltageDroop* voltagedroop);
  ::essmodule::VoltageDroop* unsafe_arena_release_voltagedroop();
  // .essmodule.VoltagePI voltagePI = 7;
  bool has_voltagepi() const;
  private:
  bool _internal_has_voltagepi() const;

  public:
  void clear_voltagepi() ;
  const ::essmodule::VoltagePI& voltagepi() const;
  PROTOBUF_NODISCARD ::essmodule::VoltagePI* release_voltagepi();
  ::essmodule::VoltagePI* mutable_voltagepi();
  void set_allocated_voltagepi(::essmodule::VoltagePI* voltagepi);
  private:
  const ::essmodule::VoltagePI& _internal_voltagepi() const;
  ::essmodule::VoltagePI* _internal_mutable_voltagepi();
  public:
  void unsafe_arena_set_allocated_voltagepi(
      ::essmodule::VoltagePI* voltagepi);
  ::essmodule::VoltagePI* unsafe_arena_release_voltagepi();
  // @@protoc_insertion_point(class_scope:essmodule.ESSFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::essmodule::CapacityFirming* capacityfirming_;
    ::essmodule::FrequencyRegulation* frequencyregulation_;
    ::essmodule::PeakShaving* peakshaving_;
    ::essmodule::SocLimit* soclimit_;
    ::essmodule::SOCManagement* socmanagement_;
    ::essmodule::VoltageDroop* voltagedroop_;
    ::essmodule::VoltagePI* voltagepi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSPoint) */ {
 public:
  inline ESSPoint() : ESSPoint(nullptr) {}
  ~ESSPoint() override;
  explicit PROTOBUF_CONSTEXPR ESSPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSPoint(const ESSPoint& from);
  ESSPoint(ESSPoint&& from) noexcept
    : ESSPoint() {
    *this = ::std::move(from);
  }

  inline ESSPoint& operator=(const ESSPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSPoint& operator=(ESSPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSPoint* internal_default_instance() {
    return reinterpret_cast<const ESSPoint*>(
               &_ESSPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ESSPoint& a, ESSPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSPoint& from) {
    ESSPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSPoint";
  }
  protected:
  explicit ESSPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlackStartEnabledFieldNumber = 1,
    kFunctionFieldNumber = 3,
    kModeFieldNumber = 4,
    kRampRatesFieldNumber = 7,
    kResetFieldNumber = 10,
    kStateFieldNumber = 11,
    kTransToIslndOnGridLossEnabledFieldNumber = 13,
    kEnterServiceOperationFieldNumber = 16,
    kHzWOperationFieldNumber = 17,
    kLimitWOperationFieldNumber = 18,
    kPFOperationFieldNumber = 19,
    kTmHzTripOperationFieldNumber = 20,
    kTmVoltTripOperationFieldNumber = 21,
    kVArOperationFieldNumber = 22,
    kVoltVarOperationFieldNumber = 23,
    kVoltWOperationFieldNumber = 24,
    kWVarOperationFieldNumber = 25,
    kWOperationFieldNumber = 26,
  };
  // .commonmodule.ControlSPC blackStartEnabled = 1;
  bool has_blackstartenabled() const;
  private:
  bool _internal_has_blackstartenabled() const;

  public:
  void clear_blackstartenabled() ;
  const ::commonmodule::ControlSPC& blackstartenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_blackstartenabled();
  ::commonmodule::ControlSPC* mutable_blackstartenabled();
  void set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_blackstartenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_blackstartenabled();
  public:
  void unsafe_arena_set_allocated_blackstartenabled(
      ::commonmodule::ControlSPC* blackstartenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_blackstartenabled();
  // .essmodule.ESSFunction function = 3;
  bool has_function() const;
  private:
  bool _internal_has_function() const;

  public:
  void clear_function() ;
  const ::essmodule::ESSFunction& function() const;
  PROTOBUF_NODISCARD ::essmodule::ESSFunction* release_function();
  ::essmodule::ESSFunction* mutable_function();
  void set_allocated_function(::essmodule::ESSFunction* function);
  private:
  const ::essmodule::ESSFunction& _internal_function() const;
  ::essmodule::ESSFunction* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::essmodule::ESSFunction* function);
  ::essmodule::ESSFunction* unsafe_arena_release_function();
  // .commonmodule.ENG_GridConnectModeKind mode = 4;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;

  public:
  void clear_mode() ;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);
  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_mode() const;
  ::commonmodule::ENG_GridConnectModeKind* _internal_mutable_mode();
  public:
  void unsafe_arena_set_allocated_mode(
      ::commonmodule::ENG_GridConnectModeKind* mode);
  ::commonmodule::ENG_GridConnectModeKind* unsafe_arena_release_mode();
  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.ControlSPC reset = 10;
  bool has_reset() const;
  private:
  bool _internal_has_reset() const;

  public:
  void clear_reset() ;
  const ::commonmodule::ControlSPC& reset() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_reset();
  ::commonmodule::ControlSPC* mutable_reset();
  void set_allocated_reset(::commonmodule::ControlSPC* reset);
  private:
  const ::commonmodule::ControlSPC& _internal_reset() const;
  ::commonmodule::ControlSPC* _internal_mutable_reset();
  public:
  void unsafe_arena_set_allocated_reset(
      ::commonmodule::ControlSPC* reset);
  ::commonmodule::ControlSPC* unsafe_arena_release_reset();
  // .commonmodule.Optional_StateKind state = 11;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // .commonmodule.ControlSPC transToIslndOnGridLossEnabled = 13;
  bool has_transtoislndongridlossenabled() const;
  private:
  bool _internal_has_transtoislndongridlossenabled() const;

  public:
  void clear_transtoislndongridlossenabled() ;
  const ::commonmodule::ControlSPC& transtoislndongridlossenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_transtoislndongridlossenabled();
  ::commonmodule::ControlSPC* mutable_transtoislndongridlossenabled();
  void set_allocated_transtoislndongridlossenabled(::commonmodule::ControlSPC* transtoislndongridlossenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_transtoislndongridlossenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_transtoislndongridlossenabled();
  public:
  void unsafe_arena_set_allocated_transtoislndongridlossenabled(
      ::commonmodule::ControlSPC* transtoislndongridlossenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_transtoislndongridlossenabled();
  // .commonmodule.EnterServiceAPC enterServiceOperation = 16;
  bool has_enterserviceoperation() const;
  private:
  bool _internal_has_enterserviceoperation() const;

  public:
  void clear_enterserviceoperation() ;
  const ::commonmodule::EnterServiceAPC& enterserviceoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::EnterServiceAPC* release_enterserviceoperation();
  ::commonmodule::EnterServiceAPC* mutable_enterserviceoperation();
  void set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation);
  private:
  const ::commonmodule::EnterServiceAPC& _internal_enterserviceoperation() const;
  ::commonmodule::EnterServiceAPC* _internal_mutable_enterserviceoperation();
  public:
  void unsafe_arena_set_allocated_enterserviceoperation(
      ::commonmodule::EnterServiceAPC* enterserviceoperation);
  ::commonmodule::EnterServiceAPC* unsafe_arena_release_enterserviceoperation();
  // .commonmodule.HzWAPC hzWOperation = 17;
  bool has_hzwoperation() const;
  private:
  bool _internal_has_hzwoperation() const;

  public:
  void clear_hzwoperation() ;
  const ::commonmodule::HzWAPC& hzwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::HzWAPC* release_hzwoperation();
  ::commonmodule::HzWAPC* mutable_hzwoperation();
  void set_allocated_hzwoperation(::commonmodule::HzWAPC* hzwoperation);
  private:
  const ::commonmodule::HzWAPC& _internal_hzwoperation() const;
  ::commonmodule::HzWAPC* _internal_mutable_hzwoperation();
  public:
  void unsafe_arena_set_allocated_hzwoperation(
      ::commonmodule::HzWAPC* hzwoperation);
  ::commonmodule::HzWAPC* unsafe_arena_release_hzwoperation();
  // .commonmodule.LimitWAPC limitWOperation = 18;
  bool has_limitwoperation() const;
  private:
  bool _internal_has_limitwoperation() const;

  public:
  void clear_limitwoperation() ;
  const ::commonmodule::LimitWAPC& limitwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::LimitWAPC* release_limitwoperation();
  ::commonmodule::LimitWAPC* mutable_limitwoperation();
  void set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation);
  private:
  const ::commonmodule::LimitWAPC& _internal_limitwoperation() const;
  ::commonmodule::LimitWAPC* _internal_mutable_limitwoperation();
  public:
  void unsafe_arena_set_allocated_limitwoperation(
      ::commonmodule::LimitWAPC* limitwoperation);
  ::commonmodule::LimitWAPC* unsafe_arena_release_limitwoperation();
  // .commonmodule.PFSPC pFOperation = 19;
  bool has_pfoperation() const;
  private:
  bool _internal_has_pfoperation() const;

  public:
  void clear_pfoperation() ;
  const ::commonmodule::PFSPC& pfoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::PFSPC* release_pfoperation();
  ::commonmodule::PFSPC* mutable_pfoperation();
  void set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation);
  private:
  const ::commonmodule::PFSPC& _internal_pfoperation() const;
  ::commonmodule::PFSPC* _internal_mutable_pfoperation();
  public:
  void unsafe_arena_set_allocated_pfoperation(
      ::commonmodule::PFSPC* pfoperation);
  ::commonmodule::PFSPC* unsafe_arena_release_pfoperation();
  // .commonmodule.TmHzCSG tmHzTripOperation = 20;
  bool has_tmhztripoperation() const;
  private:
  bool _internal_has_tmhztripoperation() const;

  public:
  void clear_tmhztripoperation() ;
  const ::commonmodule::TmHzCSG& tmhztripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmHzCSG* release_tmhztripoperation();
  ::commonmodule::TmHzCSG* mutable_tmhztripoperation();
  void set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation);
  private:
  const ::commonmodule::TmHzCSG& _internal_tmhztripoperation() const;
  ::commonmodule::TmHzCSG* _internal_mutable_tmhztripoperation();
  public:
  void unsafe_arena_set_allocated_tmhztripoperation(
      ::commonmodule::TmHzCSG* tmhztripoperation);
  ::commonmodule::TmHzCSG* unsafe_arena_release_tmhztripoperation();
  // .commonmodule.TmVoltCSG tmVoltTripOperation = 21;
  bool has_tmvolttripoperation() const;
  private:
  bool _internal_has_tmvolttripoperation() const;

  public:
  void clear_tmvolttripoperation() ;
  const ::commonmodule::TmVoltCSG& tmvolttripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmVoltCSG* release_tmvolttripoperation();
  ::commonmodule::TmVoltCSG* mutable_tmvolttripoperation();
  void set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation);
  private:
  const ::commonmodule::TmVoltCSG& _internal_tmvolttripoperation() const;
  ::commonmodule::TmVoltCSG* _internal_mutable_tmvolttripoperation();
  public:
  void unsafe_arena_set_allocated_tmvolttripoperation(
      ::commonmodule::TmVoltCSG* tmvolttripoperation);
  ::commonmodule::TmVoltCSG* unsafe_arena_release_tmvolttripoperation();
  // .commonmodule.VarSPC vArOperation = 22;
  bool has_varoperation() const;
  private:
  bool _internal_has_varoperation() const;

  public:
  void clear_varoperation() ;
  const ::commonmodule::VarSPC& varoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VarSPC* release_varoperation();
  ::commonmodule::VarSPC* mutable_varoperation();
  void set_allocated_varoperation(::commonmodule::VarSPC* varoperation);
  private:
  const ::commonmodule::VarSPC& _internal_varoperation() const;
  ::commonmodule::VarSPC* _internal_mutable_varoperation();
  public:
  void unsafe_arena_set_allocated_varoperation(
      ::commonmodule::VarSPC* varoperation);
  ::commonmodule::VarSPC* unsafe_arena_release_varoperation();
  // .commonmodule.VoltVarCSG voltVarOperation = 23;
  bool has_voltvaroperation() const;
  private:
  bool _internal_has_voltvaroperation() const;

  public:
  void clear_voltvaroperation() ;
  const ::commonmodule::VoltVarCSG& voltvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltVarCSG* release_voltvaroperation();
  ::commonmodule::VoltVarCSG* mutable_voltvaroperation();
  void set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation);
  private:
  const ::commonmodule::VoltVarCSG& _internal_voltvaroperation() const;
  ::commonmodule::VoltVarCSG* _internal_mutable_voltvaroperation();
  public:
  void unsafe_arena_set_allocated_voltvaroperation(
      ::commonmodule::VoltVarCSG* voltvaroperation);
  ::commonmodule::VoltVarCSG* unsafe_arena_release_voltvaroperation();
  // .commonmodule.VoltWCSG voltWOperation = 24;
  bool has_voltwoperation() const;
  private:
  bool _internal_has_voltwoperation() const;

  public:
  void clear_voltwoperation() ;
  const ::commonmodule::VoltWCSG& voltwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltWCSG* release_voltwoperation();
  ::commonmodule::VoltWCSG* mutable_voltwoperation();
  void set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation);
  private:
  const ::commonmodule::VoltWCSG& _internal_voltwoperation() const;
  ::commonmodule::VoltWCSG* _internal_mutable_voltwoperation();
  public:
  void unsafe_arena_set_allocated_voltwoperation(
      ::commonmodule::VoltWCSG* voltwoperation);
  ::commonmodule::VoltWCSG* unsafe_arena_release_voltwoperation();
  // .commonmodule.WVarCSG wVarOperation = 25;
  bool has_wvaroperation() const;
  private:
  bool _internal_has_wvaroperation() const;

  public:
  void clear_wvaroperation() ;
  const ::commonmodule::WVarCSG& wvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::WVarCSG* release_wvaroperation();
  ::commonmodule::WVarCSG* mutable_wvaroperation();
  void set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation);
  private:
  const ::commonmodule::WVarCSG& _internal_wvaroperation() const;
  ::commonmodule::WVarCSG* _internal_mutable_wvaroperation();
  public:
  void unsafe_arena_set_allocated_wvaroperation(
      ::commonmodule::WVarCSG* wvaroperation);
  ::commonmodule::WVarCSG* unsafe_arena_release_wvaroperation();
  // .commonmodule.WSPC wOperation = 26;
  bool has_woperation() const;
  private:
  bool _internal_has_woperation() const;

  public:
  void clear_woperation() ;
  const ::commonmodule::WSPC& woperation() const;
  PROTOBUF_NODISCARD ::commonmodule::WSPC* release_woperation();
  ::commonmodule::WSPC* mutable_woperation();
  void set_allocated_woperation(::commonmodule::WSPC* woperation);
  private:
  const ::commonmodule::WSPC& _internal_woperation() const;
  ::commonmodule::WSPC* _internal_mutable_woperation();
  public:
  void unsafe_arena_set_allocated_woperation(
      ::commonmodule::WSPC* woperation);
  ::commonmodule::WSPC* unsafe_arena_release_woperation();
  // @@protoc_insertion_point(class_scope:essmodule.ESSPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlSPC* blackstartenabled_;
    ::essmodule::ESSFunction* function_;
    ::commonmodule::ENG_GridConnectModeKind* mode_;
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::ControlSPC* reset_;
    ::commonmodule::Optional_StateKind* state_;
    ::commonmodule::ControlSPC* transtoislndongridlossenabled_;
    ::commonmodule::EnterServiceAPC* enterserviceoperation_;
    ::commonmodule::HzWAPC* hzwoperation_;
    ::commonmodule::LimitWAPC* limitwoperation_;
    ::commonmodule::PFSPC* pfoperation_;
    ::commonmodule::TmHzCSG* tmhztripoperation_;
    ::commonmodule::TmVoltCSG* tmvolttripoperation_;
    ::commonmodule::VarSPC* varoperation_;
    ::commonmodule::VoltVarCSG* voltvaroperation_;
    ::commonmodule::VoltWCSG* voltwoperation_;
    ::commonmodule::WVarCSG* wvaroperation_;
    ::commonmodule::WSPC* woperation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSCurvePoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCurvePoint) */ {
 public:
  inline ESSCurvePoint() : ESSCurvePoint(nullptr) {}
  ~ESSCurvePoint() override;
  explicit PROTOBUF_CONSTEXPR ESSCurvePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCurvePoint(const ESSCurvePoint& from);
  ESSCurvePoint(ESSCurvePoint&& from) noexcept
    : ESSCurvePoint() {
    *this = ::std::move(from);
  }

  inline ESSCurvePoint& operator=(const ESSCurvePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCurvePoint& operator=(ESSCurvePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCurvePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCurvePoint* internal_default_instance() {
    return reinterpret_cast<const ESSCurvePoint*>(
               &_ESSCurvePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ESSCurvePoint& a, ESSCurvePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCurvePoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCurvePoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCurvePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCurvePoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCurvePoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCurvePoint& from) {
    ESSCurvePoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCurvePoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCurvePoint";
  }
  protected:
  explicit ESSCurvePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFieldNumber = 1,
    kStartTimeFieldNumber = 2,
  };
  // .essmodule.ESSPoint control = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_control() const;
  private:
  bool _internal_has_control() const;

  public:
  void clear_control() ;
  const ::essmodule::ESSPoint& control() const;
  PROTOBUF_NODISCARD ::essmodule::ESSPoint* release_control();
  ::essmodule::ESSPoint* mutable_control();
  void set_allocated_control(::essmodule::ESSPoint* control);
  private:
  const ::essmodule::ESSPoint& _internal_control() const;
  ::essmodule::ESSPoint* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::essmodule::ESSPoint* control);
  ::essmodule::ESSPoint* unsafe_arena_release_control();
  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;

  public:
  void clear_starttime() ;
  const ::commonmodule::ControlTimestamp& starttime() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);
  private:
  const ::commonmodule::ControlTimestamp& _internal_starttime() const;
  ::commonmodule::ControlTimestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::commonmodule::ControlTimestamp* starttime);
  ::commonmodule::ControlTimestamp* unsafe_arena_release_starttime();
  // @@protoc_insertion_point(class_scope:essmodule.ESSCurvePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::essmodule::ESSPoint* control_;
    ::commonmodule::ControlTimestamp* starttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCSG) */ {
 public:
  inline ESSCSG() : ESSCSG(nullptr) {}
  ~ESSCSG() override;
  explicit PROTOBUF_CONSTEXPR ESSCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSCSG(const ESSCSG& from);
  ESSCSG(ESSCSG&& from) noexcept
    : ESSCSG() {
    *this = ::std::move(from);
  }

  inline ESSCSG& operator=(const ESSCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSCSG& operator=(ESSCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSCSG* internal_default_instance() {
    return reinterpret_cast<const ESSCSG*>(
               &_ESSCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ESSCSG& a, ESSCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSCSG& from) {
    ESSCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSCSG";
  }
  protected:
  explicit ESSCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .essmodule.ESSCurvePoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::essmodule::ESSCurvePoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::essmodule::ESSCurvePoint >*
      mutable_crvpts();
  private:
  const ::essmodule::ESSCurvePoint& _internal_crvpts(int index) const;
  ::essmodule::ESSCurvePoint* _internal_add_crvpts();
  public:
  const ::essmodule::ESSCurvePoint& crvpts(int index) const;
  ::essmodule::ESSCurvePoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::essmodule::ESSCurvePoint >&
      crvpts() const;
  // @@protoc_insertion_point(class_scope:essmodule.ESSCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::essmodule::ESSCurvePoint > crvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSControlScheduleFSCH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSControlScheduleFSCH) */ {
 public:
  inline ESSControlScheduleFSCH() : ESSControlScheduleFSCH(nullptr) {}
  ~ESSControlScheduleFSCH() override;
  explicit PROTOBUF_CONSTEXPR ESSControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSControlScheduleFSCH(const ESSControlScheduleFSCH& from);
  ESSControlScheduleFSCH(ESSControlScheduleFSCH&& from) noexcept
    : ESSControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline ESSControlScheduleFSCH& operator=(const ESSControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSControlScheduleFSCH& operator=(ESSControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSControlScheduleFSCH& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const ESSControlScheduleFSCH*>(
               &_ESSControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ESSControlScheduleFSCH& a, ESSControlScheduleFSCH& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSControlScheduleFSCH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSControlScheduleFSCH* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSControlScheduleFSCH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSControlScheduleFSCH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSControlScheduleFSCH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSControlScheduleFSCH& from) {
    ESSControlScheduleFSCH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSControlScheduleFSCH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSControlScheduleFSCH";
  }
  protected:
  explicit ESSControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValDCSGFieldNumber = 1,
  };
  // .essmodule.ESSCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  private:
  bool _internal_has_valdcsg() const;

  public:
  void clear_valdcsg() ;
  const ::essmodule::ESSCSG& valdcsg() const;
  PROTOBUF_NODISCARD ::essmodule::ESSCSG* release_valdcsg();
  ::essmodule::ESSCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::essmodule::ESSCSG* valdcsg);
  private:
  const ::essmodule::ESSCSG& _internal_valdcsg() const;
  ::essmodule::ESSCSG* _internal_mutable_valdcsg();
  public:
  void unsafe_arena_set_allocated_valdcsg(
      ::essmodule::ESSCSG* valdcsg);
  ::essmodule::ESSCSG* unsafe_arena_release_valdcsg();
  // @@protoc_insertion_point(class_scope:essmodule.ESSControlScheduleFSCH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::essmodule::ESSCSG* valdcsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class EssControlFSCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.EssControlFSCC) */ {
 public:
  inline EssControlFSCC() : EssControlFSCC(nullptr) {}
  ~EssControlFSCC() override;
  explicit PROTOBUF_CONSTEXPR EssControlFSCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EssControlFSCC(const EssControlFSCC& from);
  EssControlFSCC(EssControlFSCC&& from) noexcept
    : EssControlFSCC() {
    *this = ::std::move(from);
  }

  inline EssControlFSCC& operator=(const EssControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline EssControlFSCC& operator=(EssControlFSCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EssControlFSCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const EssControlFSCC* internal_default_instance() {
    return reinterpret_cast<const EssControlFSCC*>(
               &_EssControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EssControlFSCC& a, EssControlFSCC& b) {
    a.Swap(&b);
  }
  inline void Swap(EssControlFSCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EssControlFSCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EssControlFSCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EssControlFSCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EssControlFSCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EssControlFSCC& from) {
    EssControlFSCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EssControlFSCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.EssControlFSCC";
  }
  protected:
  explicit EssControlFSCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFSCCFieldNumber = 1,
    kEssControlScheduleFSCHFieldNumber = 2,
  };
  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  private:
  bool _internal_has_controlfscc() const;

  public:
  void clear_controlfscc() ;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);
  private:
  const ::commonmodule::ControlFSCC& _internal_controlfscc() const;
  ::commonmodule::ControlFSCC* _internal_mutable_controlfscc();
  public:
  void unsafe_arena_set_allocated_controlfscc(
      ::commonmodule::ControlFSCC* controlfscc);
  ::commonmodule::ControlFSCC* unsafe_arena_release_controlfscc();
  // .essmodule.ESSControlScheduleFSCH essControlScheduleFSCH = 2;
  bool has_esscontrolschedulefsch() const;
  private:
  bool _internal_has_esscontrolschedulefsch() const;

  public:
  void clear_esscontrolschedulefsch() ;
  const ::essmodule::ESSControlScheduleFSCH& esscontrolschedulefsch() const;
  PROTOBUF_NODISCARD ::essmodule::ESSControlScheduleFSCH* release_esscontrolschedulefsch();
  ::essmodule::ESSControlScheduleFSCH* mutable_esscontrolschedulefsch();
  void set_allocated_esscontrolschedulefsch(::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch);
  private:
  const ::essmodule::ESSControlScheduleFSCH& _internal_esscontrolschedulefsch() const;
  ::essmodule::ESSControlScheduleFSCH* _internal_mutable_esscontrolschedulefsch();
  public:
  void unsafe_arena_set_allocated_esscontrolschedulefsch(
      ::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch);
  ::essmodule::ESSControlScheduleFSCH* unsafe_arena_release_esscontrolschedulefsch();
  // @@protoc_insertion_point(class_scope:essmodule.EssControlFSCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlFSCC* controlfscc_;
    ::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSControl) */ {
 public:
  inline ESSControl() : ESSControl(nullptr) {}
  ~ESSControl() override;
  explicit PROTOBUF_CONSTEXPR ESSControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSControl(const ESSControl& from);
  ESSControl(ESSControl&& from) noexcept
    : ESSControl() {
    *this = ::std::move(from);
  }

  inline ESSControl& operator=(const ESSControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSControl& operator=(ESSControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSControl* internal_default_instance() {
    return reinterpret_cast<const ESSControl*>(
               &_ESSControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ESSControl& a, ESSControl& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSControl& from) {
    ESSControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSControl";
  }
  protected:
  explicit ESSControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kEssControlFSCCFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .essmodule.EssControlFSCC essControlFSCC = 3;
  bool has_esscontrolfscc() const;
  private:
  bool _internal_has_esscontrolfscc() const;

  public:
  void clear_esscontrolfscc() ;
  const ::essmodule::EssControlFSCC& esscontrolfscc() const;
  PROTOBUF_NODISCARD ::essmodule::EssControlFSCC* release_esscontrolfscc();
  ::essmodule::EssControlFSCC* mutable_esscontrolfscc();
  void set_allocated_esscontrolfscc(::essmodule::EssControlFSCC* esscontrolfscc);
  private:
  const ::essmodule::EssControlFSCC& _internal_esscontrolfscc() const;
  ::essmodule::EssControlFSCC* _internal_mutable_esscontrolfscc();
  public:
  void unsafe_arena_set_allocated_esscontrolfscc(
      ::essmodule::EssControlFSCC* esscontrolfscc);
  ::essmodule::EssControlFSCC* unsafe_arena_release_esscontrolfscc();
  // @@protoc_insertion_point(class_scope:essmodule.ESSControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::essmodule::EssControlFSCC* esscontrolfscc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSControlProfile) */ {
 public:
  inline ESSControlProfile() : ESSControlProfile(nullptr) {}
  ~ESSControlProfile() override;
  explicit PROTOBUF_CONSTEXPR ESSControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSControlProfile(const ESSControlProfile& from);
  ESSControlProfile(ESSControlProfile&& from) noexcept
    : ESSControlProfile() {
    *this = ::std::move(from);
  }

  inline ESSControlProfile& operator=(const ESSControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSControlProfile& operator=(ESSControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSControlProfile* internal_default_instance() {
    return reinterpret_cast<const ESSControlProfile*>(
               &_ESSControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ESSControlProfile& a, ESSControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSControlProfile& from) {
    ESSControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSControlProfile";
  }
  protected:
  explicit ESSControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kEssFieldNumber = 2,
    kEssControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  private:
  bool _internal_has_ess() const;

  public:
  void clear_ess() ;
  const ::commonmodule::ESS& ess() const;
  PROTOBUF_NODISCARD ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);
  private:
  const ::commonmodule::ESS& _internal_ess() const;
  ::commonmodule::ESS* _internal_mutable_ess();
  public:
  void unsafe_arena_set_allocated_ess(
      ::commonmodule::ESS* ess);
  ::commonmodule::ESS* unsafe_arena_release_ess();
  // .essmodule.ESSControl essControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_esscontrol() const;
  private:
  bool _internal_has_esscontrol() const;

  public:
  void clear_esscontrol() ;
  const ::essmodule::ESSControl& esscontrol() const;
  PROTOBUF_NODISCARD ::essmodule::ESSControl* release_esscontrol();
  ::essmodule::ESSControl* mutable_esscontrol();
  void set_allocated_esscontrol(::essmodule::ESSControl* esscontrol);
  private:
  const ::essmodule::ESSControl& _internal_esscontrol() const;
  ::essmodule::ESSControl* _internal_mutable_esscontrol();
  public:
  void unsafe_arena_set_allocated_esscontrol(
      ::essmodule::ESSControl* esscontrol);
  ::essmodule::ESSControl* unsafe_arena_release_esscontrol();
  // @@protoc_insertion_point(class_scope:essmodule.ESSControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::commonmodule::ESS* ess_;
    ::essmodule::ESSControl* esscontrol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSDiscreteControlDBAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSDiscreteControlDBAT) */ {
 public:
  inline ESSDiscreteControlDBAT() : ESSDiscreteControlDBAT(nullptr) {}
  ~ESSDiscreteControlDBAT() override;
  explicit PROTOBUF_CONSTEXPR ESSDiscreteControlDBAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSDiscreteControlDBAT(const ESSDiscreteControlDBAT& from);
  ESSDiscreteControlDBAT(ESSDiscreteControlDBAT&& from) noexcept
    : ESSDiscreteControlDBAT() {
    *this = ::std::move(from);
  }

  inline ESSDiscreteControlDBAT& operator=(const ESSDiscreteControlDBAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSDiscreteControlDBAT& operator=(ESSDiscreteControlDBAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSDiscreteControlDBAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSDiscreteControlDBAT* internal_default_instance() {
    return reinterpret_cast<const ESSDiscreteControlDBAT*>(
               &_ESSDiscreteControlDBAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ESSDiscreteControlDBAT& a, ESSDiscreteControlDBAT& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSDiscreteControlDBAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSDiscreteControlDBAT* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSDiscreteControlDBAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSDiscreteControlDBAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSDiscreteControlDBAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSDiscreteControlDBAT& from) {
    ESSDiscreteControlDBAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSDiscreteControlDBAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSDiscreteControlDBAT";
  }
  protected:
  explicit ESSDiscreteControlDBAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kControlFieldNumber = 2,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;

  public:
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();
  // .essmodule.ESSPoint control = 2;
  bool has_control() const;
  private:
  bool _internal_has_control() const;

  public:
  void clear_control() ;
  const ::essmodule::ESSPoint& control() const;
  PROTOBUF_NODISCARD ::essmodule::ESSPoint* release_control();
  ::essmodule::ESSPoint* mutable_control();
  void set_allocated_control(::essmodule::ESSPoint* control);
  private:
  const ::essmodule::ESSPoint& _internal_control() const;
  ::essmodule::ESSPoint* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::essmodule::ESSPoint* control);
  ::essmodule::ESSPoint* unsafe_arena_release_control();
  // @@protoc_insertion_point(class_scope:essmodule.ESSDiscreteControlDBAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
    ::essmodule::ESSPoint* control_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSDiscreteControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSDiscreteControl) */ {
 public:
  inline ESSDiscreteControl() : ESSDiscreteControl(nullptr) {}
  ~ESSDiscreteControl() override;
  explicit PROTOBUF_CONSTEXPR ESSDiscreteControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSDiscreteControl(const ESSDiscreteControl& from);
  ESSDiscreteControl(ESSDiscreteControl&& from) noexcept
    : ESSDiscreteControl() {
    *this = ::std::move(from);
  }

  inline ESSDiscreteControl& operator=(const ESSDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSDiscreteControl& operator=(ESSDiscreteControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSDiscreteControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSDiscreteControl* internal_default_instance() {
    return reinterpret_cast<const ESSDiscreteControl*>(
               &_ESSDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ESSDiscreteControl& a, ESSDiscreteControl& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSDiscreteControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSDiscreteControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSDiscreteControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSDiscreteControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSDiscreteControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSDiscreteControl& from) {
    ESSDiscreteControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSDiscreteControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSDiscreteControl";
  }
  protected:
  explicit ESSDiscreteControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kEssDiscreteControlDBATFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .essmodule.ESSDiscreteControlDBAT essDiscreteControlDBAT = 3;
  bool has_essdiscretecontroldbat() const;
  private:
  bool _internal_has_essdiscretecontroldbat() const;

  public:
  void clear_essdiscretecontroldbat() ;
  const ::essmodule::ESSDiscreteControlDBAT& essdiscretecontroldbat() const;
  PROTOBUF_NODISCARD ::essmodule::ESSDiscreteControlDBAT* release_essdiscretecontroldbat();
  ::essmodule::ESSDiscreteControlDBAT* mutable_essdiscretecontroldbat();
  void set_allocated_essdiscretecontroldbat(::essmodule::ESSDiscreteControlDBAT* essdiscretecontroldbat);
  private:
  const ::essmodule::ESSDiscreteControlDBAT& _internal_essdiscretecontroldbat() const;
  ::essmodule::ESSDiscreteControlDBAT* _internal_mutable_essdiscretecontroldbat();
  public:
  void unsafe_arena_set_allocated_essdiscretecontroldbat(
      ::essmodule::ESSDiscreteControlDBAT* essdiscretecontroldbat);
  ::essmodule::ESSDiscreteControlDBAT* unsafe_arena_release_essdiscretecontroldbat();
  // @@protoc_insertion_point(class_scope:essmodule.ESSDiscreteControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::essmodule::ESSDiscreteControlDBAT* essdiscretecontroldbat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSDiscreteControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSDiscreteControlProfile) */ {
 public:
  inline ESSDiscreteControlProfile() : ESSDiscreteControlProfile(nullptr) {}
  ~ESSDiscreteControlProfile() override;
  explicit PROTOBUF_CONSTEXPR ESSDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSDiscreteControlProfile(const ESSDiscreteControlProfile& from);
  ESSDiscreteControlProfile(ESSDiscreteControlProfile&& from) noexcept
    : ESSDiscreteControlProfile() {
    *this = ::std::move(from);
  }

  inline ESSDiscreteControlProfile& operator=(const ESSDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSDiscreteControlProfile& operator=(ESSDiscreteControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSDiscreteControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSDiscreteControlProfile* internal_default_instance() {
    return reinterpret_cast<const ESSDiscreteControlProfile*>(
               &_ESSDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ESSDiscreteControlProfile& a, ESSDiscreteControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSDiscreteControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSDiscreteControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSDiscreteControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSDiscreteControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSDiscreteControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSDiscreteControlProfile& from) {
    ESSDiscreteControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSDiscreteControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSDiscreteControlProfile";
  }
  protected:
  explicit ESSDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kEssFieldNumber = 2,
    kEssDiscreteControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  private:
  bool _internal_has_ess() const;

  public:
  void clear_ess() ;
  const ::commonmodule::ESS& ess() const;
  PROTOBUF_NODISCARD ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);
  private:
  const ::commonmodule::ESS& _internal_ess() const;
  ::commonmodule::ESS* _internal_mutable_ess();
  public:
  void unsafe_arena_set_allocated_ess(
      ::commonmodule::ESS* ess);
  ::commonmodule::ESS* unsafe_arena_release_ess();
  // .essmodule.ESSDiscreteControl essDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_essdiscretecontrol() const;
  private:
  bool _internal_has_essdiscretecontrol() const;

  public:
  void clear_essdiscretecontrol() ;
  const ::essmodule::ESSDiscreteControl& essdiscretecontrol() const;
  PROTOBUF_NODISCARD ::essmodule::ESSDiscreteControl* release_essdiscretecontrol();
  ::essmodule::ESSDiscreteControl* mutable_essdiscretecontrol();
  void set_allocated_essdiscretecontrol(::essmodule::ESSDiscreteControl* essdiscretecontrol);
  private:
  const ::essmodule::ESSDiscreteControl& _internal_essdiscretecontrol() const;
  ::essmodule::ESSDiscreteControl* _internal_mutable_essdiscretecontrol();
  public:
  void unsafe_arena_set_allocated_essdiscretecontrol(
      ::essmodule::ESSDiscreteControl* essdiscretecontrol);
  ::essmodule::ESSDiscreteControl* unsafe_arena_release_essdiscretecontrol();
  // @@protoc_insertion_point(class_scope:essmodule.ESSDiscreteControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::commonmodule::ESS* ess_;
    ::essmodule::ESSDiscreteControl* essdiscretecontrol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class EssEventZBAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.EssEventZBAT) */ {
 public:
  inline EssEventZBAT() : EssEventZBAT(nullptr) {}
  ~EssEventZBAT() override;
  explicit PROTOBUF_CONSTEXPR EssEventZBAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EssEventZBAT(const EssEventZBAT& from);
  EssEventZBAT(EssEventZBAT&& from) noexcept
    : EssEventZBAT() {
    *this = ::std::move(from);
  }

  inline EssEventZBAT& operator=(const EssEventZBAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline EssEventZBAT& operator=(EssEventZBAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EssEventZBAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const EssEventZBAT* internal_default_instance() {
    return reinterpret_cast<const EssEventZBAT*>(
               &_EssEventZBAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EssEventZBAT& a, EssEventZBAT& b) {
    a.Swap(&b);
  }
  inline void Swap(EssEventZBAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EssEventZBAT* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EssEventZBAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EssEventZBAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EssEventZBAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EssEventZBAT& from) {
    EssEventZBAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EssEventZBAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.EssEventZBAT";
  }
  protected:
  explicit EssEventZBAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kBatHiFieldNumber = 2,
    kBatLoFieldNumber = 3,
    kBatStFieldNumber = 4,
    kSocFieldNumber = 5,
    kStdbyFieldNumber = 6,
    kSoHFieldNumber = 7,
    kWHAvailFieldNumber = 8,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.StatusSPS BatHi = 2;
  bool has_bathi() const;
  private:
  bool _internal_has_bathi() const;

  public:
  void clear_bathi() ;
  const ::commonmodule::StatusSPS& bathi() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_bathi();
  ::commonmodule::StatusSPS* mutable_bathi();
  void set_allocated_bathi(::commonmodule::StatusSPS* bathi);
  private:
  const ::commonmodule::StatusSPS& _internal_bathi() const;
  ::commonmodule::StatusSPS* _internal_mutable_bathi();
  public:
  void unsafe_arena_set_allocated_bathi(
      ::commonmodule::StatusSPS* bathi);
  ::commonmodule::StatusSPS* unsafe_arena_release_bathi();
  // .commonmodule.StatusSPS BatLo = 3;
  bool has_batlo() const;
  private:
  bool _internal_has_batlo() const;

  public:
  void clear_batlo() ;
  const ::commonmodule::StatusSPS& batlo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_batlo();
  ::commonmodule::StatusSPS* mutable_batlo();
  void set_allocated_batlo(::commonmodule::StatusSPS* batlo);
  private:
  const ::commonmodule::StatusSPS& _internal_batlo() const;
  ::commonmodule::StatusSPS* _internal_mutable_batlo();
  public:
  void unsafe_arena_set_allocated_batlo(
      ::commonmodule::StatusSPS* batlo);
  ::commonmodule::StatusSPS* unsafe_arena_release_batlo();
  // .commonmodule.StatusSPS BatSt = 4;
  bool has_batst() const;
  private:
  bool _internal_has_batst() const;

  public:
  void clear_batst() ;
  const ::commonmodule::StatusSPS& batst() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_batst();
  ::commonmodule::StatusSPS* mutable_batst();
  void set_allocated_batst(::commonmodule::StatusSPS* batst);
  private:
  const ::commonmodule::StatusSPS& _internal_batst() const;
  ::commonmodule::StatusSPS* _internal_mutable_batst();
  public:
  void unsafe_arena_set_allocated_batst(
      ::commonmodule::StatusSPS* batst);
  ::commonmodule::StatusSPS* unsafe_arena_release_batst();
  // .commonmodule.MV Soc = 5;
  bool has_soc() const;
  private:
  bool _internal_has_soc() const;

  public:
  void clear_soc() ;
  const ::commonmodule::MV& soc() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_soc();
  ::commonmodule::MV* mutable_soc();
  void set_allocated_soc(::commonmodule::MV* soc);
  private:
  const ::commonmodule::MV& _internal_soc() const;
  ::commonmodule::MV* _internal_mutable_soc();
  public:
  void unsafe_arena_set_allocated_soc(
      ::commonmodule::MV* soc);
  ::commonmodule::MV* unsafe_arena_release_soc();
  // .commonmodule.StatusSPS Stdby = 6;
  bool has_stdby() const;
  private:
  bool _internal_has_stdby() const;

  public:
  void clear_stdby() ;
  const ::commonmodule::StatusSPS& stdby() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_stdby();
  ::commonmodule::StatusSPS* mutable_stdby();
  void set_allocated_stdby(::commonmodule::StatusSPS* stdby);
  private:
  const ::commonmodule::StatusSPS& _internal_stdby() const;
  ::commonmodule::StatusSPS* _internal_mutable_stdby();
  public:
  void unsafe_arena_set_allocated_stdby(
      ::commonmodule::StatusSPS* stdby);
  ::commonmodule::StatusSPS* unsafe_arena_release_stdby();
  // .commonmodule.MV SoH = 7;
  bool has_soh() const;
  private:
  bool _internal_has_soh() const;

  public:
  void clear_soh() ;
  const ::commonmodule::MV& soh() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_soh();
  ::commonmodule::MV* mutable_soh();
  void set_allocated_soh(::commonmodule::MV* soh);
  private:
  const ::commonmodule::MV& _internal_soh() const;
  ::commonmodule::MV* _internal_mutable_soh();
  public:
  void unsafe_arena_set_allocated_soh(
      ::commonmodule::MV* soh);
  ::commonmodule::MV* unsafe_arena_release_soh();
  // .commonmodule.MV WHAvail = 8;
  bool has_whavail() const;
  private:
  bool _internal_has_whavail() const;

  public:
  void clear_whavail() ;
  const ::commonmodule::MV& whavail() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_whavail();
  ::commonmodule::MV* mutable_whavail();
  void set_allocated_whavail(::commonmodule::MV* whavail);
  private:
  const ::commonmodule::MV& _internal_whavail() const;
  ::commonmodule::MV* _internal_mutable_whavail();
  public:
  void unsafe_arena_set_allocated_whavail(
      ::commonmodule::MV* whavail);
  ::commonmodule::MV* unsafe_arena_release_whavail();
  // @@protoc_insertion_point(class_scope:essmodule.EssEventZBAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::StatusSPS* bathi_;
    ::commonmodule::StatusSPS* batlo_;
    ::commonmodule::StatusSPS* batst_;
    ::commonmodule::MV* soc_;
    ::commonmodule::StatusSPS* stdby_;
    ::commonmodule::MV* soh_;
    ::commonmodule::MV* whavail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSPointStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSPointStatus) */ {
 public:
  inline ESSPointStatus() : ESSPointStatus(nullptr) {}
  ~ESSPointStatus() override;
  explicit PROTOBUF_CONSTEXPR ESSPointStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSPointStatus(const ESSPointStatus& from);
  ESSPointStatus(ESSPointStatus&& from) noexcept
    : ESSPointStatus() {
    *this = ::std::move(from);
  }

  inline ESSPointStatus& operator=(const ESSPointStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSPointStatus& operator=(ESSPointStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSPointStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSPointStatus* internal_default_instance() {
    return reinterpret_cast<const ESSPointStatus*>(
               &_ESSPointStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ESSPointStatus& a, ESSPointStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSPointStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSPointStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSPointStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSPointStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSPointStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSPointStatus& from) {
    ESSPointStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSPointStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSPointStatus";
  }
  protected:
  explicit ESSPointStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlackStartEnabledFieldNumber = 1,
    kFrequencySetPointEnabledFieldNumber = 2,
    kFunctionFieldNumber = 3,
    kModeFieldNumber = 4,
    kPctHzDroopFieldNumber = 5,
    kPctVDroopFieldNumber = 6,
    kRampRatesFieldNumber = 7,
    kReactivePwrSetPointEnabledFieldNumber = 8,
    kRealPwrSetPointEnabledFieldNumber = 9,
    kStateFieldNumber = 10,
    kSyncBackToGridFieldNumber = 11,
    kTransToIslndOnGridLossEnabledFieldNumber = 12,
    kVoltageSetPointEnabledFieldNumber = 13,
    kEnterServiceOperationFieldNumber = 14,
    kHzWOperationFieldNumber = 15,
    kLimitWOperationFieldNumber = 16,
    kPFOperationFieldNumber = 17,
    kTmHzTripOperationFieldNumber = 18,
    kTmVoltTripOperationFieldNumber = 19,
    kVArOperationFieldNumber = 20,
    kVoltVarOperationFieldNumber = 21,
    kVoltWOperationFieldNumber = 22,
    kWVarOperationFieldNumber = 23,
  };
  // .commonmodule.StatusSPS blackStartEnabled = 1;
  bool has_blackstartenabled() const;
  private:
  bool _internal_has_blackstartenabled() const;

  public:
  void clear_blackstartenabled() ;
  const ::commonmodule::StatusSPS& blackstartenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_blackstartenabled();
  ::commonmodule::StatusSPS* mutable_blackstartenabled();
  void set_allocated_blackstartenabled(::commonmodule::StatusSPS* blackstartenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_blackstartenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_blackstartenabled();
  public:
  void unsafe_arena_set_allocated_blackstartenabled(
      ::commonmodule::StatusSPS* blackstartenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_blackstartenabled();
  // .commonmodule.StatusSPS frequencySetPointEnabled = 2;
  bool has_frequencysetpointenabled() const;
  private:
  bool _internal_has_frequencysetpointenabled() const;

  public:
  void clear_frequencysetpointenabled() ;
  const ::commonmodule::StatusSPS& frequencysetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_frequencysetpointenabled();
  ::commonmodule::StatusSPS* mutable_frequencysetpointenabled();
  void set_allocated_frequencysetpointenabled(::commonmodule::StatusSPS* frequencysetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_frequencysetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_frequencysetpointenabled();
  public:
  void unsafe_arena_set_allocated_frequencysetpointenabled(
      ::commonmodule::StatusSPS* frequencysetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_frequencysetpointenabled();
  // .essmodule.ESSFunction function = 3;
  bool has_function() const;
  private:
  bool _internal_has_function() const;

  public:
  void clear_function() ;
  const ::essmodule::ESSFunction& function() const;
  PROTOBUF_NODISCARD ::essmodule::ESSFunction* release_function();
  ::essmodule::ESSFunction* mutable_function();
  void set_allocated_function(::essmodule::ESSFunction* function);
  private:
  const ::essmodule::ESSFunction& _internal_function() const;
  ::essmodule::ESSFunction* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::essmodule::ESSFunction* function);
  ::essmodule::ESSFunction* unsafe_arena_release_function();
  // .commonmodule.ENG_GridConnectModeKind mode = 4;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;

  public:
  void clear_mode() ;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);
  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_mode() const;
  ::commonmodule::ENG_GridConnectModeKind* _internal_mutable_mode();
  public:
  void unsafe_arena_set_allocated_mode(
      ::commonmodule::ENG_GridConnectModeKind* mode);
  ::commonmodule::ENG_GridConnectModeKind* unsafe_arena_release_mode();
  // .google.protobuf.FloatValue pctHzDroop = 5;
  bool has_pcthzdroop() const;
  private:
  bool _internal_has_pcthzdroop() const;

  public:
  void clear_pcthzdroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pcthzdroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pcthzdroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pcthzdroop();
  void set_allocated_pcthzdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pcthzdroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pcthzdroop();
  public:
  void unsafe_arena_set_allocated_pcthzdroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pcthzdroop();
  // .google.protobuf.FloatValue pctVDroop = 6;
  bool has_pctvdroop() const;
  private:
  bool _internal_has_pctvdroop() const;

  public:
  void clear_pctvdroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pctvdroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pctvdroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pctvdroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pctvdroop();
  public:
  void unsafe_arena_set_allocated_pctvdroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pctvdroop();
  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.StatusSPS reactivePwrSetPointEnabled = 8;
  bool has_reactivepwrsetpointenabled() const;
  private:
  bool _internal_has_reactivepwrsetpointenabled() const;

  public:
  void clear_reactivepwrsetpointenabled() ;
  const ::commonmodule::StatusSPS& reactivepwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_reactivepwrsetpointenabled();
  ::commonmodule::StatusSPS* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPS* reactivepwrsetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_reactivepwrsetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_reactivepwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_reactivepwrsetpointenabled(
      ::commonmodule::StatusSPS* reactivepwrsetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_reactivepwrsetpointenabled();
  // .commonmodule.StatusSPS realPwrSetPointEnabled = 9;
  bool has_realpwrsetpointenabled() const;
  private:
  bool _internal_has_realpwrsetpointenabled() const;

  public:
  void clear_realpwrsetpointenabled() ;
  const ::commonmodule::StatusSPS& realpwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_realpwrsetpointenabled();
  ::commonmodule::StatusSPS* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::StatusSPS* realpwrsetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_realpwrsetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_realpwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_realpwrsetpointenabled(
      ::commonmodule::StatusSPS* realpwrsetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_realpwrsetpointenabled();
  // .commonmodule.Optional_StateKind state = 10;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // .commonmodule.StatusSPS syncBackToGrid = 11;
  bool has_syncbacktogrid() const;
  private:
  bool _internal_has_syncbacktogrid() const;

  public:
  void clear_syncbacktogrid() ;
  const ::commonmodule::StatusSPS& syncbacktogrid() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_syncbacktogrid();
  ::commonmodule::StatusSPS* mutable_syncbacktogrid();
  void set_allocated_syncbacktogrid(::commonmodule::StatusSPS* syncbacktogrid);
  private:
  const ::commonmodule::StatusSPS& _internal_syncbacktogrid() const;
  ::commonmodule::StatusSPS* _internal_mutable_syncbacktogrid();
  public:
  void unsafe_arena_set_allocated_syncbacktogrid(
      ::commonmodule::StatusSPS* syncbacktogrid);
  ::commonmodule::StatusSPS* unsafe_arena_release_syncbacktogrid();
  // .commonmodule.StatusSPS transToIslndOnGridLossEnabled = 12;
  bool has_transtoislndongridlossenabled() const;
  private:
  bool _internal_has_transtoislndongridlossenabled() const;

  public:
  void clear_transtoislndongridlossenabled() ;
  const ::commonmodule::StatusSPS& transtoislndongridlossenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_transtoislndongridlossenabled();
  ::commonmodule::StatusSPS* mutable_transtoislndongridlossenabled();
  void set_allocated_transtoislndongridlossenabled(::commonmodule::StatusSPS* transtoislndongridlossenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_transtoislndongridlossenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_transtoislndongridlossenabled();
  public:
  void unsafe_arena_set_allocated_transtoislndongridlossenabled(
      ::commonmodule::StatusSPS* transtoislndongridlossenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_transtoislndongridlossenabled();
  // .commonmodule.StatusSPS voltageSetPointEnabled = 13;
  bool has_voltagesetpointenabled() const;
  private:
  bool _internal_has_voltagesetpointenabled() const;

  public:
  void clear_voltagesetpointenabled() ;
  const ::commonmodule::StatusSPS& voltagesetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_voltagesetpointenabled();
  ::commonmodule::StatusSPS* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* voltagesetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_voltagesetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_voltagesetpointenabled();
  public:
  void unsafe_arena_set_allocated_voltagesetpointenabled(
      ::commonmodule::StatusSPS* voltagesetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_voltagesetpointenabled();
  // .commonmodule.EnterServiceAPC enterServiceOperation = 14;
  bool has_enterserviceoperation() const;
  private:
  bool _internal_has_enterserviceoperation() const;

  public:
  void clear_enterserviceoperation() ;
  const ::commonmodule::EnterServiceAPC& enterserviceoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::EnterServiceAPC* release_enterserviceoperation();
  ::commonmodule::EnterServiceAPC* mutable_enterserviceoperation();
  void set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation);
  private:
  const ::commonmodule::EnterServiceAPC& _internal_enterserviceoperation() const;
  ::commonmodule::EnterServiceAPC* _internal_mutable_enterserviceoperation();
  public:
  void unsafe_arena_set_allocated_enterserviceoperation(
      ::commonmodule::EnterServiceAPC* enterserviceoperation);
  ::commonmodule::EnterServiceAPC* unsafe_arena_release_enterserviceoperation();
  // .commonmodule.HzWAPC hzWOperation = 15;
  bool has_hzwoperation() const;
  private:
  bool _internal_has_hzwoperation() const;

  public:
  void clear_hzwoperation() ;
  const ::commonmodule::HzWAPC& hzwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::HzWAPC* release_hzwoperation();
  ::commonmodule::HzWAPC* mutable_hzwoperation();
  void set_allocated_hzwoperation(::commonmodule::HzWAPC* hzwoperation);
  private:
  const ::commonmodule::HzWAPC& _internal_hzwoperation() const;
  ::commonmodule::HzWAPC* _internal_mutable_hzwoperation();
  public:
  void unsafe_arena_set_allocated_hzwoperation(
      ::commonmodule::HzWAPC* hzwoperation);
  ::commonmodule::HzWAPC* unsafe_arena_release_hzwoperation();
  // .commonmodule.LimitWAPC limitWOperation = 16;
  bool has_limitwoperation() const;
  private:
  bool _internal_has_limitwoperation() const;

  public:
  void clear_limitwoperation() ;
  const ::commonmodule::LimitWAPC& limitwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::LimitWAPC* release_limitwoperation();
  ::commonmodule::LimitWAPC* mutable_limitwoperation();
  void set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation);
  private:
  const ::commonmodule::LimitWAPC& _internal_limitwoperation() const;
  ::commonmodule::LimitWAPC* _internal_mutable_limitwoperation();
  public:
  void unsafe_arena_set_allocated_limitwoperation(
      ::commonmodule::LimitWAPC* limitwoperation);
  ::commonmodule::LimitWAPC* unsafe_arena_release_limitwoperation();
  // .commonmodule.PFSPC pFOperation = 17;
  bool has_pfoperation() const;
  private:
  bool _internal_has_pfoperation() const;

  public:
  void clear_pfoperation() ;
  const ::commonmodule::PFSPC& pfoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::PFSPC* release_pfoperation();
  ::commonmodule::PFSPC* mutable_pfoperation();
  void set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation);
  private:
  const ::commonmodule::PFSPC& _internal_pfoperation() const;
  ::commonmodule::PFSPC* _internal_mutable_pfoperation();
  public:
  void unsafe_arena_set_allocated_pfoperation(
      ::commonmodule::PFSPC* pfoperation);
  ::commonmodule::PFSPC* unsafe_arena_release_pfoperation();
  // .commonmodule.TmHzCSG tmHzTripOperation = 18;
  bool has_tmhztripoperation() const;
  private:
  bool _internal_has_tmhztripoperation() const;

  public:
  void clear_tmhztripoperation() ;
  const ::commonmodule::TmHzCSG& tmhztripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmHzCSG* release_tmhztripoperation();
  ::commonmodule::TmHzCSG* mutable_tmhztripoperation();
  void set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation);
  private:
  const ::commonmodule::TmHzCSG& _internal_tmhztripoperation() const;
  ::commonmodule::TmHzCSG* _internal_mutable_tmhztripoperation();
  public:
  void unsafe_arena_set_allocated_tmhztripoperation(
      ::commonmodule::TmHzCSG* tmhztripoperation);
  ::commonmodule::TmHzCSG* unsafe_arena_release_tmhztripoperation();
  // .commonmodule.TmVoltCSG tmVoltTripOperation = 19;
  bool has_tmvolttripoperation() const;
  private:
  bool _internal_has_tmvolttripoperation() const;

  public:
  void clear_tmvolttripoperation() ;
  const ::commonmodule::TmVoltCSG& tmvolttripoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::TmVoltCSG* release_tmvolttripoperation();
  ::commonmodule::TmVoltCSG* mutable_tmvolttripoperation();
  void set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation);
  private:
  const ::commonmodule::TmVoltCSG& _internal_tmvolttripoperation() const;
  ::commonmodule::TmVoltCSG* _internal_mutable_tmvolttripoperation();
  public:
  void unsafe_arena_set_allocated_tmvolttripoperation(
      ::commonmodule::TmVoltCSG* tmvolttripoperation);
  ::commonmodule::TmVoltCSG* unsafe_arena_release_tmvolttripoperation();
  // .commonmodule.VarSPC vArOperation = 20;
  bool has_varoperation() const;
  private:
  bool _internal_has_varoperation() const;

  public:
  void clear_varoperation() ;
  const ::commonmodule::VarSPC& varoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VarSPC* release_varoperation();
  ::commonmodule::VarSPC* mutable_varoperation();
  void set_allocated_varoperation(::commonmodule::VarSPC* varoperation);
  private:
  const ::commonmodule::VarSPC& _internal_varoperation() const;
  ::commonmodule::VarSPC* _internal_mutable_varoperation();
  public:
  void unsafe_arena_set_allocated_varoperation(
      ::commonmodule::VarSPC* varoperation);
  ::commonmodule::VarSPC* unsafe_arena_release_varoperation();
  // .commonmodule.VoltVarCSG voltVarOperation = 21;
  bool has_voltvaroperation() const;
  private:
  bool _internal_has_voltvaroperation() const;

  public:
  void clear_voltvaroperation() ;
  const ::commonmodule::VoltVarCSG& voltvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltVarCSG* release_voltvaroperation();
  ::commonmodule::VoltVarCSG* mutable_voltvaroperation();
  void set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation);
  private:
  const ::commonmodule::VoltVarCSG& _internal_voltvaroperation() const;
  ::commonmodule::VoltVarCSG* _internal_mutable_voltvaroperation();
  public:
  void unsafe_arena_set_allocated_voltvaroperation(
      ::commonmodule::VoltVarCSG* voltvaroperation);
  ::commonmodule::VoltVarCSG* unsafe_arena_release_voltvaroperation();
  // .commonmodule.VoltWCSG voltWOperation = 22;
  bool has_voltwoperation() const;
  private:
  bool _internal_has_voltwoperation() const;

  public:
  void clear_voltwoperation() ;
  const ::commonmodule::VoltWCSG& voltwoperation() const;
  PROTOBUF_NODISCARD ::commonmodule::VoltWCSG* release_voltwoperation();
  ::commonmodule::VoltWCSG* mutable_voltwoperation();
  void set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation);
  private:
  const ::commonmodule::VoltWCSG& _internal_voltwoperation() const;
  ::commonmodule::VoltWCSG* _internal_mutable_voltwoperation();
  public:
  void unsafe_arena_set_allocated_voltwoperation(
      ::commonmodule::VoltWCSG* voltwoperation);
  ::commonmodule::VoltWCSG* unsafe_arena_release_voltwoperation();
  // .commonmodule.WVarCSG wVarOperation = 23;
  bool has_wvaroperation() const;
  private:
  bool _internal_has_wvaroperation() const;

  public:
  void clear_wvaroperation() ;
  const ::commonmodule::WVarCSG& wvaroperation() const;
  PROTOBUF_NODISCARD ::commonmodule::WVarCSG* release_wvaroperation();
  ::commonmodule::WVarCSG* mutable_wvaroperation();
  void set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation);
  private:
  const ::commonmodule::WVarCSG& _internal_wvaroperation() const;
  ::commonmodule::WVarCSG* _internal_mutable_wvaroperation();
  public:
  void unsafe_arena_set_allocated_wvaroperation(
      ::commonmodule::WVarCSG* wvaroperation);
  ::commonmodule::WVarCSG* unsafe_arena_release_wvaroperation();
  // @@protoc_insertion_point(class_scope:essmodule.ESSPointStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusSPS* blackstartenabled_;
    ::commonmodule::StatusSPS* frequencysetpointenabled_;
    ::essmodule::ESSFunction* function_;
    ::commonmodule::ENG_GridConnectModeKind* mode_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop_;
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::StatusSPS* reactivepwrsetpointenabled_;
    ::commonmodule::StatusSPS* realpwrsetpointenabled_;
    ::commonmodule::Optional_StateKind* state_;
    ::commonmodule::StatusSPS* syncbacktogrid_;
    ::commonmodule::StatusSPS* transtoislndongridlossenabled_;
    ::commonmodule::StatusSPS* voltagesetpointenabled_;
    ::commonmodule::EnterServiceAPC* enterserviceoperation_;
    ::commonmodule::HzWAPC* hzwoperation_;
    ::commonmodule::LimitWAPC* limitwoperation_;
    ::commonmodule::PFSPC* pfoperation_;
    ::commonmodule::TmHzCSG* tmhztripoperation_;
    ::commonmodule::TmVoltCSG* tmvolttripoperation_;
    ::commonmodule::VarSPC* varoperation_;
    ::commonmodule::VoltVarCSG* voltvaroperation_;
    ::commonmodule::VoltWCSG* voltwoperation_;
    ::commonmodule::WVarCSG* wvaroperation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSEventAndStatusZGEN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEventAndStatusZGEN) */ {
 public:
  inline ESSEventAndStatusZGEN() : ESSEventAndStatusZGEN(nullptr) {}
  ~ESSEventAndStatusZGEN() override;
  explicit PROTOBUF_CONSTEXPR ESSEventAndStatusZGEN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSEventAndStatusZGEN(const ESSEventAndStatusZGEN& from);
  ESSEventAndStatusZGEN(ESSEventAndStatusZGEN&& from) noexcept
    : ESSEventAndStatusZGEN() {
    *this = ::std::move(from);
  }

  inline ESSEventAndStatusZGEN& operator=(const ESSEventAndStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSEventAndStatusZGEN& operator=(ESSEventAndStatusZGEN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSEventAndStatusZGEN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSEventAndStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const ESSEventAndStatusZGEN*>(
               &_ESSEventAndStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ESSEventAndStatusZGEN& a, ESSEventAndStatusZGEN& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSEventAndStatusZGEN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSEventAndStatusZGEN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSEventAndStatusZGEN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSEventAndStatusZGEN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSEventAndStatusZGEN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSEventAndStatusZGEN& from) {
    ESSEventAndStatusZGEN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEventAndStatusZGEN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSEventAndStatusZGEN";
  }
  protected:
  explicit ESSEventAndStatusZGEN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kAuxPwrStFieldNumber = 2,
    kDynamicTestFieldNumber = 3,
    kEmgStopFieldNumber = 4,
    kGnSynStFieldNumber = 5,
    kPointStatusFieldNumber = 6,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.StatusSPS AuxPwrSt = 2;
  bool has_auxpwrst() const;
  private:
  bool _internal_has_auxpwrst() const;

  public:
  void clear_auxpwrst() ;
  const ::commonmodule::StatusSPS& auxpwrst() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_auxpwrst();
  ::commonmodule::StatusSPS* mutable_auxpwrst();
  void set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst);
  private:
  const ::commonmodule::StatusSPS& _internal_auxpwrst() const;
  ::commonmodule::StatusSPS* _internal_mutable_auxpwrst();
  public:
  void unsafe_arena_set_allocated_auxpwrst(
      ::commonmodule::StatusSPS* auxpwrst);
  ::commonmodule::StatusSPS* unsafe_arena_release_auxpwrst();
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
  bool has_dynamictest() const;
  private:
  bool _internal_has_dynamictest() const;

  public:
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);
  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* _internal_mutable_dynamictest();
  public:
  void unsafe_arena_set_allocated_dynamictest(
      ::commonmodule::ENS_DynamicTestKind* dynamictest);
  ::commonmodule::ENS_DynamicTestKind* unsafe_arena_release_dynamictest();
  // .commonmodule.StatusSPS EmgStop = 4;
  bool has_emgstop() const;
  private:
  bool _internal_has_emgstop() const;

  public:
  void clear_emgstop() ;
  const ::commonmodule::StatusSPS& emgstop() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_emgstop();
  ::commonmodule::StatusSPS* mutable_emgstop();
  void set_allocated_emgstop(::commonmodule::StatusSPS* emgstop);
  private:
  const ::commonmodule::StatusSPS& _internal_emgstop() const;
  ::commonmodule::StatusSPS* _internal_mutable_emgstop();
  public:
  void unsafe_arena_set_allocated_emgstop(
      ::commonmodule::StatusSPS* emgstop);
  ::commonmodule::StatusSPS* unsafe_arena_release_emgstop();
  // .commonmodule.StatusSPS GnSynSt = 5;
  bool has_gnsynst() const;
  private:
  bool _internal_has_gnsynst() const;

  public:
  void clear_gnsynst() ;
  const ::commonmodule::StatusSPS& gnsynst() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_gnsynst();
  ::commonmodule::StatusSPS* mutable_gnsynst();
  void set_allocated_gnsynst(::commonmodule::StatusSPS* gnsynst);
  private:
  const ::commonmodule::StatusSPS& _internal_gnsynst() const;
  ::commonmodule::StatusSPS* _internal_mutable_gnsynst();
  public:
  void unsafe_arena_set_allocated_gnsynst(
      ::commonmodule::StatusSPS* gnsynst);
  ::commonmodule::StatusSPS* unsafe_arena_release_gnsynst();
  // .essmodule.ESSPointStatus PointStatus = 6;
  bool has_pointstatus() const;
  private:
  bool _internal_has_pointstatus() const;

  public:
  void clear_pointstatus() ;
  const ::essmodule::ESSPointStatus& pointstatus() const;
  PROTOBUF_NODISCARD ::essmodule::ESSPointStatus* release_pointstatus();
  ::essmodule::ESSPointStatus* mutable_pointstatus();
  void set_allocated_pointstatus(::essmodule::ESSPointStatus* pointstatus);
  private:
  const ::essmodule::ESSPointStatus& _internal_pointstatus() const;
  ::essmodule::ESSPointStatus* _internal_mutable_pointstatus();
  public:
  void unsafe_arena_set_allocated_pointstatus(
      ::essmodule::ESSPointStatus* pointstatus);
  ::essmodule::ESSPointStatus* unsafe_arena_release_pointstatus();
  // @@protoc_insertion_point(class_scope:essmodule.ESSEventAndStatusZGEN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::StatusSPS* auxpwrst_;
    ::commonmodule::ENS_DynamicTestKind* dynamictest_;
    ::commonmodule::StatusSPS* emgstop_;
    ::commonmodule::StatusSPS* gnsynst_;
    ::essmodule::ESSPointStatus* pointstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSEventZGEN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEventZGEN) */ {
 public:
  inline ESSEventZGEN() : ESSEventZGEN(nullptr) {}
  ~ESSEventZGEN() override;
  explicit PROTOBUF_CONSTEXPR ESSEventZGEN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSEventZGEN(const ESSEventZGEN& from);
  ESSEventZGEN(ESSEventZGEN&& from) noexcept
    : ESSEventZGEN() {
    *this = ::std::move(from);
  }

  inline ESSEventZGEN& operator=(const ESSEventZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSEventZGEN& operator=(ESSEventZGEN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSEventZGEN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSEventZGEN* internal_default_instance() {
    return reinterpret_cast<const ESSEventZGEN*>(
               &_ESSEventZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ESSEventZGEN& a, ESSEventZGEN& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSEventZGEN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSEventZGEN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSEventZGEN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSEventZGEN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSEventZGEN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSEventZGEN& from) {
    ESSEventZGEN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEventZGEN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSEventZGEN";
  }
  protected:
  explicit ESSEventZGEN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kESSEventAndStatusZGENFieldNumber = 1,
  };
  // .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_esseventandstatuszgen() const;
  private:
  bool _internal_has_esseventandstatuszgen() const;

  public:
  void clear_esseventandstatuszgen() ;
  const ::essmodule::ESSEventAndStatusZGEN& esseventandstatuszgen() const;
  PROTOBUF_NODISCARD ::essmodule::ESSEventAndStatusZGEN* release_esseventandstatuszgen();
  ::essmodule::ESSEventAndStatusZGEN* mutable_esseventandstatuszgen();
  void set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen);
  private:
  const ::essmodule::ESSEventAndStatusZGEN& _internal_esseventandstatuszgen() const;
  ::essmodule::ESSEventAndStatusZGEN* _internal_mutable_esseventandstatuszgen();
  public:
  void unsafe_arena_set_allocated_esseventandstatuszgen(
      ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen);
  ::essmodule::ESSEventAndStatusZGEN* unsafe_arena_release_esseventandstatuszgen();
  // @@protoc_insertion_point(class_scope:essmodule.ESSEventZGEN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEvent) */ {
 public:
  inline ESSEvent() : ESSEvent(nullptr) {}
  ~ESSEvent() override;
  explicit PROTOBUF_CONSTEXPR ESSEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSEvent(const ESSEvent& from);
  ESSEvent(ESSEvent&& from) noexcept
    : ESSEvent() {
    *this = ::std::move(from);
  }

  inline ESSEvent& operator=(const ESSEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSEvent& operator=(ESSEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSEvent* internal_default_instance() {
    return reinterpret_cast<const ESSEvent*>(
               &_ESSEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ESSEvent& a, ESSEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSEvent& from) {
    ESSEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSEvent";
  }
  protected:
  explicit ESSEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventValueFieldNumber = 1,
    kEssEventZBATFieldNumber = 2,
    kEssEventZGENFieldNumber = 3,
  };
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  private:
  bool _internal_has_eventvalue() const;

  public:
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);
  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* _internal_mutable_eventvalue();
  public:
  void unsafe_arena_set_allocated_eventvalue(
      ::commonmodule::EventValue* eventvalue);
  ::commonmodule::EventValue* unsafe_arena_release_eventvalue();
  // .essmodule.EssEventZBAT essEventZBAT = 2;
  bool has_esseventzbat() const;
  private:
  bool _internal_has_esseventzbat() const;

  public:
  void clear_esseventzbat() ;
  const ::essmodule::EssEventZBAT& esseventzbat() const;
  PROTOBUF_NODISCARD ::essmodule::EssEventZBAT* release_esseventzbat();
  ::essmodule::EssEventZBAT* mutable_esseventzbat();
  void set_allocated_esseventzbat(::essmodule::EssEventZBAT* esseventzbat);
  private:
  const ::essmodule::EssEventZBAT& _internal_esseventzbat() const;
  ::essmodule::EssEventZBAT* _internal_mutable_esseventzbat();
  public:
  void unsafe_arena_set_allocated_esseventzbat(
      ::essmodule::EssEventZBAT* esseventzbat);
  ::essmodule::EssEventZBAT* unsafe_arena_release_esseventzbat();
  // .essmodule.ESSEventZGEN essEventZGEN = 3;
  bool has_esseventzgen() const;
  private:
  bool _internal_has_esseventzgen() const;

  public:
  void clear_esseventzgen() ;
  const ::essmodule::ESSEventZGEN& esseventzgen() const;
  PROTOBUF_NODISCARD ::essmodule::ESSEventZGEN* release_esseventzgen();
  ::essmodule::ESSEventZGEN* mutable_esseventzgen();
  void set_allocated_esseventzgen(::essmodule::ESSEventZGEN* esseventzgen);
  private:
  const ::essmodule::ESSEventZGEN& _internal_esseventzgen() const;
  ::essmodule::ESSEventZGEN* _internal_mutable_esseventzgen();
  public:
  void unsafe_arena_set_allocated_esseventzgen(
      ::essmodule::ESSEventZGEN* esseventzgen);
  ::essmodule::ESSEventZGEN* unsafe_arena_release_esseventzgen();
  // @@protoc_insertion_point(class_scope:essmodule.ESSEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventValue* eventvalue_;
    ::essmodule::EssEventZBAT* esseventzbat_;
    ::essmodule::ESSEventZGEN* esseventzgen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSEventProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEventProfile) */ {
 public:
  inline ESSEventProfile() : ESSEventProfile(nullptr) {}
  ~ESSEventProfile() override;
  explicit PROTOBUF_CONSTEXPR ESSEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSEventProfile(const ESSEventProfile& from);
  ESSEventProfile(ESSEventProfile&& from) noexcept
    : ESSEventProfile() {
    *this = ::std::move(from);
  }

  inline ESSEventProfile& operator=(const ESSEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSEventProfile& operator=(ESSEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSEventProfile* internal_default_instance() {
    return reinterpret_cast<const ESSEventProfile*>(
               &_ESSEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ESSEventProfile& a, ESSEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSEventProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSEventProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSEventProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSEventProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSEventProfile& from) {
    ESSEventProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEventProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSEventProfile";
  }
  protected:
  explicit ESSEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kEssFieldNumber = 2,
    kEssEventFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;

  public:
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();
  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  private:
  bool _internal_has_ess() const;

  public:
  void clear_ess() ;
  const ::commonmodule::ESS& ess() const;
  PROTOBUF_NODISCARD ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);
  private:
  const ::commonmodule::ESS& _internal_ess() const;
  ::commonmodule::ESS* _internal_mutable_ess();
  public:
  void unsafe_arena_set_allocated_ess(
      ::commonmodule::ESS* ess);
  ::commonmodule::ESS* unsafe_arena_release_ess();
  // .essmodule.ESSEvent essEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_essevent() const;
  private:
  bool _internal_has_essevent() const;

  public:
  void clear_essevent() ;
  const ::essmodule::ESSEvent& essevent() const;
  PROTOBUF_NODISCARD ::essmodule::ESSEvent* release_essevent();
  ::essmodule::ESSEvent* mutable_essevent();
  void set_allocated_essevent(::essmodule::ESSEvent* essevent);
  private:
  const ::essmodule::ESSEvent& _internal_essevent() const;
  ::essmodule::ESSEvent* _internal_mutable_essevent();
  public:
  void unsafe_arena_set_allocated_essevent(
      ::essmodule::ESSEvent* essevent);
  ::essmodule::ESSEvent* unsafe_arena_release_essevent();
  // @@protoc_insertion_point(class_scope:essmodule.ESSEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventMessageInfo* eventmessageinfo_;
    ::commonmodule::ESS* ess_;
    ::essmodule::ESSEvent* essevent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSReading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSReading) */ {
 public:
  inline ESSReading() : ESSReading(nullptr) {}
  ~ESSReading() override;
  explicit PROTOBUF_CONSTEXPR ESSReading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSReading(const ESSReading& from);
  ESSReading(ESSReading&& from) noexcept
    : ESSReading() {
    *this = ::std::move(from);
  }

  inline ESSReading& operator=(const ESSReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSReading& operator=(ESSReading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSReading& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSReading* internal_default_instance() {
    return reinterpret_cast<const ESSReading*>(
               &_ESSReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ESSReading& a, ESSReading& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSReading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSReading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSReading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSReading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSReading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSReading& from) {
    ESSReading::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSReading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSReading";
  }
  protected:
  explicit ESSReading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kPhaseMMTNFieldNumber = 2,
    kReadingMMTRFieldNumber = 3,
    kReadingMMXUFieldNumber = 4,
  };
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  private:
  bool _internal_has_conductingequipmentterminalreading() const;

  public:
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* _internal_mutable_conductingequipmentterminalreading();
  public:
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(
      ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  ::commonmodule::ConductingEquipmentTerminalReading* unsafe_arena_release_conductingequipmentterminalreading();
  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  private:
  bool _internal_has_phasemmtn() const;

  public:
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);
  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* _internal_mutable_phasemmtn();
  public:
  void unsafe_arena_set_allocated_phasemmtn(
      ::commonmodule::PhaseMMTN* phasemmtn);
  ::commonmodule::PhaseMMTN* unsafe_arena_release_phasemmtn();
  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  private:
  bool _internal_has_readingmmtr() const;

  public:
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);
  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* _internal_mutable_readingmmtr();
  public:
  void unsafe_arena_set_allocated_readingmmtr(
      ::commonmodule::ReadingMMTR* readingmmtr);
  ::commonmodule::ReadingMMTR* unsafe_arena_release_readingmmtr();
  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  private:
  bool _internal_has_readingmmxu() const;

  public:
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_readingmmxu();
  public:
  void unsafe_arena_set_allocated_readingmmxu(
      ::commonmodule::ReadingMMXU* readingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_readingmmxu();
  // @@protoc_insertion_point(class_scope:essmodule.ESSReading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
    ::commonmodule::PhaseMMTN* phasemmtn_;
    ::commonmodule::ReadingMMTR* readingmmtr_;
    ::commonmodule::ReadingMMXU* readingmmxu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSReadingProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSReadingProfile) */ {
 public:
  inline ESSReadingProfile() : ESSReadingProfile(nullptr) {}
  ~ESSReadingProfile() override;
  explicit PROTOBUF_CONSTEXPR ESSReadingProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSReadingProfile(const ESSReadingProfile& from);
  ESSReadingProfile(ESSReadingProfile&& from) noexcept
    : ESSReadingProfile() {
    *this = ::std::move(from);
  }

  inline ESSReadingProfile& operator=(const ESSReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSReadingProfile& operator=(ESSReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSReadingProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSReadingProfile* internal_default_instance() {
    return reinterpret_cast<const ESSReadingProfile*>(
               &_ESSReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ESSReadingProfile& a, ESSReadingProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSReadingProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSReadingProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSReadingProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSReadingProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSReadingProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSReadingProfile& from) {
    ESSReadingProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSReadingProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSReadingProfile";
  }
  protected:
  explicit ESSReadingProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadingMessageInfoFieldNumber = 1,
    kEssFieldNumber = 2,
    kEssReadingFieldNumber = 3,
  };
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  private:
  bool _internal_has_readingmessageinfo() const;

  public:
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);
  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* _internal_mutable_readingmessageinfo();
  public:
  void unsafe_arena_set_allocated_readingmessageinfo(
      ::commonmodule::ReadingMessageInfo* readingmessageinfo);
  ::commonmodule::ReadingMessageInfo* unsafe_arena_release_readingmessageinfo();
  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  private:
  bool _internal_has_ess() const;

  public:
  void clear_ess() ;
  const ::commonmodule::ESS& ess() const;
  PROTOBUF_NODISCARD ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);
  private:
  const ::commonmodule::ESS& _internal_ess() const;
  ::commonmodule::ESS* _internal_mutable_ess();
  public:
  void unsafe_arena_set_allocated_ess(
      ::commonmodule::ESS* ess);
  ::commonmodule::ESS* unsafe_arena_release_ess();
  // .essmodule.ESSReading essReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_essreading() const;
  private:
  bool _internal_has_essreading() const;

  public:
  void clear_essreading() ;
  const ::essmodule::ESSReading& essreading() const;
  PROTOBUF_NODISCARD ::essmodule::ESSReading* release_essreading();
  ::essmodule::ESSReading* mutable_essreading();
  void set_allocated_essreading(::essmodule::ESSReading* essreading);
  private:
  const ::essmodule::ESSReading& _internal_essreading() const;
  ::essmodule::ESSReading* _internal_mutable_essreading();
  public:
  void unsafe_arena_set_allocated_essreading(
      ::essmodule::ESSReading* essreading);
  ::essmodule::ESSReading* unsafe_arena_release_essreading();
  // @@protoc_insertion_point(class_scope:essmodule.ESSReadingProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
    ::commonmodule::ESS* ess_;
    ::essmodule::ESSReading* essreading_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class EssStatusZBAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.EssStatusZBAT) */ {
 public:
  inline EssStatusZBAT() : EssStatusZBAT(nullptr) {}
  ~EssStatusZBAT() override;
  explicit PROTOBUF_CONSTEXPR EssStatusZBAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EssStatusZBAT(const EssStatusZBAT& from);
  EssStatusZBAT(EssStatusZBAT&& from) noexcept
    : EssStatusZBAT() {
    *this = ::std::move(from);
  }

  inline EssStatusZBAT& operator=(const EssStatusZBAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline EssStatusZBAT& operator=(EssStatusZBAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EssStatusZBAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const EssStatusZBAT* internal_default_instance() {
    return reinterpret_cast<const EssStatusZBAT*>(
               &_EssStatusZBAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(EssStatusZBAT& a, EssStatusZBAT& b) {
    a.Swap(&b);
  }
  inline void Swap(EssStatusZBAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EssStatusZBAT* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EssStatusZBAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EssStatusZBAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EssStatusZBAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EssStatusZBAT& from) {
    EssStatusZBAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EssStatusZBAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.EssStatusZBAT";
  }
  protected:
  explicit EssStatusZBAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kBatStFieldNumber = 2,
    kGriModFieldNumber = 3,
    kSocFieldNumber = 4,
    kStdbyFieldNumber = 5,
    kSoHFieldNumber = 6,
    kWHAvailFieldNumber = 7,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.StatusSPS BatSt = 2;
  bool has_batst() const;
  private:
  bool _internal_has_batst() const;

  public:
  void clear_batst() ;
  const ::commonmodule::StatusSPS& batst() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_batst();
  ::commonmodule::StatusSPS* mutable_batst();
  void set_allocated_batst(::commonmodule::StatusSPS* batst);
  private:
  const ::commonmodule::StatusSPS& _internal_batst() const;
  ::commonmodule::StatusSPS* _internal_mutable_batst();
  public:
  void unsafe_arena_set_allocated_batst(
      ::commonmodule::StatusSPS* batst);
  ::commonmodule::StatusSPS* unsafe_arena_release_batst();
  // .commonmodule.ENG_GridConnectModeKind GriMod = 3;
  bool has_grimod() const;
  private:
  bool _internal_has_grimod() const;

  public:
  void clear_grimod() ;
  const ::commonmodule::ENG_GridConnectModeKind& grimod() const;
  PROTOBUF_NODISCARD ::commonmodule::ENG_GridConnectModeKind* release_grimod();
  ::commonmodule::ENG_GridConnectModeKind* mutable_grimod();
  void set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod);
  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_grimod() const;
  ::commonmodule::ENG_GridConnectModeKind* _internal_mutable_grimod();
  public:
  void unsafe_arena_set_allocated_grimod(
      ::commonmodule::ENG_GridConnectModeKind* grimod);
  ::commonmodule::ENG_GridConnectModeKind* unsafe_arena_release_grimod();
  // .commonmodule.MV Soc = 4;
  bool has_soc() const;
  private:
  bool _internal_has_soc() const;

  public:
  void clear_soc() ;
  const ::commonmodule::MV& soc() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_soc();
  ::commonmodule::MV* mutable_soc();
  void set_allocated_soc(::commonmodule::MV* soc);
  private:
  const ::commonmodule::MV& _internal_soc() const;
  ::commonmodule::MV* _internal_mutable_soc();
  public:
  void unsafe_arena_set_allocated_soc(
      ::commonmodule::MV* soc);
  ::commonmodule::MV* unsafe_arena_release_soc();
  // .commonmodule.StatusSPS Stdby = 5;
  bool has_stdby() const;
  private:
  bool _internal_has_stdby() const;

  public:
  void clear_stdby() ;
  const ::commonmodule::StatusSPS& stdby() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_stdby();
  ::commonmodule::StatusSPS* mutable_stdby();
  void set_allocated_stdby(::commonmodule::StatusSPS* stdby);
  private:
  const ::commonmodule::StatusSPS& _internal_stdby() const;
  ::commonmodule::StatusSPS* _internal_mutable_stdby();
  public:
  void unsafe_arena_set_allocated_stdby(
      ::commonmodule::StatusSPS* stdby);
  ::commonmodule::StatusSPS* unsafe_arena_release_stdby();
  // .commonmodule.MV SoH = 6;
  bool has_soh() const;
  private:
  bool _internal_has_soh() const;

  public:
  void clear_soh() ;
  const ::commonmodule::MV& soh() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_soh();
  ::commonmodule::MV* mutable_soh();
  void set_allocated_soh(::commonmodule::MV* soh);
  private:
  const ::commonmodule::MV& _internal_soh() const;
  ::commonmodule::MV* _internal_mutable_soh();
  public:
  void unsafe_arena_set_allocated_soh(
      ::commonmodule::MV* soh);
  ::commonmodule::MV* unsafe_arena_release_soh();
  // .commonmodule.MV WHAvail = 7;
  bool has_whavail() const;
  private:
  bool _internal_has_whavail() const;

  public:
  void clear_whavail() ;
  const ::commonmodule::MV& whavail() const;
  PROTOBUF_NODISCARD ::commonmodule::MV* release_whavail();
  ::commonmodule::MV* mutable_whavail();
  void set_allocated_whavail(::commonmodule::MV* whavail);
  private:
  const ::commonmodule::MV& _internal_whavail() const;
  ::commonmodule::MV* _internal_mutable_whavail();
  public:
  void unsafe_arena_set_allocated_whavail(
      ::commonmodule::MV* whavail);
  ::commonmodule::MV* unsafe_arena_release_whavail();
  // @@protoc_insertion_point(class_scope:essmodule.EssStatusZBAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::StatusSPS* batst_;
    ::commonmodule::ENG_GridConnectModeKind* grimod_;
    ::commonmodule::MV* soc_;
    ::commonmodule::StatusSPS* stdby_;
    ::commonmodule::MV* soh_;
    ::commonmodule::MV* whavail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSStatusZGEN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSStatusZGEN) */ {
 public:
  inline ESSStatusZGEN() : ESSStatusZGEN(nullptr) {}
  ~ESSStatusZGEN() override;
  explicit PROTOBUF_CONSTEXPR ESSStatusZGEN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSStatusZGEN(const ESSStatusZGEN& from);
  ESSStatusZGEN(ESSStatusZGEN&& from) noexcept
    : ESSStatusZGEN() {
    *this = ::std::move(from);
  }

  inline ESSStatusZGEN& operator=(const ESSStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSStatusZGEN& operator=(ESSStatusZGEN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSStatusZGEN& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const ESSStatusZGEN*>(
               &_ESSStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ESSStatusZGEN& a, ESSStatusZGEN& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSStatusZGEN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSStatusZGEN* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSStatusZGEN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSStatusZGEN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSStatusZGEN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSStatusZGEN& from) {
    ESSStatusZGEN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSStatusZGEN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSStatusZGEN";
  }
  protected:
  explicit ESSStatusZGEN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kESSEventAndStatusZGENFieldNumber = 1,
  };
  // .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_esseventandstatuszgen() const;
  private:
  bool _internal_has_esseventandstatuszgen() const;

  public:
  void clear_esseventandstatuszgen() ;
  const ::essmodule::ESSEventAndStatusZGEN& esseventandstatuszgen() const;
  PROTOBUF_NODISCARD ::essmodule::ESSEventAndStatusZGEN* release_esseventandstatuszgen();
  ::essmodule::ESSEventAndStatusZGEN* mutable_esseventandstatuszgen();
  void set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen);
  private:
  const ::essmodule::ESSEventAndStatusZGEN& _internal_esseventandstatuszgen() const;
  ::essmodule::ESSEventAndStatusZGEN* _internal_mutable_esseventandstatuszgen();
  public:
  void unsafe_arena_set_allocated_esseventandstatuszgen(
      ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen);
  ::essmodule::ESSEventAndStatusZGEN* unsafe_arena_release_esseventandstatuszgen();
  // @@protoc_insertion_point(class_scope:essmodule.ESSStatusZGEN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSStatus) */ {
 public:
  inline ESSStatus() : ESSStatus(nullptr) {}
  ~ESSStatus() override;
  explicit PROTOBUF_CONSTEXPR ESSStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSStatus(const ESSStatus& from);
  ESSStatus(ESSStatus&& from) noexcept
    : ESSStatus() {
    *this = ::std::move(from);
  }

  inline ESSStatus& operator=(const ESSStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSStatus& operator=(ESSStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSStatus* internal_default_instance() {
    return reinterpret_cast<const ESSStatus*>(
               &_ESSStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ESSStatus& a, ESSStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSStatus& from) {
    ESSStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSStatus";
  }
  protected:
  explicit ESSStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusValueFieldNumber = 1,
    kEssStatusZBATFieldNumber = 2,
    kEssStatusZGENFieldNumber = 3,
  };
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  private:
  bool _internal_has_statusvalue() const;

  public:
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);
  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* _internal_mutable_statusvalue();
  public:
  void unsafe_arena_set_allocated_statusvalue(
      ::commonmodule::StatusValue* statusvalue);
  ::commonmodule::StatusValue* unsafe_arena_release_statusvalue();
  // .essmodule.EssStatusZBAT essStatusZBAT = 2;
  bool has_essstatuszbat() const;
  private:
  bool _internal_has_essstatuszbat() const;

  public:
  void clear_essstatuszbat() ;
  const ::essmodule::EssStatusZBAT& essstatuszbat() const;
  PROTOBUF_NODISCARD ::essmodule::EssStatusZBAT* release_essstatuszbat();
  ::essmodule::EssStatusZBAT* mutable_essstatuszbat();
  void set_allocated_essstatuszbat(::essmodule::EssStatusZBAT* essstatuszbat);
  private:
  const ::essmodule::EssStatusZBAT& _internal_essstatuszbat() const;
  ::essmodule::EssStatusZBAT* _internal_mutable_essstatuszbat();
  public:
  void unsafe_arena_set_allocated_essstatuszbat(
      ::essmodule::EssStatusZBAT* essstatuszbat);
  ::essmodule::EssStatusZBAT* unsafe_arena_release_essstatuszbat();
  // .essmodule.ESSStatusZGEN essStatusZGEN = 3;
  bool has_essstatuszgen() const;
  private:
  bool _internal_has_essstatuszgen() const;

  public:
  void clear_essstatuszgen() ;
  const ::essmodule::ESSStatusZGEN& essstatuszgen() const;
  PROTOBUF_NODISCARD ::essmodule::ESSStatusZGEN* release_essstatuszgen();
  ::essmodule::ESSStatusZGEN* mutable_essstatuszgen();
  void set_allocated_essstatuszgen(::essmodule::ESSStatusZGEN* essstatuszgen);
  private:
  const ::essmodule::ESSStatusZGEN& _internal_essstatuszgen() const;
  ::essmodule::ESSStatusZGEN* _internal_mutable_essstatuszgen();
  public:
  void unsafe_arena_set_allocated_essstatuszgen(
      ::essmodule::ESSStatusZGEN* essstatuszgen);
  ::essmodule::ESSStatusZGEN* unsafe_arena_release_essstatuszgen();
  // @@protoc_insertion_point(class_scope:essmodule.ESSStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusValue* statusvalue_;
    ::essmodule::EssStatusZBAT* essstatuszbat_;
    ::essmodule::ESSStatusZGEN* essstatuszgen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};// -------------------------------------------------------------------

class ESSStatusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSStatusProfile) */ {
 public:
  inline ESSStatusProfile() : ESSStatusProfile(nullptr) {}
  ~ESSStatusProfile() override;
  explicit PROTOBUF_CONSTEXPR ESSStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ESSStatusProfile(const ESSStatusProfile& from);
  ESSStatusProfile(ESSStatusProfile&& from) noexcept
    : ESSStatusProfile() {
    *this = ::std::move(from);
  }

  inline ESSStatusProfile& operator=(const ESSStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ESSStatusProfile& operator=(ESSStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ESSStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ESSStatusProfile* internal_default_instance() {
    return reinterpret_cast<const ESSStatusProfile*>(
               &_ESSStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ESSStatusProfile& a, ESSStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ESSStatusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ESSStatusProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ESSStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ESSStatusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ESSStatusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ESSStatusProfile& from) {
    ESSStatusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSStatusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "essmodule.ESSStatusProfile";
  }
  protected:
  explicit ESSStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kEssFieldNumber = 2,
    kEssStatusFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  private:
  bool _internal_has_statusmessageinfo() const;

  public:
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);
  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* _internal_mutable_statusmessageinfo();
  public:
  void unsafe_arena_set_allocated_statusmessageinfo(
      ::commonmodule::StatusMessageInfo* statusmessageinfo);
  ::commonmodule::StatusMessageInfo* unsafe_arena_release_statusmessageinfo();
  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  private:
  bool _internal_has_ess() const;

  public:
  void clear_ess() ;
  const ::commonmodule::ESS& ess() const;
  PROTOBUF_NODISCARD ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);
  private:
  const ::commonmodule::ESS& _internal_ess() const;
  ::commonmodule::ESS* _internal_mutable_ess();
  public:
  void unsafe_arena_set_allocated_ess(
      ::commonmodule::ESS* ess);
  ::commonmodule::ESS* unsafe_arena_release_ess();
  // .essmodule.ESSStatus essStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_essstatus() const;
  private:
  bool _internal_has_essstatus() const;

  public:
  void clear_essstatus() ;
  const ::essmodule::ESSStatus& essstatus() const;
  PROTOBUF_NODISCARD ::essmodule::ESSStatus* release_essstatus();
  ::essmodule::ESSStatus* mutable_essstatus();
  void set_allocated_essstatus(::essmodule::ESSStatus* essstatus);
  private:
  const ::essmodule::ESSStatus& _internal_essstatus() const;
  ::essmodule::ESSStatus* _internal_mutable_essstatus();
  public:
  void unsafe_arena_set_allocated_essstatus(
      ::essmodule::ESSStatus* essstatus);
  ::essmodule::ESSStatus* unsafe_arena_release_essstatus();
  // @@protoc_insertion_point(class_scope:essmodule.ESSStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusMessageInfo* statusmessageinfo_;
    ::commonmodule::ESS* ess_;
    ::essmodule::ESSStatus* essstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ESSCapabilityConfiguration

// .commonmodule.SourceCapabilityConfiguration sourceCapabilityConfiguration = 1 [(.uml.option_parent_message) = true];
inline bool ESSCapabilityConfiguration::_internal_has_sourcecapabilityconfiguration() const {
  return this != internal_default_instance() && _impl_.sourcecapabilityconfiguration_ != nullptr;
}
inline bool ESSCapabilityConfiguration::has_sourcecapabilityconfiguration() const {
  return _internal_has_sourcecapabilityconfiguration();
}
inline const ::commonmodule::SourceCapabilityConfiguration& ESSCapabilityConfiguration::_internal_sourcecapabilityconfiguration() const {
  const ::commonmodule::SourceCapabilityConfiguration* p = _impl_.sourcecapabilityconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SourceCapabilityConfiguration&>(
      ::commonmodule::_SourceCapabilityConfiguration_default_instance_);
}
inline const ::commonmodule::SourceCapabilityConfiguration& ESSCapabilityConfiguration::sourcecapabilityconfiguration() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityConfiguration.sourceCapabilityConfiguration)
  return _internal_sourcecapabilityconfiguration();
}
inline void ESSCapabilityConfiguration::unsafe_arena_set_allocated_sourcecapabilityconfiguration(
    ::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityconfiguration_);
  }
  _impl_.sourcecapabilityconfiguration_ = sourcecapabilityconfiguration;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityConfiguration.sourceCapabilityConfiguration)
}
inline ::commonmodule::SourceCapabilityConfiguration* ESSCapabilityConfiguration::release_sourcecapabilityconfiguration() {
  
  ::commonmodule::SourceCapabilityConfiguration* temp = _impl_.sourcecapabilityconfiguration_;
  _impl_.sourcecapabilityconfiguration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::SourceCapabilityConfiguration* ESSCapabilityConfiguration::unsafe_arena_release_sourcecapabilityconfiguration() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityConfiguration.sourceCapabilityConfiguration)
  
  ::commonmodule::SourceCapabilityConfiguration* temp = _impl_.sourcecapabilityconfiguration_;
  _impl_.sourcecapabilityconfiguration_ = nullptr;
  return temp;
}
inline ::commonmodule::SourceCapabilityConfiguration* ESSCapabilityConfiguration::_internal_mutable_sourcecapabilityconfiguration() {
  
  if (_impl_.sourcecapabilityconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::SourceCapabilityConfiguration>(GetArenaForAllocation());
    _impl_.sourcecapabilityconfiguration_ = p;
  }
  return _impl_.sourcecapabilityconfiguration_;
}
inline ::commonmodule::SourceCapabilityConfiguration* ESSCapabilityConfiguration::mutable_sourcecapabilityconfiguration() {
  ::commonmodule::SourceCapabilityConfiguration* _msg = _internal_mutable_sourcecapabilityconfiguration();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityConfiguration.sourceCapabilityConfiguration)
  return _msg;
}
inline void ESSCapabilityConfiguration::set_allocated_sourcecapabilityconfiguration(::commonmodule::SourceCapabilityConfiguration* sourcecapabilityconfiguration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityconfiguration_);
  }
  if (sourcecapabilityconfiguration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sourcecapabilityconfiguration));
    if (message_arena != submessage_arena) {
      sourcecapabilityconfiguration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sourcecapabilityconfiguration, submessage_arena);
    }

  } else {

  }
  _impl_.sourcecapabilityconfiguration_ = sourcecapabilityconfiguration;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityConfiguration.sourceCapabilityConfiguration)
}

// .commonmodule.ASG VAChaRteMax = 2;
inline bool ESSCapabilityConfiguration::_internal_has_vachartemax() const {
  return this != internal_default_instance() && _impl_.vachartemax_ != nullptr;
}
inline bool ESSCapabilityConfiguration::has_vachartemax() const {
  return _internal_has_vachartemax();
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::_internal_vachartemax() const {
  const ::commonmodule::ASG* p = _impl_.vachartemax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::vachartemax() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityConfiguration.VAChaRteMax)
  return _internal_vachartemax();
}
inline void ESSCapabilityConfiguration::unsafe_arena_set_allocated_vachartemax(
    ::commonmodule::ASG* vachartemax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vachartemax_);
  }
  _impl_.vachartemax_ = vachartemax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityConfiguration.VAChaRteMax)
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::release_vachartemax() {
  
  ::commonmodule::ASG* temp = _impl_.vachartemax_;
  _impl_.vachartemax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::unsafe_arena_release_vachartemax() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityConfiguration.VAChaRteMax)
  
  ::commonmodule::ASG* temp = _impl_.vachartemax_;
  _impl_.vachartemax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::_internal_mutable_vachartemax() {
  
  if (_impl_.vachartemax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vachartemax_ = p;
  }
  return _impl_.vachartemax_;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::mutable_vachartemax() {
  ::commonmodule::ASG* _msg = _internal_mutable_vachartemax();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityConfiguration.VAChaRteMax)
  return _msg;
}
inline void ESSCapabilityConfiguration::set_allocated_vachartemax(::commonmodule::ASG* vachartemax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vachartemax_);
  }
  if (vachartemax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vachartemax));
    if (message_arena != submessage_arena) {
      vachartemax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vachartemax, submessage_arena);
    }

  } else {

  }
  _impl_.vachartemax_ = vachartemax;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityConfiguration.VAChaRteMax)
}

// .commonmodule.ASG VADisChaRteMax = 3;
inline bool ESSCapabilityConfiguration::_internal_has_vadischartemax() const {
  return this != internal_default_instance() && _impl_.vadischartemax_ != nullptr;
}
inline bool ESSCapabilityConfiguration::has_vadischartemax() const {
  return _internal_has_vadischartemax();
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::_internal_vadischartemax() const {
  const ::commonmodule::ASG* p = _impl_.vadischartemax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::vadischartemax() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityConfiguration.VADisChaRteMax)
  return _internal_vadischartemax();
}
inline void ESSCapabilityConfiguration::unsafe_arena_set_allocated_vadischartemax(
    ::commonmodule::ASG* vadischartemax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vadischartemax_);
  }
  _impl_.vadischartemax_ = vadischartemax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityConfiguration.VADisChaRteMax)
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::release_vadischartemax() {
  
  ::commonmodule::ASG* temp = _impl_.vadischartemax_;
  _impl_.vadischartemax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::unsafe_arena_release_vadischartemax() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityConfiguration.VADisChaRteMax)
  
  ::commonmodule::ASG* temp = _impl_.vadischartemax_;
  _impl_.vadischartemax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::_internal_mutable_vadischartemax() {
  
  if (_impl_.vadischartemax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vadischartemax_ = p;
  }
  return _impl_.vadischartemax_;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::mutable_vadischartemax() {
  ::commonmodule::ASG* _msg = _internal_mutable_vadischartemax();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityConfiguration.VADisChaRteMax)
  return _msg;
}
inline void ESSCapabilityConfiguration::set_allocated_vadischartemax(::commonmodule::ASG* vadischartemax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vadischartemax_);
  }
  if (vadischartemax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vadischartemax));
    if (message_arena != submessage_arena) {
      vadischartemax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vadischartemax, submessage_arena);
    }

  } else {

  }
  _impl_.vadischartemax_ = vadischartemax;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityConfiguration.VADisChaRteMax)
}

// .commonmodule.ASG WChaRteMax = 4;
inline bool ESSCapabilityConfiguration::_internal_has_wchartemax() const {
  return this != internal_default_instance() && _impl_.wchartemax_ != nullptr;
}
inline bool ESSCapabilityConfiguration::has_wchartemax() const {
  return _internal_has_wchartemax();
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::_internal_wchartemax() const {
  const ::commonmodule::ASG* p = _impl_.wchartemax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::wchartemax() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityConfiguration.WChaRteMax)
  return _internal_wchartemax();
}
inline void ESSCapabilityConfiguration::unsafe_arena_set_allocated_wchartemax(
    ::commonmodule::ASG* wchartemax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wchartemax_);
  }
  _impl_.wchartemax_ = wchartemax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityConfiguration.WChaRteMax)
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::release_wchartemax() {
  
  ::commonmodule::ASG* temp = _impl_.wchartemax_;
  _impl_.wchartemax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::unsafe_arena_release_wchartemax() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityConfiguration.WChaRteMax)
  
  ::commonmodule::ASG* temp = _impl_.wchartemax_;
  _impl_.wchartemax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::_internal_mutable_wchartemax() {
  
  if (_impl_.wchartemax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wchartemax_ = p;
  }
  return _impl_.wchartemax_;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::mutable_wchartemax() {
  ::commonmodule::ASG* _msg = _internal_mutable_wchartemax();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityConfiguration.WChaRteMax)
  return _msg;
}
inline void ESSCapabilityConfiguration::set_allocated_wchartemax(::commonmodule::ASG* wchartemax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wchartemax_);
  }
  if (wchartemax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wchartemax));
    if (message_arena != submessage_arena) {
      wchartemax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wchartemax, submessage_arena);
    }

  } else {

  }
  _impl_.wchartemax_ = wchartemax;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityConfiguration.WChaRteMax)
}

// .commonmodule.ASG WDisChaRteMax = 5;
inline bool ESSCapabilityConfiguration::_internal_has_wdischartemax() const {
  return this != internal_default_instance() && _impl_.wdischartemax_ != nullptr;
}
inline bool ESSCapabilityConfiguration::has_wdischartemax() const {
  return _internal_has_wdischartemax();
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::_internal_wdischartemax() const {
  const ::commonmodule::ASG* p = _impl_.wdischartemax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityConfiguration::wdischartemax() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityConfiguration.WDisChaRteMax)
  return _internal_wdischartemax();
}
inline void ESSCapabilityConfiguration::unsafe_arena_set_allocated_wdischartemax(
    ::commonmodule::ASG* wdischartemax) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wdischartemax_);
  }
  _impl_.wdischartemax_ = wdischartemax;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityConfiguration.WDisChaRteMax)
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::release_wdischartemax() {
  
  ::commonmodule::ASG* temp = _impl_.wdischartemax_;
  _impl_.wdischartemax_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::unsafe_arena_release_wdischartemax() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityConfiguration.WDisChaRteMax)
  
  ::commonmodule::ASG* temp = _impl_.wdischartemax_;
  _impl_.wdischartemax_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::_internal_mutable_wdischartemax() {
  
  if (_impl_.wdischartemax_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wdischartemax_ = p;
  }
  return _impl_.wdischartemax_;
}
inline ::commonmodule::ASG* ESSCapabilityConfiguration::mutable_wdischartemax() {
  ::commonmodule::ASG* _msg = _internal_mutable_wdischartemax();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityConfiguration.WDisChaRteMax)
  return _msg;
}
inline void ESSCapabilityConfiguration::set_allocated_wdischartemax(::commonmodule::ASG* wdischartemax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wdischartemax_);
  }
  if (wdischartemax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wdischartemax));
    if (message_arena != submessage_arena) {
      wdischartemax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wdischartemax, submessage_arena);
    }

  } else {

  }
  _impl_.wdischartemax_ = wdischartemax;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityConfiguration.WDisChaRteMax)
}

// -------------------------------------------------------------------

// ESSCapabilityOverride

// .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSCapabilityOverride::_internal_has_nameplatevalue() const {
  return this != internal_default_instance() && _impl_.nameplatevalue_ != nullptr;
}
inline bool ESSCapabilityOverride::has_nameplatevalue() const {
  return _internal_has_nameplatevalue();
}
inline const ::commonmodule::NameplateValue& ESSCapabilityOverride::_internal_nameplatevalue() const {
  const ::commonmodule::NameplateValue* p = _impl_.nameplatevalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::NameplateValue&>(
      ::commonmodule::_NameplateValue_default_instance_);
}
inline const ::commonmodule::NameplateValue& ESSCapabilityOverride::nameplatevalue() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityOverride.nameplateValue)
  return _internal_nameplatevalue();
}
inline void ESSCapabilityOverride::unsafe_arena_set_allocated_nameplatevalue(
    ::commonmodule::NameplateValue* nameplatevalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nameplatevalue_);
  }
  _impl_.nameplatevalue_ = nameplatevalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityOverride.nameplateValue)
}
inline ::commonmodule::NameplateValue* ESSCapabilityOverride::release_nameplatevalue() {
  
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::NameplateValue* ESSCapabilityOverride::unsafe_arena_release_nameplatevalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityOverride.nameplateValue)
  
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
  return temp;
}
inline ::commonmodule::NameplateValue* ESSCapabilityOverride::_internal_mutable_nameplatevalue() {
  
  if (_impl_.nameplatevalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::NameplateValue>(GetArenaForAllocation());
    _impl_.nameplatevalue_ = p;
  }
  return _impl_.nameplatevalue_;
}
inline ::commonmodule::NameplateValue* ESSCapabilityOverride::mutable_nameplatevalue() {
  ::commonmodule::NameplateValue* _msg = _internal_mutable_nameplatevalue();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityOverride.nameplateValue)
  return _msg;
}
inline void ESSCapabilityOverride::set_allocated_nameplatevalue(::commonmodule::NameplateValue* nameplatevalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nameplatevalue_);
  }
  if (nameplatevalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nameplatevalue));
    if (message_arena != submessage_arena) {
      nameplatevalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nameplatevalue, submessage_arena);
    }

  } else {

  }
  _impl_.nameplatevalue_ = nameplatevalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityOverride.nameplateValue)
}

// .essmodule.ESSCapabilityConfiguration essCapabilityConfiguration = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityOverride::_internal_has_esscapabilityconfiguration() const {
  return this != internal_default_instance() && _impl_.esscapabilityconfiguration_ != nullptr;
}
inline bool ESSCapabilityOverride::has_esscapabilityconfiguration() const {
  return _internal_has_esscapabilityconfiguration();
}
inline void ESSCapabilityOverride::clear_esscapabilityconfiguration() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscapabilityconfiguration_ != nullptr) {
    delete _impl_.esscapabilityconfiguration_;
  }
  _impl_.esscapabilityconfiguration_ = nullptr;
}
inline const ::essmodule::ESSCapabilityConfiguration& ESSCapabilityOverride::_internal_esscapabilityconfiguration() const {
  const ::essmodule::ESSCapabilityConfiguration* p = _impl_.esscapabilityconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSCapabilityConfiguration&>(
      ::essmodule::_ESSCapabilityConfiguration_default_instance_);
}
inline const ::essmodule::ESSCapabilityConfiguration& ESSCapabilityOverride::esscapabilityconfiguration() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityOverride.essCapabilityConfiguration)
  return _internal_esscapabilityconfiguration();
}
inline void ESSCapabilityOverride::unsafe_arena_set_allocated_esscapabilityconfiguration(
    ::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscapabilityconfiguration_);
  }
  _impl_.esscapabilityconfiguration_ = esscapabilityconfiguration;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityOverride.essCapabilityConfiguration)
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapabilityOverride::release_esscapabilityconfiguration() {
  
  ::essmodule::ESSCapabilityConfiguration* temp = _impl_.esscapabilityconfiguration_;
  _impl_.esscapabilityconfiguration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapabilityOverride::unsafe_arena_release_esscapabilityconfiguration() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityOverride.essCapabilityConfiguration)
  
  ::essmodule::ESSCapabilityConfiguration* temp = _impl_.esscapabilityconfiguration_;
  _impl_.esscapabilityconfiguration_ = nullptr;
  return temp;
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapabilityOverride::_internal_mutable_esscapabilityconfiguration() {
  
  if (_impl_.esscapabilityconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSCapabilityConfiguration>(GetArenaForAllocation());
    _impl_.esscapabilityconfiguration_ = p;
  }
  return _impl_.esscapabilityconfiguration_;
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapabilityOverride::mutable_esscapabilityconfiguration() {
  ::essmodule::ESSCapabilityConfiguration* _msg = _internal_mutable_esscapabilityconfiguration();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityOverride.essCapabilityConfiguration)
  return _msg;
}
inline void ESSCapabilityOverride::set_allocated_esscapabilityconfiguration(::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscapabilityconfiguration_;
  }
  if (esscapabilityconfiguration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscapabilityconfiguration);
    if (message_arena != submessage_arena) {
      esscapabilityconfiguration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscapabilityconfiguration, submessage_arena);
    }

  } else {

  }
  _impl_.esscapabilityconfiguration_ = esscapabilityconfiguration;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityOverride.essCapabilityConfiguration)
}

// -------------------------------------------------------------------

// ESSCapabilityOverrideProfile

// .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSCapabilityOverrideProfile::_internal_has_capabilitymessageinfo() const {
  return this != internal_default_instance() && _impl_.capabilitymessageinfo_ != nullptr;
}
inline bool ESSCapabilityOverrideProfile::has_capabilitymessageinfo() const {
  return _internal_has_capabilitymessageinfo();
}
inline const ::commonmodule::CapabilityMessageInfo& ESSCapabilityOverrideProfile::_internal_capabilitymessageinfo() const {
  const ::commonmodule::CapabilityMessageInfo* p = _impl_.capabilitymessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CapabilityMessageInfo&>(
      ::commonmodule::_CapabilityMessageInfo_default_instance_);
}
inline const ::commonmodule::CapabilityMessageInfo& ESSCapabilityOverrideProfile::capabilitymessageinfo() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityOverrideProfile.capabilityMessageInfo)
  return _internal_capabilitymessageinfo();
}
inline void ESSCapabilityOverrideProfile::unsafe_arena_set_allocated_capabilitymessageinfo(
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityOverrideProfile.capabilityMessageInfo)
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityOverrideProfile::release_capabilitymessageinfo() {
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityOverrideProfile::unsafe_arena_release_capabilitymessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityOverrideProfile.capabilityMessageInfo)
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityOverrideProfile::_internal_mutable_capabilitymessageinfo() {
  
  if (_impl_.capabilitymessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CapabilityMessageInfo>(GetArenaForAllocation());
    _impl_.capabilitymessageinfo_ = p;
  }
  return _impl_.capabilitymessageinfo_;
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityOverrideProfile::mutable_capabilitymessageinfo() {
  ::commonmodule::CapabilityMessageInfo* _msg = _internal_mutable_capabilitymessageinfo();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityOverrideProfile.capabilityMessageInfo)
  return _msg;
}
inline void ESSCapabilityOverrideProfile::set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  if (capabilitymessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilitymessageinfo));
    if (message_arena != submessage_arena) {
      capabilitymessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilitymessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityOverrideProfile.capabilityMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityOverrideProfile::_internal_has_ess() const {
  return this != internal_default_instance() && _impl_.ess_ != nullptr;
}
inline bool ESSCapabilityOverrideProfile::has_ess() const {
  return _internal_has_ess();
}
inline const ::commonmodule::ESS& ESSCapabilityOverrideProfile::_internal_ess() const {
  const ::commonmodule::ESS* p = _impl_.ess_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ESS&>(
      ::commonmodule::_ESS_default_instance_);
}
inline const ::commonmodule::ESS& ESSCapabilityOverrideProfile::ess() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityOverrideProfile.ess)
  return _internal_ess();
}
inline void ESSCapabilityOverrideProfile::unsafe_arena_set_allocated_ess(
    ::commonmodule::ESS* ess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityOverrideProfile.ess)
}
inline ::commonmodule::ESS* ESSCapabilityOverrideProfile::release_ess() {
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ESS* ESSCapabilityOverrideProfile::unsafe_arena_release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityOverrideProfile.ess)
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSCapabilityOverrideProfile::_internal_mutable_ess() {
  
  if (_impl_.ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaForAllocation());
    _impl_.ess_ = p;
  }
  return _impl_.ess_;
}
inline ::commonmodule::ESS* ESSCapabilityOverrideProfile::mutable_ess() {
  ::commonmodule::ESS* _msg = _internal_mutable_ess();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityOverrideProfile.ess)
  return _msg;
}
inline void ESSCapabilityOverrideProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  if (ess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ess));
    if (message_arena != submessage_arena) {
      ess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }

  } else {

  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityOverrideProfile.ess)
}

// .essmodule.ESSCapabilityOverride essCapabilityOverride = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityOverrideProfile::_internal_has_esscapabilityoverride() const {
  return this != internal_default_instance() && _impl_.esscapabilityoverride_ != nullptr;
}
inline bool ESSCapabilityOverrideProfile::has_esscapabilityoverride() const {
  return _internal_has_esscapabilityoverride();
}
inline void ESSCapabilityOverrideProfile::clear_esscapabilityoverride() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscapabilityoverride_ != nullptr) {
    delete _impl_.esscapabilityoverride_;
  }
  _impl_.esscapabilityoverride_ = nullptr;
}
inline const ::essmodule::ESSCapabilityOverride& ESSCapabilityOverrideProfile::_internal_esscapabilityoverride() const {
  const ::essmodule::ESSCapabilityOverride* p = _impl_.esscapabilityoverride_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSCapabilityOverride&>(
      ::essmodule::_ESSCapabilityOverride_default_instance_);
}
inline const ::essmodule::ESSCapabilityOverride& ESSCapabilityOverrideProfile::esscapabilityoverride() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityOverrideProfile.essCapabilityOverride)
  return _internal_esscapabilityoverride();
}
inline void ESSCapabilityOverrideProfile::unsafe_arena_set_allocated_esscapabilityoverride(
    ::essmodule::ESSCapabilityOverride* esscapabilityoverride) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscapabilityoverride_);
  }
  _impl_.esscapabilityoverride_ = esscapabilityoverride;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityOverrideProfile.essCapabilityOverride)
}
inline ::essmodule::ESSCapabilityOverride* ESSCapabilityOverrideProfile::release_esscapabilityoverride() {
  
  ::essmodule::ESSCapabilityOverride* temp = _impl_.esscapabilityoverride_;
  _impl_.esscapabilityoverride_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSCapabilityOverride* ESSCapabilityOverrideProfile::unsafe_arena_release_esscapabilityoverride() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityOverrideProfile.essCapabilityOverride)
  
  ::essmodule::ESSCapabilityOverride* temp = _impl_.esscapabilityoverride_;
  _impl_.esscapabilityoverride_ = nullptr;
  return temp;
}
inline ::essmodule::ESSCapabilityOverride* ESSCapabilityOverrideProfile::_internal_mutable_esscapabilityoverride() {
  
  if (_impl_.esscapabilityoverride_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSCapabilityOverride>(GetArenaForAllocation());
    _impl_.esscapabilityoverride_ = p;
  }
  return _impl_.esscapabilityoverride_;
}
inline ::essmodule::ESSCapabilityOverride* ESSCapabilityOverrideProfile::mutable_esscapabilityoverride() {
  ::essmodule::ESSCapabilityOverride* _msg = _internal_mutable_esscapabilityoverride();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityOverrideProfile.essCapabilityOverride)
  return _msg;
}
inline void ESSCapabilityOverrideProfile::set_allocated_esscapabilityoverride(::essmodule::ESSCapabilityOverride* esscapabilityoverride) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscapabilityoverride_;
  }
  if (esscapabilityoverride) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscapabilityoverride);
    if (message_arena != submessage_arena) {
      esscapabilityoverride = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscapabilityoverride, submessage_arena);
    }

  } else {

  }
  _impl_.esscapabilityoverride_ = esscapabilityoverride;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityOverrideProfile.essCapabilityOverride)
}

// -------------------------------------------------------------------

// ESSCapabilityRatings

// .commonmodule.SourceCapabilityRatings sourceCapabilityRatings = 1 [(.uml.option_parent_message) = true];
inline bool ESSCapabilityRatings::_internal_has_sourcecapabilityratings() const {
  return this != internal_default_instance() && _impl_.sourcecapabilityratings_ != nullptr;
}
inline bool ESSCapabilityRatings::has_sourcecapabilityratings() const {
  return _internal_has_sourcecapabilityratings();
}
inline const ::commonmodule::SourceCapabilityRatings& ESSCapabilityRatings::_internal_sourcecapabilityratings() const {
  const ::commonmodule::SourceCapabilityRatings* p = _impl_.sourcecapabilityratings_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SourceCapabilityRatings&>(
      ::commonmodule::_SourceCapabilityRatings_default_instance_);
}
inline const ::commonmodule::SourceCapabilityRatings& ESSCapabilityRatings::sourcecapabilityratings() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityRatings.sourceCapabilityRatings)
  return _internal_sourcecapabilityratings();
}
inline void ESSCapabilityRatings::unsafe_arena_set_allocated_sourcecapabilityratings(
    ::commonmodule::SourceCapabilityRatings* sourcecapabilityratings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityratings_);
  }
  _impl_.sourcecapabilityratings_ = sourcecapabilityratings;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityRatings.sourceCapabilityRatings)
}
inline ::commonmodule::SourceCapabilityRatings* ESSCapabilityRatings::release_sourcecapabilityratings() {
  
  ::commonmodule::SourceCapabilityRatings* temp = _impl_.sourcecapabilityratings_;
  _impl_.sourcecapabilityratings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::SourceCapabilityRatings* ESSCapabilityRatings::unsafe_arena_release_sourcecapabilityratings() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityRatings.sourceCapabilityRatings)
  
  ::commonmodule::SourceCapabilityRatings* temp = _impl_.sourcecapabilityratings_;
  _impl_.sourcecapabilityratings_ = nullptr;
  return temp;
}
inline ::commonmodule::SourceCapabilityRatings* ESSCapabilityRatings::_internal_mutable_sourcecapabilityratings() {
  
  if (_impl_.sourcecapabilityratings_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::SourceCapabilityRatings>(GetArenaForAllocation());
    _impl_.sourcecapabilityratings_ = p;
  }
  return _impl_.sourcecapabilityratings_;
}
inline ::commonmodule::SourceCapabilityRatings* ESSCapabilityRatings::mutable_sourcecapabilityratings() {
  ::commonmodule::SourceCapabilityRatings* _msg = _internal_mutable_sourcecapabilityratings();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityRatings.sourceCapabilityRatings)
  return _msg;
}
inline void ESSCapabilityRatings::set_allocated_sourcecapabilityratings(::commonmodule::SourceCapabilityRatings* sourcecapabilityratings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sourcecapabilityratings_);
  }
  if (sourcecapabilityratings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sourcecapabilityratings));
    if (message_arena != submessage_arena) {
      sourcecapabilityratings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sourcecapabilityratings, submessage_arena);
    }

  } else {

  }
  _impl_.sourcecapabilityratings_ = sourcecapabilityratings;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityRatings.sourceCapabilityRatings)
}

// .commonmodule.ASG VAChaRteMaxRtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityRatings::_internal_has_vachartemaxrtg() const {
  return this != internal_default_instance() && _impl_.vachartemaxrtg_ != nullptr;
}
inline bool ESSCapabilityRatings::has_vachartemaxrtg() const {
  return _internal_has_vachartemaxrtg();
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::_internal_vachartemaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.vachartemaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::vachartemaxrtg() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityRatings.VAChaRteMaxRtg)
  return _internal_vachartemaxrtg();
}
inline void ESSCapabilityRatings::unsafe_arena_set_allocated_vachartemaxrtg(
    ::commonmodule::ASG* vachartemaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vachartemaxrtg_);
  }
  _impl_.vachartemaxrtg_ = vachartemaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityRatings.VAChaRteMaxRtg)
}
inline ::commonmodule::ASG* ESSCapabilityRatings::release_vachartemaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.vachartemaxrtg_;
  _impl_.vachartemaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::unsafe_arena_release_vachartemaxrtg() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityRatings.VAChaRteMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.vachartemaxrtg_;
  _impl_.vachartemaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::_internal_mutable_vachartemaxrtg() {
  
  if (_impl_.vachartemaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vachartemaxrtg_ = p;
  }
  return _impl_.vachartemaxrtg_;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::mutable_vachartemaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_vachartemaxrtg();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityRatings.VAChaRteMaxRtg)
  return _msg;
}
inline void ESSCapabilityRatings::set_allocated_vachartemaxrtg(::commonmodule::ASG* vachartemaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vachartemaxrtg_);
  }
  if (vachartemaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vachartemaxrtg));
    if (message_arena != submessage_arena) {
      vachartemaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vachartemaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.vachartemaxrtg_ = vachartemaxrtg;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityRatings.VAChaRteMaxRtg)
}

// .commonmodule.ASG VADisChaRteMaxRtg = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityRatings::_internal_has_vadischartemaxrtg() const {
  return this != internal_default_instance() && _impl_.vadischartemaxrtg_ != nullptr;
}
inline bool ESSCapabilityRatings::has_vadischartemaxrtg() const {
  return _internal_has_vadischartemaxrtg();
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::_internal_vadischartemaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.vadischartemaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::vadischartemaxrtg() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityRatings.VADisChaRteMaxRtg)
  return _internal_vadischartemaxrtg();
}
inline void ESSCapabilityRatings::unsafe_arena_set_allocated_vadischartemaxrtg(
    ::commonmodule::ASG* vadischartemaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vadischartemaxrtg_);
  }
  _impl_.vadischartemaxrtg_ = vadischartemaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityRatings.VADisChaRteMaxRtg)
}
inline ::commonmodule::ASG* ESSCapabilityRatings::release_vadischartemaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.vadischartemaxrtg_;
  _impl_.vadischartemaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::unsafe_arena_release_vadischartemaxrtg() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityRatings.VADisChaRteMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.vadischartemaxrtg_;
  _impl_.vadischartemaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::_internal_mutable_vadischartemaxrtg() {
  
  if (_impl_.vadischartemaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.vadischartemaxrtg_ = p;
  }
  return _impl_.vadischartemaxrtg_;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::mutable_vadischartemaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_vadischartemaxrtg();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityRatings.VADisChaRteMaxRtg)
  return _msg;
}
inline void ESSCapabilityRatings::set_allocated_vadischartemaxrtg(::commonmodule::ASG* vadischartemaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vadischartemaxrtg_);
  }
  if (vadischartemaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vadischartemaxrtg));
    if (message_arena != submessage_arena) {
      vadischartemaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vadischartemaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.vadischartemaxrtg_ = vadischartemaxrtg;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityRatings.VADisChaRteMaxRtg)
}

// .commonmodule.ASG WChaRteMaxRtg = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityRatings::_internal_has_wchartemaxrtg() const {
  return this != internal_default_instance() && _impl_.wchartemaxrtg_ != nullptr;
}
inline bool ESSCapabilityRatings::has_wchartemaxrtg() const {
  return _internal_has_wchartemaxrtg();
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::_internal_wchartemaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.wchartemaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::wchartemaxrtg() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityRatings.WChaRteMaxRtg)
  return _internal_wchartemaxrtg();
}
inline void ESSCapabilityRatings::unsafe_arena_set_allocated_wchartemaxrtg(
    ::commonmodule::ASG* wchartemaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wchartemaxrtg_);
  }
  _impl_.wchartemaxrtg_ = wchartemaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityRatings.WChaRteMaxRtg)
}
inline ::commonmodule::ASG* ESSCapabilityRatings::release_wchartemaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.wchartemaxrtg_;
  _impl_.wchartemaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::unsafe_arena_release_wchartemaxrtg() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityRatings.WChaRteMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.wchartemaxrtg_;
  _impl_.wchartemaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::_internal_mutable_wchartemaxrtg() {
  
  if (_impl_.wchartemaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wchartemaxrtg_ = p;
  }
  return _impl_.wchartemaxrtg_;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::mutable_wchartemaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_wchartemaxrtg();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityRatings.WChaRteMaxRtg)
  return _msg;
}
inline void ESSCapabilityRatings::set_allocated_wchartemaxrtg(::commonmodule::ASG* wchartemaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wchartemaxrtg_);
  }
  if (wchartemaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wchartemaxrtg));
    if (message_arena != submessage_arena) {
      wchartemaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wchartemaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.wchartemaxrtg_ = wchartemaxrtg;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityRatings.WChaRteMaxRtg)
}

// .commonmodule.ASG WDisChaRteMaxRtg = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityRatings::_internal_has_wdischartemaxrtg() const {
  return this != internal_default_instance() && _impl_.wdischartemaxrtg_ != nullptr;
}
inline bool ESSCapabilityRatings::has_wdischartemaxrtg() const {
  return _internal_has_wdischartemaxrtg();
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::_internal_wdischartemaxrtg() const {
  const ::commonmodule::ASG* p = _impl_.wdischartemaxrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::wdischartemaxrtg() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityRatings.WDisChaRteMaxRtg)
  return _internal_wdischartemaxrtg();
}
inline void ESSCapabilityRatings::unsafe_arena_set_allocated_wdischartemaxrtg(
    ::commonmodule::ASG* wdischartemaxrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wdischartemaxrtg_);
  }
  _impl_.wdischartemaxrtg_ = wdischartemaxrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityRatings.WDisChaRteMaxRtg)
}
inline ::commonmodule::ASG* ESSCapabilityRatings::release_wdischartemaxrtg() {
  
  ::commonmodule::ASG* temp = _impl_.wdischartemaxrtg_;
  _impl_.wdischartemaxrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::unsafe_arena_release_wdischartemaxrtg() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityRatings.WDisChaRteMaxRtg)
  
  ::commonmodule::ASG* temp = _impl_.wdischartemaxrtg_;
  _impl_.wdischartemaxrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::_internal_mutable_wdischartemaxrtg() {
  
  if (_impl_.wdischartemaxrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.wdischartemaxrtg_ = p;
  }
  return _impl_.wdischartemaxrtg_;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::mutable_wdischartemaxrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_wdischartemaxrtg();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityRatings.WDisChaRteMaxRtg)
  return _msg;
}
inline void ESSCapabilityRatings::set_allocated_wdischartemaxrtg(::commonmodule::ASG* wdischartemaxrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wdischartemaxrtg_);
  }
  if (wdischartemaxrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wdischartemaxrtg));
    if (message_arena != submessage_arena) {
      wdischartemaxrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wdischartemaxrtg, submessage_arena);
    }

  } else {

  }
  _impl_.wdischartemaxrtg_ = wdischartemaxrtg;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityRatings.WDisChaRteMaxRtg)
}

// .commonmodule.ASG WHRtg = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityRatings::_internal_has_whrtg() const {
  return this != internal_default_instance() && _impl_.whrtg_ != nullptr;
}
inline bool ESSCapabilityRatings::has_whrtg() const {
  return _internal_has_whrtg();
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::_internal_whrtg() const {
  const ::commonmodule::ASG* p = _impl_.whrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& ESSCapabilityRatings::whrtg() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityRatings.WHRtg)
  return _internal_whrtg();
}
inline void ESSCapabilityRatings::unsafe_arena_set_allocated_whrtg(
    ::commonmodule::ASG* whrtg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.whrtg_);
  }
  _impl_.whrtg_ = whrtg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityRatings.WHRtg)
}
inline ::commonmodule::ASG* ESSCapabilityRatings::release_whrtg() {
  
  ::commonmodule::ASG* temp = _impl_.whrtg_;
  _impl_.whrtg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::unsafe_arena_release_whrtg() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityRatings.WHRtg)
  
  ::commonmodule::ASG* temp = _impl_.whrtg_;
  _impl_.whrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::_internal_mutable_whrtg() {
  
  if (_impl_.whrtg_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.whrtg_ = p;
  }
  return _impl_.whrtg_;
}
inline ::commonmodule::ASG* ESSCapabilityRatings::mutable_whrtg() {
  ::commonmodule::ASG* _msg = _internal_mutable_whrtg();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityRatings.WHRtg)
  return _msg;
}
inline void ESSCapabilityRatings::set_allocated_whrtg(::commonmodule::ASG* whrtg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.whrtg_);
  }
  if (whrtg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(whrtg));
    if (message_arena != submessage_arena) {
      whrtg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, whrtg, submessage_arena);
    }

  } else {

  }
  _impl_.whrtg_ = whrtg;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityRatings.WHRtg)
}

// -------------------------------------------------------------------

// ESSCapability

// .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSCapability::_internal_has_nameplatevalue() const {
  return this != internal_default_instance() && _impl_.nameplatevalue_ != nullptr;
}
inline bool ESSCapability::has_nameplatevalue() const {
  return _internal_has_nameplatevalue();
}
inline const ::commonmodule::NameplateValue& ESSCapability::_internal_nameplatevalue() const {
  const ::commonmodule::NameplateValue* p = _impl_.nameplatevalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::NameplateValue&>(
      ::commonmodule::_NameplateValue_default_instance_);
}
inline const ::commonmodule::NameplateValue& ESSCapability::nameplatevalue() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapability.nameplateValue)
  return _internal_nameplatevalue();
}
inline void ESSCapability::unsafe_arena_set_allocated_nameplatevalue(
    ::commonmodule::NameplateValue* nameplatevalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nameplatevalue_);
  }
  _impl_.nameplatevalue_ = nameplatevalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapability.nameplateValue)
}
inline ::commonmodule::NameplateValue* ESSCapability::release_nameplatevalue() {
  
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::NameplateValue* ESSCapability::unsafe_arena_release_nameplatevalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapability.nameplateValue)
  
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
  return temp;
}
inline ::commonmodule::NameplateValue* ESSCapability::_internal_mutable_nameplatevalue() {
  
  if (_impl_.nameplatevalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::NameplateValue>(GetArenaForAllocation());
    _impl_.nameplatevalue_ = p;
  }
  return _impl_.nameplatevalue_;
}
inline ::commonmodule::NameplateValue* ESSCapability::mutable_nameplatevalue() {
  ::commonmodule::NameplateValue* _msg = _internal_mutable_nameplatevalue();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapability.nameplateValue)
  return _msg;
}
inline void ESSCapability::set_allocated_nameplatevalue(::commonmodule::NameplateValue* nameplatevalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nameplatevalue_);
  }
  if (nameplatevalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nameplatevalue));
    if (message_arena != submessage_arena) {
      nameplatevalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nameplatevalue, submessage_arena);
    }

  } else {

  }
  _impl_.nameplatevalue_ = nameplatevalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapability.nameplateValue)
}

// .essmodule.ESSCapabilityRatings essCapabilityRatings = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapability::_internal_has_esscapabilityratings() const {
  return this != internal_default_instance() && _impl_.esscapabilityratings_ != nullptr;
}
inline bool ESSCapability::has_esscapabilityratings() const {
  return _internal_has_esscapabilityratings();
}
inline void ESSCapability::clear_esscapabilityratings() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscapabilityratings_ != nullptr) {
    delete _impl_.esscapabilityratings_;
  }
  _impl_.esscapabilityratings_ = nullptr;
}
inline const ::essmodule::ESSCapabilityRatings& ESSCapability::_internal_esscapabilityratings() const {
  const ::essmodule::ESSCapabilityRatings* p = _impl_.esscapabilityratings_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSCapabilityRatings&>(
      ::essmodule::_ESSCapabilityRatings_default_instance_);
}
inline const ::essmodule::ESSCapabilityRatings& ESSCapability::esscapabilityratings() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapability.essCapabilityRatings)
  return _internal_esscapabilityratings();
}
inline void ESSCapability::unsafe_arena_set_allocated_esscapabilityratings(
    ::essmodule::ESSCapabilityRatings* esscapabilityratings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscapabilityratings_);
  }
  _impl_.esscapabilityratings_ = esscapabilityratings;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapability.essCapabilityRatings)
}
inline ::essmodule::ESSCapabilityRatings* ESSCapability::release_esscapabilityratings() {
  
  ::essmodule::ESSCapabilityRatings* temp = _impl_.esscapabilityratings_;
  _impl_.esscapabilityratings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSCapabilityRatings* ESSCapability::unsafe_arena_release_esscapabilityratings() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapability.essCapabilityRatings)
  
  ::essmodule::ESSCapabilityRatings* temp = _impl_.esscapabilityratings_;
  _impl_.esscapabilityratings_ = nullptr;
  return temp;
}
inline ::essmodule::ESSCapabilityRatings* ESSCapability::_internal_mutable_esscapabilityratings() {
  
  if (_impl_.esscapabilityratings_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSCapabilityRatings>(GetArenaForAllocation());
    _impl_.esscapabilityratings_ = p;
  }
  return _impl_.esscapabilityratings_;
}
inline ::essmodule::ESSCapabilityRatings* ESSCapability::mutable_esscapabilityratings() {
  ::essmodule::ESSCapabilityRatings* _msg = _internal_mutable_esscapabilityratings();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapability.essCapabilityRatings)
  return _msg;
}
inline void ESSCapability::set_allocated_esscapabilityratings(::essmodule::ESSCapabilityRatings* esscapabilityratings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscapabilityratings_;
  }
  if (esscapabilityratings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscapabilityratings);
    if (message_arena != submessage_arena) {
      esscapabilityratings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscapabilityratings, submessage_arena);
    }

  } else {

  }
  _impl_.esscapabilityratings_ = esscapabilityratings;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapability.essCapabilityRatings)
}

// .essmodule.ESSCapabilityConfiguration essCapabilityConfiguration = 3;
inline bool ESSCapability::_internal_has_esscapabilityconfiguration() const {
  return this != internal_default_instance() && _impl_.esscapabilityconfiguration_ != nullptr;
}
inline bool ESSCapability::has_esscapabilityconfiguration() const {
  return _internal_has_esscapabilityconfiguration();
}
inline void ESSCapability::clear_esscapabilityconfiguration() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscapabilityconfiguration_ != nullptr) {
    delete _impl_.esscapabilityconfiguration_;
  }
  _impl_.esscapabilityconfiguration_ = nullptr;
}
inline const ::essmodule::ESSCapabilityConfiguration& ESSCapability::_internal_esscapabilityconfiguration() const {
  const ::essmodule::ESSCapabilityConfiguration* p = _impl_.esscapabilityconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSCapabilityConfiguration&>(
      ::essmodule::_ESSCapabilityConfiguration_default_instance_);
}
inline const ::essmodule::ESSCapabilityConfiguration& ESSCapability::esscapabilityconfiguration() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapability.essCapabilityConfiguration)
  return _internal_esscapabilityconfiguration();
}
inline void ESSCapability::unsafe_arena_set_allocated_esscapabilityconfiguration(
    ::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscapabilityconfiguration_);
  }
  _impl_.esscapabilityconfiguration_ = esscapabilityconfiguration;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapability.essCapabilityConfiguration)
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapability::release_esscapabilityconfiguration() {
  
  ::essmodule::ESSCapabilityConfiguration* temp = _impl_.esscapabilityconfiguration_;
  _impl_.esscapabilityconfiguration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapability::unsafe_arena_release_esscapabilityconfiguration() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapability.essCapabilityConfiguration)
  
  ::essmodule::ESSCapabilityConfiguration* temp = _impl_.esscapabilityconfiguration_;
  _impl_.esscapabilityconfiguration_ = nullptr;
  return temp;
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapability::_internal_mutable_esscapabilityconfiguration() {
  
  if (_impl_.esscapabilityconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSCapabilityConfiguration>(GetArenaForAllocation());
    _impl_.esscapabilityconfiguration_ = p;
  }
  return _impl_.esscapabilityconfiguration_;
}
inline ::essmodule::ESSCapabilityConfiguration* ESSCapability::mutable_esscapabilityconfiguration() {
  ::essmodule::ESSCapabilityConfiguration* _msg = _internal_mutable_esscapabilityconfiguration();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapability.essCapabilityConfiguration)
  return _msg;
}
inline void ESSCapability::set_allocated_esscapabilityconfiguration(::essmodule::ESSCapabilityConfiguration* esscapabilityconfiguration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscapabilityconfiguration_;
  }
  if (esscapabilityconfiguration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscapabilityconfiguration);
    if (message_arena != submessage_arena) {
      esscapabilityconfiguration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscapabilityconfiguration, submessage_arena);
    }

  } else {

  }
  _impl_.esscapabilityconfiguration_ = esscapabilityconfiguration;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapability.essCapabilityConfiguration)
}

// -------------------------------------------------------------------

// ESSCapabilityProfile

// .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSCapabilityProfile::_internal_has_capabilitymessageinfo() const {
  return this != internal_default_instance() && _impl_.capabilitymessageinfo_ != nullptr;
}
inline bool ESSCapabilityProfile::has_capabilitymessageinfo() const {
  return _internal_has_capabilitymessageinfo();
}
inline const ::commonmodule::CapabilityMessageInfo& ESSCapabilityProfile::_internal_capabilitymessageinfo() const {
  const ::commonmodule::CapabilityMessageInfo* p = _impl_.capabilitymessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CapabilityMessageInfo&>(
      ::commonmodule::_CapabilityMessageInfo_default_instance_);
}
inline const ::commonmodule::CapabilityMessageInfo& ESSCapabilityProfile::capabilitymessageinfo() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityProfile.capabilityMessageInfo)
  return _internal_capabilitymessageinfo();
}
inline void ESSCapabilityProfile::unsafe_arena_set_allocated_capabilitymessageinfo(
    ::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityProfile.capabilityMessageInfo)
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityProfile::release_capabilitymessageinfo() {
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityProfile::unsafe_arena_release_capabilitymessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityProfile.capabilityMessageInfo)
  
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityProfile::_internal_mutable_capabilitymessageinfo() {
  
  if (_impl_.capabilitymessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CapabilityMessageInfo>(GetArenaForAllocation());
    _impl_.capabilitymessageinfo_ = p;
  }
  return _impl_.capabilitymessageinfo_;
}
inline ::commonmodule::CapabilityMessageInfo* ESSCapabilityProfile::mutable_capabilitymessageinfo() {
  ::commonmodule::CapabilityMessageInfo* _msg = _internal_mutable_capabilitymessageinfo();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityProfile.capabilityMessageInfo)
  return _msg;
}
inline void ESSCapabilityProfile::set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* capabilitymessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  if (capabilitymessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilitymessageinfo));
    if (message_arena != submessage_arena) {
      capabilitymessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilitymessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.capabilitymessageinfo_ = capabilitymessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityProfile.capabilityMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityProfile::_internal_has_ess() const {
  return this != internal_default_instance() && _impl_.ess_ != nullptr;
}
inline bool ESSCapabilityProfile::has_ess() const {
  return _internal_has_ess();
}
inline const ::commonmodule::ESS& ESSCapabilityProfile::_internal_ess() const {
  const ::commonmodule::ESS* p = _impl_.ess_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ESS&>(
      ::commonmodule::_ESS_default_instance_);
}
inline const ::commonmodule::ESS& ESSCapabilityProfile::ess() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityProfile.ess)
  return _internal_ess();
}
inline void ESSCapabilityProfile::unsafe_arena_set_allocated_ess(
    ::commonmodule::ESS* ess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityProfile.ess)
}
inline ::commonmodule::ESS* ESSCapabilityProfile::release_ess() {
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ESS* ESSCapabilityProfile::unsafe_arena_release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityProfile.ess)
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSCapabilityProfile::_internal_mutable_ess() {
  
  if (_impl_.ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaForAllocation());
    _impl_.ess_ = p;
  }
  return _impl_.ess_;
}
inline ::commonmodule::ESS* ESSCapabilityProfile::mutable_ess() {
  ::commonmodule::ESS* _msg = _internal_mutable_ess();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityProfile.ess)
  return _msg;
}
inline void ESSCapabilityProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  if (ess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ess));
    if (message_arena != submessage_arena) {
      ess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }

  } else {

  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityProfile.ess)
}

// .essmodule.ESSCapability essCapability = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCapabilityProfile::_internal_has_esscapability() const {
  return this != internal_default_instance() && _impl_.esscapability_ != nullptr;
}
inline bool ESSCapabilityProfile::has_esscapability() const {
  return _internal_has_esscapability();
}
inline void ESSCapabilityProfile::clear_esscapability() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscapability_ != nullptr) {
    delete _impl_.esscapability_;
  }
  _impl_.esscapability_ = nullptr;
}
inline const ::essmodule::ESSCapability& ESSCapabilityProfile::_internal_esscapability() const {
  const ::essmodule::ESSCapability* p = _impl_.esscapability_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSCapability&>(
      ::essmodule::_ESSCapability_default_instance_);
}
inline const ::essmodule::ESSCapability& ESSCapabilityProfile::esscapability() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCapabilityProfile.essCapability)
  return _internal_esscapability();
}
inline void ESSCapabilityProfile::unsafe_arena_set_allocated_esscapability(
    ::essmodule::ESSCapability* esscapability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscapability_);
  }
  _impl_.esscapability_ = esscapability;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCapabilityProfile.essCapability)
}
inline ::essmodule::ESSCapability* ESSCapabilityProfile::release_esscapability() {
  
  ::essmodule::ESSCapability* temp = _impl_.esscapability_;
  _impl_.esscapability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSCapability* ESSCapabilityProfile::unsafe_arena_release_esscapability() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCapabilityProfile.essCapability)
  
  ::essmodule::ESSCapability* temp = _impl_.esscapability_;
  _impl_.esscapability_ = nullptr;
  return temp;
}
inline ::essmodule::ESSCapability* ESSCapabilityProfile::_internal_mutable_esscapability() {
  
  if (_impl_.esscapability_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSCapability>(GetArenaForAllocation());
    _impl_.esscapability_ = p;
  }
  return _impl_.esscapability_;
}
inline ::essmodule::ESSCapability* ESSCapabilityProfile::mutable_esscapability() {
  ::essmodule::ESSCapability* _msg = _internal_mutable_esscapability();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCapabilityProfile.essCapability)
  return _msg;
}
inline void ESSCapabilityProfile::set_allocated_esscapability(::essmodule::ESSCapability* esscapability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscapability_;
  }
  if (esscapability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscapability);
    if (message_arena != submessage_arena) {
      esscapability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscapability, submessage_arena);
    }

  } else {

  }
  _impl_.esscapability_ = esscapability;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCapabilityProfile.essCapability)
}

// -------------------------------------------------------------------

// FrequencyRegulation

// .google.protobuf.FloatValue frequencyDeadBandMinus = 1;
inline bool FrequencyRegulation::_internal_has_frequencydeadbandminus() const {
  return this != internal_default_instance() && _impl_.frequencydeadbandminus_ != nullptr;
}
inline bool FrequencyRegulation::has_frequencydeadbandminus() const {
  return _internal_has_frequencydeadbandminus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::_internal_frequencydeadbandminus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.frequencydeadbandminus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::frequencydeadbandminus() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
  return _internal_frequencydeadbandminus();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_frequencydeadbandminus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandminus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencydeadbandminus_);
  }
  _impl_.frequencydeadbandminus_ = frequencydeadbandminus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::release_frequencydeadbandminus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.frequencydeadbandminus_;
  _impl_.frequencydeadbandminus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::unsafe_arena_release_frequencydeadbandminus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.frequencydeadbandminus_;
  _impl_.frequencydeadbandminus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::_internal_mutable_frequencydeadbandminus() {
  
  if (_impl_.frequencydeadbandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.frequencydeadbandminus_ = p;
  }
  return _impl_.frequencydeadbandminus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::mutable_frequencydeadbandminus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_frequencydeadbandminus();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_frequencydeadbandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandminus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencydeadbandminus_);
  }
  if (frequencydeadbandminus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequencydeadbandminus));
    if (message_arena != submessage_arena) {
      frequencydeadbandminus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencydeadbandminus, submessage_arena);
    }

  } else {

  }
  _impl_.frequencydeadbandminus_ = frequencydeadbandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
}

// .google.protobuf.FloatValue frequencyDeadBandPlus = 2;
inline bool FrequencyRegulation::_internal_has_frequencydeadbandplus() const {
  return this != internal_default_instance() && _impl_.frequencydeadbandplus_ != nullptr;
}
inline bool FrequencyRegulation::has_frequencydeadbandplus() const {
  return _internal_has_frequencydeadbandplus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::_internal_frequencydeadbandplus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.frequencydeadbandplus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::frequencydeadbandplus() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
  return _internal_frequencydeadbandplus();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_frequencydeadbandplus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandplus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencydeadbandplus_);
  }
  _impl_.frequencydeadbandplus_ = frequencydeadbandplus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::release_frequencydeadbandplus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.frequencydeadbandplus_;
  _impl_.frequencydeadbandplus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::unsafe_arena_release_frequencydeadbandplus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.frequencydeadbandplus_;
  _impl_.frequencydeadbandplus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::_internal_mutable_frequencydeadbandplus() {
  
  if (_impl_.frequencydeadbandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.frequencydeadbandplus_ = p;
  }
  return _impl_.frequencydeadbandplus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::mutable_frequencydeadbandplus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_frequencydeadbandplus();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_frequencydeadbandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* frequencydeadbandplus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencydeadbandplus_);
  }
  if (frequencydeadbandplus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequencydeadbandplus));
    if (message_arena != submessage_arena) {
      frequencydeadbandplus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencydeadbandplus, submessage_arena);
    }

  } else {

  }
  _impl_.frequencydeadbandplus_ = frequencydeadbandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
}

// .google.protobuf.BoolValue frequencyRegulationCtl = 3;
inline bool FrequencyRegulation::_internal_has_frequencyregulationctl() const {
  return this != internal_default_instance() && _impl_.frequencyregulationctl_ != nullptr;
}
inline bool FrequencyRegulation::has_frequencyregulationctl() const {
  return _internal_has_frequencyregulationctl();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& FrequencyRegulation::_internal_frequencyregulationctl() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.frequencyregulationctl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& FrequencyRegulation::frequencyregulationctl() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencyRegulationCtl)
  return _internal_frequencyregulationctl();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_frequencyregulationctl(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* frequencyregulationctl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencyregulationctl_);
  }
  _impl_.frequencyregulationctl_ = frequencyregulationctl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.frequencyRegulationCtl)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FrequencyRegulation::release_frequencyregulationctl() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.frequencyregulationctl_;
  _impl_.frequencyregulationctl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FrequencyRegulation::unsafe_arena_release_frequencyregulationctl() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencyRegulationCtl)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.frequencyregulationctl_;
  _impl_.frequencyregulationctl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FrequencyRegulation::_internal_mutable_frequencyregulationctl() {
  
  if (_impl_.frequencyregulationctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.frequencyregulationctl_ = p;
  }
  return _impl_.frequencyregulationctl_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FrequencyRegulation::mutable_frequencyregulationctl() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_frequencyregulationctl();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencyRegulationCtl)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_frequencyregulationctl(::PROTOBUF_NAMESPACE_ID::BoolValue* frequencyregulationctl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencyregulationctl_);
  }
  if (frequencyregulationctl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequencyregulationctl));
    if (message_arena != submessage_arena) {
      frequencyregulationctl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencyregulationctl, submessage_arena);
    }

  } else {

  }
  _impl_.frequencyregulationctl_ = frequencyregulationctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencyRegulationCtl)
}

// .google.protobuf.FloatValue frequencySetPoint = 4;
inline bool FrequencyRegulation::_internal_has_frequencysetpoint() const {
  return this != internal_default_instance() && _impl_.frequencysetpoint_ != nullptr;
}
inline bool FrequencyRegulation::has_frequencysetpoint() const {
  return _internal_has_frequencysetpoint();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::_internal_frequencysetpoint() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.frequencysetpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::frequencysetpoint() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencySetPoint)
  return _internal_frequencysetpoint();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_frequencysetpoint(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* frequencysetpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpoint_);
  }
  _impl_.frequencysetpoint_ = frequencysetpoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.frequencySetPoint)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::release_frequencysetpoint() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.frequencysetpoint_;
  _impl_.frequencysetpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::unsafe_arena_release_frequencysetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencySetPoint)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.frequencysetpoint_;
  _impl_.frequencysetpoint_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::_internal_mutable_frequencysetpoint() {
  
  if (_impl_.frequencysetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.frequencysetpoint_ = p;
  }
  return _impl_.frequencysetpoint_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::mutable_frequencysetpoint() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_frequencysetpoint();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencySetPoint)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_frequencysetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* frequencysetpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpoint_);
  }
  if (frequencysetpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequencysetpoint));
    if (message_arena != submessage_arena) {
      frequencysetpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencysetpoint, submessage_arena);
    }

  } else {

  }
  _impl_.frequencysetpoint_ = frequencysetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencySetPoint)
}

// .google.protobuf.FloatValue gridFrequencyStableBandMinus = 5;
inline bool FrequencyRegulation::_internal_has_gridfrequencystablebandminus() const {
  return this != internal_default_instance() && _impl_.gridfrequencystablebandminus_ != nullptr;
}
inline bool FrequencyRegulation::has_gridfrequencystablebandminus() const {
  return _internal_has_gridfrequencystablebandminus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::_internal_gridfrequencystablebandminus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.gridfrequencystablebandminus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::gridfrequencystablebandminus() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
  return _internal_gridfrequencystablebandminus();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_gridfrequencystablebandminus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandminus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gridfrequencystablebandminus_);
  }
  _impl_.gridfrequencystablebandminus_ = gridfrequencystablebandminus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::release_gridfrequencystablebandminus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.gridfrequencystablebandminus_;
  _impl_.gridfrequencystablebandminus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::unsafe_arena_release_gridfrequencystablebandminus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.gridfrequencystablebandminus_;
  _impl_.gridfrequencystablebandminus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::_internal_mutable_gridfrequencystablebandminus() {
  
  if (_impl_.gridfrequencystablebandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.gridfrequencystablebandminus_ = p;
  }
  return _impl_.gridfrequencystablebandminus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::mutable_gridfrequencystablebandminus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_gridfrequencystablebandminus();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_gridfrequencystablebandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandminus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gridfrequencystablebandminus_);
  }
  if (gridfrequencystablebandminus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gridfrequencystablebandminus));
    if (message_arena != submessage_arena) {
      gridfrequencystablebandminus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gridfrequencystablebandminus, submessage_arena);
    }

  } else {

  }
  _impl_.gridfrequencystablebandminus_ = gridfrequencystablebandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
}

// .google.protobuf.FloatValue gridFrequencyStableBandPlus = 6;
inline bool FrequencyRegulation::_internal_has_gridfrequencystablebandplus() const {
  return this != internal_default_instance() && _impl_.gridfrequencystablebandplus_ != nullptr;
}
inline bool FrequencyRegulation::has_gridfrequencystablebandplus() const {
  return _internal_has_gridfrequencystablebandplus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::_internal_gridfrequencystablebandplus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.gridfrequencystablebandplus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::gridfrequencystablebandplus() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
  return _internal_gridfrequencystablebandplus();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_gridfrequencystablebandplus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandplus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gridfrequencystablebandplus_);
  }
  _impl_.gridfrequencystablebandplus_ = gridfrequencystablebandplus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::release_gridfrequencystablebandplus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.gridfrequencystablebandplus_;
  _impl_.gridfrequencystablebandplus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::unsafe_arena_release_gridfrequencystablebandplus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.gridfrequencystablebandplus_;
  _impl_.gridfrequencystablebandplus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::_internal_mutable_gridfrequencystablebandplus() {
  
  if (_impl_.gridfrequencystablebandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.gridfrequencystablebandplus_ = p;
  }
  return _impl_.gridfrequencystablebandplus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::mutable_gridfrequencystablebandplus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_gridfrequencystablebandplus();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_gridfrequencystablebandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* gridfrequencystablebandplus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gridfrequencystablebandplus_);
  }
  if (gridfrequencystablebandplus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gridfrequencystablebandplus));
    if (message_arena != submessage_arena) {
      gridfrequencystablebandplus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gridfrequencystablebandplus, submessage_arena);
    }

  } else {

  }
  _impl_.gridfrequencystablebandplus_ = gridfrequencystablebandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
}

// .google.protobuf.FloatValue overFrequencyDroop = 7;
inline bool FrequencyRegulation::_internal_has_overfrequencydroop() const {
  return this != internal_default_instance() && _impl_.overfrequencydroop_ != nullptr;
}
inline bool FrequencyRegulation::has_overfrequencydroop() const {
  return _internal_has_overfrequencydroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::_internal_overfrequencydroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.overfrequencydroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::overfrequencydroop() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.overFrequencyDroop)
  return _internal_overfrequencydroop();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_overfrequencydroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* overfrequencydroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overfrequencydroop_);
  }
  _impl_.overfrequencydroop_ = overfrequencydroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.overFrequencyDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::release_overfrequencydroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.overfrequencydroop_;
  _impl_.overfrequencydroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::unsafe_arena_release_overfrequencydroop() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.overFrequencyDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.overfrequencydroop_;
  _impl_.overfrequencydroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::_internal_mutable_overfrequencydroop() {
  
  if (_impl_.overfrequencydroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.overfrequencydroop_ = p;
  }
  return _impl_.overfrequencydroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::mutable_overfrequencydroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_overfrequencydroop();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.overFrequencyDroop)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_overfrequencydroop(::PROTOBUF_NAMESPACE_ID::FloatValue* overfrequencydroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overfrequencydroop_);
  }
  if (overfrequencydroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(overfrequencydroop));
    if (message_arena != submessage_arena) {
      overfrequencydroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overfrequencydroop, submessage_arena);
    }

  } else {

  }
  _impl_.overfrequencydroop_ = overfrequencydroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.overFrequencyDroop)
}

// .google.protobuf.FloatValue underFrequencyDroop = 8;
inline bool FrequencyRegulation::_internal_has_underfrequencydroop() const {
  return this != internal_default_instance() && _impl_.underfrequencydroop_ != nullptr;
}
inline bool FrequencyRegulation::has_underfrequencydroop() const {
  return _internal_has_underfrequencydroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::_internal_underfrequencydroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.underfrequencydroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& FrequencyRegulation::underfrequencydroop() const {
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.underFrequencyDroop)
  return _internal_underfrequencydroop();
}
inline void FrequencyRegulation::unsafe_arena_set_allocated_underfrequencydroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* underfrequencydroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.underfrequencydroop_);
  }
  _impl_.underfrequencydroop_ = underfrequencydroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.FrequencyRegulation.underFrequencyDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::release_underfrequencydroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.underfrequencydroop_;
  _impl_.underfrequencydroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::unsafe_arena_release_underfrequencydroop() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.underFrequencyDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.underfrequencydroop_;
  _impl_.underfrequencydroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::_internal_mutable_underfrequencydroop() {
  
  if (_impl_.underfrequencydroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.underfrequencydroop_ = p;
  }
  return _impl_.underfrequencydroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* FrequencyRegulation::mutable_underfrequencydroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_underfrequencydroop();
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.underFrequencyDroop)
  return _msg;
}
inline void FrequencyRegulation::set_allocated_underfrequencydroop(::PROTOBUF_NAMESPACE_ID::FloatValue* underfrequencydroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.underfrequencydroop_);
  }
  if (underfrequencydroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(underfrequencydroop));
    if (message_arena != submessage_arena) {
      underfrequencydroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, underfrequencydroop, submessage_arena);
    }

  } else {

  }
  _impl_.underfrequencydroop_ = underfrequencydroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.underFrequencyDroop)
}

// -------------------------------------------------------------------

// PeakShaving

// .google.protobuf.FloatValue baseShavingLimit = 1;
inline bool PeakShaving::_internal_has_baseshavinglimit() const {
  return this != internal_default_instance() && _impl_.baseshavinglimit_ != nullptr;
}
inline bool PeakShaving::has_baseshavinglimit() const {
  return _internal_has_baseshavinglimit();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::_internal_baseshavinglimit() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.baseshavinglimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::baseshavinglimit() const {
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.baseShavingLimit)
  return _internal_baseshavinglimit();
}
inline void PeakShaving::unsafe_arena_set_allocated_baseshavinglimit(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* baseshavinglimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.baseshavinglimit_);
  }
  _impl_.baseshavinglimit_ = baseshavinglimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.PeakShaving.baseShavingLimit)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::release_baseshavinglimit() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.baseshavinglimit_;
  _impl_.baseshavinglimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::unsafe_arena_release_baseshavinglimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.baseShavingLimit)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.baseshavinglimit_;
  _impl_.baseshavinglimit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::_internal_mutable_baseshavinglimit() {
  
  if (_impl_.baseshavinglimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.baseshavinglimit_ = p;
  }
  return _impl_.baseshavinglimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::mutable_baseshavinglimit() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_baseshavinglimit();
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.baseShavingLimit)
  return _msg;
}
inline void PeakShaving::set_allocated_baseshavinglimit(::PROTOBUF_NAMESPACE_ID::FloatValue* baseshavinglimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.baseshavinglimit_);
  }
  if (baseshavinglimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseshavinglimit));
    if (message_arena != submessage_arena) {
      baseshavinglimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseshavinglimit, submessage_arena);
    }

  } else {

  }
  _impl_.baseshavinglimit_ = baseshavinglimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.baseShavingLimit)
}

// .google.protobuf.BoolValue peakShavingCtl = 2;
inline bool PeakShaving::_internal_has_peakshavingctl() const {
  return this != internal_default_instance() && _impl_.peakshavingctl_ != nullptr;
}
inline bool PeakShaving::has_peakshavingctl() const {
  return _internal_has_peakshavingctl();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& PeakShaving::_internal_peakshavingctl() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.peakshavingctl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& PeakShaving::peakshavingctl() const {
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.peakShavingCtl)
  return _internal_peakshavingctl();
}
inline void PeakShaving::unsafe_arena_set_allocated_peakshavingctl(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* peakshavingctl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peakshavingctl_);
  }
  _impl_.peakshavingctl_ = peakshavingctl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.PeakShaving.peakShavingCtl)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* PeakShaving::release_peakshavingctl() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.peakshavingctl_;
  _impl_.peakshavingctl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* PeakShaving::unsafe_arena_release_peakshavingctl() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.peakShavingCtl)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.peakshavingctl_;
  _impl_.peakshavingctl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* PeakShaving::_internal_mutable_peakshavingctl() {
  
  if (_impl_.peakshavingctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.peakshavingctl_ = p;
  }
  return _impl_.peakshavingctl_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* PeakShaving::mutable_peakshavingctl() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_peakshavingctl();
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.peakShavingCtl)
  return _msg;
}
inline void PeakShaving::set_allocated_peakshavingctl(::PROTOBUF_NAMESPACE_ID::BoolValue* peakshavingctl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peakshavingctl_);
  }
  if (peakshavingctl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peakshavingctl));
    if (message_arena != submessage_arena) {
      peakshavingctl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peakshavingctl, submessage_arena);
    }

  } else {

  }
  _impl_.peakshavingctl_ = peakshavingctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.peakShavingCtl)
}

// .google.protobuf.FloatValue peakShavingLimit = 3;
inline bool PeakShaving::_internal_has_peakshavinglimit() const {
  return this != internal_default_instance() && _impl_.peakshavinglimit_ != nullptr;
}
inline bool PeakShaving::has_peakshavinglimit() const {
  return _internal_has_peakshavinglimit();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::_internal_peakshavinglimit() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.peakshavinglimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::peakshavinglimit() const {
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.peakShavingLimit)
  return _internal_peakshavinglimit();
}
inline void PeakShaving::unsafe_arena_set_allocated_peakshavinglimit(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* peakshavinglimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peakshavinglimit_);
  }
  _impl_.peakshavinglimit_ = peakshavinglimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.PeakShaving.peakShavingLimit)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::release_peakshavinglimit() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.peakshavinglimit_;
  _impl_.peakshavinglimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::unsafe_arena_release_peakshavinglimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.peakShavingLimit)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.peakshavinglimit_;
  _impl_.peakshavinglimit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::_internal_mutable_peakshavinglimit() {
  
  if (_impl_.peakshavinglimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.peakshavinglimit_ = p;
  }
  return _impl_.peakshavinglimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::mutable_peakshavinglimit() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_peakshavinglimit();
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.peakShavingLimit)
  return _msg;
}
inline void PeakShaving::set_allocated_peakshavinglimit(::PROTOBUF_NAMESPACE_ID::FloatValue* peakshavinglimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peakshavinglimit_);
  }
  if (peakshavinglimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peakshavinglimit));
    if (message_arena != submessage_arena) {
      peakshavinglimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peakshavinglimit, submessage_arena);
    }

  } else {

  }
  _impl_.peakshavinglimit_ = peakshavinglimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.peakShavingLimit)
}

// .google.protobuf.FloatValue socManagementAllowedHighLimit = 4;
inline bool PeakShaving::_internal_has_socmanagementallowedhighlimit() const {
  return this != internal_default_instance() && _impl_.socmanagementallowedhighlimit_ != nullptr;
}
inline bool PeakShaving::has_socmanagementallowedhighlimit() const {
  return _internal_has_socmanagementallowedhighlimit();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::_internal_socmanagementallowedhighlimit() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.socmanagementallowedhighlimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::socmanagementallowedhighlimit() const {
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.socManagementAllowedHighLimit)
  return _internal_socmanagementallowedhighlimit();
}
inline void PeakShaving::unsafe_arena_set_allocated_socmanagementallowedhighlimit(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedhighlimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socmanagementallowedhighlimit_);
  }
  _impl_.socmanagementallowedhighlimit_ = socmanagementallowedhighlimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.PeakShaving.socManagementAllowedHighLimit)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::release_socmanagementallowedhighlimit() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socmanagementallowedhighlimit_;
  _impl_.socmanagementallowedhighlimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::unsafe_arena_release_socmanagementallowedhighlimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.socManagementAllowedHighLimit)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socmanagementallowedhighlimit_;
  _impl_.socmanagementallowedhighlimit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::_internal_mutable_socmanagementallowedhighlimit() {
  
  if (_impl_.socmanagementallowedhighlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.socmanagementallowedhighlimit_ = p;
  }
  return _impl_.socmanagementallowedhighlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::mutable_socmanagementallowedhighlimit() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_socmanagementallowedhighlimit();
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.socManagementAllowedHighLimit)
  return _msg;
}
inline void PeakShaving::set_allocated_socmanagementallowedhighlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedhighlimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socmanagementallowedhighlimit_);
  }
  if (socmanagementallowedhighlimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(socmanagementallowedhighlimit));
    if (message_arena != submessage_arena) {
      socmanagementallowedhighlimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socmanagementallowedhighlimit, submessage_arena);
    }

  } else {

  }
  _impl_.socmanagementallowedhighlimit_ = socmanagementallowedhighlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.socManagementAllowedHighLimit)
}

// .google.protobuf.FloatValue socManagementAllowedLowLimit = 5;
inline bool PeakShaving::_internal_has_socmanagementallowedlowlimit() const {
  return this != internal_default_instance() && _impl_.socmanagementallowedlowlimit_ != nullptr;
}
inline bool PeakShaving::has_socmanagementallowedlowlimit() const {
  return _internal_has_socmanagementallowedlowlimit();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::_internal_socmanagementallowedlowlimit() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.socmanagementallowedlowlimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& PeakShaving::socmanagementallowedlowlimit() const {
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.socManagementAllowedLowLimit)
  return _internal_socmanagementallowedlowlimit();
}
inline void PeakShaving::unsafe_arena_set_allocated_socmanagementallowedlowlimit(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedlowlimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socmanagementallowedlowlimit_);
  }
  _impl_.socmanagementallowedlowlimit_ = socmanagementallowedlowlimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.PeakShaving.socManagementAllowedLowLimit)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::release_socmanagementallowedlowlimit() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socmanagementallowedlowlimit_;
  _impl_.socmanagementallowedlowlimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::unsafe_arena_release_socmanagementallowedlowlimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.socManagementAllowedLowLimit)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socmanagementallowedlowlimit_;
  _impl_.socmanagementallowedlowlimit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::_internal_mutable_socmanagementallowedlowlimit() {
  
  if (_impl_.socmanagementallowedlowlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.socmanagementallowedlowlimit_ = p;
  }
  return _impl_.socmanagementallowedlowlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* PeakShaving::mutable_socmanagementallowedlowlimit() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_socmanagementallowedlowlimit();
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.socManagementAllowedLowLimit)
  return _msg;
}
inline void PeakShaving::set_allocated_socmanagementallowedlowlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* socmanagementallowedlowlimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socmanagementallowedlowlimit_);
  }
  if (socmanagementallowedlowlimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(socmanagementallowedlowlimit));
    if (message_arena != submessage_arena) {
      socmanagementallowedlowlimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socmanagementallowedlowlimit, submessage_arena);
    }

  } else {

  }
  _impl_.socmanagementallowedlowlimit_ = socmanagementallowedlowlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.socManagementAllowedLowLimit)
}

// -------------------------------------------------------------------

// SocLimit

// .google.protobuf.FloatValue socHighLimit = 1;
inline bool SocLimit::_internal_has_sochighlimit() const {
  return this != internal_default_instance() && _impl_.sochighlimit_ != nullptr;
}
inline bool SocLimit::has_sochighlimit() const {
  return _internal_has_sochighlimit();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::_internal_sochighlimit() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.sochighlimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::sochighlimit() const {
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socHighLimit)
  return _internal_sochighlimit();
}
inline void SocLimit::unsafe_arena_set_allocated_sochighlimit(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sochighlimit_);
  }
  _impl_.sochighlimit_ = sochighlimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SocLimit.socHighLimit)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::release_sochighlimit() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.sochighlimit_;
  _impl_.sochighlimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::unsafe_arena_release_sochighlimit() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socHighLimit)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.sochighlimit_;
  _impl_.sochighlimit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::_internal_mutable_sochighlimit() {
  
  if (_impl_.sochighlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.sochighlimit_ = p;
  }
  return _impl_.sochighlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::mutable_sochighlimit() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_sochighlimit();
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socHighLimit)
  return _msg;
}
inline void SocLimit::set_allocated_sochighlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sochighlimit_);
  }
  if (sochighlimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sochighlimit));
    if (message_arena != submessage_arena) {
      sochighlimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sochighlimit, submessage_arena);
    }

  } else {

  }
  _impl_.sochighlimit_ = sochighlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socHighLimit)
}

// .google.protobuf.FloatValue socHighLimitHysteresis = 2;
inline bool SocLimit::_internal_has_sochighlimithysteresis() const {
  return this != internal_default_instance() && _impl_.sochighlimithysteresis_ != nullptr;
}
inline bool SocLimit::has_sochighlimithysteresis() const {
  return _internal_has_sochighlimithysteresis();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::_internal_sochighlimithysteresis() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.sochighlimithysteresis_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::sochighlimithysteresis() const {
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socHighLimitHysteresis)
  return _internal_sochighlimithysteresis();
}
inline void SocLimit::unsafe_arena_set_allocated_sochighlimithysteresis(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimithysteresis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sochighlimithysteresis_);
  }
  _impl_.sochighlimithysteresis_ = sochighlimithysteresis;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SocLimit.socHighLimitHysteresis)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::release_sochighlimithysteresis() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.sochighlimithysteresis_;
  _impl_.sochighlimithysteresis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::unsafe_arena_release_sochighlimithysteresis() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socHighLimitHysteresis)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.sochighlimithysteresis_;
  _impl_.sochighlimithysteresis_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::_internal_mutable_sochighlimithysteresis() {
  
  if (_impl_.sochighlimithysteresis_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.sochighlimithysteresis_ = p;
  }
  return _impl_.sochighlimithysteresis_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::mutable_sochighlimithysteresis() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_sochighlimithysteresis();
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socHighLimitHysteresis)
  return _msg;
}
inline void SocLimit::set_allocated_sochighlimithysteresis(::PROTOBUF_NAMESPACE_ID::FloatValue* sochighlimithysteresis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sochighlimithysteresis_);
  }
  if (sochighlimithysteresis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sochighlimithysteresis));
    if (message_arena != submessage_arena) {
      sochighlimithysteresis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sochighlimithysteresis, submessage_arena);
    }

  } else {

  }
  _impl_.sochighlimithysteresis_ = sochighlimithysteresis;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socHighLimitHysteresis)
}

// .google.protobuf.BoolValue socLimitCtl = 3;
inline bool SocLimit::_internal_has_soclimitctl() const {
  return this != internal_default_instance() && _impl_.soclimitctl_ != nullptr;
}
inline bool SocLimit::has_soclimitctl() const {
  return _internal_has_soclimitctl();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SocLimit::_internal_soclimitctl() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.soclimitctl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SocLimit::soclimitctl() const {
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socLimitCtl)
  return _internal_soclimitctl();
}
inline void SocLimit::unsafe_arena_set_allocated_soclimitctl(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* soclimitctl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soclimitctl_);
  }
  _impl_.soclimitctl_ = soclimitctl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SocLimit.socLimitCtl)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SocLimit::release_soclimitctl() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.soclimitctl_;
  _impl_.soclimitctl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SocLimit::unsafe_arena_release_soclimitctl() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socLimitCtl)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.soclimitctl_;
  _impl_.soclimitctl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SocLimit::_internal_mutable_soclimitctl() {
  
  if (_impl_.soclimitctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.soclimitctl_ = p;
  }
  return _impl_.soclimitctl_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SocLimit::mutable_soclimitctl() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_soclimitctl();
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socLimitCtl)
  return _msg;
}
inline void SocLimit::set_allocated_soclimitctl(::PROTOBUF_NAMESPACE_ID::BoolValue* soclimitctl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soclimitctl_);
  }
  if (soclimitctl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soclimitctl));
    if (message_arena != submessage_arena) {
      soclimitctl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soclimitctl, submessage_arena);
    }

  } else {

  }
  _impl_.soclimitctl_ = soclimitctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socLimitCtl)
}

// .google.protobuf.FloatValue socLowLimit = 4;
inline bool SocLimit::_internal_has_soclowlimit() const {
  return this != internal_default_instance() && _impl_.soclowlimit_ != nullptr;
}
inline bool SocLimit::has_soclowlimit() const {
  return _internal_has_soclowlimit();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::_internal_soclowlimit() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.soclowlimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::soclowlimit() const {
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socLowLimit)
  return _internal_soclowlimit();
}
inline void SocLimit::unsafe_arena_set_allocated_soclowlimit(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soclowlimit_);
  }
  _impl_.soclowlimit_ = soclowlimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SocLimit.socLowLimit)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::release_soclowlimit() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.soclowlimit_;
  _impl_.soclowlimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::unsafe_arena_release_soclowlimit() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socLowLimit)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.soclowlimit_;
  _impl_.soclowlimit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::_internal_mutable_soclowlimit() {
  
  if (_impl_.soclowlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.soclowlimit_ = p;
  }
  return _impl_.soclowlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::mutable_soclowlimit() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_soclowlimit();
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socLowLimit)
  return _msg;
}
inline void SocLimit::set_allocated_soclowlimit(::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soclowlimit_);
  }
  if (soclowlimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soclowlimit));
    if (message_arena != submessage_arena) {
      soclowlimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soclowlimit, submessage_arena);
    }

  } else {

  }
  _impl_.soclowlimit_ = soclowlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socLowLimit)
}

// .google.protobuf.FloatValue socLowLimitHysteresis = 5;
inline bool SocLimit::_internal_has_soclowlimithysteresis() const {
  return this != internal_default_instance() && _impl_.soclowlimithysteresis_ != nullptr;
}
inline bool SocLimit::has_soclowlimithysteresis() const {
  return _internal_has_soclowlimithysteresis();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::_internal_soclowlimithysteresis() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.soclowlimithysteresis_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SocLimit::soclowlimithysteresis() const {
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socLowLimitHysteresis)
  return _internal_soclowlimithysteresis();
}
inline void SocLimit::unsafe_arena_set_allocated_soclowlimithysteresis(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimithysteresis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soclowlimithysteresis_);
  }
  _impl_.soclowlimithysteresis_ = soclowlimithysteresis;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SocLimit.socLowLimitHysteresis)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::release_soclowlimithysteresis() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.soclowlimithysteresis_;
  _impl_.soclowlimithysteresis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::unsafe_arena_release_soclowlimithysteresis() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socLowLimitHysteresis)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.soclowlimithysteresis_;
  _impl_.soclowlimithysteresis_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::_internal_mutable_soclowlimithysteresis() {
  
  if (_impl_.soclowlimithysteresis_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.soclowlimithysteresis_ = p;
  }
  return _impl_.soclowlimithysteresis_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SocLimit::mutable_soclowlimithysteresis() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_soclowlimithysteresis();
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socLowLimitHysteresis)
  return _msg;
}
inline void SocLimit::set_allocated_soclowlimithysteresis(::PROTOBUF_NAMESPACE_ID::FloatValue* soclowlimithysteresis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soclowlimithysteresis_);
  }
  if (soclowlimithysteresis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soclowlimithysteresis));
    if (message_arena != submessage_arena) {
      soclowlimithysteresis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soclowlimithysteresis, submessage_arena);
    }

  } else {

  }
  _impl_.soclowlimithysteresis_ = soclowlimithysteresis;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socLowLimitHysteresis)
}

// -------------------------------------------------------------------

// SOCManagement

// .google.protobuf.FloatValue socDeadBandMinus = 1;
inline bool SOCManagement::_internal_has_socdeadbandminus() const {
  return this != internal_default_instance() && _impl_.socdeadbandminus_ != nullptr;
}
inline bool SOCManagement::has_socdeadbandminus() const {
  return _internal_has_socdeadbandminus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::_internal_socdeadbandminus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.socdeadbandminus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::socdeadbandminus() const {
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socDeadBandMinus)
  return _internal_socdeadbandminus();
}
inline void SOCManagement::unsafe_arena_set_allocated_socdeadbandminus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandminus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socdeadbandminus_);
  }
  _impl_.socdeadbandminus_ = socdeadbandminus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SOCManagement.socDeadBandMinus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::release_socdeadbandminus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socdeadbandminus_;
  _impl_.socdeadbandminus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::unsafe_arena_release_socdeadbandminus() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socDeadBandMinus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socdeadbandminus_;
  _impl_.socdeadbandminus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::_internal_mutable_socdeadbandminus() {
  
  if (_impl_.socdeadbandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.socdeadbandminus_ = p;
  }
  return _impl_.socdeadbandminus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::mutable_socdeadbandminus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_socdeadbandminus();
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socDeadBandMinus)
  return _msg;
}
inline void SOCManagement::set_allocated_socdeadbandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandminus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socdeadbandminus_);
  }
  if (socdeadbandminus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(socdeadbandminus));
    if (message_arena != submessage_arena) {
      socdeadbandminus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socdeadbandminus, submessage_arena);
    }

  } else {

  }
  _impl_.socdeadbandminus_ = socdeadbandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socDeadBandMinus)
}

// .google.protobuf.FloatValue socDeadBandPlus = 2;
inline bool SOCManagement::_internal_has_socdeadbandplus() const {
  return this != internal_default_instance() && _impl_.socdeadbandplus_ != nullptr;
}
inline bool SOCManagement::has_socdeadbandplus() const {
  return _internal_has_socdeadbandplus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::_internal_socdeadbandplus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.socdeadbandplus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::socdeadbandplus() const {
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socDeadBandPlus)
  return _internal_socdeadbandplus();
}
inline void SOCManagement::unsafe_arena_set_allocated_socdeadbandplus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandplus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socdeadbandplus_);
  }
  _impl_.socdeadbandplus_ = socdeadbandplus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SOCManagement.socDeadBandPlus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::release_socdeadbandplus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socdeadbandplus_;
  _impl_.socdeadbandplus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::unsafe_arena_release_socdeadbandplus() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socDeadBandPlus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socdeadbandplus_;
  _impl_.socdeadbandplus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::_internal_mutable_socdeadbandplus() {
  
  if (_impl_.socdeadbandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.socdeadbandplus_ = p;
  }
  return _impl_.socdeadbandplus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::mutable_socdeadbandplus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_socdeadbandplus();
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socDeadBandPlus)
  return _msg;
}
inline void SOCManagement::set_allocated_socdeadbandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* socdeadbandplus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socdeadbandplus_);
  }
  if (socdeadbandplus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(socdeadbandplus));
    if (message_arena != submessage_arena) {
      socdeadbandplus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socdeadbandplus, submessage_arena);
    }

  } else {

  }
  _impl_.socdeadbandplus_ = socdeadbandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socDeadBandPlus)
}

// .google.protobuf.BoolValue socManagementCtl = 3;
inline bool SOCManagement::_internal_has_socmanagementctl() const {
  return this != internal_default_instance() && _impl_.socmanagementctl_ != nullptr;
}
inline bool SOCManagement::has_socmanagementctl() const {
  return _internal_has_socmanagementctl();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SOCManagement::_internal_socmanagementctl() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.socmanagementctl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& SOCManagement::socmanagementctl() const {
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socManagementCtl)
  return _internal_socmanagementctl();
}
inline void SOCManagement::unsafe_arena_set_allocated_socmanagementctl(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* socmanagementctl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socmanagementctl_);
  }
  _impl_.socmanagementctl_ = socmanagementctl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SOCManagement.socManagementCtl)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SOCManagement::release_socmanagementctl() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.socmanagementctl_;
  _impl_.socmanagementctl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SOCManagement::unsafe_arena_release_socmanagementctl() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socManagementCtl)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.socmanagementctl_;
  _impl_.socmanagementctl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SOCManagement::_internal_mutable_socmanagementctl() {
  
  if (_impl_.socmanagementctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.socmanagementctl_ = p;
  }
  return _impl_.socmanagementctl_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* SOCManagement::mutable_socmanagementctl() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_socmanagementctl();
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socManagementCtl)
  return _msg;
}
inline void SOCManagement::set_allocated_socmanagementctl(::PROTOBUF_NAMESPACE_ID::BoolValue* socmanagementctl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socmanagementctl_);
  }
  if (socmanagementctl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(socmanagementctl));
    if (message_arena != submessage_arena) {
      socmanagementctl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socmanagementctl, submessage_arena);
    }

  } else {

  }
  _impl_.socmanagementctl_ = socmanagementctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socManagementCtl)
}

// .google.protobuf.FloatValue socPowerSetPoint = 4;
inline bool SOCManagement::_internal_has_socpowersetpoint() const {
  return this != internal_default_instance() && _impl_.socpowersetpoint_ != nullptr;
}
inline bool SOCManagement::has_socpowersetpoint() const {
  return _internal_has_socpowersetpoint();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::_internal_socpowersetpoint() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.socpowersetpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::socpowersetpoint() const {
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socPowerSetPoint)
  return _internal_socpowersetpoint();
}
inline void SOCManagement::unsafe_arena_set_allocated_socpowersetpoint(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socpowersetpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socpowersetpoint_);
  }
  _impl_.socpowersetpoint_ = socpowersetpoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SOCManagement.socPowerSetPoint)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::release_socpowersetpoint() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socpowersetpoint_;
  _impl_.socpowersetpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::unsafe_arena_release_socpowersetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socPowerSetPoint)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socpowersetpoint_;
  _impl_.socpowersetpoint_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::_internal_mutable_socpowersetpoint() {
  
  if (_impl_.socpowersetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.socpowersetpoint_ = p;
  }
  return _impl_.socpowersetpoint_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::mutable_socpowersetpoint() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_socpowersetpoint();
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socPowerSetPoint)
  return _msg;
}
inline void SOCManagement::set_allocated_socpowersetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* socpowersetpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socpowersetpoint_);
  }
  if (socpowersetpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(socpowersetpoint));
    if (message_arena != submessage_arena) {
      socpowersetpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socpowersetpoint, submessage_arena);
    }

  } else {

  }
  _impl_.socpowersetpoint_ = socpowersetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socPowerSetPoint)
}

// .google.protobuf.FloatValue socSetPoint = 5;
inline bool SOCManagement::_internal_has_socsetpoint() const {
  return this != internal_default_instance() && _impl_.socsetpoint_ != nullptr;
}
inline bool SOCManagement::has_socsetpoint() const {
  return _internal_has_socsetpoint();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::_internal_socsetpoint() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.socsetpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& SOCManagement::socsetpoint() const {
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socSetPoint)
  return _internal_socsetpoint();
}
inline void SOCManagement::unsafe_arena_set_allocated_socsetpoint(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* socsetpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socsetpoint_);
  }
  _impl_.socsetpoint_ = socsetpoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.SOCManagement.socSetPoint)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::release_socsetpoint() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socsetpoint_;
  _impl_.socsetpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::unsafe_arena_release_socsetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socSetPoint)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.socsetpoint_;
  _impl_.socsetpoint_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::_internal_mutable_socsetpoint() {
  
  if (_impl_.socsetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.socsetpoint_ = p;
  }
  return _impl_.socsetpoint_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* SOCManagement::mutable_socsetpoint() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_socsetpoint();
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socSetPoint)
  return _msg;
}
inline void SOCManagement::set_allocated_socsetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* socsetpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socsetpoint_);
  }
  if (socsetpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(socsetpoint));
    if (message_arena != submessage_arena) {
      socsetpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socsetpoint, submessage_arena);
    }

  } else {

  }
  _impl_.socsetpoint_ = socsetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socSetPoint)
}

// -------------------------------------------------------------------

// VoltageRegulation

// .google.protobuf.FloatValue overVoltageDroop = 1;
inline bool VoltageRegulation::_internal_has_overvoltagedroop() const {
  return this != internal_default_instance() && _impl_.overvoltagedroop_ != nullptr;
}
inline bool VoltageRegulation::has_overvoltagedroop() const {
  return _internal_has_overvoltagedroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::_internal_overvoltagedroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.overvoltagedroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::overvoltagedroop() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.overVoltageDroop)
  return _internal_overvoltagedroop();
}
inline void VoltageRegulation::unsafe_arena_set_allocated_overvoltagedroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* overvoltagedroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overvoltagedroop_);
  }
  _impl_.overvoltagedroop_ = overvoltagedroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltageRegulation.overVoltageDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::release_overvoltagedroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.overvoltagedroop_;
  _impl_.overvoltagedroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::unsafe_arena_release_overvoltagedroop() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.overVoltageDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.overvoltagedroop_;
  _impl_.overvoltagedroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::_internal_mutable_overvoltagedroop() {
  
  if (_impl_.overvoltagedroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.overvoltagedroop_ = p;
  }
  return _impl_.overvoltagedroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::mutable_overvoltagedroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_overvoltagedroop();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.overVoltageDroop)
  return _msg;
}
inline void VoltageRegulation::set_allocated_overvoltagedroop(::PROTOBUF_NAMESPACE_ID::FloatValue* overvoltagedroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overvoltagedroop_);
  }
  if (overvoltagedroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(overvoltagedroop));
    if (message_arena != submessage_arena) {
      overvoltagedroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overvoltagedroop, submessage_arena);
    }

  } else {

  }
  _impl_.overvoltagedroop_ = overvoltagedroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.overVoltageDroop)
}

// .google.protobuf.FloatValue underVoltageDroop = 2;
inline bool VoltageRegulation::_internal_has_undervoltagedroop() const {
  return this != internal_default_instance() && _impl_.undervoltagedroop_ != nullptr;
}
inline bool VoltageRegulation::has_undervoltagedroop() const {
  return _internal_has_undervoltagedroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::_internal_undervoltagedroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.undervoltagedroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::undervoltagedroop() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.underVoltageDroop)
  return _internal_undervoltagedroop();
}
inline void VoltageRegulation::unsafe_arena_set_allocated_undervoltagedroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* undervoltagedroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undervoltagedroop_);
  }
  _impl_.undervoltagedroop_ = undervoltagedroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltageRegulation.underVoltageDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::release_undervoltagedroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.undervoltagedroop_;
  _impl_.undervoltagedroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::unsafe_arena_release_undervoltagedroop() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.underVoltageDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.undervoltagedroop_;
  _impl_.undervoltagedroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::_internal_mutable_undervoltagedroop() {
  
  if (_impl_.undervoltagedroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.undervoltagedroop_ = p;
  }
  return _impl_.undervoltagedroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::mutable_undervoltagedroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_undervoltagedroop();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.underVoltageDroop)
  return _msg;
}
inline void VoltageRegulation::set_allocated_undervoltagedroop(::PROTOBUF_NAMESPACE_ID::FloatValue* undervoltagedroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undervoltagedroop_);
  }
  if (undervoltagedroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undervoltagedroop));
    if (message_arena != submessage_arena) {
      undervoltagedroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undervoltagedroop, submessage_arena);
    }

  } else {

  }
  _impl_.undervoltagedroop_ = undervoltagedroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.underVoltageDroop)
}

// .google.protobuf.FloatValue voltageDeadBandMinus = 3;
inline bool VoltageRegulation::_internal_has_voltagedeadbandminus() const {
  return this != internal_default_instance() && _impl_.voltagedeadbandminus_ != nullptr;
}
inline bool VoltageRegulation::has_voltagedeadbandminus() const {
  return _internal_has_voltagedeadbandminus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::_internal_voltagedeadbandminus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.voltagedeadbandminus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::voltagedeadbandminus() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.voltageDeadBandMinus)
  return _internal_voltagedeadbandminus();
}
inline void VoltageRegulation::unsafe_arena_set_allocated_voltagedeadbandminus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandminus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagedeadbandminus_);
  }
  _impl_.voltagedeadbandminus_ = voltagedeadbandminus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltageRegulation.voltageDeadBandMinus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::release_voltagedeadbandminus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.voltagedeadbandminus_;
  _impl_.voltagedeadbandminus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::unsafe_arena_release_voltagedeadbandminus() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.voltageDeadBandMinus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.voltagedeadbandminus_;
  _impl_.voltagedeadbandminus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::_internal_mutable_voltagedeadbandminus() {
  
  if (_impl_.voltagedeadbandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.voltagedeadbandminus_ = p;
  }
  return _impl_.voltagedeadbandminus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::mutable_voltagedeadbandminus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_voltagedeadbandminus();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.voltageDeadBandMinus)
  return _msg;
}
inline void VoltageRegulation::set_allocated_voltagedeadbandminus(::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandminus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagedeadbandminus_);
  }
  if (voltagedeadbandminus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagedeadbandminus));
    if (message_arena != submessage_arena) {
      voltagedeadbandminus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagedeadbandminus, submessage_arena);
    }

  } else {

  }
  _impl_.voltagedeadbandminus_ = voltagedeadbandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.voltageDeadBandMinus)
}

// .google.protobuf.FloatValue voltageDeadBandPlus = 4;
inline bool VoltageRegulation::_internal_has_voltagedeadbandplus() const {
  return this != internal_default_instance() && _impl_.voltagedeadbandplus_ != nullptr;
}
inline bool VoltageRegulation::has_voltagedeadbandplus() const {
  return _internal_has_voltagedeadbandplus();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::_internal_voltagedeadbandplus() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.voltagedeadbandplus_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::voltagedeadbandplus() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.voltageDeadBandPlus)
  return _internal_voltagedeadbandplus();
}
inline void VoltageRegulation::unsafe_arena_set_allocated_voltagedeadbandplus(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandplus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagedeadbandplus_);
  }
  _impl_.voltagedeadbandplus_ = voltagedeadbandplus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltageRegulation.voltageDeadBandPlus)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::release_voltagedeadbandplus() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.voltagedeadbandplus_;
  _impl_.voltagedeadbandplus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::unsafe_arena_release_voltagedeadbandplus() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.voltageDeadBandPlus)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.voltagedeadbandplus_;
  _impl_.voltagedeadbandplus_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::_internal_mutable_voltagedeadbandplus() {
  
  if (_impl_.voltagedeadbandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.voltagedeadbandplus_ = p;
  }
  return _impl_.voltagedeadbandplus_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::mutable_voltagedeadbandplus() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_voltagedeadbandplus();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.voltageDeadBandPlus)
  return _msg;
}
inline void VoltageRegulation::set_allocated_voltagedeadbandplus(::PROTOBUF_NAMESPACE_ID::FloatValue* voltagedeadbandplus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagedeadbandplus_);
  }
  if (voltagedeadbandplus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagedeadbandplus));
    if (message_arena != submessage_arena) {
      voltagedeadbandplus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagedeadbandplus, submessage_arena);
    }

  } else {

  }
  _impl_.voltagedeadbandplus_ = voltagedeadbandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.voltageDeadBandPlus)
}

// .google.protobuf.FloatValue voltageSetPoint = 5;
inline bool VoltageRegulation::_internal_has_voltagesetpoint() const {
  return this != internal_default_instance() && _impl_.voltagesetpoint_ != nullptr;
}
inline bool VoltageRegulation::has_voltagesetpoint() const {
  return _internal_has_voltagesetpoint();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::_internal_voltagesetpoint() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.voltagesetpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& VoltageRegulation::voltagesetpoint() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.voltageSetPoint)
  return _internal_voltagesetpoint();
}
inline void VoltageRegulation::unsafe_arena_set_allocated_voltagesetpoint(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* voltagesetpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpoint_);
  }
  _impl_.voltagesetpoint_ = voltagesetpoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltageRegulation.voltageSetPoint)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::release_voltagesetpoint() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.voltagesetpoint_;
  _impl_.voltagesetpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::unsafe_arena_release_voltagesetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.voltageSetPoint)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.voltagesetpoint_;
  _impl_.voltagesetpoint_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::_internal_mutable_voltagesetpoint() {
  
  if (_impl_.voltagesetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.voltagesetpoint_ = p;
  }
  return _impl_.voltagesetpoint_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* VoltageRegulation::mutable_voltagesetpoint() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_voltagesetpoint();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.voltageSetPoint)
  return _msg;
}
inline void VoltageRegulation::set_allocated_voltagesetpoint(::PROTOBUF_NAMESPACE_ID::FloatValue* voltagesetpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpoint_);
  }
  if (voltagesetpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesetpoint));
    if (message_arena != submessage_arena) {
      voltagesetpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesetpoint, submessage_arena);
    }

  } else {

  }
  _impl_.voltagesetpoint_ = voltagesetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.voltageSetPoint)
}

// -------------------------------------------------------------------

// VoltageDroop

// .google.protobuf.BoolValue voltageDroopCtl = 1;
inline bool VoltageDroop::_internal_has_voltagedroopctl() const {
  return this != internal_default_instance() && _impl_.voltagedroopctl_ != nullptr;
}
inline bool VoltageDroop::has_voltagedroopctl() const {
  return _internal_has_voltagedroopctl();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& VoltageDroop::_internal_voltagedroopctl() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.voltagedroopctl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& VoltageDroop::voltagedroopctl() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltageDroop.voltageDroopCtl)
  return _internal_voltagedroopctl();
}
inline void VoltageDroop::unsafe_arena_set_allocated_voltagedroopctl(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* voltagedroopctl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagedroopctl_);
  }
  _impl_.voltagedroopctl_ = voltagedroopctl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltageDroop.voltageDroopCtl)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltageDroop::release_voltagedroopctl() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.voltagedroopctl_;
  _impl_.voltagedroopctl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltageDroop::unsafe_arena_release_voltagedroopctl() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageDroop.voltageDroopCtl)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.voltagedroopctl_;
  _impl_.voltagedroopctl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltageDroop::_internal_mutable_voltagedroopctl() {
  
  if (_impl_.voltagedroopctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.voltagedroopctl_ = p;
  }
  return _impl_.voltagedroopctl_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltageDroop::mutable_voltagedroopctl() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_voltagedroopctl();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageDroop.voltageDroopCtl)
  return _msg;
}
inline void VoltageDroop::set_allocated_voltagedroopctl(::PROTOBUF_NAMESPACE_ID::BoolValue* voltagedroopctl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagedroopctl_);
  }
  if (voltagedroopctl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagedroopctl));
    if (message_arena != submessage_arena) {
      voltagedroopctl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagedroopctl, submessage_arena);
    }

  } else {

  }
  _impl_.voltagedroopctl_ = voltagedroopctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageDroop.voltageDroopCtl)
}

// .essmodule.VoltageRegulation voltageRegulation = 2;
inline bool VoltageDroop::_internal_has_voltageregulation() const {
  return this != internal_default_instance() && _impl_.voltageregulation_ != nullptr;
}
inline bool VoltageDroop::has_voltageregulation() const {
  return _internal_has_voltageregulation();
}
inline void VoltageDroop::clear_voltageregulation() {
  if (GetArenaForAllocation() == nullptr && _impl_.voltageregulation_ != nullptr) {
    delete _impl_.voltageregulation_;
  }
  _impl_.voltageregulation_ = nullptr;
}
inline const ::essmodule::VoltageRegulation& VoltageDroop::_internal_voltageregulation() const {
  const ::essmodule::VoltageRegulation* p = _impl_.voltageregulation_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::VoltageRegulation&>(
      ::essmodule::_VoltageRegulation_default_instance_);
}
inline const ::essmodule::VoltageRegulation& VoltageDroop::voltageregulation() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltageDroop.voltageRegulation)
  return _internal_voltageregulation();
}
inline void VoltageDroop::unsafe_arena_set_allocated_voltageregulation(
    ::essmodule::VoltageRegulation* voltageregulation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltageregulation_);
  }
  _impl_.voltageregulation_ = voltageregulation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltageDroop.voltageRegulation)
}
inline ::essmodule::VoltageRegulation* VoltageDroop::release_voltageregulation() {
  
  ::essmodule::VoltageRegulation* temp = _impl_.voltageregulation_;
  _impl_.voltageregulation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::VoltageRegulation* VoltageDroop::unsafe_arena_release_voltageregulation() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageDroop.voltageRegulation)
  
  ::essmodule::VoltageRegulation* temp = _impl_.voltageregulation_;
  _impl_.voltageregulation_ = nullptr;
  return temp;
}
inline ::essmodule::VoltageRegulation* VoltageDroop::_internal_mutable_voltageregulation() {
  
  if (_impl_.voltageregulation_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltageRegulation>(GetArenaForAllocation());
    _impl_.voltageregulation_ = p;
  }
  return _impl_.voltageregulation_;
}
inline ::essmodule::VoltageRegulation* VoltageDroop::mutable_voltageregulation() {
  ::essmodule::VoltageRegulation* _msg = _internal_mutable_voltageregulation();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageDroop.voltageRegulation)
  return _msg;
}
inline void VoltageDroop::set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voltageregulation_;
  }
  if (voltageregulation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voltageregulation);
    if (message_arena != submessage_arena) {
      voltageregulation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltageregulation, submessage_arena);
    }

  } else {

  }
  _impl_.voltageregulation_ = voltageregulation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageDroop.voltageRegulation)
}

// -------------------------------------------------------------------

// VoltagePI

// .google.protobuf.BoolValue voltagePICtl = 1;
inline bool VoltagePI::_internal_has_voltagepictl() const {
  return this != internal_default_instance() && _impl_.voltagepictl_ != nullptr;
}
inline bool VoltagePI::has_voltagepictl() const {
  return _internal_has_voltagepictl();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& VoltagePI::_internal_voltagepictl() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.voltagepictl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& VoltagePI::voltagepictl() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltagePI.voltagePICtl)
  return _internal_voltagepictl();
}
inline void VoltagePI::unsafe_arena_set_allocated_voltagepictl(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* voltagepictl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagepictl_);
  }
  _impl_.voltagepictl_ = voltagepictl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltagePI.voltagePICtl)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltagePI::release_voltagepictl() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.voltagepictl_;
  _impl_.voltagepictl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltagePI::unsafe_arena_release_voltagepictl() {
  // @@protoc_insertion_point(field_release:essmodule.VoltagePI.voltagePICtl)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.voltagepictl_;
  _impl_.voltagepictl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltagePI::_internal_mutable_voltagepictl() {
  
  if (_impl_.voltagepictl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.voltagepictl_ = p;
  }
  return _impl_.voltagepictl_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* VoltagePI::mutable_voltagepictl() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_voltagepictl();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltagePI.voltagePICtl)
  return _msg;
}
inline void VoltagePI::set_allocated_voltagepictl(::PROTOBUF_NAMESPACE_ID::BoolValue* voltagepictl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagepictl_);
  }
  if (voltagepictl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagepictl));
    if (message_arena != submessage_arena) {
      voltagepictl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagepictl, submessage_arena);
    }

  } else {

  }
  _impl_.voltagepictl_ = voltagepictl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltagePI.voltagePICtl)
}

// .essmodule.VoltageRegulation voltageRegulation = 2;
inline bool VoltagePI::_internal_has_voltageregulation() const {
  return this != internal_default_instance() && _impl_.voltageregulation_ != nullptr;
}
inline bool VoltagePI::has_voltageregulation() const {
  return _internal_has_voltageregulation();
}
inline void VoltagePI::clear_voltageregulation() {
  if (GetArenaForAllocation() == nullptr && _impl_.voltageregulation_ != nullptr) {
    delete _impl_.voltageregulation_;
  }
  _impl_.voltageregulation_ = nullptr;
}
inline const ::essmodule::VoltageRegulation& VoltagePI::_internal_voltageregulation() const {
  const ::essmodule::VoltageRegulation* p = _impl_.voltageregulation_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::VoltageRegulation&>(
      ::essmodule::_VoltageRegulation_default_instance_);
}
inline const ::essmodule::VoltageRegulation& VoltagePI::voltageregulation() const {
  // @@protoc_insertion_point(field_get:essmodule.VoltagePI.voltageRegulation)
  return _internal_voltageregulation();
}
inline void VoltagePI::unsafe_arena_set_allocated_voltageregulation(
    ::essmodule::VoltageRegulation* voltageregulation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltageregulation_);
  }
  _impl_.voltageregulation_ = voltageregulation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.VoltagePI.voltageRegulation)
}
inline ::essmodule::VoltageRegulation* VoltagePI::release_voltageregulation() {
  
  ::essmodule::VoltageRegulation* temp = _impl_.voltageregulation_;
  _impl_.voltageregulation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::VoltageRegulation* VoltagePI::unsafe_arena_release_voltageregulation() {
  // @@protoc_insertion_point(field_release:essmodule.VoltagePI.voltageRegulation)
  
  ::essmodule::VoltageRegulation* temp = _impl_.voltageregulation_;
  _impl_.voltageregulation_ = nullptr;
  return temp;
}
inline ::essmodule::VoltageRegulation* VoltagePI::_internal_mutable_voltageregulation() {
  
  if (_impl_.voltageregulation_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltageRegulation>(GetArenaForAllocation());
    _impl_.voltageregulation_ = p;
  }
  return _impl_.voltageregulation_;
}
inline ::essmodule::VoltageRegulation* VoltagePI::mutable_voltageregulation() {
  ::essmodule::VoltageRegulation* _msg = _internal_mutable_voltageregulation();
  // @@protoc_insertion_point(field_mutable:essmodule.VoltagePI.voltageRegulation)
  return _msg;
}
inline void VoltagePI::set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voltageregulation_;
  }
  if (voltageregulation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voltageregulation);
    if (message_arena != submessage_arena) {
      voltageregulation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltageregulation, submessage_arena);
    }

  } else {

  }
  _impl_.voltageregulation_ = voltageregulation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltagePI.voltageRegulation)
}

// -------------------------------------------------------------------

// CapacityFirming

// .google.protobuf.BoolValue capacityFirmingCtl = 1;
inline bool CapacityFirming::_internal_has_capacityfirmingctl() const {
  return this != internal_default_instance() && _impl_.capacityfirmingctl_ != nullptr;
}
inline bool CapacityFirming::has_capacityfirmingctl() const {
  return _internal_has_capacityfirmingctl();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& CapacityFirming::_internal_capacityfirmingctl() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.capacityfirmingctl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& CapacityFirming::capacityfirmingctl() const {
  // @@protoc_insertion_point(field_get:essmodule.CapacityFirming.capacityFirmingCtl)
  return _internal_capacityfirmingctl();
}
inline void CapacityFirming::unsafe_arena_set_allocated_capacityfirmingctl(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* capacityfirmingctl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capacityfirmingctl_);
  }
  _impl_.capacityfirmingctl_ = capacityfirmingctl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.CapacityFirming.capacityFirmingCtl)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CapacityFirming::release_capacityfirmingctl() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.capacityfirmingctl_;
  _impl_.capacityfirmingctl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CapacityFirming::unsafe_arena_release_capacityfirmingctl() {
  // @@protoc_insertion_point(field_release:essmodule.CapacityFirming.capacityFirmingCtl)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.capacityfirmingctl_;
  _impl_.capacityfirmingctl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CapacityFirming::_internal_mutable_capacityfirmingctl() {
  
  if (_impl_.capacityfirmingctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.capacityfirmingctl_ = p;
  }
  return _impl_.capacityfirmingctl_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* CapacityFirming::mutable_capacityfirmingctl() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_capacityfirmingctl();
  // @@protoc_insertion_point(field_mutable:essmodule.CapacityFirming.capacityFirmingCtl)
  return _msg;
}
inline void CapacityFirming::set_allocated_capacityfirmingctl(::PROTOBUF_NAMESPACE_ID::BoolValue* capacityfirmingctl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capacityfirmingctl_);
  }
  if (capacityfirmingctl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacityfirmingctl));
    if (message_arena != submessage_arena) {
      capacityfirmingctl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacityfirmingctl, submessage_arena);
    }

  } else {

  }
  _impl_.capacityfirmingctl_ = capacityfirmingctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.CapacityFirming.capacityFirmingCtl)
}

// .google.protobuf.FloatValue limitNegative_dp_dt = 2;
inline bool CapacityFirming::_internal_has_limitnegative_dp_dt() const {
  return this != internal_default_instance() && _impl_.limitnegative_dp_dt_ != nullptr;
}
inline bool CapacityFirming::has_limitnegative_dp_dt() const {
  return _internal_has_limitnegative_dp_dt();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& CapacityFirming::_internal_limitnegative_dp_dt() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.limitnegative_dp_dt_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& CapacityFirming::limitnegative_dp_dt() const {
  // @@protoc_insertion_point(field_get:essmodule.CapacityFirming.limitNegative_dp_dt)
  return _internal_limitnegative_dp_dt();
}
inline void CapacityFirming::unsafe_arena_set_allocated_limitnegative_dp_dt(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* limitnegative_dp_dt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitnegative_dp_dt_);
  }
  _impl_.limitnegative_dp_dt_ = limitnegative_dp_dt;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.CapacityFirming.limitNegative_dp_dt)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::release_limitnegative_dp_dt() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.limitnegative_dp_dt_;
  _impl_.limitnegative_dp_dt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::unsafe_arena_release_limitnegative_dp_dt() {
  // @@protoc_insertion_point(field_release:essmodule.CapacityFirming.limitNegative_dp_dt)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.limitnegative_dp_dt_;
  _impl_.limitnegative_dp_dt_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::_internal_mutable_limitnegative_dp_dt() {
  
  if (_impl_.limitnegative_dp_dt_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.limitnegative_dp_dt_ = p;
  }
  return _impl_.limitnegative_dp_dt_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::mutable_limitnegative_dp_dt() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_limitnegative_dp_dt();
  // @@protoc_insertion_point(field_mutable:essmodule.CapacityFirming.limitNegative_dp_dt)
  return _msg;
}
inline void CapacityFirming::set_allocated_limitnegative_dp_dt(::PROTOBUF_NAMESPACE_ID::FloatValue* limitnegative_dp_dt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitnegative_dp_dt_);
  }
  if (limitnegative_dp_dt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limitnegative_dp_dt));
    if (message_arena != submessage_arena) {
      limitnegative_dp_dt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limitnegative_dp_dt, submessage_arena);
    }

  } else {

  }
  _impl_.limitnegative_dp_dt_ = limitnegative_dp_dt;
  // @@protoc_insertion_point(field_set_allocated:essmodule.CapacityFirming.limitNegative_dp_dt)
}

// .google.protobuf.FloatValue limitPositive_dp_dt = 3;
inline bool CapacityFirming::_internal_has_limitpositive_dp_dt() const {
  return this != internal_default_instance() && _impl_.limitpositive_dp_dt_ != nullptr;
}
inline bool CapacityFirming::has_limitpositive_dp_dt() const {
  return _internal_has_limitpositive_dp_dt();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& CapacityFirming::_internal_limitpositive_dp_dt() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.limitpositive_dp_dt_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& CapacityFirming::limitpositive_dp_dt() const {
  // @@protoc_insertion_point(field_get:essmodule.CapacityFirming.limitPositive_dp_dt)
  return _internal_limitpositive_dp_dt();
}
inline void CapacityFirming::unsafe_arena_set_allocated_limitpositive_dp_dt(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* limitpositive_dp_dt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitpositive_dp_dt_);
  }
  _impl_.limitpositive_dp_dt_ = limitpositive_dp_dt;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.CapacityFirming.limitPositive_dp_dt)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::release_limitpositive_dp_dt() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.limitpositive_dp_dt_;
  _impl_.limitpositive_dp_dt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::unsafe_arena_release_limitpositive_dp_dt() {
  // @@protoc_insertion_point(field_release:essmodule.CapacityFirming.limitPositive_dp_dt)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.limitpositive_dp_dt_;
  _impl_.limitpositive_dp_dt_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::_internal_mutable_limitpositive_dp_dt() {
  
  if (_impl_.limitpositive_dp_dt_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.limitpositive_dp_dt_ = p;
  }
  return _impl_.limitpositive_dp_dt_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* CapacityFirming::mutable_limitpositive_dp_dt() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_limitpositive_dp_dt();
  // @@protoc_insertion_point(field_mutable:essmodule.CapacityFirming.limitPositive_dp_dt)
  return _msg;
}
inline void CapacityFirming::set_allocated_limitpositive_dp_dt(::PROTOBUF_NAMESPACE_ID::FloatValue* limitpositive_dp_dt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitpositive_dp_dt_);
  }
  if (limitpositive_dp_dt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limitpositive_dp_dt));
    if (message_arena != submessage_arena) {
      limitpositive_dp_dt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limitpositive_dp_dt, submessage_arena);
    }

  } else {

  }
  _impl_.limitpositive_dp_dt_ = limitpositive_dp_dt;
  // @@protoc_insertion_point(field_set_allocated:essmodule.CapacityFirming.limitPositive_dp_dt)
}

// -------------------------------------------------------------------

// ESSFunction

// .essmodule.CapacityFirming capacityFirming = 1;
inline bool ESSFunction::_internal_has_capacityfirming() const {
  return this != internal_default_instance() && _impl_.capacityfirming_ != nullptr;
}
inline bool ESSFunction::has_capacityfirming() const {
  return _internal_has_capacityfirming();
}
inline void ESSFunction::clear_capacityfirming() {
  if (GetArenaForAllocation() == nullptr && _impl_.capacityfirming_ != nullptr) {
    delete _impl_.capacityfirming_;
  }
  _impl_.capacityfirming_ = nullptr;
}
inline const ::essmodule::CapacityFirming& ESSFunction::_internal_capacityfirming() const {
  const ::essmodule::CapacityFirming* p = _impl_.capacityfirming_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::CapacityFirming&>(
      ::essmodule::_CapacityFirming_default_instance_);
}
inline const ::essmodule::CapacityFirming& ESSFunction::capacityfirming() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.capacityFirming)
  return _internal_capacityfirming();
}
inline void ESSFunction::unsafe_arena_set_allocated_capacityfirming(
    ::essmodule::CapacityFirming* capacityfirming) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capacityfirming_);
  }
  _impl_.capacityfirming_ = capacityfirming;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSFunction.capacityFirming)
}
inline ::essmodule::CapacityFirming* ESSFunction::release_capacityfirming() {
  
  ::essmodule::CapacityFirming* temp = _impl_.capacityfirming_;
  _impl_.capacityfirming_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::CapacityFirming* ESSFunction::unsafe_arena_release_capacityfirming() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.capacityFirming)
  
  ::essmodule::CapacityFirming* temp = _impl_.capacityfirming_;
  _impl_.capacityfirming_ = nullptr;
  return temp;
}
inline ::essmodule::CapacityFirming* ESSFunction::_internal_mutable_capacityfirming() {
  
  if (_impl_.capacityfirming_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::CapacityFirming>(GetArenaForAllocation());
    _impl_.capacityfirming_ = p;
  }
  return _impl_.capacityfirming_;
}
inline ::essmodule::CapacityFirming* ESSFunction::mutable_capacityfirming() {
  ::essmodule::CapacityFirming* _msg = _internal_mutable_capacityfirming();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.capacityFirming)
  return _msg;
}
inline void ESSFunction::set_allocated_capacityfirming(::essmodule::CapacityFirming* capacityfirming) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capacityfirming_;
  }
  if (capacityfirming) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capacityfirming);
    if (message_arena != submessage_arena) {
      capacityfirming = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacityfirming, submessage_arena);
    }

  } else {

  }
  _impl_.capacityfirming_ = capacityfirming;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.capacityFirming)
}

// .essmodule.FrequencyRegulation frequencyRegulation = 2;
inline bool ESSFunction::_internal_has_frequencyregulation() const {
  return this != internal_default_instance() && _impl_.frequencyregulation_ != nullptr;
}
inline bool ESSFunction::has_frequencyregulation() const {
  return _internal_has_frequencyregulation();
}
inline void ESSFunction::clear_frequencyregulation() {
  if (GetArenaForAllocation() == nullptr && _impl_.frequencyregulation_ != nullptr) {
    delete _impl_.frequencyregulation_;
  }
  _impl_.frequencyregulation_ = nullptr;
}
inline const ::essmodule::FrequencyRegulation& ESSFunction::_internal_frequencyregulation() const {
  const ::essmodule::FrequencyRegulation* p = _impl_.frequencyregulation_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::FrequencyRegulation&>(
      ::essmodule::_FrequencyRegulation_default_instance_);
}
inline const ::essmodule::FrequencyRegulation& ESSFunction::frequencyregulation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.frequencyRegulation)
  return _internal_frequencyregulation();
}
inline void ESSFunction::unsafe_arena_set_allocated_frequencyregulation(
    ::essmodule::FrequencyRegulation* frequencyregulation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencyregulation_);
  }
  _impl_.frequencyregulation_ = frequencyregulation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSFunction.frequencyRegulation)
}
inline ::essmodule::FrequencyRegulation* ESSFunction::release_frequencyregulation() {
  
  ::essmodule::FrequencyRegulation* temp = _impl_.frequencyregulation_;
  _impl_.frequencyregulation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::FrequencyRegulation* ESSFunction::unsafe_arena_release_frequencyregulation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.frequencyRegulation)
  
  ::essmodule::FrequencyRegulation* temp = _impl_.frequencyregulation_;
  _impl_.frequencyregulation_ = nullptr;
  return temp;
}
inline ::essmodule::FrequencyRegulation* ESSFunction::_internal_mutable_frequencyregulation() {
  
  if (_impl_.frequencyregulation_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::FrequencyRegulation>(GetArenaForAllocation());
    _impl_.frequencyregulation_ = p;
  }
  return _impl_.frequencyregulation_;
}
inline ::essmodule::FrequencyRegulation* ESSFunction::mutable_frequencyregulation() {
  ::essmodule::FrequencyRegulation* _msg = _internal_mutable_frequencyregulation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.frequencyRegulation)
  return _msg;
}
inline void ESSFunction::set_allocated_frequencyregulation(::essmodule::FrequencyRegulation* frequencyregulation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frequencyregulation_;
  }
  if (frequencyregulation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frequencyregulation);
    if (message_arena != submessage_arena) {
      frequencyregulation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencyregulation, submessage_arena);
    }

  } else {

  }
  _impl_.frequencyregulation_ = frequencyregulation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.frequencyRegulation)
}

// .essmodule.PeakShaving peakShaving = 3;
inline bool ESSFunction::_internal_has_peakshaving() const {
  return this != internal_default_instance() && _impl_.peakshaving_ != nullptr;
}
inline bool ESSFunction::has_peakshaving() const {
  return _internal_has_peakshaving();
}
inline void ESSFunction::clear_peakshaving() {
  if (GetArenaForAllocation() == nullptr && _impl_.peakshaving_ != nullptr) {
    delete _impl_.peakshaving_;
  }
  _impl_.peakshaving_ = nullptr;
}
inline const ::essmodule::PeakShaving& ESSFunction::_internal_peakshaving() const {
  const ::essmodule::PeakShaving* p = _impl_.peakshaving_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::PeakShaving&>(
      ::essmodule::_PeakShaving_default_instance_);
}
inline const ::essmodule::PeakShaving& ESSFunction::peakshaving() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.peakShaving)
  return _internal_peakshaving();
}
inline void ESSFunction::unsafe_arena_set_allocated_peakshaving(
    ::essmodule::PeakShaving* peakshaving) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peakshaving_);
  }
  _impl_.peakshaving_ = peakshaving;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSFunction.peakShaving)
}
inline ::essmodule::PeakShaving* ESSFunction::release_peakshaving() {
  
  ::essmodule::PeakShaving* temp = _impl_.peakshaving_;
  _impl_.peakshaving_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::PeakShaving* ESSFunction::unsafe_arena_release_peakshaving() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.peakShaving)
  
  ::essmodule::PeakShaving* temp = _impl_.peakshaving_;
  _impl_.peakshaving_ = nullptr;
  return temp;
}
inline ::essmodule::PeakShaving* ESSFunction::_internal_mutable_peakshaving() {
  
  if (_impl_.peakshaving_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::PeakShaving>(GetArenaForAllocation());
    _impl_.peakshaving_ = p;
  }
  return _impl_.peakshaving_;
}
inline ::essmodule::PeakShaving* ESSFunction::mutable_peakshaving() {
  ::essmodule::PeakShaving* _msg = _internal_mutable_peakshaving();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.peakShaving)
  return _msg;
}
inline void ESSFunction::set_allocated_peakshaving(::essmodule::PeakShaving* peakshaving) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.peakshaving_;
  }
  if (peakshaving) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peakshaving);
    if (message_arena != submessage_arena) {
      peakshaving = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peakshaving, submessage_arena);
    }

  } else {

  }
  _impl_.peakshaving_ = peakshaving;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.peakShaving)
}

// .essmodule.SocLimit socLimit = 4;
inline bool ESSFunction::_internal_has_soclimit() const {
  return this != internal_default_instance() && _impl_.soclimit_ != nullptr;
}
inline bool ESSFunction::has_soclimit() const {
  return _internal_has_soclimit();
}
inline void ESSFunction::clear_soclimit() {
  if (GetArenaForAllocation() == nullptr && _impl_.soclimit_ != nullptr) {
    delete _impl_.soclimit_;
  }
  _impl_.soclimit_ = nullptr;
}
inline const ::essmodule::SocLimit& ESSFunction::_internal_soclimit() const {
  const ::essmodule::SocLimit* p = _impl_.soclimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::SocLimit&>(
      ::essmodule::_SocLimit_default_instance_);
}
inline const ::essmodule::SocLimit& ESSFunction::soclimit() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.socLimit)
  return _internal_soclimit();
}
inline void ESSFunction::unsafe_arena_set_allocated_soclimit(
    ::essmodule::SocLimit* soclimit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soclimit_);
  }
  _impl_.soclimit_ = soclimit;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSFunction.socLimit)
}
inline ::essmodule::SocLimit* ESSFunction::release_soclimit() {
  
  ::essmodule::SocLimit* temp = _impl_.soclimit_;
  _impl_.soclimit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::SocLimit* ESSFunction::unsafe_arena_release_soclimit() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.socLimit)
  
  ::essmodule::SocLimit* temp = _impl_.soclimit_;
  _impl_.soclimit_ = nullptr;
  return temp;
}
inline ::essmodule::SocLimit* ESSFunction::_internal_mutable_soclimit() {
  
  if (_impl_.soclimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::SocLimit>(GetArenaForAllocation());
    _impl_.soclimit_ = p;
  }
  return _impl_.soclimit_;
}
inline ::essmodule::SocLimit* ESSFunction::mutable_soclimit() {
  ::essmodule::SocLimit* _msg = _internal_mutable_soclimit();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.socLimit)
  return _msg;
}
inline void ESSFunction::set_allocated_soclimit(::essmodule::SocLimit* soclimit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.soclimit_;
  }
  if (soclimit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(soclimit);
    if (message_arena != submessage_arena) {
      soclimit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soclimit, submessage_arena);
    }

  } else {

  }
  _impl_.soclimit_ = soclimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.socLimit)
}

// .essmodule.SOCManagement socManagement = 5;
inline bool ESSFunction::_internal_has_socmanagement() const {
  return this != internal_default_instance() && _impl_.socmanagement_ != nullptr;
}
inline bool ESSFunction::has_socmanagement() const {
  return _internal_has_socmanagement();
}
inline void ESSFunction::clear_socmanagement() {
  if (GetArenaForAllocation() == nullptr && _impl_.socmanagement_ != nullptr) {
    delete _impl_.socmanagement_;
  }
  _impl_.socmanagement_ = nullptr;
}
inline const ::essmodule::SOCManagement& ESSFunction::_internal_socmanagement() const {
  const ::essmodule::SOCManagement* p = _impl_.socmanagement_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::SOCManagement&>(
      ::essmodule::_SOCManagement_default_instance_);
}
inline const ::essmodule::SOCManagement& ESSFunction::socmanagement() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.socManagement)
  return _internal_socmanagement();
}
inline void ESSFunction::unsafe_arena_set_allocated_socmanagement(
    ::essmodule::SOCManagement* socmanagement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.socmanagement_);
  }
  _impl_.socmanagement_ = socmanagement;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSFunction.socManagement)
}
inline ::essmodule::SOCManagement* ESSFunction::release_socmanagement() {
  
  ::essmodule::SOCManagement* temp = _impl_.socmanagement_;
  _impl_.socmanagement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::SOCManagement* ESSFunction::unsafe_arena_release_socmanagement() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.socManagement)
  
  ::essmodule::SOCManagement* temp = _impl_.socmanagement_;
  _impl_.socmanagement_ = nullptr;
  return temp;
}
inline ::essmodule::SOCManagement* ESSFunction::_internal_mutable_socmanagement() {
  
  if (_impl_.socmanagement_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::SOCManagement>(GetArenaForAllocation());
    _impl_.socmanagement_ = p;
  }
  return _impl_.socmanagement_;
}
inline ::essmodule::SOCManagement* ESSFunction::mutable_socmanagement() {
  ::essmodule::SOCManagement* _msg = _internal_mutable_socmanagement();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.socManagement)
  return _msg;
}
inline void ESSFunction::set_allocated_socmanagement(::essmodule::SOCManagement* socmanagement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.socmanagement_;
  }
  if (socmanagement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(socmanagement);
    if (message_arena != submessage_arena) {
      socmanagement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, socmanagement, submessage_arena);
    }

  } else {

  }
  _impl_.socmanagement_ = socmanagement;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.socManagement)
}

// .essmodule.VoltageDroop voltageDroop = 6;
inline bool ESSFunction::_internal_has_voltagedroop() const {
  return this != internal_default_instance() && _impl_.voltagedroop_ != nullptr;
}
inline bool ESSFunction::has_voltagedroop() const {
  return _internal_has_voltagedroop();
}
inline void ESSFunction::clear_voltagedroop() {
  if (GetArenaForAllocation() == nullptr && _impl_.voltagedroop_ != nullptr) {
    delete _impl_.voltagedroop_;
  }
  _impl_.voltagedroop_ = nullptr;
}
inline const ::essmodule::VoltageDroop& ESSFunction::_internal_voltagedroop() const {
  const ::essmodule::VoltageDroop* p = _impl_.voltagedroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::VoltageDroop&>(
      ::essmodule::_VoltageDroop_default_instance_);
}
inline const ::essmodule::VoltageDroop& ESSFunction::voltagedroop() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.voltageDroop)
  return _internal_voltagedroop();
}
inline void ESSFunction::unsafe_arena_set_allocated_voltagedroop(
    ::essmodule::VoltageDroop* voltagedroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagedroop_);
  }
  _impl_.voltagedroop_ = voltagedroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSFunction.voltageDroop)
}
inline ::essmodule::VoltageDroop* ESSFunction::release_voltagedroop() {
  
  ::essmodule::VoltageDroop* temp = _impl_.voltagedroop_;
  _impl_.voltagedroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::VoltageDroop* ESSFunction::unsafe_arena_release_voltagedroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.voltageDroop)
  
  ::essmodule::VoltageDroop* temp = _impl_.voltagedroop_;
  _impl_.voltagedroop_ = nullptr;
  return temp;
}
inline ::essmodule::VoltageDroop* ESSFunction::_internal_mutable_voltagedroop() {
  
  if (_impl_.voltagedroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltageDroop>(GetArenaForAllocation());
    _impl_.voltagedroop_ = p;
  }
  return _impl_.voltagedroop_;
}
inline ::essmodule::VoltageDroop* ESSFunction::mutable_voltagedroop() {
  ::essmodule::VoltageDroop* _msg = _internal_mutable_voltagedroop();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.voltageDroop)
  return _msg;
}
inline void ESSFunction::set_allocated_voltagedroop(::essmodule::VoltageDroop* voltagedroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voltagedroop_;
  }
  if (voltagedroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voltagedroop);
    if (message_arena != submessage_arena) {
      voltagedroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagedroop, submessage_arena);
    }

  } else {

  }
  _impl_.voltagedroop_ = voltagedroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.voltageDroop)
}

// .essmodule.VoltagePI voltagePI = 7;
inline bool ESSFunction::_internal_has_voltagepi() const {
  return this != internal_default_instance() && _impl_.voltagepi_ != nullptr;
}
inline bool ESSFunction::has_voltagepi() const {
  return _internal_has_voltagepi();
}
inline void ESSFunction::clear_voltagepi() {
  if (GetArenaForAllocation() == nullptr && _impl_.voltagepi_ != nullptr) {
    delete _impl_.voltagepi_;
  }
  _impl_.voltagepi_ = nullptr;
}
inline const ::essmodule::VoltagePI& ESSFunction::_internal_voltagepi() const {
  const ::essmodule::VoltagePI* p = _impl_.voltagepi_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::VoltagePI&>(
      ::essmodule::_VoltagePI_default_instance_);
}
inline const ::essmodule::VoltagePI& ESSFunction::voltagepi() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.voltagePI)
  return _internal_voltagepi();
}
inline void ESSFunction::unsafe_arena_set_allocated_voltagepi(
    ::essmodule::VoltagePI* voltagepi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagepi_);
  }
  _impl_.voltagepi_ = voltagepi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSFunction.voltagePI)
}
inline ::essmodule::VoltagePI* ESSFunction::release_voltagepi() {
  
  ::essmodule::VoltagePI* temp = _impl_.voltagepi_;
  _impl_.voltagepi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::VoltagePI* ESSFunction::unsafe_arena_release_voltagepi() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.voltagePI)
  
  ::essmodule::VoltagePI* temp = _impl_.voltagepi_;
  _impl_.voltagepi_ = nullptr;
  return temp;
}
inline ::essmodule::VoltagePI* ESSFunction::_internal_mutable_voltagepi() {
  
  if (_impl_.voltagepi_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltagePI>(GetArenaForAllocation());
    _impl_.voltagepi_ = p;
  }
  return _impl_.voltagepi_;
}
inline ::essmodule::VoltagePI* ESSFunction::mutable_voltagepi() {
  ::essmodule::VoltagePI* _msg = _internal_mutable_voltagepi();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.voltagePI)
  return _msg;
}
inline void ESSFunction::set_allocated_voltagepi(::essmodule::VoltagePI* voltagepi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voltagepi_;
  }
  if (voltagepi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voltagepi);
    if (message_arena != submessage_arena) {
      voltagepi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagepi, submessage_arena);
    }

  } else {

  }
  _impl_.voltagepi_ = voltagepi;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.voltagePI)
}

// -------------------------------------------------------------------

// ESSPoint

// .commonmodule.ControlSPC blackStartEnabled = 1;
inline bool ESSPoint::_internal_has_blackstartenabled() const {
  return this != internal_default_instance() && _impl_.blackstartenabled_ != nullptr;
}
inline bool ESSPoint::has_blackstartenabled() const {
  return _internal_has_blackstartenabled();
}
inline const ::commonmodule::ControlSPC& ESSPoint::_internal_blackstartenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.blackstartenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& ESSPoint::blackstartenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.blackStartEnabled)
  return _internal_blackstartenabled();
}
inline void ESSPoint::unsafe_arena_set_allocated_blackstartenabled(
    ::commonmodule::ControlSPC* blackstartenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.blackStartEnabled)
}
inline ::commonmodule::ControlSPC* ESSPoint::release_blackstartenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* ESSPoint::unsafe_arena_release_blackstartenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.blackStartEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* ESSPoint::_internal_mutable_blackstartenabled() {
  
  if (_impl_.blackstartenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.blackstartenabled_ = p;
  }
  return _impl_.blackstartenabled_;
}
inline ::commonmodule::ControlSPC* ESSPoint::mutable_blackstartenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_blackstartenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.blackStartEnabled)
  return _msg;
}
inline void ESSPoint::set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  if (blackstartenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blackstartenabled));
    if (message_arena != submessage_arena) {
      blackstartenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blackstartenabled, submessage_arena);
    }

  } else {

  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.blackStartEnabled)
}

// .essmodule.ESSFunction function = 3;
inline bool ESSPoint::_internal_has_function() const {
  return this != internal_default_instance() && _impl_.function_ != nullptr;
}
inline bool ESSPoint::has_function() const {
  return _internal_has_function();
}
inline void ESSPoint::clear_function() {
  if (GetArenaForAllocation() == nullptr && _impl_.function_ != nullptr) {
    delete _impl_.function_;
  }
  _impl_.function_ = nullptr;
}
inline const ::essmodule::ESSFunction& ESSPoint::_internal_function() const {
  const ::essmodule::ESSFunction* p = _impl_.function_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSFunction&>(
      ::essmodule::_ESSFunction_default_instance_);
}
inline const ::essmodule::ESSFunction& ESSPoint::function() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.function)
  return _internal_function();
}
inline void ESSPoint::unsafe_arena_set_allocated_function(
    ::essmodule::ESSFunction* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.function_);
  }
  _impl_.function_ = function;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.function)
}
inline ::essmodule::ESSFunction* ESSPoint::release_function() {
  
  ::essmodule::ESSFunction* temp = _impl_.function_;
  _impl_.function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSFunction* ESSPoint::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.function)
  
  ::essmodule::ESSFunction* temp = _impl_.function_;
  _impl_.function_ = nullptr;
  return temp;
}
inline ::essmodule::ESSFunction* ESSPoint::_internal_mutable_function() {
  
  if (_impl_.function_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSFunction>(GetArenaForAllocation());
    _impl_.function_ = p;
  }
  return _impl_.function_;
}
inline ::essmodule::ESSFunction* ESSPoint::mutable_function() {
  ::essmodule::ESSFunction* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.function)
  return _msg;
}
inline void ESSPoint::set_allocated_function(::essmodule::ESSFunction* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }

  } else {

  }
  _impl_.function_ = function;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.function)
}

// .commonmodule.ENG_GridConnectModeKind mode = 4;
inline bool ESSPoint::_internal_has_mode() const {
  return this != internal_default_instance() && _impl_.mode_ != nullptr;
}
inline bool ESSPoint::has_mode() const {
  return _internal_has_mode();
}
inline const ::commonmodule::ENG_GridConnectModeKind& ESSPoint::_internal_mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(
      ::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& ESSPoint::mode() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.mode)
  return _internal_mode();
}
inline void ESSPoint::unsafe_arena_set_allocated_mode(
    ::commonmodule::ENG_GridConnectModeKind* mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.mode)
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPoint::release_mode() {
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPoint::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPoint::_internal_mutable_mode() {
  
  if (_impl_.mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaForAllocation());
    _impl_.mode_ = p;
  }
  return _impl_.mode_;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPoint::mutable_mode() {
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.mode)
  return _msg;
}
inline void ESSPoint::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  if (mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mode));
    if (message_arena != submessage_arena) {
      mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }

  } else {

  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.mode)
}

// .commonmodule.RampRate rampRates = 7;
inline bool ESSPoint::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool ESSPoint::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& ESSPoint::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& ESSPoint::ramprates() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.rampRates)
  return _internal_ramprates();
}
inline void ESSPoint::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.rampRates)
}
inline ::commonmodule::RampRate* ESSPoint::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* ESSPoint::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* ESSPoint::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* ESSPoint::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.rampRates)
  return _msg;
}
inline void ESSPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.rampRates)
}

// .commonmodule.ControlSPC reset = 10;
inline bool ESSPoint::_internal_has_reset() const {
  return this != internal_default_instance() && _impl_.reset_ != nullptr;
}
inline bool ESSPoint::has_reset() const {
  return _internal_has_reset();
}
inline const ::commonmodule::ControlSPC& ESSPoint::_internal_reset() const {
  const ::commonmodule::ControlSPC* p = _impl_.reset_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& ESSPoint::reset() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.reset)
  return _internal_reset();
}
inline void ESSPoint::unsafe_arena_set_allocated_reset(
    ::commonmodule::ControlSPC* reset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.reset)
}
inline ::commonmodule::ControlSPC* ESSPoint::release_reset() {
  
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* ESSPoint::unsafe_arena_release_reset() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.reset)
  
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* ESSPoint::_internal_mutable_reset() {
  
  if (_impl_.reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.reset_ = p;
  }
  return _impl_.reset_;
}
inline ::commonmodule::ControlSPC* ESSPoint::mutable_reset() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_reset();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.reset)
  return _msg;
}
inline void ESSPoint::set_allocated_reset(::commonmodule::ControlSPC* reset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  if (reset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reset));
    if (message_arena != submessage_arena) {
      reset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }

  } else {

  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.reset)
}

// .commonmodule.Optional_StateKind state = 11;
inline bool ESSPoint::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool ESSPoint::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& ESSPoint::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& ESSPoint::state() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.state)
  return _internal_state();
}
inline void ESSPoint::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.state)
}
inline ::commonmodule::Optional_StateKind* ESSPoint::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* ESSPoint::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* ESSPoint::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* ESSPoint::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.state)
  return _msg;
}
inline void ESSPoint::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.state)
}

// .commonmodule.ControlSPC transToIslndOnGridLossEnabled = 13;
inline bool ESSPoint::_internal_has_transtoislndongridlossenabled() const {
  return this != internal_default_instance() && _impl_.transtoislndongridlossenabled_ != nullptr;
}
inline bool ESSPoint::has_transtoislndongridlossenabled() const {
  return _internal_has_transtoislndongridlossenabled();
}
inline const ::commonmodule::ControlSPC& ESSPoint::_internal_transtoislndongridlossenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.transtoislndongridlossenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& ESSPoint::transtoislndongridlossenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
  return _internal_transtoislndongridlossenabled();
}
inline void ESSPoint::unsafe_arena_set_allocated_transtoislndongridlossenabled(
    ::commonmodule::ControlSPC* transtoislndongridlossenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transtoislndongridlossenabled_);
  }
  _impl_.transtoislndongridlossenabled_ = transtoislndongridlossenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
}
inline ::commonmodule::ControlSPC* ESSPoint::release_transtoislndongridlossenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.transtoislndongridlossenabled_;
  _impl_.transtoislndongridlossenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* ESSPoint::unsafe_arena_release_transtoislndongridlossenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.transtoislndongridlossenabled_;
  _impl_.transtoislndongridlossenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* ESSPoint::_internal_mutable_transtoislndongridlossenabled() {
  
  if (_impl_.transtoislndongridlossenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.transtoislndongridlossenabled_ = p;
  }
  return _impl_.transtoislndongridlossenabled_;
}
inline ::commonmodule::ControlSPC* ESSPoint::mutable_transtoislndongridlossenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_transtoislndongridlossenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
  return _msg;
}
inline void ESSPoint::set_allocated_transtoislndongridlossenabled(::commonmodule::ControlSPC* transtoislndongridlossenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transtoislndongridlossenabled_);
  }
  if (transtoislndongridlossenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transtoislndongridlossenabled));
    if (message_arena != submessage_arena) {
      transtoislndongridlossenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transtoislndongridlossenabled, submessage_arena);
    }

  } else {

  }
  _impl_.transtoislndongridlossenabled_ = transtoislndongridlossenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
}

// .commonmodule.EnterServiceAPC enterServiceOperation = 16;
inline bool ESSPoint::_internal_has_enterserviceoperation() const {
  return this != internal_default_instance() && _impl_.enterserviceoperation_ != nullptr;
}
inline bool ESSPoint::has_enterserviceoperation() const {
  return _internal_has_enterserviceoperation();
}
inline const ::commonmodule::EnterServiceAPC& ESSPoint::_internal_enterserviceoperation() const {
  const ::commonmodule::EnterServiceAPC* p = _impl_.enterserviceoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnterServiceAPC&>(
      ::commonmodule::_EnterServiceAPC_default_instance_);
}
inline const ::commonmodule::EnterServiceAPC& ESSPoint::enterserviceoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.enterServiceOperation)
  return _internal_enterserviceoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_enterserviceoperation(
    ::commonmodule::EnterServiceAPC* enterserviceoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.enterServiceOperation)
}
inline ::commonmodule::EnterServiceAPC* ESSPoint::release_enterserviceoperation() {
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnterServiceAPC* ESSPoint::unsafe_arena_release_enterserviceoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.enterServiceOperation)
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::EnterServiceAPC* ESSPoint::_internal_mutable_enterserviceoperation() {
  
  if (_impl_.enterserviceoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnterServiceAPC>(GetArenaForAllocation());
    _impl_.enterserviceoperation_ = p;
  }
  return _impl_.enterserviceoperation_;
}
inline ::commonmodule::EnterServiceAPC* ESSPoint::mutable_enterserviceoperation() {
  ::commonmodule::EnterServiceAPC* _msg = _internal_mutable_enterserviceoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.enterServiceOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  if (enterserviceoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enterserviceoperation));
    if (message_arena != submessage_arena) {
      enterserviceoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enterserviceoperation, submessage_arena);
    }

  } else {

  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.enterServiceOperation)
}

// .commonmodule.HzWAPC hzWOperation = 17;
inline bool ESSPoint::_internal_has_hzwoperation() const {
  return this != internal_default_instance() && _impl_.hzwoperation_ != nullptr;
}
inline bool ESSPoint::has_hzwoperation() const {
  return _internal_has_hzwoperation();
}
inline const ::commonmodule::HzWAPC& ESSPoint::_internal_hzwoperation() const {
  const ::commonmodule::HzWAPC* p = _impl_.hzwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWAPC&>(
      ::commonmodule::_HzWAPC_default_instance_);
}
inline const ::commonmodule::HzWAPC& ESSPoint::hzwoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.hzWOperation)
  return _internal_hzwoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_hzwoperation(
    ::commonmodule::HzWAPC* hzwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.hzWOperation)
}
inline ::commonmodule::HzWAPC* ESSPoint::release_hzwoperation() {
  
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::HzWAPC* ESSPoint::unsafe_arena_release_hzwoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.hzWOperation)
  
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWAPC* ESSPoint::_internal_mutable_hzwoperation() {
  
  if (_impl_.hzwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::HzWAPC>(GetArenaForAllocation());
    _impl_.hzwoperation_ = p;
  }
  return _impl_.hzwoperation_;
}
inline ::commonmodule::HzWAPC* ESSPoint::mutable_hzwoperation() {
  ::commonmodule::HzWAPC* _msg = _internal_mutable_hzwoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.hzWOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_hzwoperation(::commonmodule::HzWAPC* hzwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  if (hzwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hzwoperation));
    if (message_arena != submessage_arena) {
      hzwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hzwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.hzWOperation)
}

// .commonmodule.LimitWAPC limitWOperation = 18;
inline bool ESSPoint::_internal_has_limitwoperation() const {
  return this != internal_default_instance() && _impl_.limitwoperation_ != nullptr;
}
inline bool ESSPoint::has_limitwoperation() const {
  return _internal_has_limitwoperation();
}
inline const ::commonmodule::LimitWAPC& ESSPoint::_internal_limitwoperation() const {
  const ::commonmodule::LimitWAPC* p = _impl_.limitwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LimitWAPC&>(
      ::commonmodule::_LimitWAPC_default_instance_);
}
inline const ::commonmodule::LimitWAPC& ESSPoint::limitwoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.limitWOperation)
  return _internal_limitwoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_limitwoperation(
    ::commonmodule::LimitWAPC* limitwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.limitWOperation)
}
inline ::commonmodule::LimitWAPC* ESSPoint::release_limitwoperation() {
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LimitWAPC* ESSPoint::unsafe_arena_release_limitwoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.limitWOperation)
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::LimitWAPC* ESSPoint::_internal_mutable_limitwoperation() {
  
  if (_impl_.limitwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LimitWAPC>(GetArenaForAllocation());
    _impl_.limitwoperation_ = p;
  }
  return _impl_.limitwoperation_;
}
inline ::commonmodule::LimitWAPC* ESSPoint::mutable_limitwoperation() {
  ::commonmodule::LimitWAPC* _msg = _internal_mutable_limitwoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.limitWOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  if (limitwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limitwoperation));
    if (message_arena != submessage_arena) {
      limitwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limitwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.limitWOperation)
}

// .commonmodule.PFSPC pFOperation = 19;
inline bool ESSPoint::_internal_has_pfoperation() const {
  return this != internal_default_instance() && _impl_.pfoperation_ != nullptr;
}
inline bool ESSPoint::has_pfoperation() const {
  return _internal_has_pfoperation();
}
inline const ::commonmodule::PFSPC& ESSPoint::_internal_pfoperation() const {
  const ::commonmodule::PFSPC* p = _impl_.pfoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PFSPC&>(
      ::commonmodule::_PFSPC_default_instance_);
}
inline const ::commonmodule::PFSPC& ESSPoint::pfoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.pFOperation)
  return _internal_pfoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_pfoperation(
    ::commonmodule::PFSPC* pfoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.pFOperation)
}
inline ::commonmodule::PFSPC* ESSPoint::release_pfoperation() {
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PFSPC* ESSPoint::unsafe_arena_release_pfoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.pFOperation)
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::PFSPC* ESSPoint::_internal_mutable_pfoperation() {
  
  if (_impl_.pfoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PFSPC>(GetArenaForAllocation());
    _impl_.pfoperation_ = p;
  }
  return _impl_.pfoperation_;
}
inline ::commonmodule::PFSPC* ESSPoint::mutable_pfoperation() {
  ::commonmodule::PFSPC* _msg = _internal_mutable_pfoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.pFOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  if (pfoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pfoperation));
    if (message_arena != submessage_arena) {
      pfoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pfoperation, submessage_arena);
    }

  } else {

  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.pFOperation)
}

// .commonmodule.TmHzCSG tmHzTripOperation = 20;
inline bool ESSPoint::_internal_has_tmhztripoperation() const {
  return this != internal_default_instance() && _impl_.tmhztripoperation_ != nullptr;
}
inline bool ESSPoint::has_tmhztripoperation() const {
  return _internal_has_tmhztripoperation();
}
inline const ::commonmodule::TmHzCSG& ESSPoint::_internal_tmhztripoperation() const {
  const ::commonmodule::TmHzCSG* p = _impl_.tmhztripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmHzCSG&>(
      ::commonmodule::_TmHzCSG_default_instance_);
}
inline const ::commonmodule::TmHzCSG& ESSPoint::tmhztripoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.tmHzTripOperation)
  return _internal_tmhztripoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_tmhztripoperation(
    ::commonmodule::TmHzCSG* tmhztripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.tmHzTripOperation)
}
inline ::commonmodule::TmHzCSG* ESSPoint::release_tmhztripoperation() {
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmHzCSG* ESSPoint::unsafe_arena_release_tmhztripoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.tmHzTripOperation)
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmHzCSG* ESSPoint::_internal_mutable_tmhztripoperation() {
  
  if (_impl_.tmhztripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmHzCSG>(GetArenaForAllocation());
    _impl_.tmhztripoperation_ = p;
  }
  return _impl_.tmhztripoperation_;
}
inline ::commonmodule::TmHzCSG* ESSPoint::mutable_tmhztripoperation() {
  ::commonmodule::TmHzCSG* _msg = _internal_mutable_tmhztripoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.tmHzTripOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  if (tmhztripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmhztripoperation));
    if (message_arena != submessage_arena) {
      tmhztripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmhztripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.tmHzTripOperation)
}

// .commonmodule.TmVoltCSG tmVoltTripOperation = 21;
inline bool ESSPoint::_internal_has_tmvolttripoperation() const {
  return this != internal_default_instance() && _impl_.tmvolttripoperation_ != nullptr;
}
inline bool ESSPoint::has_tmvolttripoperation() const {
  return _internal_has_tmvolttripoperation();
}
inline const ::commonmodule::TmVoltCSG& ESSPoint::_internal_tmvolttripoperation() const {
  const ::commonmodule::TmVoltCSG* p = _impl_.tmvolttripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmVoltCSG&>(
      ::commonmodule::_TmVoltCSG_default_instance_);
}
inline const ::commonmodule::TmVoltCSG& ESSPoint::tmvolttripoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.tmVoltTripOperation)
  return _internal_tmvolttripoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_tmvolttripoperation(
    ::commonmodule::TmVoltCSG* tmvolttripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.tmVoltTripOperation)
}
inline ::commonmodule::TmVoltCSG* ESSPoint::release_tmvolttripoperation() {
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmVoltCSG* ESSPoint::unsafe_arena_release_tmvolttripoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.tmVoltTripOperation)
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmVoltCSG* ESSPoint::_internal_mutable_tmvolttripoperation() {
  
  if (_impl_.tmvolttripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmVoltCSG>(GetArenaForAllocation());
    _impl_.tmvolttripoperation_ = p;
  }
  return _impl_.tmvolttripoperation_;
}
inline ::commonmodule::TmVoltCSG* ESSPoint::mutable_tmvolttripoperation() {
  ::commonmodule::TmVoltCSG* _msg = _internal_mutable_tmvolttripoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.tmVoltTripOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  if (tmvolttripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmvolttripoperation));
    if (message_arena != submessage_arena) {
      tmvolttripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmvolttripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.tmVoltTripOperation)
}

// .commonmodule.VarSPC vArOperation = 22;
inline bool ESSPoint::_internal_has_varoperation() const {
  return this != internal_default_instance() && _impl_.varoperation_ != nullptr;
}
inline bool ESSPoint::has_varoperation() const {
  return _internal_has_varoperation();
}
inline const ::commonmodule::VarSPC& ESSPoint::_internal_varoperation() const {
  const ::commonmodule::VarSPC* p = _impl_.varoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VarSPC&>(
      ::commonmodule::_VarSPC_default_instance_);
}
inline const ::commonmodule::VarSPC& ESSPoint::varoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.vArOperation)
  return _internal_varoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_varoperation(
    ::commonmodule::VarSPC* varoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.vArOperation)
}
inline ::commonmodule::VarSPC* ESSPoint::release_varoperation() {
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VarSPC* ESSPoint::unsafe_arena_release_varoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.vArOperation)
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VarSPC* ESSPoint::_internal_mutable_varoperation() {
  
  if (_impl_.varoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VarSPC>(GetArenaForAllocation());
    _impl_.varoperation_ = p;
  }
  return _impl_.varoperation_;
}
inline ::commonmodule::VarSPC* ESSPoint::mutable_varoperation() {
  ::commonmodule::VarSPC* _msg = _internal_mutable_varoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.vArOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_varoperation(::commonmodule::VarSPC* varoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  if (varoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(varoperation));
    if (message_arena != submessage_arena) {
      varoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varoperation, submessage_arena);
    }

  } else {

  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.vArOperation)
}

// .commonmodule.VoltVarCSG voltVarOperation = 23;
inline bool ESSPoint::_internal_has_voltvaroperation() const {
  return this != internal_default_instance() && _impl_.voltvaroperation_ != nullptr;
}
inline bool ESSPoint::has_voltvaroperation() const {
  return _internal_has_voltvaroperation();
}
inline const ::commonmodule::VoltVarCSG& ESSPoint::_internal_voltvaroperation() const {
  const ::commonmodule::VoltVarCSG* p = _impl_.voltvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltVarCSG&>(
      ::commonmodule::_VoltVarCSG_default_instance_);
}
inline const ::commonmodule::VoltVarCSG& ESSPoint::voltvaroperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.voltVarOperation)
  return _internal_voltvaroperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_voltvaroperation(
    ::commonmodule::VoltVarCSG* voltvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.voltVarOperation)
}
inline ::commonmodule::VoltVarCSG* ESSPoint::release_voltvaroperation() {
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltVarCSG* ESSPoint::unsafe_arena_release_voltvaroperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.voltVarOperation)
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltVarCSG* ESSPoint::_internal_mutable_voltvaroperation() {
  
  if (_impl_.voltvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltVarCSG>(GetArenaForAllocation());
    _impl_.voltvaroperation_ = p;
  }
  return _impl_.voltvaroperation_;
}
inline ::commonmodule::VoltVarCSG* ESSPoint::mutable_voltvaroperation() {
  ::commonmodule::VoltVarCSG* _msg = _internal_mutable_voltvaroperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.voltVarOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  if (voltvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltvaroperation));
    if (message_arena != submessage_arena) {
      voltvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.voltVarOperation)
}

// .commonmodule.VoltWCSG voltWOperation = 24;
inline bool ESSPoint::_internal_has_voltwoperation() const {
  return this != internal_default_instance() && _impl_.voltwoperation_ != nullptr;
}
inline bool ESSPoint::has_voltwoperation() const {
  return _internal_has_voltwoperation();
}
inline const ::commonmodule::VoltWCSG& ESSPoint::_internal_voltwoperation() const {
  const ::commonmodule::VoltWCSG* p = _impl_.voltwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltWCSG&>(
      ::commonmodule::_VoltWCSG_default_instance_);
}
inline const ::commonmodule::VoltWCSG& ESSPoint::voltwoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.voltWOperation)
  return _internal_voltwoperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_voltwoperation(
    ::commonmodule::VoltWCSG* voltwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.voltWOperation)
}
inline ::commonmodule::VoltWCSG* ESSPoint::release_voltwoperation() {
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltWCSG* ESSPoint::unsafe_arena_release_voltwoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.voltWOperation)
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltWCSG* ESSPoint::_internal_mutable_voltwoperation() {
  
  if (_impl_.voltwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltWCSG>(GetArenaForAllocation());
    _impl_.voltwoperation_ = p;
  }
  return _impl_.voltwoperation_;
}
inline ::commonmodule::VoltWCSG* ESSPoint::mutable_voltwoperation() {
  ::commonmodule::VoltWCSG* _msg = _internal_mutable_voltwoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.voltWOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  if (voltwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltwoperation));
    if (message_arena != submessage_arena) {
      voltwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.voltWOperation)
}

// .commonmodule.WVarCSG wVarOperation = 25;
inline bool ESSPoint::_internal_has_wvaroperation() const {
  return this != internal_default_instance() && _impl_.wvaroperation_ != nullptr;
}
inline bool ESSPoint::has_wvaroperation() const {
  return _internal_has_wvaroperation();
}
inline const ::commonmodule::WVarCSG& ESSPoint::_internal_wvaroperation() const {
  const ::commonmodule::WVarCSG* p = _impl_.wvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WVarCSG&>(
      ::commonmodule::_WVarCSG_default_instance_);
}
inline const ::commonmodule::WVarCSG& ESSPoint::wvaroperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.wVarOperation)
  return _internal_wvaroperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_wvaroperation(
    ::commonmodule::WVarCSG* wvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.wVarOperation)
}
inline ::commonmodule::WVarCSG* ESSPoint::release_wvaroperation() {
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WVarCSG* ESSPoint::unsafe_arena_release_wvaroperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.wVarOperation)
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WVarCSG* ESSPoint::_internal_mutable_wvaroperation() {
  
  if (_impl_.wvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WVarCSG>(GetArenaForAllocation());
    _impl_.wvaroperation_ = p;
  }
  return _impl_.wvaroperation_;
}
inline ::commonmodule::WVarCSG* ESSPoint::mutable_wvaroperation() {
  ::commonmodule::WVarCSG* _msg = _internal_mutable_wvaroperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.wVarOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  if (wvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wvaroperation));
    if (message_arena != submessage_arena) {
      wvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.wVarOperation)
}

// .commonmodule.WSPC wOperation = 26;
inline bool ESSPoint::_internal_has_woperation() const {
  return this != internal_default_instance() && _impl_.woperation_ != nullptr;
}
inline bool ESSPoint::has_woperation() const {
  return _internal_has_woperation();
}
inline const ::commonmodule::WSPC& ESSPoint::_internal_woperation() const {
  const ::commonmodule::WSPC* p = _impl_.woperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WSPC&>(
      ::commonmodule::_WSPC_default_instance_);
}
inline const ::commonmodule::WSPC& ESSPoint::woperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.wOperation)
  return _internal_woperation();
}
inline void ESSPoint::unsafe_arena_set_allocated_woperation(
    ::commonmodule::WSPC* woperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.woperation_);
  }
  _impl_.woperation_ = woperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPoint.wOperation)
}
inline ::commonmodule::WSPC* ESSPoint::release_woperation() {
  
  ::commonmodule::WSPC* temp = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WSPC* ESSPoint::unsafe_arena_release_woperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.wOperation)
  
  ::commonmodule::WSPC* temp = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WSPC* ESSPoint::_internal_mutable_woperation() {
  
  if (_impl_.woperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WSPC>(GetArenaForAllocation());
    _impl_.woperation_ = p;
  }
  return _impl_.woperation_;
}
inline ::commonmodule::WSPC* ESSPoint::mutable_woperation() {
  ::commonmodule::WSPC* _msg = _internal_mutable_woperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.wOperation)
  return _msg;
}
inline void ESSPoint::set_allocated_woperation(::commonmodule::WSPC* woperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.woperation_);
  }
  if (woperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(woperation));
    if (message_arena != submessage_arena) {
      woperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, woperation, submessage_arena);
    }

  } else {

  }
  _impl_.woperation_ = woperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.wOperation)
}

// -------------------------------------------------------------------

// ESSCurvePoint

// .essmodule.ESSPoint control = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCurvePoint::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool ESSCurvePoint::has_control() const {
  return _internal_has_control();
}
inline void ESSCurvePoint::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::essmodule::ESSPoint& ESSCurvePoint::_internal_control() const {
  const ::essmodule::ESSPoint* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSPoint&>(
      ::essmodule::_ESSPoint_default_instance_);
}
inline const ::essmodule::ESSPoint& ESSCurvePoint::control() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCurvePoint.control)
  return _internal_control();
}
inline void ESSCurvePoint::unsafe_arena_set_allocated_control(
    ::essmodule::ESSPoint* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCurvePoint.control)
}
inline ::essmodule::ESSPoint* ESSCurvePoint::release_control() {
  
  ::essmodule::ESSPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSPoint* ESSCurvePoint::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCurvePoint.control)
  
  ::essmodule::ESSPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::essmodule::ESSPoint* ESSCurvePoint::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSPoint>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::essmodule::ESSPoint* ESSCurvePoint::mutable_control() {
  ::essmodule::ESSPoint* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCurvePoint.control)
  return _msg;
}
inline void ESSCurvePoint::set_allocated_control(::essmodule::ESSPoint* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }

  } else {

  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCurvePoint.control)
}

// .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSCurvePoint::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool ESSCurvePoint::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::commonmodule::ControlTimestamp& ESSCurvePoint::_internal_starttime() const {
  const ::commonmodule::ControlTimestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlTimestamp&>(
      ::commonmodule::_ControlTimestamp_default_instance_);
}
inline const ::commonmodule::ControlTimestamp& ESSCurvePoint::starttime() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCurvePoint.startTime)
  return _internal_starttime();
}
inline void ESSCurvePoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::ControlTimestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSCurvePoint.startTime)
}
inline ::commonmodule::ControlTimestamp* ESSCurvePoint::release_starttime() {
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlTimestamp* ESSCurvePoint::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:essmodule.ESSCurvePoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* ESSCurvePoint::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::commonmodule::ControlTimestamp* ESSCurvePoint::mutable_starttime() {
  ::commonmodule::ControlTimestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCurvePoint.startTime)
  return _msg;
}
inline void ESSCurvePoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }

  } else {

  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSCurvePoint.startTime)
}

// -------------------------------------------------------------------

// ESSCSG

// repeated .essmodule.ESSCurvePoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int ESSCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int ESSCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void ESSCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::essmodule::ESSCurvePoint* ESSCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::essmodule::ESSCurvePoint >*
ESSCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:essmodule.ESSCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::essmodule::ESSCurvePoint& ESSCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::essmodule::ESSCurvePoint& ESSCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::essmodule::ESSCurvePoint* ESSCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::essmodule::ESSCurvePoint* ESSCSG::add_crvpts() {
  ::essmodule::ESSCurvePoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:essmodule.ESSCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::essmodule::ESSCurvePoint >&
ESSCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:essmodule.ESSCSG.crvPts)
  return _impl_.crvpts_;
}

// -------------------------------------------------------------------

// ESSControlScheduleFSCH

// .essmodule.ESSCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControlScheduleFSCH::_internal_has_valdcsg() const {
  return this != internal_default_instance() && _impl_.valdcsg_ != nullptr;
}
inline bool ESSControlScheduleFSCH::has_valdcsg() const {
  return _internal_has_valdcsg();
}
inline void ESSControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaForAllocation() == nullptr && _impl_.valdcsg_ != nullptr) {
    delete _impl_.valdcsg_;
  }
  _impl_.valdcsg_ = nullptr;
}
inline const ::essmodule::ESSCSG& ESSControlScheduleFSCH::_internal_valdcsg() const {
  const ::essmodule::ESSCSG* p = _impl_.valdcsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSCSG&>(
      ::essmodule::_ESSCSG_default_instance_);
}
inline const ::essmodule::ESSCSG& ESSControlScheduleFSCH::valdcsg() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSControlScheduleFSCH.ValDCSG)
  return _internal_valdcsg();
}
inline void ESSControlScheduleFSCH::unsafe_arena_set_allocated_valdcsg(
    ::essmodule::ESSCSG* valdcsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valdcsg_);
  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSControlScheduleFSCH.ValDCSG)
}
inline ::essmodule::ESSCSG* ESSControlScheduleFSCH::release_valdcsg() {
  
  ::essmodule::ESSCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSCSG* ESSControlScheduleFSCH::unsafe_arena_release_valdcsg() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlScheduleFSCH.ValDCSG)
  
  ::essmodule::ESSCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  return temp;
}
inline ::essmodule::ESSCSG* ESSControlScheduleFSCH::_internal_mutable_valdcsg() {
  
  if (_impl_.valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSCSG>(GetArenaForAllocation());
    _impl_.valdcsg_ = p;
  }
  return _impl_.valdcsg_;
}
inline ::essmodule::ESSCSG* ESSControlScheduleFSCH::mutable_valdcsg() {
  ::essmodule::ESSCSG* _msg = _internal_mutable_valdcsg();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlScheduleFSCH.ValDCSG)
  return _msg;
}
inline void ESSControlScheduleFSCH::set_allocated_valdcsg(::essmodule::ESSCSG* valdcsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.valdcsg_;
  }
  if (valdcsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(valdcsg);
    if (message_arena != submessage_arena) {
      valdcsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }

  } else {

  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// EssControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool EssControlFSCC::_internal_has_controlfscc() const {
  return this != internal_default_instance() && _impl_.controlfscc_ != nullptr;
}
inline bool EssControlFSCC::has_controlfscc() const {
  return _internal_has_controlfscc();
}
inline const ::commonmodule::ControlFSCC& EssControlFSCC::_internal_controlfscc() const {
  const ::commonmodule::ControlFSCC* p = _impl_.controlfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlFSCC&>(
      ::commonmodule::_ControlFSCC_default_instance_);
}
inline const ::commonmodule::ControlFSCC& EssControlFSCC::controlfscc() const {
  // @@protoc_insertion_point(field_get:essmodule.EssControlFSCC.controlFSCC)
  return _internal_controlfscc();
}
inline void EssControlFSCC::unsafe_arena_set_allocated_controlfscc(
    ::commonmodule::ControlFSCC* controlfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssControlFSCC.controlFSCC)
}
inline ::commonmodule::ControlFSCC* EssControlFSCC::release_controlfscc() {
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlFSCC* EssControlFSCC::unsafe_arena_release_controlfscc() {
  // @@protoc_insertion_point(field_release:essmodule.EssControlFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* EssControlFSCC::_internal_mutable_controlfscc() {
  
  if (_impl_.controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaForAllocation());
    _impl_.controlfscc_ = p;
  }
  return _impl_.controlfscc_;
}
inline ::commonmodule::ControlFSCC* EssControlFSCC::mutable_controlfscc() {
  ::commonmodule::ControlFSCC* _msg = _internal_mutable_controlfscc();
  // @@protoc_insertion_point(field_mutable:essmodule.EssControlFSCC.controlFSCC)
  return _msg;
}
inline void EssControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  if (controlfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlfscc));
    if (message_arena != submessage_arena) {
      controlfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }

  } else {

  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssControlFSCC.controlFSCC)
}

// .essmodule.ESSControlScheduleFSCH essControlScheduleFSCH = 2;
inline bool EssControlFSCC::_internal_has_esscontrolschedulefsch() const {
  return this != internal_default_instance() && _impl_.esscontrolschedulefsch_ != nullptr;
}
inline bool EssControlFSCC::has_esscontrolschedulefsch() const {
  return _internal_has_esscontrolschedulefsch();
}
inline void EssControlFSCC::clear_esscontrolschedulefsch() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscontrolschedulefsch_ != nullptr) {
    delete _impl_.esscontrolschedulefsch_;
  }
  _impl_.esscontrolschedulefsch_ = nullptr;
}
inline const ::essmodule::ESSControlScheduleFSCH& EssControlFSCC::_internal_esscontrolschedulefsch() const {
  const ::essmodule::ESSControlScheduleFSCH* p = _impl_.esscontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSControlScheduleFSCH&>(
      ::essmodule::_ESSControlScheduleFSCH_default_instance_);
}
inline const ::essmodule::ESSControlScheduleFSCH& EssControlFSCC::esscontrolschedulefsch() const {
  // @@protoc_insertion_point(field_get:essmodule.EssControlFSCC.essControlScheduleFSCH)
  return _internal_esscontrolschedulefsch();
}
inline void EssControlFSCC::unsafe_arena_set_allocated_esscontrolschedulefsch(
    ::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscontrolschedulefsch_);
  }
  _impl_.esscontrolschedulefsch_ = esscontrolschedulefsch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssControlFSCC.essControlScheduleFSCH)
}
inline ::essmodule::ESSControlScheduleFSCH* EssControlFSCC::release_esscontrolschedulefsch() {
  
  ::essmodule::ESSControlScheduleFSCH* temp = _impl_.esscontrolschedulefsch_;
  _impl_.esscontrolschedulefsch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSControlScheduleFSCH* EssControlFSCC::unsafe_arena_release_esscontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:essmodule.EssControlFSCC.essControlScheduleFSCH)
  
  ::essmodule::ESSControlScheduleFSCH* temp = _impl_.esscontrolschedulefsch_;
  _impl_.esscontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::essmodule::ESSControlScheduleFSCH* EssControlFSCC::_internal_mutable_esscontrolschedulefsch() {
  
  if (_impl_.esscontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSControlScheduleFSCH>(GetArenaForAllocation());
    _impl_.esscontrolschedulefsch_ = p;
  }
  return _impl_.esscontrolschedulefsch_;
}
inline ::essmodule::ESSControlScheduleFSCH* EssControlFSCC::mutable_esscontrolschedulefsch() {
  ::essmodule::ESSControlScheduleFSCH* _msg = _internal_mutable_esscontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:essmodule.EssControlFSCC.essControlScheduleFSCH)
  return _msg;
}
inline void EssControlFSCC::set_allocated_esscontrolschedulefsch(::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscontrolschedulefsch_;
  }
  if (esscontrolschedulefsch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscontrolschedulefsch);
    if (message_arena != submessage_arena) {
      esscontrolschedulefsch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscontrolschedulefsch, submessage_arena);
    }

  } else {

  }
  _impl_.esscontrolschedulefsch_ = esscontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssControlFSCC.essControlScheduleFSCH)
}

// -------------------------------------------------------------------

// ESSControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool ESSControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& ESSControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& ESSControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSControl.controlValue)
  return _internal_controlvalue();
}
inline void ESSControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSControl.controlValue)
}
inline ::commonmodule::ControlValue* ESSControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* ESSControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* ESSControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* ESSControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControl.controlValue)
  return _msg;
}
inline void ESSControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool ESSControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool ESSControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& ESSControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& ESSControl::check() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSControl.check)
  return _internal_check();
}
inline void ESSControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSControl.check)
}
inline ::commonmodule::CheckConditions* ESSControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* ESSControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* ESSControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* ESSControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControl.check)
  return _msg;
}
inline void ESSControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControl.check)
}

// .essmodule.EssControlFSCC essControlFSCC = 3;
inline bool ESSControl::_internal_has_esscontrolfscc() const {
  return this != internal_default_instance() && _impl_.esscontrolfscc_ != nullptr;
}
inline bool ESSControl::has_esscontrolfscc() const {
  return _internal_has_esscontrolfscc();
}
inline void ESSControl::clear_esscontrolfscc() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscontrolfscc_ != nullptr) {
    delete _impl_.esscontrolfscc_;
  }
  _impl_.esscontrolfscc_ = nullptr;
}
inline const ::essmodule::EssControlFSCC& ESSControl::_internal_esscontrolfscc() const {
  const ::essmodule::EssControlFSCC* p = _impl_.esscontrolfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::EssControlFSCC&>(
      ::essmodule::_EssControlFSCC_default_instance_);
}
inline const ::essmodule::EssControlFSCC& ESSControl::esscontrolfscc() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSControl.essControlFSCC)
  return _internal_esscontrolfscc();
}
inline void ESSControl::unsafe_arena_set_allocated_esscontrolfscc(
    ::essmodule::EssControlFSCC* esscontrolfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscontrolfscc_);
  }
  _impl_.esscontrolfscc_ = esscontrolfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSControl.essControlFSCC)
}
inline ::essmodule::EssControlFSCC* ESSControl::release_esscontrolfscc() {
  
  ::essmodule::EssControlFSCC* temp = _impl_.esscontrolfscc_;
  _impl_.esscontrolfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::EssControlFSCC* ESSControl::unsafe_arena_release_esscontrolfscc() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControl.essControlFSCC)
  
  ::essmodule::EssControlFSCC* temp = _impl_.esscontrolfscc_;
  _impl_.esscontrolfscc_ = nullptr;
  return temp;
}
inline ::essmodule::EssControlFSCC* ESSControl::_internal_mutable_esscontrolfscc() {
  
  if (_impl_.esscontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::EssControlFSCC>(GetArenaForAllocation());
    _impl_.esscontrolfscc_ = p;
  }
  return _impl_.esscontrolfscc_;
}
inline ::essmodule::EssControlFSCC* ESSControl::mutable_esscontrolfscc() {
  ::essmodule::EssControlFSCC* _msg = _internal_mutable_esscontrolfscc();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControl.essControlFSCC)
  return _msg;
}
inline void ESSControl::set_allocated_esscontrolfscc(::essmodule::EssControlFSCC* esscontrolfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscontrolfscc_;
  }
  if (esscontrolfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscontrolfscc);
    if (message_arena != submessage_arena) {
      esscontrolfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscontrolfscc, submessage_arena);
    }

  } else {

  }
  _impl_.esscontrolfscc_ = esscontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControl.essControlFSCC)
}

// -------------------------------------------------------------------

// ESSControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool ESSControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& ESSControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& ESSControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void ESSControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* ESSControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ESSControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ESSControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* ESSControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlProfile.controlMessageInfo)
  return _msg;
}
inline void ESSControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlProfile.controlMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControlProfile::_internal_has_ess() const {
  return this != internal_default_instance() && _impl_.ess_ != nullptr;
}
inline bool ESSControlProfile::has_ess() const {
  return _internal_has_ess();
}
inline const ::commonmodule::ESS& ESSControlProfile::_internal_ess() const {
  const ::commonmodule::ESS* p = _impl_.ess_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ESS&>(
      ::commonmodule::_ESS_default_instance_);
}
inline const ::commonmodule::ESS& ESSControlProfile::ess() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSControlProfile.ess)
  return _internal_ess();
}
inline void ESSControlProfile::unsafe_arena_set_allocated_ess(
    ::commonmodule::ESS* ess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSControlProfile.ess)
}
inline ::commonmodule::ESS* ESSControlProfile::release_ess() {
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ESS* ESSControlProfile::unsafe_arena_release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlProfile.ess)
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSControlProfile::_internal_mutable_ess() {
  
  if (_impl_.ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaForAllocation());
    _impl_.ess_ = p;
  }
  return _impl_.ess_;
}
inline ::commonmodule::ESS* ESSControlProfile::mutable_ess() {
  ::commonmodule::ESS* _msg = _internal_mutable_ess();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlProfile.ess)
  return _msg;
}
inline void ESSControlProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  if (ess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ess));
    if (message_arena != submessage_arena) {
      ess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }

  } else {

  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlProfile.ess)
}

// .essmodule.ESSControl essControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControlProfile::_internal_has_esscontrol() const {
  return this != internal_default_instance() && _impl_.esscontrol_ != nullptr;
}
inline bool ESSControlProfile::has_esscontrol() const {
  return _internal_has_esscontrol();
}
inline void ESSControlProfile::clear_esscontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.esscontrol_ != nullptr) {
    delete _impl_.esscontrol_;
  }
  _impl_.esscontrol_ = nullptr;
}
inline const ::essmodule::ESSControl& ESSControlProfile::_internal_esscontrol() const {
  const ::essmodule::ESSControl* p = _impl_.esscontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSControl&>(
      ::essmodule::_ESSControl_default_instance_);
}
inline const ::essmodule::ESSControl& ESSControlProfile::esscontrol() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSControlProfile.essControl)
  return _internal_esscontrol();
}
inline void ESSControlProfile::unsafe_arena_set_allocated_esscontrol(
    ::essmodule::ESSControl* esscontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esscontrol_);
  }
  _impl_.esscontrol_ = esscontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSControlProfile.essControl)
}
inline ::essmodule::ESSControl* ESSControlProfile::release_esscontrol() {
  
  ::essmodule::ESSControl* temp = _impl_.esscontrol_;
  _impl_.esscontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSControl* ESSControlProfile::unsafe_arena_release_esscontrol() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlProfile.essControl)
  
  ::essmodule::ESSControl* temp = _impl_.esscontrol_;
  _impl_.esscontrol_ = nullptr;
  return temp;
}
inline ::essmodule::ESSControl* ESSControlProfile::_internal_mutable_esscontrol() {
  
  if (_impl_.esscontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSControl>(GetArenaForAllocation());
    _impl_.esscontrol_ = p;
  }
  return _impl_.esscontrol_;
}
inline ::essmodule::ESSControl* ESSControlProfile::mutable_esscontrol() {
  ::essmodule::ESSControl* _msg = _internal_mutable_esscontrol();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlProfile.essControl)
  return _msg;
}
inline void ESSControlProfile::set_allocated_esscontrol(::essmodule::ESSControl* esscontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esscontrol_;
  }
  if (esscontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esscontrol);
    if (message_arena != submessage_arena) {
      esscontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esscontrol, submessage_arena);
    }

  } else {

  }
  _impl_.esscontrol_ = esscontrol;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlProfile.essControl)
}

// -------------------------------------------------------------------

// ESSDiscreteControlDBAT

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool ESSDiscreteControlDBAT::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && _impl_.logicalnodeforcontrol_ != nullptr;
}
inline bool ESSDiscreteControlDBAT::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline const ::commonmodule::LogicalNodeForControl& ESSDiscreteControlDBAT::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& ESSDiscreteControlDBAT::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControlDBAT.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void ESSDiscreteControlDBAT::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControlDBAT.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* ESSDiscreteControlDBAT::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* ESSDiscreteControlDBAT::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControlDBAT.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* ESSDiscreteControlDBAT::_internal_mutable_logicalnodeforcontrol() {
  
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaForAllocation());
    _impl_.logicalnodeforcontrol_ = p;
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* ESSDiscreteControlDBAT::mutable_logicalnodeforcontrol() {
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControlDBAT.logicalNodeForControl)
  return _msg;
}
inline void ESSDiscreteControlDBAT::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol));
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControlDBAT.logicalNodeForControl)
}

// .essmodule.ESSPoint control = 2;
inline bool ESSDiscreteControlDBAT::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool ESSDiscreteControlDBAT::has_control() const {
  return _internal_has_control();
}
inline void ESSDiscreteControlDBAT::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::essmodule::ESSPoint& ESSDiscreteControlDBAT::_internal_control() const {
  const ::essmodule::ESSPoint* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSPoint&>(
      ::essmodule::_ESSPoint_default_instance_);
}
inline const ::essmodule::ESSPoint& ESSDiscreteControlDBAT::control() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControlDBAT.control)
  return _internal_control();
}
inline void ESSDiscreteControlDBAT::unsafe_arena_set_allocated_control(
    ::essmodule::ESSPoint* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControlDBAT.control)
}
inline ::essmodule::ESSPoint* ESSDiscreteControlDBAT::release_control() {
  
  ::essmodule::ESSPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSPoint* ESSDiscreteControlDBAT::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControlDBAT.control)
  
  ::essmodule::ESSPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::essmodule::ESSPoint* ESSDiscreteControlDBAT::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSPoint>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::essmodule::ESSPoint* ESSDiscreteControlDBAT::mutable_control() {
  ::essmodule::ESSPoint* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControlDBAT.control)
  return _msg;
}
inline void ESSDiscreteControlDBAT::set_allocated_control(::essmodule::ESSPoint* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }

  } else {

  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControlDBAT.control)
}

// -------------------------------------------------------------------

// ESSDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSDiscreteControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool ESSDiscreteControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& ESSDiscreteControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& ESSDiscreteControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControl.controlValue)
  return _internal_controlvalue();
}
inline void ESSDiscreteControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControl.controlValue)
}
inline ::commonmodule::ControlValue* ESSDiscreteControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* ESSDiscreteControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* ESSDiscreteControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* ESSDiscreteControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControl.controlValue)
  return _msg;
}
inline void ESSDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool ESSDiscreteControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool ESSDiscreteControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& ESSDiscreteControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& ESSDiscreteControl::check() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControl.check)
  return _internal_check();
}
inline void ESSDiscreteControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControl.check)
}
inline ::commonmodule::CheckConditions* ESSDiscreteControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* ESSDiscreteControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* ESSDiscreteControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* ESSDiscreteControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControl.check)
  return _msg;
}
inline void ESSDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControl.check)
}

// .essmodule.ESSDiscreteControlDBAT essDiscreteControlDBAT = 3;
inline bool ESSDiscreteControl::_internal_has_essdiscretecontroldbat() const {
  return this != internal_default_instance() && _impl_.essdiscretecontroldbat_ != nullptr;
}
inline bool ESSDiscreteControl::has_essdiscretecontroldbat() const {
  return _internal_has_essdiscretecontroldbat();
}
inline void ESSDiscreteControl::clear_essdiscretecontroldbat() {
  if (GetArenaForAllocation() == nullptr && _impl_.essdiscretecontroldbat_ != nullptr) {
    delete _impl_.essdiscretecontroldbat_;
  }
  _impl_.essdiscretecontroldbat_ = nullptr;
}
inline const ::essmodule::ESSDiscreteControlDBAT& ESSDiscreteControl::_internal_essdiscretecontroldbat() const {
  const ::essmodule::ESSDiscreteControlDBAT* p = _impl_.essdiscretecontroldbat_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSDiscreteControlDBAT&>(
      ::essmodule::_ESSDiscreteControlDBAT_default_instance_);
}
inline const ::essmodule::ESSDiscreteControlDBAT& ESSDiscreteControl::essdiscretecontroldbat() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControl.essDiscreteControlDBAT)
  return _internal_essdiscretecontroldbat();
}
inline void ESSDiscreteControl::unsafe_arena_set_allocated_essdiscretecontroldbat(
    ::essmodule::ESSDiscreteControlDBAT* essdiscretecontroldbat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.essdiscretecontroldbat_);
  }
  _impl_.essdiscretecontroldbat_ = essdiscretecontroldbat;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControl.essDiscreteControlDBAT)
}
inline ::essmodule::ESSDiscreteControlDBAT* ESSDiscreteControl::release_essdiscretecontroldbat() {
  
  ::essmodule::ESSDiscreteControlDBAT* temp = _impl_.essdiscretecontroldbat_;
  _impl_.essdiscretecontroldbat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSDiscreteControlDBAT* ESSDiscreteControl::unsafe_arena_release_essdiscretecontroldbat() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControl.essDiscreteControlDBAT)
  
  ::essmodule::ESSDiscreteControlDBAT* temp = _impl_.essdiscretecontroldbat_;
  _impl_.essdiscretecontroldbat_ = nullptr;
  return temp;
}
inline ::essmodule::ESSDiscreteControlDBAT* ESSDiscreteControl::_internal_mutable_essdiscretecontroldbat() {
  
  if (_impl_.essdiscretecontroldbat_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSDiscreteControlDBAT>(GetArenaForAllocation());
    _impl_.essdiscretecontroldbat_ = p;
  }
  return _impl_.essdiscretecontroldbat_;
}
inline ::essmodule::ESSDiscreteControlDBAT* ESSDiscreteControl::mutable_essdiscretecontroldbat() {
  ::essmodule::ESSDiscreteControlDBAT* _msg = _internal_mutable_essdiscretecontroldbat();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControl.essDiscreteControlDBAT)
  return _msg;
}
inline void ESSDiscreteControl::set_allocated_essdiscretecontroldbat(::essmodule::ESSDiscreteControlDBAT* essdiscretecontroldbat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.essdiscretecontroldbat_;
  }
  if (essdiscretecontroldbat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(essdiscretecontroldbat);
    if (message_arena != submessage_arena) {
      essdiscretecontroldbat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, essdiscretecontroldbat, submessage_arena);
    }

  } else {

  }
  _impl_.essdiscretecontroldbat_ = essdiscretecontroldbat;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControl.essDiscreteControlDBAT)
}

// -------------------------------------------------------------------

// ESSDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSDiscreteControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool ESSDiscreteControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& ESSDiscreteControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& ESSDiscreteControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void ESSDiscreteControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* ESSDiscreteControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ESSDiscreteControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ESSDiscreteControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* ESSDiscreteControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControlProfile.controlMessageInfo)
  return _msg;
}
inline void ESSDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControlProfile.controlMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSDiscreteControlProfile::_internal_has_ess() const {
  return this != internal_default_instance() && _impl_.ess_ != nullptr;
}
inline bool ESSDiscreteControlProfile::has_ess() const {
  return _internal_has_ess();
}
inline const ::commonmodule::ESS& ESSDiscreteControlProfile::_internal_ess() const {
  const ::commonmodule::ESS* p = _impl_.ess_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ESS&>(
      ::commonmodule::_ESS_default_instance_);
}
inline const ::commonmodule::ESS& ESSDiscreteControlProfile::ess() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControlProfile.ess)
  return _internal_ess();
}
inline void ESSDiscreteControlProfile::unsafe_arena_set_allocated_ess(
    ::commonmodule::ESS* ess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControlProfile.ess)
}
inline ::commonmodule::ESS* ESSDiscreteControlProfile::release_ess() {
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ESS* ESSDiscreteControlProfile::unsafe_arena_release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControlProfile.ess)
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSDiscreteControlProfile::_internal_mutable_ess() {
  
  if (_impl_.ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaForAllocation());
    _impl_.ess_ = p;
  }
  return _impl_.ess_;
}
inline ::commonmodule::ESS* ESSDiscreteControlProfile::mutable_ess() {
  ::commonmodule::ESS* _msg = _internal_mutable_ess();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControlProfile.ess)
  return _msg;
}
inline void ESSDiscreteControlProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  if (ess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ess));
    if (message_arena != submessage_arena) {
      ess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }

  } else {

  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControlProfile.ess)
}

// .essmodule.ESSDiscreteControl essDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSDiscreteControlProfile::_internal_has_essdiscretecontrol() const {
  return this != internal_default_instance() && _impl_.essdiscretecontrol_ != nullptr;
}
inline bool ESSDiscreteControlProfile::has_essdiscretecontrol() const {
  return _internal_has_essdiscretecontrol();
}
inline void ESSDiscreteControlProfile::clear_essdiscretecontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.essdiscretecontrol_ != nullptr) {
    delete _impl_.essdiscretecontrol_;
  }
  _impl_.essdiscretecontrol_ = nullptr;
}
inline const ::essmodule::ESSDiscreteControl& ESSDiscreteControlProfile::_internal_essdiscretecontrol() const {
  const ::essmodule::ESSDiscreteControl* p = _impl_.essdiscretecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSDiscreteControl&>(
      ::essmodule::_ESSDiscreteControl_default_instance_);
}
inline const ::essmodule::ESSDiscreteControl& ESSDiscreteControlProfile::essdiscretecontrol() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSDiscreteControlProfile.essDiscreteControl)
  return _internal_essdiscretecontrol();
}
inline void ESSDiscreteControlProfile::unsafe_arena_set_allocated_essdiscretecontrol(
    ::essmodule::ESSDiscreteControl* essdiscretecontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.essdiscretecontrol_);
  }
  _impl_.essdiscretecontrol_ = essdiscretecontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSDiscreteControlProfile.essDiscreteControl)
}
inline ::essmodule::ESSDiscreteControl* ESSDiscreteControlProfile::release_essdiscretecontrol() {
  
  ::essmodule::ESSDiscreteControl* temp = _impl_.essdiscretecontrol_;
  _impl_.essdiscretecontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSDiscreteControl* ESSDiscreteControlProfile::unsafe_arena_release_essdiscretecontrol() {
  // @@protoc_insertion_point(field_release:essmodule.ESSDiscreteControlProfile.essDiscreteControl)
  
  ::essmodule::ESSDiscreteControl* temp = _impl_.essdiscretecontrol_;
  _impl_.essdiscretecontrol_ = nullptr;
  return temp;
}
inline ::essmodule::ESSDiscreteControl* ESSDiscreteControlProfile::_internal_mutable_essdiscretecontrol() {
  
  if (_impl_.essdiscretecontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSDiscreteControl>(GetArenaForAllocation());
    _impl_.essdiscretecontrol_ = p;
  }
  return _impl_.essdiscretecontrol_;
}
inline ::essmodule::ESSDiscreteControl* ESSDiscreteControlProfile::mutable_essdiscretecontrol() {
  ::essmodule::ESSDiscreteControl* _msg = _internal_mutable_essdiscretecontrol();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSDiscreteControlProfile.essDiscreteControl)
  return _msg;
}
inline void ESSDiscreteControlProfile::set_allocated_essdiscretecontrol(::essmodule::ESSDiscreteControl* essdiscretecontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.essdiscretecontrol_;
  }
  if (essdiscretecontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(essdiscretecontrol);
    if (message_arena != submessage_arena) {
      essdiscretecontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, essdiscretecontrol, submessage_arena);
    }

  } else {

  }
  _impl_.essdiscretecontrol_ = essdiscretecontrol;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSDiscreteControlProfile.essDiscreteControl)
}

// -------------------------------------------------------------------

// EssEventZBAT

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EssEventZBAT::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool EssEventZBAT::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EssEventZBAT::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EssEventZBAT::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssEventZBAT::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssEventZBAT::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssEventZBAT::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssEventZBAT::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
  return _msg;
}
inline void EssEventZBAT::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS BatHi = 2;
inline bool EssEventZBAT::_internal_has_bathi() const {
  return this != internal_default_instance() && _impl_.bathi_ != nullptr;
}
inline bool EssEventZBAT::has_bathi() const {
  return _internal_has_bathi();
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::_internal_bathi() const {
  const ::commonmodule::StatusSPS* p = _impl_.bathi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::bathi() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.BatHi)
  return _internal_bathi();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_bathi(
    ::commonmodule::StatusSPS* bathi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bathi_);
  }
  _impl_.bathi_ = bathi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.BatHi)
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_bathi() {
  
  ::commonmodule::StatusSPS* temp = _impl_.bathi_;
  _impl_.bathi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::unsafe_arena_release_bathi() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.BatHi)
  
  ::commonmodule::StatusSPS* temp = _impl_.bathi_;
  _impl_.bathi_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::_internal_mutable_bathi() {
  
  if (_impl_.bathi_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.bathi_ = p;
  }
  return _impl_.bathi_;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_bathi() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_bathi();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.BatHi)
  return _msg;
}
inline void EssEventZBAT::set_allocated_bathi(::commonmodule::StatusSPS* bathi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bathi_);
  }
  if (bathi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bathi));
    if (message_arena != submessage_arena) {
      bathi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bathi, submessage_arena);
    }

  } else {

  }
  _impl_.bathi_ = bathi;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.BatHi)
}

// .commonmodule.StatusSPS BatLo = 3;
inline bool EssEventZBAT::_internal_has_batlo() const {
  return this != internal_default_instance() && _impl_.batlo_ != nullptr;
}
inline bool EssEventZBAT::has_batlo() const {
  return _internal_has_batlo();
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::_internal_batlo() const {
  const ::commonmodule::StatusSPS* p = _impl_.batlo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::batlo() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.BatLo)
  return _internal_batlo();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_batlo(
    ::commonmodule::StatusSPS* batlo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batlo_);
  }
  _impl_.batlo_ = batlo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.BatLo)
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_batlo() {
  
  ::commonmodule::StatusSPS* temp = _impl_.batlo_;
  _impl_.batlo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::unsafe_arena_release_batlo() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.BatLo)
  
  ::commonmodule::StatusSPS* temp = _impl_.batlo_;
  _impl_.batlo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::_internal_mutable_batlo() {
  
  if (_impl_.batlo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.batlo_ = p;
  }
  return _impl_.batlo_;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_batlo() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_batlo();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.BatLo)
  return _msg;
}
inline void EssEventZBAT::set_allocated_batlo(::commonmodule::StatusSPS* batlo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batlo_);
  }
  if (batlo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batlo));
    if (message_arena != submessage_arena) {
      batlo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batlo, submessage_arena);
    }

  } else {

  }
  _impl_.batlo_ = batlo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.BatLo)
}

// .commonmodule.StatusSPS BatSt = 4;
inline bool EssEventZBAT::_internal_has_batst() const {
  return this != internal_default_instance() && _impl_.batst_ != nullptr;
}
inline bool EssEventZBAT::has_batst() const {
  return _internal_has_batst();
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::_internal_batst() const {
  const ::commonmodule::StatusSPS* p = _impl_.batst_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::batst() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.BatSt)
  return _internal_batst();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_batst(
    ::commonmodule::StatusSPS* batst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batst_);
  }
  _impl_.batst_ = batst;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.BatSt)
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_batst() {
  
  ::commonmodule::StatusSPS* temp = _impl_.batst_;
  _impl_.batst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::unsafe_arena_release_batst() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.BatSt)
  
  ::commonmodule::StatusSPS* temp = _impl_.batst_;
  _impl_.batst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::_internal_mutable_batst() {
  
  if (_impl_.batst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.batst_ = p;
  }
  return _impl_.batst_;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_batst() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_batst();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.BatSt)
  return _msg;
}
inline void EssEventZBAT::set_allocated_batst(::commonmodule::StatusSPS* batst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batst_);
  }
  if (batst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batst));
    if (message_arena != submessage_arena) {
      batst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batst, submessage_arena);
    }

  } else {

  }
  _impl_.batst_ = batst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.BatSt)
}

// .commonmodule.MV Soc = 5;
inline bool EssEventZBAT::_internal_has_soc() const {
  return this != internal_default_instance() && _impl_.soc_ != nullptr;
}
inline bool EssEventZBAT::has_soc() const {
  return _internal_has_soc();
}
inline const ::commonmodule::MV& EssEventZBAT::_internal_soc() const {
  const ::commonmodule::MV* p = _impl_.soc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EssEventZBAT::soc() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.Soc)
  return _internal_soc();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_soc(
    ::commonmodule::MV* soc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soc_);
  }
  _impl_.soc_ = soc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.Soc)
}
inline ::commonmodule::MV* EssEventZBAT::release_soc() {
  
  ::commonmodule::MV* temp = _impl_.soc_;
  _impl_.soc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* EssEventZBAT::unsafe_arena_release_soc() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.Soc)
  
  ::commonmodule::MV* temp = _impl_.soc_;
  _impl_.soc_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssEventZBAT::_internal_mutable_soc() {
  
  if (_impl_.soc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.soc_ = p;
  }
  return _impl_.soc_;
}
inline ::commonmodule::MV* EssEventZBAT::mutable_soc() {
  ::commonmodule::MV* _msg = _internal_mutable_soc();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.Soc)
  return _msg;
}
inline void EssEventZBAT::set_allocated_soc(::commonmodule::MV* soc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soc_);
  }
  if (soc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soc));
    if (message_arena != submessage_arena) {
      soc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soc, submessage_arena);
    }

  } else {

  }
  _impl_.soc_ = soc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.Soc)
}

// .commonmodule.StatusSPS Stdby = 6;
inline bool EssEventZBAT::_internal_has_stdby() const {
  return this != internal_default_instance() && _impl_.stdby_ != nullptr;
}
inline bool EssEventZBAT::has_stdby() const {
  return _internal_has_stdby();
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::_internal_stdby() const {
  const ::commonmodule::StatusSPS* p = _impl_.stdby_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::stdby() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.Stdby)
  return _internal_stdby();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_stdby(
    ::commonmodule::StatusSPS* stdby) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stdby_);
  }
  _impl_.stdby_ = stdby;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.Stdby)
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_stdby() {
  
  ::commonmodule::StatusSPS* temp = _impl_.stdby_;
  _impl_.stdby_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::unsafe_arena_release_stdby() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.Stdby)
  
  ::commonmodule::StatusSPS* temp = _impl_.stdby_;
  _impl_.stdby_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::_internal_mutable_stdby() {
  
  if (_impl_.stdby_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.stdby_ = p;
  }
  return _impl_.stdby_;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_stdby() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_stdby();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.Stdby)
  return _msg;
}
inline void EssEventZBAT::set_allocated_stdby(::commonmodule::StatusSPS* stdby) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stdby_);
  }
  if (stdby) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stdby));
    if (message_arena != submessage_arena) {
      stdby = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stdby, submessage_arena);
    }

  } else {

  }
  _impl_.stdby_ = stdby;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.Stdby)
}

// .commonmodule.MV SoH = 7;
inline bool EssEventZBAT::_internal_has_soh() const {
  return this != internal_default_instance() && _impl_.soh_ != nullptr;
}
inline bool EssEventZBAT::has_soh() const {
  return _internal_has_soh();
}
inline const ::commonmodule::MV& EssEventZBAT::_internal_soh() const {
  const ::commonmodule::MV* p = _impl_.soh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EssEventZBAT::soh() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.SoH)
  return _internal_soh();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_soh(
    ::commonmodule::MV* soh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soh_);
  }
  _impl_.soh_ = soh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.SoH)
}
inline ::commonmodule::MV* EssEventZBAT::release_soh() {
  
  ::commonmodule::MV* temp = _impl_.soh_;
  _impl_.soh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* EssEventZBAT::unsafe_arena_release_soh() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.SoH)
  
  ::commonmodule::MV* temp = _impl_.soh_;
  _impl_.soh_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssEventZBAT::_internal_mutable_soh() {
  
  if (_impl_.soh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.soh_ = p;
  }
  return _impl_.soh_;
}
inline ::commonmodule::MV* EssEventZBAT::mutable_soh() {
  ::commonmodule::MV* _msg = _internal_mutable_soh();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.SoH)
  return _msg;
}
inline void EssEventZBAT::set_allocated_soh(::commonmodule::MV* soh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soh_);
  }
  if (soh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soh));
    if (message_arena != submessage_arena) {
      soh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soh, submessage_arena);
    }

  } else {

  }
  _impl_.soh_ = soh;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.SoH)
}

// .commonmodule.MV WHAvail = 8;
inline bool EssEventZBAT::_internal_has_whavail() const {
  return this != internal_default_instance() && _impl_.whavail_ != nullptr;
}
inline bool EssEventZBAT::has_whavail() const {
  return _internal_has_whavail();
}
inline const ::commonmodule::MV& EssEventZBAT::_internal_whavail() const {
  const ::commonmodule::MV* p = _impl_.whavail_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EssEventZBAT::whavail() const {
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.WHAvail)
  return _internal_whavail();
}
inline void EssEventZBAT::unsafe_arena_set_allocated_whavail(
    ::commonmodule::MV* whavail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.whavail_);
  }
  _impl_.whavail_ = whavail;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssEventZBAT.WHAvail)
}
inline ::commonmodule::MV* EssEventZBAT::release_whavail() {
  
  ::commonmodule::MV* temp = _impl_.whavail_;
  _impl_.whavail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* EssEventZBAT::unsafe_arena_release_whavail() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.WHAvail)
  
  ::commonmodule::MV* temp = _impl_.whavail_;
  _impl_.whavail_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssEventZBAT::_internal_mutable_whavail() {
  
  if (_impl_.whavail_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.whavail_ = p;
  }
  return _impl_.whavail_;
}
inline ::commonmodule::MV* EssEventZBAT::mutable_whavail() {
  ::commonmodule::MV* _msg = _internal_mutable_whavail();
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.WHAvail)
  return _msg;
}
inline void EssEventZBAT::set_allocated_whavail(::commonmodule::MV* whavail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.whavail_);
  }
  if (whavail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(whavail));
    if (message_arena != submessage_arena) {
      whavail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, whavail, submessage_arena);
    }

  } else {

  }
  _impl_.whavail_ = whavail;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.WHAvail)
}

// -------------------------------------------------------------------

// ESSPointStatus

// .commonmodule.StatusSPS blackStartEnabled = 1;
inline bool ESSPointStatus::_internal_has_blackstartenabled() const {
  return this != internal_default_instance() && _impl_.blackstartenabled_ != nullptr;
}
inline bool ESSPointStatus::has_blackstartenabled() const {
  return _internal_has_blackstartenabled();
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::_internal_blackstartenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.blackstartenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::blackstartenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.blackStartEnabled)
  return _internal_blackstartenabled();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_blackstartenabled(
    ::commonmodule::StatusSPS* blackstartenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.blackStartEnabled)
}
inline ::commonmodule::StatusSPS* ESSPointStatus::release_blackstartenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::unsafe_arena_release_blackstartenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.blackStartEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::_internal_mutable_blackstartenabled() {
  
  if (_impl_.blackstartenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.blackstartenabled_ = p;
  }
  return _impl_.blackstartenabled_;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::mutable_blackstartenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_blackstartenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.blackStartEnabled)
  return _msg;
}
inline void ESSPointStatus::set_allocated_blackstartenabled(::commonmodule::StatusSPS* blackstartenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  if (blackstartenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blackstartenabled));
    if (message_arena != submessage_arena) {
      blackstartenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blackstartenabled, submessage_arena);
    }

  } else {

  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.blackStartEnabled)
}

// .commonmodule.StatusSPS frequencySetPointEnabled = 2;
inline bool ESSPointStatus::_internal_has_frequencysetpointenabled() const {
  return this != internal_default_instance() && _impl_.frequencysetpointenabled_ != nullptr;
}
inline bool ESSPointStatus::has_frequencysetpointenabled() const {
  return _internal_has_frequencysetpointenabled();
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::_internal_frequencysetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.frequencysetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::frequencysetpointenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.frequencySetPointEnabled)
  return _internal_frequencysetpointenabled();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_frequencysetpointenabled(
    ::commonmodule::StatusSPS* frequencysetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpointenabled_);
  }
  _impl_.frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.frequencySetPointEnabled)
}
inline ::commonmodule::StatusSPS* ESSPointStatus::release_frequencysetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.frequencysetpointenabled_;
  _impl_.frequencysetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::unsafe_arena_release_frequencysetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.frequencySetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.frequencysetpointenabled_;
  _impl_.frequencysetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::_internal_mutable_frequencysetpointenabled() {
  
  if (_impl_.frequencysetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.frequencysetpointenabled_ = p;
  }
  return _impl_.frequencysetpointenabled_;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::mutable_frequencysetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_frequencysetpointenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.frequencySetPointEnabled)
  return _msg;
}
inline void ESSPointStatus::set_allocated_frequencysetpointenabled(::commonmodule::StatusSPS* frequencysetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpointenabled_);
  }
  if (frequencysetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequencysetpointenabled));
    if (message_arena != submessage_arena) {
      frequencysetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencysetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.frequencySetPointEnabled)
}

// .essmodule.ESSFunction function = 3;
inline bool ESSPointStatus::_internal_has_function() const {
  return this != internal_default_instance() && _impl_.function_ != nullptr;
}
inline bool ESSPointStatus::has_function() const {
  return _internal_has_function();
}
inline void ESSPointStatus::clear_function() {
  if (GetArenaForAllocation() == nullptr && _impl_.function_ != nullptr) {
    delete _impl_.function_;
  }
  _impl_.function_ = nullptr;
}
inline const ::essmodule::ESSFunction& ESSPointStatus::_internal_function() const {
  const ::essmodule::ESSFunction* p = _impl_.function_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSFunction&>(
      ::essmodule::_ESSFunction_default_instance_);
}
inline const ::essmodule::ESSFunction& ESSPointStatus::function() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.function)
  return _internal_function();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_function(
    ::essmodule::ESSFunction* function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.function_);
  }
  _impl_.function_ = function;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.function)
}
inline ::essmodule::ESSFunction* ESSPointStatus::release_function() {
  
  ::essmodule::ESSFunction* temp = _impl_.function_;
  _impl_.function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSFunction* ESSPointStatus::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.function)
  
  ::essmodule::ESSFunction* temp = _impl_.function_;
  _impl_.function_ = nullptr;
  return temp;
}
inline ::essmodule::ESSFunction* ESSPointStatus::_internal_mutable_function() {
  
  if (_impl_.function_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSFunction>(GetArenaForAllocation());
    _impl_.function_ = p;
  }
  return _impl_.function_;
}
inline ::essmodule::ESSFunction* ESSPointStatus::mutable_function() {
  ::essmodule::ESSFunction* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.function)
  return _msg;
}
inline void ESSPointStatus::set_allocated_function(::essmodule::ESSFunction* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }

  } else {

  }
  _impl_.function_ = function;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.function)
}

// .commonmodule.ENG_GridConnectModeKind mode = 4;
inline bool ESSPointStatus::_internal_has_mode() const {
  return this != internal_default_instance() && _impl_.mode_ != nullptr;
}
inline bool ESSPointStatus::has_mode() const {
  return _internal_has_mode();
}
inline const ::commonmodule::ENG_GridConnectModeKind& ESSPointStatus::_internal_mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(
      ::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& ESSPointStatus::mode() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.mode)
  return _internal_mode();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_mode(
    ::commonmodule::ENG_GridConnectModeKind* mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.mode)
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPointStatus::release_mode() {
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPointStatus::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPointStatus::_internal_mutable_mode() {
  
  if (_impl_.mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaForAllocation());
    _impl_.mode_ = p;
  }
  return _impl_.mode_;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPointStatus::mutable_mode() {
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.mode)
  return _msg;
}
inline void ESSPointStatus::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mode_);
  }
  if (mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mode));
    if (message_arena != submessage_arena) {
      mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }

  } else {

  }
  _impl_.mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.mode)
}

// .google.protobuf.FloatValue pctHzDroop = 5;
inline bool ESSPointStatus::_internal_has_pcthzdroop() const {
  return this != internal_default_instance() && _impl_.pcthzdroop_ != nullptr;
}
inline bool ESSPointStatus::has_pcthzdroop() const {
  return _internal_has_pcthzdroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& ESSPointStatus::_internal_pcthzdroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pcthzdroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& ESSPointStatus::pcthzdroop() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.pctHzDroop)
  return _internal_pcthzdroop();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_pcthzdroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pcthzdroop_);
  }
  _impl_.pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.pctHzDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::release_pcthzdroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pcthzdroop_;
  _impl_.pcthzdroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::unsafe_arena_release_pcthzdroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.pctHzDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pcthzdroop_;
  _impl_.pcthzdroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::_internal_mutable_pcthzdroop() {
  
  if (_impl_.pcthzdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pcthzdroop_ = p;
  }
  return _impl_.pcthzdroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::mutable_pcthzdroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pcthzdroop();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.pctHzDroop)
  return _msg;
}
inline void ESSPointStatus::set_allocated_pcthzdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pcthzdroop_);
  }
  if (pcthzdroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcthzdroop));
    if (message_arena != submessage_arena) {
      pcthzdroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pcthzdroop, submessage_arena);
    }

  } else {

  }
  _impl_.pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.pctHzDroop)
}

// .google.protobuf.FloatValue pctVDroop = 6;
inline bool ESSPointStatus::_internal_has_pctvdroop() const {
  return this != internal_default_instance() && _impl_.pctvdroop_ != nullptr;
}
inline bool ESSPointStatus::has_pctvdroop() const {
  return _internal_has_pctvdroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& ESSPointStatus::_internal_pctvdroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pctvdroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& ESSPointStatus::pctvdroop() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.pctVDroop)
  return _internal_pctvdroop();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_pctvdroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pctvdroop_);
  }
  _impl_.pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.pctVDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::release_pctvdroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pctvdroop_;
  _impl_.pctvdroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::unsafe_arena_release_pctvdroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.pctVDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pctvdroop_;
  _impl_.pctvdroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::_internal_mutable_pctvdroop() {
  
  if (_impl_.pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pctvdroop_ = p;
  }
  return _impl_.pctvdroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* ESSPointStatus::mutable_pctvdroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pctvdroop();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.pctVDroop)
  return _msg;
}
inline void ESSPointStatus::set_allocated_pctvdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pctvdroop_);
  }
  if (pctvdroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pctvdroop));
    if (message_arena != submessage_arena) {
      pctvdroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }

  } else {

  }
  _impl_.pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.pctVDroop)
}

// .commonmodule.RampRate rampRates = 7;
inline bool ESSPointStatus::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool ESSPointStatus::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& ESSPointStatus::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& ESSPointStatus::ramprates() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.rampRates)
  return _internal_ramprates();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.rampRates)
}
inline ::commonmodule::RampRate* ESSPointStatus::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* ESSPointStatus::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* ESSPointStatus::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* ESSPointStatus::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.rampRates)
  return _msg;
}
inline void ESSPointStatus::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.rampRates)
}

// .commonmodule.StatusSPS reactivePwrSetPointEnabled = 8;
inline bool ESSPointStatus::_internal_has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.reactivepwrsetpointenabled_ != nullptr;
}
inline bool ESSPointStatus::has_reactivepwrsetpointenabled() const {
  return _internal_has_reactivepwrsetpointenabled();
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::_internal_reactivepwrsetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.reactivepwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::reactivepwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
  return _internal_reactivepwrsetpointenabled();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_reactivepwrsetpointenabled(
    ::commonmodule::StatusSPS* reactivepwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
}
inline ::commonmodule::StatusSPS* ESSPointStatus::release_reactivepwrsetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::unsafe_arena_release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::_internal_mutable_reactivepwrsetpointenabled() {
  
  if (_impl_.reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.reactivepwrsetpointenabled_ = p;
  }
  return _impl_.reactivepwrsetpointenabled_;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::mutable_reactivepwrsetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_reactivepwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
  return _msg;
}
inline void ESSPointStatus::set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPS* reactivepwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reactivepwrsetpointenabled));
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
}

// .commonmodule.StatusSPS realPwrSetPointEnabled = 9;
inline bool ESSPointStatus::_internal_has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.realpwrsetpointenabled_ != nullptr;
}
inline bool ESSPointStatus::has_realpwrsetpointenabled() const {
  return _internal_has_realpwrsetpointenabled();
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::_internal_realpwrsetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.realpwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::realpwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.realPwrSetPointEnabled)
  return _internal_realpwrsetpointenabled();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_realpwrsetpointenabled(
    ::commonmodule::StatusSPS* realpwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.realPwrSetPointEnabled)
}
inline ::commonmodule::StatusSPS* ESSPointStatus::release_realpwrsetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::unsafe_arena_release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.realPwrSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::_internal_mutable_realpwrsetpointenabled() {
  
  if (_impl_.realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.realpwrsetpointenabled_ = p;
  }
  return _impl_.realpwrsetpointenabled_;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::mutable_realpwrsetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_realpwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.realPwrSetPointEnabled)
  return _msg;
}
inline void ESSPointStatus::set_allocated_realpwrsetpointenabled(::commonmodule::StatusSPS* realpwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(realpwrsetpointenabled));
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.realPwrSetPointEnabled)
}

// .commonmodule.Optional_StateKind state = 10;
inline bool ESSPointStatus::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool ESSPointStatus::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& ESSPointStatus::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& ESSPointStatus::state() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.state)
  return _internal_state();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.state)
}
inline ::commonmodule::Optional_StateKind* ESSPointStatus::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* ESSPointStatus::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* ESSPointStatus::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* ESSPointStatus::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.state)
  return _msg;
}
inline void ESSPointStatus::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.state)
}

// .commonmodule.StatusSPS syncBackToGrid = 11;
inline bool ESSPointStatus::_internal_has_syncbacktogrid() const {
  return this != internal_default_instance() && _impl_.syncbacktogrid_ != nullptr;
}
inline bool ESSPointStatus::has_syncbacktogrid() const {
  return _internal_has_syncbacktogrid();
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::_internal_syncbacktogrid() const {
  const ::commonmodule::StatusSPS* p = _impl_.syncbacktogrid_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::syncbacktogrid() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.syncBackToGrid)
  return _internal_syncbacktogrid();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_syncbacktogrid(
    ::commonmodule::StatusSPS* syncbacktogrid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.syncbacktogrid_);
  }
  _impl_.syncbacktogrid_ = syncbacktogrid;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.syncBackToGrid)
}
inline ::commonmodule::StatusSPS* ESSPointStatus::release_syncbacktogrid() {
  
  ::commonmodule::StatusSPS* temp = _impl_.syncbacktogrid_;
  _impl_.syncbacktogrid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::unsafe_arena_release_syncbacktogrid() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.syncBackToGrid)
  
  ::commonmodule::StatusSPS* temp = _impl_.syncbacktogrid_;
  _impl_.syncbacktogrid_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::_internal_mutable_syncbacktogrid() {
  
  if (_impl_.syncbacktogrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.syncbacktogrid_ = p;
  }
  return _impl_.syncbacktogrid_;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::mutable_syncbacktogrid() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_syncbacktogrid();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.syncBackToGrid)
  return _msg;
}
inline void ESSPointStatus::set_allocated_syncbacktogrid(::commonmodule::StatusSPS* syncbacktogrid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.syncbacktogrid_);
  }
  if (syncbacktogrid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(syncbacktogrid));
    if (message_arena != submessage_arena) {
      syncbacktogrid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, syncbacktogrid, submessage_arena);
    }

  } else {

  }
  _impl_.syncbacktogrid_ = syncbacktogrid;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.syncBackToGrid)
}

// .commonmodule.StatusSPS transToIslndOnGridLossEnabled = 12;
inline bool ESSPointStatus::_internal_has_transtoislndongridlossenabled() const {
  return this != internal_default_instance() && _impl_.transtoislndongridlossenabled_ != nullptr;
}
inline bool ESSPointStatus::has_transtoislndongridlossenabled() const {
  return _internal_has_transtoislndongridlossenabled();
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::_internal_transtoislndongridlossenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.transtoislndongridlossenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::transtoislndongridlossenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
  return _internal_transtoislndongridlossenabled();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_transtoislndongridlossenabled(
    ::commonmodule::StatusSPS* transtoislndongridlossenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transtoislndongridlossenabled_);
  }
  _impl_.transtoislndongridlossenabled_ = transtoislndongridlossenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
}
inline ::commonmodule::StatusSPS* ESSPointStatus::release_transtoislndongridlossenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.transtoislndongridlossenabled_;
  _impl_.transtoislndongridlossenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::unsafe_arena_release_transtoislndongridlossenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.transtoislndongridlossenabled_;
  _impl_.transtoislndongridlossenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::_internal_mutable_transtoislndongridlossenabled() {
  
  if (_impl_.transtoislndongridlossenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.transtoislndongridlossenabled_ = p;
  }
  return _impl_.transtoislndongridlossenabled_;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::mutable_transtoislndongridlossenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_transtoislndongridlossenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
  return _msg;
}
inline void ESSPointStatus::set_allocated_transtoislndongridlossenabled(::commonmodule::StatusSPS* transtoislndongridlossenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transtoislndongridlossenabled_);
  }
  if (transtoislndongridlossenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transtoislndongridlossenabled));
    if (message_arena != submessage_arena) {
      transtoislndongridlossenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transtoislndongridlossenabled, submessage_arena);
    }

  } else {

  }
  _impl_.transtoislndongridlossenabled_ = transtoislndongridlossenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
}

// .commonmodule.StatusSPS voltageSetPointEnabled = 13;
inline bool ESSPointStatus::_internal_has_voltagesetpointenabled() const {
  return this != internal_default_instance() && _impl_.voltagesetpointenabled_ != nullptr;
}
inline bool ESSPointStatus::has_voltagesetpointenabled() const {
  return _internal_has_voltagesetpointenabled();
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::_internal_voltagesetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.voltagesetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSPointStatus::voltagesetpointenabled() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.voltageSetPointEnabled)
  return _internal_voltagesetpointenabled();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_voltagesetpointenabled(
    ::commonmodule::StatusSPS* voltagesetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.voltageSetPointEnabled)
}
inline ::commonmodule::StatusSPS* ESSPointStatus::release_voltagesetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::unsafe_arena_release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.voltageSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::_internal_mutable_voltagesetpointenabled() {
  
  if (_impl_.voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.voltagesetpointenabled_ = p;
  }
  return _impl_.voltagesetpointenabled_;
}
inline ::commonmodule::StatusSPS* ESSPointStatus::mutable_voltagesetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_voltagesetpointenabled();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.voltageSetPointEnabled)
  return _msg;
}
inline void ESSPointStatus::set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* voltagesetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesetpointenabled));
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.voltageSetPointEnabled)
}

// .commonmodule.EnterServiceAPC enterServiceOperation = 14;
inline bool ESSPointStatus::_internal_has_enterserviceoperation() const {
  return this != internal_default_instance() && _impl_.enterserviceoperation_ != nullptr;
}
inline bool ESSPointStatus::has_enterserviceoperation() const {
  return _internal_has_enterserviceoperation();
}
inline const ::commonmodule::EnterServiceAPC& ESSPointStatus::_internal_enterserviceoperation() const {
  const ::commonmodule::EnterServiceAPC* p = _impl_.enterserviceoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnterServiceAPC&>(
      ::commonmodule::_EnterServiceAPC_default_instance_);
}
inline const ::commonmodule::EnterServiceAPC& ESSPointStatus::enterserviceoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.enterServiceOperation)
  return _internal_enterserviceoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_enterserviceoperation(
    ::commonmodule::EnterServiceAPC* enterserviceoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.enterServiceOperation)
}
inline ::commonmodule::EnterServiceAPC* ESSPointStatus::release_enterserviceoperation() {
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnterServiceAPC* ESSPointStatus::unsafe_arena_release_enterserviceoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.enterServiceOperation)
  
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::EnterServiceAPC* ESSPointStatus::_internal_mutable_enterserviceoperation() {
  
  if (_impl_.enterserviceoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnterServiceAPC>(GetArenaForAllocation());
    _impl_.enterserviceoperation_ = p;
  }
  return _impl_.enterserviceoperation_;
}
inline ::commonmodule::EnterServiceAPC* ESSPointStatus::mutable_enterserviceoperation() {
  ::commonmodule::EnterServiceAPC* _msg = _internal_mutable_enterserviceoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.enterServiceOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* enterserviceoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enterserviceoperation_);
  }
  if (enterserviceoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enterserviceoperation));
    if (message_arena != submessage_arena) {
      enterserviceoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enterserviceoperation, submessage_arena);
    }

  } else {

  }
  _impl_.enterserviceoperation_ = enterserviceoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.enterServiceOperation)
}

// .commonmodule.HzWAPC hzWOperation = 15;
inline bool ESSPointStatus::_internal_has_hzwoperation() const {
  return this != internal_default_instance() && _impl_.hzwoperation_ != nullptr;
}
inline bool ESSPointStatus::has_hzwoperation() const {
  return _internal_has_hzwoperation();
}
inline const ::commonmodule::HzWAPC& ESSPointStatus::_internal_hzwoperation() const {
  const ::commonmodule::HzWAPC* p = _impl_.hzwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWAPC&>(
      ::commonmodule::_HzWAPC_default_instance_);
}
inline const ::commonmodule::HzWAPC& ESSPointStatus::hzwoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.hzWOperation)
  return _internal_hzwoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_hzwoperation(
    ::commonmodule::HzWAPC* hzwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.hzWOperation)
}
inline ::commonmodule::HzWAPC* ESSPointStatus::release_hzwoperation() {
  
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::HzWAPC* ESSPointStatus::unsafe_arena_release_hzwoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.hzWOperation)
  
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWAPC* ESSPointStatus::_internal_mutable_hzwoperation() {
  
  if (_impl_.hzwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::HzWAPC>(GetArenaForAllocation());
    _impl_.hzwoperation_ = p;
  }
  return _impl_.hzwoperation_;
}
inline ::commonmodule::HzWAPC* ESSPointStatus::mutable_hzwoperation() {
  ::commonmodule::HzWAPC* _msg = _internal_mutable_hzwoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.hzWOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_hzwoperation(::commonmodule::HzWAPC* hzwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hzwoperation_);
  }
  if (hzwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hzwoperation));
    if (message_arena != submessage_arena) {
      hzwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hzwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.hzwoperation_ = hzwoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.hzWOperation)
}

// .commonmodule.LimitWAPC limitWOperation = 16;
inline bool ESSPointStatus::_internal_has_limitwoperation() const {
  return this != internal_default_instance() && _impl_.limitwoperation_ != nullptr;
}
inline bool ESSPointStatus::has_limitwoperation() const {
  return _internal_has_limitwoperation();
}
inline const ::commonmodule::LimitWAPC& ESSPointStatus::_internal_limitwoperation() const {
  const ::commonmodule::LimitWAPC* p = _impl_.limitwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LimitWAPC&>(
      ::commonmodule::_LimitWAPC_default_instance_);
}
inline const ::commonmodule::LimitWAPC& ESSPointStatus::limitwoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.limitWOperation)
  return _internal_limitwoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_limitwoperation(
    ::commonmodule::LimitWAPC* limitwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.limitWOperation)
}
inline ::commonmodule::LimitWAPC* ESSPointStatus::release_limitwoperation() {
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LimitWAPC* ESSPointStatus::unsafe_arena_release_limitwoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.limitWOperation)
  
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::LimitWAPC* ESSPointStatus::_internal_mutable_limitwoperation() {
  
  if (_impl_.limitwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LimitWAPC>(GetArenaForAllocation());
    _impl_.limitwoperation_ = p;
  }
  return _impl_.limitwoperation_;
}
inline ::commonmodule::LimitWAPC* ESSPointStatus::mutable_limitwoperation() {
  ::commonmodule::LimitWAPC* _msg = _internal_mutable_limitwoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.limitWOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_limitwoperation(::commonmodule::LimitWAPC* limitwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limitwoperation_);
  }
  if (limitwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limitwoperation));
    if (message_arena != submessage_arena) {
      limitwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limitwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.limitwoperation_ = limitwoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.limitWOperation)
}

// .commonmodule.PFSPC pFOperation = 17;
inline bool ESSPointStatus::_internal_has_pfoperation() const {
  return this != internal_default_instance() && _impl_.pfoperation_ != nullptr;
}
inline bool ESSPointStatus::has_pfoperation() const {
  return _internal_has_pfoperation();
}
inline const ::commonmodule::PFSPC& ESSPointStatus::_internal_pfoperation() const {
  const ::commonmodule::PFSPC* p = _impl_.pfoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PFSPC&>(
      ::commonmodule::_PFSPC_default_instance_);
}
inline const ::commonmodule::PFSPC& ESSPointStatus::pfoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.pFOperation)
  return _internal_pfoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_pfoperation(
    ::commonmodule::PFSPC* pfoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.pFOperation)
}
inline ::commonmodule::PFSPC* ESSPointStatus::release_pfoperation() {
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PFSPC* ESSPointStatus::unsafe_arena_release_pfoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.pFOperation)
  
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::PFSPC* ESSPointStatus::_internal_mutable_pfoperation() {
  
  if (_impl_.pfoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PFSPC>(GetArenaForAllocation());
    _impl_.pfoperation_ = p;
  }
  return _impl_.pfoperation_;
}
inline ::commonmodule::PFSPC* ESSPointStatus::mutable_pfoperation() {
  ::commonmodule::PFSPC* _msg = _internal_mutable_pfoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.pFOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_pfoperation(::commonmodule::PFSPC* pfoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pfoperation_);
  }
  if (pfoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pfoperation));
    if (message_arena != submessage_arena) {
      pfoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pfoperation, submessage_arena);
    }

  } else {

  }
  _impl_.pfoperation_ = pfoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.pFOperation)
}

// .commonmodule.TmHzCSG tmHzTripOperation = 18;
inline bool ESSPointStatus::_internal_has_tmhztripoperation() const {
  return this != internal_default_instance() && _impl_.tmhztripoperation_ != nullptr;
}
inline bool ESSPointStatus::has_tmhztripoperation() const {
  return _internal_has_tmhztripoperation();
}
inline const ::commonmodule::TmHzCSG& ESSPointStatus::_internal_tmhztripoperation() const {
  const ::commonmodule::TmHzCSG* p = _impl_.tmhztripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmHzCSG&>(
      ::commonmodule::_TmHzCSG_default_instance_);
}
inline const ::commonmodule::TmHzCSG& ESSPointStatus::tmhztripoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.tmHzTripOperation)
  return _internal_tmhztripoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_tmhztripoperation(
    ::commonmodule::TmHzCSG* tmhztripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.tmHzTripOperation)
}
inline ::commonmodule::TmHzCSG* ESSPointStatus::release_tmhztripoperation() {
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmHzCSG* ESSPointStatus::unsafe_arena_release_tmhztripoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.tmHzTripOperation)
  
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmHzCSG* ESSPointStatus::_internal_mutable_tmhztripoperation() {
  
  if (_impl_.tmhztripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmHzCSG>(GetArenaForAllocation());
    _impl_.tmhztripoperation_ = p;
  }
  return _impl_.tmhztripoperation_;
}
inline ::commonmodule::TmHzCSG* ESSPointStatus::mutable_tmhztripoperation() {
  ::commonmodule::TmHzCSG* _msg = _internal_mutable_tmhztripoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.tmHzTripOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* tmhztripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmhztripoperation_);
  }
  if (tmhztripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmhztripoperation));
    if (message_arena != submessage_arena) {
      tmhztripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmhztripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmhztripoperation_ = tmhztripoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.tmHzTripOperation)
}

// .commonmodule.TmVoltCSG tmVoltTripOperation = 19;
inline bool ESSPointStatus::_internal_has_tmvolttripoperation() const {
  return this != internal_default_instance() && _impl_.tmvolttripoperation_ != nullptr;
}
inline bool ESSPointStatus::has_tmvolttripoperation() const {
  return _internal_has_tmvolttripoperation();
}
inline const ::commonmodule::TmVoltCSG& ESSPointStatus::_internal_tmvolttripoperation() const {
  const ::commonmodule::TmVoltCSG* p = _impl_.tmvolttripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmVoltCSG&>(
      ::commonmodule::_TmVoltCSG_default_instance_);
}
inline const ::commonmodule::TmVoltCSG& ESSPointStatus::tmvolttripoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.tmVoltTripOperation)
  return _internal_tmvolttripoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_tmvolttripoperation(
    ::commonmodule::TmVoltCSG* tmvolttripoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.tmVoltTripOperation)
}
inline ::commonmodule::TmVoltCSG* ESSPointStatus::release_tmvolttripoperation() {
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::TmVoltCSG* ESSPointStatus::unsafe_arena_release_tmvolttripoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.tmVoltTripOperation)
  
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmVoltCSG* ESSPointStatus::_internal_mutable_tmvolttripoperation() {
  
  if (_impl_.tmvolttripoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::TmVoltCSG>(GetArenaForAllocation());
    _impl_.tmvolttripoperation_ = p;
  }
  return _impl_.tmvolttripoperation_;
}
inline ::commonmodule::TmVoltCSG* ESSPointStatus::mutable_tmvolttripoperation() {
  ::commonmodule::TmVoltCSG* _msg = _internal_mutable_tmvolttripoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.tmVoltTripOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* tmvolttripoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  if (tmvolttripoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tmvolttripoperation));
    if (message_arena != submessage_arena) {
      tmvolttripoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tmvolttripoperation, submessage_arena);
    }

  } else {

  }
  _impl_.tmvolttripoperation_ = tmvolttripoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.tmVoltTripOperation)
}

// .commonmodule.VarSPC vArOperation = 20;
inline bool ESSPointStatus::_internal_has_varoperation() const {
  return this != internal_default_instance() && _impl_.varoperation_ != nullptr;
}
inline bool ESSPointStatus::has_varoperation() const {
  return _internal_has_varoperation();
}
inline const ::commonmodule::VarSPC& ESSPointStatus::_internal_varoperation() const {
  const ::commonmodule::VarSPC* p = _impl_.varoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VarSPC&>(
      ::commonmodule::_VarSPC_default_instance_);
}
inline const ::commonmodule::VarSPC& ESSPointStatus::varoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.vArOperation)
  return _internal_varoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_varoperation(
    ::commonmodule::VarSPC* varoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.vArOperation)
}
inline ::commonmodule::VarSPC* ESSPointStatus::release_varoperation() {
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VarSPC* ESSPointStatus::unsafe_arena_release_varoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.vArOperation)
  
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VarSPC* ESSPointStatus::_internal_mutable_varoperation() {
  
  if (_impl_.varoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VarSPC>(GetArenaForAllocation());
    _impl_.varoperation_ = p;
  }
  return _impl_.varoperation_;
}
inline ::commonmodule::VarSPC* ESSPointStatus::mutable_varoperation() {
  ::commonmodule::VarSPC* _msg = _internal_mutable_varoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.vArOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_varoperation(::commonmodule::VarSPC* varoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.varoperation_);
  }
  if (varoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(varoperation));
    if (message_arena != submessage_arena) {
      varoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, varoperation, submessage_arena);
    }

  } else {

  }
  _impl_.varoperation_ = varoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.vArOperation)
}

// .commonmodule.VoltVarCSG voltVarOperation = 21;
inline bool ESSPointStatus::_internal_has_voltvaroperation() const {
  return this != internal_default_instance() && _impl_.voltvaroperation_ != nullptr;
}
inline bool ESSPointStatus::has_voltvaroperation() const {
  return _internal_has_voltvaroperation();
}
inline const ::commonmodule::VoltVarCSG& ESSPointStatus::_internal_voltvaroperation() const {
  const ::commonmodule::VoltVarCSG* p = _impl_.voltvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltVarCSG&>(
      ::commonmodule::_VoltVarCSG_default_instance_);
}
inline const ::commonmodule::VoltVarCSG& ESSPointStatus::voltvaroperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.voltVarOperation)
  return _internal_voltvaroperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_voltvaroperation(
    ::commonmodule::VoltVarCSG* voltvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.voltVarOperation)
}
inline ::commonmodule::VoltVarCSG* ESSPointStatus::release_voltvaroperation() {
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltVarCSG* ESSPointStatus::unsafe_arena_release_voltvaroperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.voltVarOperation)
  
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltVarCSG* ESSPointStatus::_internal_mutable_voltvaroperation() {
  
  if (_impl_.voltvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltVarCSG>(GetArenaForAllocation());
    _impl_.voltvaroperation_ = p;
  }
  return _impl_.voltvaroperation_;
}
inline ::commonmodule::VoltVarCSG* ESSPointStatus::mutable_voltvaroperation() {
  ::commonmodule::VoltVarCSG* _msg = _internal_mutable_voltvaroperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.voltVarOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* voltvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltvaroperation_);
  }
  if (voltvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltvaroperation));
    if (message_arena != submessage_arena) {
      voltvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltvaroperation_ = voltvaroperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.voltVarOperation)
}

// .commonmodule.VoltWCSG voltWOperation = 22;
inline bool ESSPointStatus::_internal_has_voltwoperation() const {
  return this != internal_default_instance() && _impl_.voltwoperation_ != nullptr;
}
inline bool ESSPointStatus::has_voltwoperation() const {
  return _internal_has_voltwoperation();
}
inline const ::commonmodule::VoltWCSG& ESSPointStatus::_internal_voltwoperation() const {
  const ::commonmodule::VoltWCSG* p = _impl_.voltwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltWCSG&>(
      ::commonmodule::_VoltWCSG_default_instance_);
}
inline const ::commonmodule::VoltWCSG& ESSPointStatus::voltwoperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.voltWOperation)
  return _internal_voltwoperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_voltwoperation(
    ::commonmodule::VoltWCSG* voltwoperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.voltWOperation)
}
inline ::commonmodule::VoltWCSG* ESSPointStatus::release_voltwoperation() {
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::VoltWCSG* ESSPointStatus::unsafe_arena_release_voltwoperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.voltWOperation)
  
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltWCSG* ESSPointStatus::_internal_mutable_voltwoperation() {
  
  if (_impl_.voltwoperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::VoltWCSG>(GetArenaForAllocation());
    _impl_.voltwoperation_ = p;
  }
  return _impl_.voltwoperation_;
}
inline ::commonmodule::VoltWCSG* ESSPointStatus::mutable_voltwoperation() {
  ::commonmodule::VoltWCSG* _msg = _internal_mutable_voltwoperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.voltWOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_voltwoperation(::commonmodule::VoltWCSG* voltwoperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltwoperation_);
  }
  if (voltwoperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltwoperation));
    if (message_arena != submessage_arena) {
      voltwoperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltwoperation, submessage_arena);
    }

  } else {

  }
  _impl_.voltwoperation_ = voltwoperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.voltWOperation)
}

// .commonmodule.WVarCSG wVarOperation = 23;
inline bool ESSPointStatus::_internal_has_wvaroperation() const {
  return this != internal_default_instance() && _impl_.wvaroperation_ != nullptr;
}
inline bool ESSPointStatus::has_wvaroperation() const {
  return _internal_has_wvaroperation();
}
inline const ::commonmodule::WVarCSG& ESSPointStatus::_internal_wvaroperation() const {
  const ::commonmodule::WVarCSG* p = _impl_.wvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WVarCSG&>(
      ::commonmodule::_WVarCSG_default_instance_);
}
inline const ::commonmodule::WVarCSG& ESSPointStatus::wvaroperation() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.wVarOperation)
  return _internal_wvaroperation();
}
inline void ESSPointStatus::unsafe_arena_set_allocated_wvaroperation(
    ::commonmodule::WVarCSG* wvaroperation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSPointStatus.wVarOperation)
}
inline ::commonmodule::WVarCSG* ESSPointStatus::release_wvaroperation() {
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::WVarCSG* ESSPointStatus::unsafe_arena_release_wvaroperation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.wVarOperation)
  
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WVarCSG* ESSPointStatus::_internal_mutable_wvaroperation() {
  
  if (_impl_.wvaroperation_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::WVarCSG>(GetArenaForAllocation());
    _impl_.wvaroperation_ = p;
  }
  return _impl_.wvaroperation_;
}
inline ::commonmodule::WVarCSG* ESSPointStatus::mutable_wvaroperation() {
  ::commonmodule::WVarCSG* _msg = _internal_mutable_wvaroperation();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.wVarOperation)
  return _msg;
}
inline void ESSPointStatus::set_allocated_wvaroperation(::commonmodule::WVarCSG* wvaroperation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wvaroperation_);
  }
  if (wvaroperation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wvaroperation));
    if (message_arena != submessage_arena) {
      wvaroperation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wvaroperation, submessage_arena);
    }

  } else {

  }
  _impl_.wvaroperation_ = wvaroperation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.wVarOperation)
}

// -------------------------------------------------------------------

// ESSEventAndStatusZGEN

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool ESSEventAndStatusZGEN::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool ESSEventAndStatusZGEN::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& ESSEventAndStatusZGEN::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& ESSEventAndStatusZGEN::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void ESSEventAndStatusZGEN::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* ESSEventAndStatusZGEN::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* ESSEventAndStatusZGEN::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* ESSEventAndStatusZGEN::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* ESSEventAndStatusZGEN::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return _msg;
}
inline void ESSEventAndStatusZGEN::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS AuxPwrSt = 2;
inline bool ESSEventAndStatusZGEN::_internal_has_auxpwrst() const {
  return this != internal_default_instance() && _impl_.auxpwrst_ != nullptr;
}
inline bool ESSEventAndStatusZGEN::has_auxpwrst() const {
  return _internal_has_auxpwrst();
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::_internal_auxpwrst() const {
  const ::commonmodule::StatusSPS* p = _impl_.auxpwrst_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::auxpwrst() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
  return _internal_auxpwrst();
}
inline void ESSEventAndStatusZGEN::unsafe_arena_set_allocated_auxpwrst(
    ::commonmodule::StatusSPS* auxpwrst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auxpwrst_);
  }
  _impl_.auxpwrst_ = auxpwrst;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::release_auxpwrst() {
  
  ::commonmodule::StatusSPS* temp = _impl_.auxpwrst_;
  _impl_.auxpwrst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::unsafe_arena_release_auxpwrst() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
  
  ::commonmodule::StatusSPS* temp = _impl_.auxpwrst_;
  _impl_.auxpwrst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::_internal_mutable_auxpwrst() {
  
  if (_impl_.auxpwrst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.auxpwrst_ = p;
  }
  return _impl_.auxpwrst_;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::mutable_auxpwrst() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_auxpwrst();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
  return _msg;
}
inline void ESSEventAndStatusZGEN::set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auxpwrst_);
  }
  if (auxpwrst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auxpwrst));
    if (message_arena != submessage_arena) {
      auxpwrst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auxpwrst, submessage_arena);
    }

  } else {

  }
  _impl_.auxpwrst_ = auxpwrst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
inline bool ESSEventAndStatusZGEN::_internal_has_dynamictest() const {
  return this != internal_default_instance() && _impl_.dynamictest_ != nullptr;
}
inline bool ESSEventAndStatusZGEN::has_dynamictest() const {
  return _internal_has_dynamictest();
}
inline const ::commonmodule::ENS_DynamicTestKind& ESSEventAndStatusZGEN::_internal_dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(
      ::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& ESSEventAndStatusZGEN::dynamictest() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.DynamicTest)
  return _internal_dynamictest();
}
inline void ESSEventAndStatusZGEN::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* dynamictest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventAndStatusZGEN.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* ESSEventAndStatusZGEN::release_dynamictest() {
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* ESSEventAndStatusZGEN::unsafe_arena_release_dynamictest() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* ESSEventAndStatusZGEN::_internal_mutable_dynamictest() {
  
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaForAllocation());
    _impl_.dynamictest_ = p;
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* ESSEventAndStatusZGEN::mutable_dynamictest() {
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.DynamicTest)
  return _msg;
}
inline void ESSEventAndStatusZGEN::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  if (dynamictest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamictest));
    if (message_arena != submessage_arena) {
      dynamictest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }

  } else {

  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.DynamicTest)
}

// .commonmodule.StatusSPS EmgStop = 4;
inline bool ESSEventAndStatusZGEN::_internal_has_emgstop() const {
  return this != internal_default_instance() && _impl_.emgstop_ != nullptr;
}
inline bool ESSEventAndStatusZGEN::has_emgstop() const {
  return _internal_has_emgstop();
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::_internal_emgstop() const {
  const ::commonmodule::StatusSPS* p = _impl_.emgstop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::emgstop() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.EmgStop)
  return _internal_emgstop();
}
inline void ESSEventAndStatusZGEN::unsafe_arena_set_allocated_emgstop(
    ::commonmodule::StatusSPS* emgstop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emgstop_);
  }
  _impl_.emgstop_ = emgstop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventAndStatusZGEN.EmgStop)
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::release_emgstop() {
  
  ::commonmodule::StatusSPS* temp = _impl_.emgstop_;
  _impl_.emgstop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::unsafe_arena_release_emgstop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.EmgStop)
  
  ::commonmodule::StatusSPS* temp = _impl_.emgstop_;
  _impl_.emgstop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::_internal_mutable_emgstop() {
  
  if (_impl_.emgstop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.emgstop_ = p;
  }
  return _impl_.emgstop_;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::mutable_emgstop() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_emgstop();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.EmgStop)
  return _msg;
}
inline void ESSEventAndStatusZGEN::set_allocated_emgstop(::commonmodule::StatusSPS* emgstop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emgstop_);
  }
  if (emgstop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emgstop));
    if (message_arena != submessage_arena) {
      emgstop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emgstop, submessage_arena);
    }

  } else {

  }
  _impl_.emgstop_ = emgstop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.EmgStop)
}

// .commonmodule.StatusSPS GnSynSt = 5;
inline bool ESSEventAndStatusZGEN::_internal_has_gnsynst() const {
  return this != internal_default_instance() && _impl_.gnsynst_ != nullptr;
}
inline bool ESSEventAndStatusZGEN::has_gnsynst() const {
  return _internal_has_gnsynst();
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::_internal_gnsynst() const {
  const ::commonmodule::StatusSPS* p = _impl_.gnsynst_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::gnsynst() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.GnSynSt)
  return _internal_gnsynst();
}
inline void ESSEventAndStatusZGEN::unsafe_arena_set_allocated_gnsynst(
    ::commonmodule::StatusSPS* gnsynst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gnsynst_);
  }
  _impl_.gnsynst_ = gnsynst;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventAndStatusZGEN.GnSynSt)
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::release_gnsynst() {
  
  ::commonmodule::StatusSPS* temp = _impl_.gnsynst_;
  _impl_.gnsynst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::unsafe_arena_release_gnsynst() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.GnSynSt)
  
  ::commonmodule::StatusSPS* temp = _impl_.gnsynst_;
  _impl_.gnsynst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::_internal_mutable_gnsynst() {
  
  if (_impl_.gnsynst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.gnsynst_ = p;
  }
  return _impl_.gnsynst_;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::mutable_gnsynst() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_gnsynst();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.GnSynSt)
  return _msg;
}
inline void ESSEventAndStatusZGEN::set_allocated_gnsynst(::commonmodule::StatusSPS* gnsynst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gnsynst_);
  }
  if (gnsynst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gnsynst));
    if (message_arena != submessage_arena) {
      gnsynst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gnsynst, submessage_arena);
    }

  } else {

  }
  _impl_.gnsynst_ = gnsynst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.GnSynSt)
}

// .essmodule.ESSPointStatus PointStatus = 6;
inline bool ESSEventAndStatusZGEN::_internal_has_pointstatus() const {
  return this != internal_default_instance() && _impl_.pointstatus_ != nullptr;
}
inline bool ESSEventAndStatusZGEN::has_pointstatus() const {
  return _internal_has_pointstatus();
}
inline void ESSEventAndStatusZGEN::clear_pointstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.pointstatus_ != nullptr) {
    delete _impl_.pointstatus_;
  }
  _impl_.pointstatus_ = nullptr;
}
inline const ::essmodule::ESSPointStatus& ESSEventAndStatusZGEN::_internal_pointstatus() const {
  const ::essmodule::ESSPointStatus* p = _impl_.pointstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSPointStatus&>(
      ::essmodule::_ESSPointStatus_default_instance_);
}
inline const ::essmodule::ESSPointStatus& ESSEventAndStatusZGEN::pointstatus() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.PointStatus)
  return _internal_pointstatus();
}
inline void ESSEventAndStatusZGEN::unsafe_arena_set_allocated_pointstatus(
    ::essmodule::ESSPointStatus* pointstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointstatus_);
  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventAndStatusZGEN.PointStatus)
}
inline ::essmodule::ESSPointStatus* ESSEventAndStatusZGEN::release_pointstatus() {
  
  ::essmodule::ESSPointStatus* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSPointStatus* ESSEventAndStatusZGEN::unsafe_arena_release_pointstatus() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.PointStatus)
  
  ::essmodule::ESSPointStatus* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  return temp;
}
inline ::essmodule::ESSPointStatus* ESSEventAndStatusZGEN::_internal_mutable_pointstatus() {
  
  if (_impl_.pointstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSPointStatus>(GetArenaForAllocation());
    _impl_.pointstatus_ = p;
  }
  return _impl_.pointstatus_;
}
inline ::essmodule::ESSPointStatus* ESSEventAndStatusZGEN::mutable_pointstatus() {
  ::essmodule::ESSPointStatus* _msg = _internal_mutable_pointstatus();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.PointStatus)
  return _msg;
}
inline void ESSEventAndStatusZGEN::set_allocated_pointstatus(::essmodule::ESSPointStatus* pointstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pointstatus_;
  }
  if (pointstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pointstatus);
    if (message_arena != submessage_arena) {
      pointstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointstatus, submessage_arena);
    }

  } else {

  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.PointStatus)
}

// -------------------------------------------------------------------

// ESSEventZGEN

// .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool ESSEventZGEN::_internal_has_esseventandstatuszgen() const {
  return this != internal_default_instance() && _impl_.esseventandstatuszgen_ != nullptr;
}
inline bool ESSEventZGEN::has_esseventandstatuszgen() const {
  return _internal_has_esseventandstatuszgen();
}
inline void ESSEventZGEN::clear_esseventandstatuszgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.esseventandstatuszgen_ != nullptr) {
    delete _impl_.esseventandstatuszgen_;
  }
  _impl_.esseventandstatuszgen_ = nullptr;
}
inline const ::essmodule::ESSEventAndStatusZGEN& ESSEventZGEN::_internal_esseventandstatuszgen() const {
  const ::essmodule::ESSEventAndStatusZGEN* p = _impl_.esseventandstatuszgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSEventAndStatusZGEN&>(
      ::essmodule::_ESSEventAndStatusZGEN_default_instance_);
}
inline const ::essmodule::ESSEventAndStatusZGEN& ESSEventZGEN::esseventandstatuszgen() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
  return _internal_esseventandstatuszgen();
}
inline void ESSEventZGEN::unsafe_arena_set_allocated_esseventandstatuszgen(
    ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esseventandstatuszgen_);
  }
  _impl_.esseventandstatuszgen_ = esseventandstatuszgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSEventZGEN::release_esseventandstatuszgen() {
  
  ::essmodule::ESSEventAndStatusZGEN* temp = _impl_.esseventandstatuszgen_;
  _impl_.esseventandstatuszgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSEventZGEN::unsafe_arena_release_esseventandstatuszgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
  
  ::essmodule::ESSEventAndStatusZGEN* temp = _impl_.esseventandstatuszgen_;
  _impl_.esseventandstatuszgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSEventZGEN::_internal_mutable_esseventandstatuszgen() {
  
  if (_impl_.esseventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEventAndStatusZGEN>(GetArenaForAllocation());
    _impl_.esseventandstatuszgen_ = p;
  }
  return _impl_.esseventandstatuszgen_;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSEventZGEN::mutable_esseventandstatuszgen() {
  ::essmodule::ESSEventAndStatusZGEN* _msg = _internal_mutable_esseventandstatuszgen();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
  return _msg;
}
inline void ESSEventZGEN::set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esseventandstatuszgen_;
  }
  if (esseventandstatuszgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esseventandstatuszgen);
    if (message_arena != submessage_arena) {
      esseventandstatuszgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esseventandstatuszgen, submessage_arena);
    }

  } else {

  }
  _impl_.esseventandstatuszgen_ = esseventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
}

// -------------------------------------------------------------------

// ESSEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSEvent::_internal_has_eventvalue() const {
  return this != internal_default_instance() && _impl_.eventvalue_ != nullptr;
}
inline bool ESSEvent::has_eventvalue() const {
  return _internal_has_eventvalue();
}
inline const ::commonmodule::EventValue& ESSEvent::_internal_eventvalue() const {
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(
      ::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& ESSEvent::eventvalue() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEvent.eventValue)
  return _internal_eventvalue();
}
inline void ESSEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* eventvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEvent.eventValue)
}
inline ::commonmodule::EventValue* ESSEvent::release_eventvalue() {
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventValue* ESSEvent::unsafe_arena_release_eventvalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEvent.eventValue)
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* ESSEvent::_internal_mutable_eventvalue() {
  
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaForAllocation());
    _impl_.eventvalue_ = p;
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* ESSEvent::mutable_eventvalue() {
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEvent.eventValue)
  return _msg;
}
inline void ESSEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  if (eventvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventvalue));
    if (message_arena != submessage_arena) {
      eventvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }

  } else {

  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEvent.eventValue)
}

// .essmodule.EssEventZBAT essEventZBAT = 2;
inline bool ESSEvent::_internal_has_esseventzbat() const {
  return this != internal_default_instance() && _impl_.esseventzbat_ != nullptr;
}
inline bool ESSEvent::has_esseventzbat() const {
  return _internal_has_esseventzbat();
}
inline void ESSEvent::clear_esseventzbat() {
  if (GetArenaForAllocation() == nullptr && _impl_.esseventzbat_ != nullptr) {
    delete _impl_.esseventzbat_;
  }
  _impl_.esseventzbat_ = nullptr;
}
inline const ::essmodule::EssEventZBAT& ESSEvent::_internal_esseventzbat() const {
  const ::essmodule::EssEventZBAT* p = _impl_.esseventzbat_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::EssEventZBAT&>(
      ::essmodule::_EssEventZBAT_default_instance_);
}
inline const ::essmodule::EssEventZBAT& ESSEvent::esseventzbat() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEvent.essEventZBAT)
  return _internal_esseventzbat();
}
inline void ESSEvent::unsafe_arena_set_allocated_esseventzbat(
    ::essmodule::EssEventZBAT* esseventzbat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esseventzbat_);
  }
  _impl_.esseventzbat_ = esseventzbat;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEvent.essEventZBAT)
}
inline ::essmodule::EssEventZBAT* ESSEvent::release_esseventzbat() {
  
  ::essmodule::EssEventZBAT* temp = _impl_.esseventzbat_;
  _impl_.esseventzbat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::EssEventZBAT* ESSEvent::unsafe_arena_release_esseventzbat() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEvent.essEventZBAT)
  
  ::essmodule::EssEventZBAT* temp = _impl_.esseventzbat_;
  _impl_.esseventzbat_ = nullptr;
  return temp;
}
inline ::essmodule::EssEventZBAT* ESSEvent::_internal_mutable_esseventzbat() {
  
  if (_impl_.esseventzbat_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::EssEventZBAT>(GetArenaForAllocation());
    _impl_.esseventzbat_ = p;
  }
  return _impl_.esseventzbat_;
}
inline ::essmodule::EssEventZBAT* ESSEvent::mutable_esseventzbat() {
  ::essmodule::EssEventZBAT* _msg = _internal_mutable_esseventzbat();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEvent.essEventZBAT)
  return _msg;
}
inline void ESSEvent::set_allocated_esseventzbat(::essmodule::EssEventZBAT* esseventzbat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esseventzbat_;
  }
  if (esseventzbat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esseventzbat);
    if (message_arena != submessage_arena) {
      esseventzbat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esseventzbat, submessage_arena);
    }

  } else {

  }
  _impl_.esseventzbat_ = esseventzbat;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEvent.essEventZBAT)
}

// .essmodule.ESSEventZGEN essEventZGEN = 3;
inline bool ESSEvent::_internal_has_esseventzgen() const {
  return this != internal_default_instance() && _impl_.esseventzgen_ != nullptr;
}
inline bool ESSEvent::has_esseventzgen() const {
  return _internal_has_esseventzgen();
}
inline void ESSEvent::clear_esseventzgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.esseventzgen_ != nullptr) {
    delete _impl_.esseventzgen_;
  }
  _impl_.esseventzgen_ = nullptr;
}
inline const ::essmodule::ESSEventZGEN& ESSEvent::_internal_esseventzgen() const {
  const ::essmodule::ESSEventZGEN* p = _impl_.esseventzgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSEventZGEN&>(
      ::essmodule::_ESSEventZGEN_default_instance_);
}
inline const ::essmodule::ESSEventZGEN& ESSEvent::esseventzgen() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEvent.essEventZGEN)
  return _internal_esseventzgen();
}
inline void ESSEvent::unsafe_arena_set_allocated_esseventzgen(
    ::essmodule::ESSEventZGEN* esseventzgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esseventzgen_);
  }
  _impl_.esseventzgen_ = esseventzgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEvent.essEventZGEN)
}
inline ::essmodule::ESSEventZGEN* ESSEvent::release_esseventzgen() {
  
  ::essmodule::ESSEventZGEN* temp = _impl_.esseventzgen_;
  _impl_.esseventzgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSEventZGEN* ESSEvent::unsafe_arena_release_esseventzgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEvent.essEventZGEN)
  
  ::essmodule::ESSEventZGEN* temp = _impl_.esseventzgen_;
  _impl_.esseventzgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEventZGEN* ESSEvent::_internal_mutable_esseventzgen() {
  
  if (_impl_.esseventzgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEventZGEN>(GetArenaForAllocation());
    _impl_.esseventzgen_ = p;
  }
  return _impl_.esseventzgen_;
}
inline ::essmodule::ESSEventZGEN* ESSEvent::mutable_esseventzgen() {
  ::essmodule::ESSEventZGEN* _msg = _internal_mutable_esseventzgen();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEvent.essEventZGEN)
  return _msg;
}
inline void ESSEvent::set_allocated_esseventzgen(::essmodule::ESSEventZGEN* esseventzgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esseventzgen_;
  }
  if (esseventzgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esseventzgen);
    if (message_arena != submessage_arena) {
      esseventzgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esseventzgen, submessage_arena);
    }

  } else {

  }
  _impl_.esseventzgen_ = esseventzgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEvent.essEventZGEN)
}

// -------------------------------------------------------------------

// ESSEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && _impl_.eventmessageinfo_ != nullptr;
}
inline bool ESSEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& ESSEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& ESSEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void ESSEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* ESSEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventMessageInfo* ESSEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* ESSEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaForAllocation());
    _impl_.eventmessageinfo_ = p;
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* ESSEventProfile::mutable_eventmessageinfo() {
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventProfile.eventMessageInfo)
  return _msg;
}
inline void ESSEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo));
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventProfile.eventMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSEventProfile::_internal_has_ess() const {
  return this != internal_default_instance() && _impl_.ess_ != nullptr;
}
inline bool ESSEventProfile::has_ess() const {
  return _internal_has_ess();
}
inline const ::commonmodule::ESS& ESSEventProfile::_internal_ess() const {
  const ::commonmodule::ESS* p = _impl_.ess_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ESS&>(
      ::commonmodule::_ESS_default_instance_);
}
inline const ::commonmodule::ESS& ESSEventProfile::ess() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventProfile.ess)
  return _internal_ess();
}
inline void ESSEventProfile::unsafe_arena_set_allocated_ess(
    ::commonmodule::ESS* ess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventProfile.ess)
}
inline ::commonmodule::ESS* ESSEventProfile::release_ess() {
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ESS* ESSEventProfile::unsafe_arena_release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventProfile.ess)
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSEventProfile::_internal_mutable_ess() {
  
  if (_impl_.ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaForAllocation());
    _impl_.ess_ = p;
  }
  return _impl_.ess_;
}
inline ::commonmodule::ESS* ESSEventProfile::mutable_ess() {
  ::commonmodule::ESS* _msg = _internal_mutable_ess();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventProfile.ess)
  return _msg;
}
inline void ESSEventProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  if (ess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ess));
    if (message_arena != submessage_arena) {
      ess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }

  } else {

  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventProfile.ess)
}

// .essmodule.ESSEvent essEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSEventProfile::_internal_has_essevent() const {
  return this != internal_default_instance() && _impl_.essevent_ != nullptr;
}
inline bool ESSEventProfile::has_essevent() const {
  return _internal_has_essevent();
}
inline void ESSEventProfile::clear_essevent() {
  if (GetArenaForAllocation() == nullptr && _impl_.essevent_ != nullptr) {
    delete _impl_.essevent_;
  }
  _impl_.essevent_ = nullptr;
}
inline const ::essmodule::ESSEvent& ESSEventProfile::_internal_essevent() const {
  const ::essmodule::ESSEvent* p = _impl_.essevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSEvent&>(
      ::essmodule::_ESSEvent_default_instance_);
}
inline const ::essmodule::ESSEvent& ESSEventProfile::essevent() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSEventProfile.essEvent)
  return _internal_essevent();
}
inline void ESSEventProfile::unsafe_arena_set_allocated_essevent(
    ::essmodule::ESSEvent* essevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.essevent_);
  }
  _impl_.essevent_ = essevent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSEventProfile.essEvent)
}
inline ::essmodule::ESSEvent* ESSEventProfile::release_essevent() {
  
  ::essmodule::ESSEvent* temp = _impl_.essevent_;
  _impl_.essevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSEvent* ESSEventProfile::unsafe_arena_release_essevent() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventProfile.essEvent)
  
  ::essmodule::ESSEvent* temp = _impl_.essevent_;
  _impl_.essevent_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEvent* ESSEventProfile::_internal_mutable_essevent() {
  
  if (_impl_.essevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEvent>(GetArenaForAllocation());
    _impl_.essevent_ = p;
  }
  return _impl_.essevent_;
}
inline ::essmodule::ESSEvent* ESSEventProfile::mutable_essevent() {
  ::essmodule::ESSEvent* _msg = _internal_mutable_essevent();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventProfile.essEvent)
  return _msg;
}
inline void ESSEventProfile::set_allocated_essevent(::essmodule::ESSEvent* essevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.essevent_;
  }
  if (essevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(essevent);
    if (message_arena != submessage_arena) {
      essevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, essevent, submessage_arena);
    }

  } else {

  }
  _impl_.essevent_ = essevent;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventProfile.essEvent)
}

// -------------------------------------------------------------------

// ESSReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool ESSReading::_internal_has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && _impl_.conductingequipmentterminalreading_ != nullptr;
}
inline bool ESSReading::has_conductingequipmentterminalreading() const {
  return _internal_has_conductingequipmentterminalreading();
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& ESSReading::_internal_conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(
      ::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& ESSReading::conductingequipmentterminalreading() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void ESSReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* ESSReading::release_conductingequipmentterminalreading() {
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* ESSReading::unsafe_arena_release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* ESSReading::_internal_mutable_conductingequipmentterminalreading() {
  
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaForAllocation());
    _impl_.conductingequipmentterminalreading_ = p;
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* ESSReading::mutable_conductingequipmentterminalreading() {
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void ESSReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipmentterminalreading));
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool ESSReading::_internal_has_phasemmtn() const {
  return this != internal_default_instance() && _impl_.phasemmtn_ != nullptr;
}
inline bool ESSReading::has_phasemmtn() const {
  return _internal_has_phasemmtn();
}
inline const ::commonmodule::PhaseMMTN& ESSReading::_internal_phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(
      ::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& ESSReading::phasemmtn() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void ESSReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* phasemmtn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* ESSReading::release_phasemmtn() {
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseMMTN* ESSReading::unsafe_arena_release_phasemmtn() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* ESSReading::_internal_mutable_phasemmtn() {
  
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaForAllocation());
    _impl_.phasemmtn_ = p;
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* ESSReading::mutable_phasemmtn() {
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.phaseMMTN)
  return _msg;
}
inline void ESSReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  if (phasemmtn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phasemmtn));
    if (message_arena != submessage_arena) {
      phasemmtn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }

  } else {

  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool ESSReading::_internal_has_readingmmtr() const {
  return this != internal_default_instance() && _impl_.readingmmtr_ != nullptr;
}
inline bool ESSReading::has_readingmmtr() const {
  return _internal_has_readingmmtr();
}
inline const ::commonmodule::ReadingMMTR& ESSReading::_internal_readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(
      ::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& ESSReading::readingmmtr() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void ESSReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* readingmmtr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* ESSReading::release_readingmmtr() {
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTR* ESSReading::unsafe_arena_release_readingmmtr() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* ESSReading::_internal_mutable_readingmmtr() {
  
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaForAllocation());
    _impl_.readingmmtr_ = p;
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* ESSReading::mutable_readingmmtr() {
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.readingMMTR)
  return _msg;
}
inline void ESSReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  if (readingmmtr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmtr));
    if (message_arena != submessage_arena) {
      readingmmtr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool ESSReading::_internal_has_readingmmxu() const {
  return this != internal_default_instance() && _impl_.readingmmxu_ != nullptr;
}
inline bool ESSReading::has_readingmmxu() const {
  return _internal_has_readingmmxu();
}
inline const ::commonmodule::ReadingMMXU& ESSReading::_internal_readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& ESSReading::readingmmxu() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void ESSReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* readingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* ESSReading::release_readingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* ESSReading::unsafe_arena_release_readingmmxu() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* ESSReading::_internal_mutable_readingmmxu() {
  
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.readingmmxu_ = p;
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* ESSReading::mutable_readingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.readingMMXU)
  return _msg;
}
inline void ESSReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  if (readingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmxu));
    if (message_arena != submessage_arena) {
      readingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.readingMMXU)
}

// -------------------------------------------------------------------

// ESSReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSReadingProfile::_internal_has_readingmessageinfo() const {
  return this != internal_default_instance() && _impl_.readingmessageinfo_ != nullptr;
}
inline bool ESSReadingProfile::has_readingmessageinfo() const {
  return _internal_has_readingmessageinfo();
}
inline const ::commonmodule::ReadingMessageInfo& ESSReadingProfile::_internal_readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(
      ::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& ESSReadingProfile::readingmessageinfo() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void ESSReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* ESSReadingProfile::release_readingmessageinfo() {
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* ESSReadingProfile::unsafe_arena_release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* ESSReadingProfile::_internal_mutable_readingmessageinfo() {
  
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaForAllocation());
    _impl_.readingmessageinfo_ = p;
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* ESSReadingProfile::mutable_readingmessageinfo() {
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReadingProfile.readingMessageInfo)
  return _msg;
}
inline void ESSReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmessageinfo));
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReadingProfile.readingMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSReadingProfile::_internal_has_ess() const {
  return this != internal_default_instance() && _impl_.ess_ != nullptr;
}
inline bool ESSReadingProfile::has_ess() const {
  return _internal_has_ess();
}
inline const ::commonmodule::ESS& ESSReadingProfile::_internal_ess() const {
  const ::commonmodule::ESS* p = _impl_.ess_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ESS&>(
      ::commonmodule::_ESS_default_instance_);
}
inline const ::commonmodule::ESS& ESSReadingProfile::ess() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSReadingProfile.ess)
  return _internal_ess();
}
inline void ESSReadingProfile::unsafe_arena_set_allocated_ess(
    ::commonmodule::ESS* ess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSReadingProfile.ess)
}
inline ::commonmodule::ESS* ESSReadingProfile::release_ess() {
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ESS* ESSReadingProfile::unsafe_arena_release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReadingProfile.ess)
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSReadingProfile::_internal_mutable_ess() {
  
  if (_impl_.ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaForAllocation());
    _impl_.ess_ = p;
  }
  return _impl_.ess_;
}
inline ::commonmodule::ESS* ESSReadingProfile::mutable_ess() {
  ::commonmodule::ESS* _msg = _internal_mutable_ess();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReadingProfile.ess)
  return _msg;
}
inline void ESSReadingProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  if (ess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ess));
    if (message_arena != submessage_arena) {
      ess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }

  } else {

  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReadingProfile.ess)
}

// .essmodule.ESSReading essReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSReadingProfile::_internal_has_essreading() const {
  return this != internal_default_instance() && _impl_.essreading_ != nullptr;
}
inline bool ESSReadingProfile::has_essreading() const {
  return _internal_has_essreading();
}
inline void ESSReadingProfile::clear_essreading() {
  if (GetArenaForAllocation() == nullptr && _impl_.essreading_ != nullptr) {
    delete _impl_.essreading_;
  }
  _impl_.essreading_ = nullptr;
}
inline const ::essmodule::ESSReading& ESSReadingProfile::_internal_essreading() const {
  const ::essmodule::ESSReading* p = _impl_.essreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSReading&>(
      ::essmodule::_ESSReading_default_instance_);
}
inline const ::essmodule::ESSReading& ESSReadingProfile::essreading() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSReadingProfile.essReading)
  return _internal_essreading();
}
inline void ESSReadingProfile::unsafe_arena_set_allocated_essreading(
    ::essmodule::ESSReading* essreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.essreading_);
  }
  _impl_.essreading_ = essreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSReadingProfile.essReading)
}
inline ::essmodule::ESSReading* ESSReadingProfile::release_essreading() {
  
  ::essmodule::ESSReading* temp = _impl_.essreading_;
  _impl_.essreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSReading* ESSReadingProfile::unsafe_arena_release_essreading() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReadingProfile.essReading)
  
  ::essmodule::ESSReading* temp = _impl_.essreading_;
  _impl_.essreading_ = nullptr;
  return temp;
}
inline ::essmodule::ESSReading* ESSReadingProfile::_internal_mutable_essreading() {
  
  if (_impl_.essreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSReading>(GetArenaForAllocation());
    _impl_.essreading_ = p;
  }
  return _impl_.essreading_;
}
inline ::essmodule::ESSReading* ESSReadingProfile::mutable_essreading() {
  ::essmodule::ESSReading* _msg = _internal_mutable_essreading();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReadingProfile.essReading)
  return _msg;
}
inline void ESSReadingProfile::set_allocated_essreading(::essmodule::ESSReading* essreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.essreading_;
  }
  if (essreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(essreading);
    if (message_arena != submessage_arena) {
      essreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, essreading, submessage_arena);
    }

  } else {

  }
  _impl_.essreading_ = essreading;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReadingProfile.essReading)
}

// -------------------------------------------------------------------

// EssStatusZBAT

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EssStatusZBAT::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool EssStatusZBAT::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EssStatusZBAT::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EssStatusZBAT::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void EssStatusZBAT::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssStatusZBAT::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssStatusZBAT::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssStatusZBAT::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssStatusZBAT::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
  return _msg;
}
inline void EssStatusZBAT::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS BatSt = 2;
inline bool EssStatusZBAT::_internal_has_batst() const {
  return this != internal_default_instance() && _impl_.batst_ != nullptr;
}
inline bool EssStatusZBAT::has_batst() const {
  return _internal_has_batst();
}
inline const ::commonmodule::StatusSPS& EssStatusZBAT::_internal_batst() const {
  const ::commonmodule::StatusSPS* p = _impl_.batst_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EssStatusZBAT::batst() const {
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.BatSt)
  return _internal_batst();
}
inline void EssStatusZBAT::unsafe_arena_set_allocated_batst(
    ::commonmodule::StatusSPS* batst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batst_);
  }
  _impl_.batst_ = batst;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssStatusZBAT.BatSt)
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::release_batst() {
  
  ::commonmodule::StatusSPS* temp = _impl_.batst_;
  _impl_.batst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::unsafe_arena_release_batst() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.BatSt)
  
  ::commonmodule::StatusSPS* temp = _impl_.batst_;
  _impl_.batst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::_internal_mutable_batst() {
  
  if (_impl_.batst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.batst_ = p;
  }
  return _impl_.batst_;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::mutable_batst() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_batst();
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.BatSt)
  return _msg;
}
inline void EssStatusZBAT::set_allocated_batst(::commonmodule::StatusSPS* batst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batst_);
  }
  if (batst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batst));
    if (message_arena != submessage_arena) {
      batst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batst, submessage_arena);
    }

  } else {

  }
  _impl_.batst_ = batst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.BatSt)
}

// .commonmodule.ENG_GridConnectModeKind GriMod = 3;
inline bool EssStatusZBAT::_internal_has_grimod() const {
  return this != internal_default_instance() && _impl_.grimod_ != nullptr;
}
inline bool EssStatusZBAT::has_grimod() const {
  return _internal_has_grimod();
}
inline const ::commonmodule::ENG_GridConnectModeKind& EssStatusZBAT::_internal_grimod() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.grimod_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(
      ::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& EssStatusZBAT::grimod() const {
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.GriMod)
  return _internal_grimod();
}
inline void EssStatusZBAT::unsafe_arena_set_allocated_grimod(
    ::commonmodule::ENG_GridConnectModeKind* grimod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grimod_);
  }
  _impl_.grimod_ = grimod;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssStatusZBAT.GriMod)
}
inline ::commonmodule::ENG_GridConnectModeKind* EssStatusZBAT::release_grimod() {
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.grimod_;
  _impl_.grimod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* EssStatusZBAT::unsafe_arena_release_grimod() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.GriMod)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.grimod_;
  _impl_.grimod_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* EssStatusZBAT::_internal_mutable_grimod() {
  
  if (_impl_.grimod_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaForAllocation());
    _impl_.grimod_ = p;
  }
  return _impl_.grimod_;
}
inline ::commonmodule::ENG_GridConnectModeKind* EssStatusZBAT::mutable_grimod() {
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_grimod();
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.GriMod)
  return _msg;
}
inline void EssStatusZBAT::set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grimod_);
  }
  if (grimod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grimod));
    if (message_arena != submessage_arena) {
      grimod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grimod, submessage_arena);
    }

  } else {

  }
  _impl_.grimod_ = grimod;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.GriMod)
}

// .commonmodule.MV Soc = 4;
inline bool EssStatusZBAT::_internal_has_soc() const {
  return this != internal_default_instance() && _impl_.soc_ != nullptr;
}
inline bool EssStatusZBAT::has_soc() const {
  return _internal_has_soc();
}
inline const ::commonmodule::MV& EssStatusZBAT::_internal_soc() const {
  const ::commonmodule::MV* p = _impl_.soc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EssStatusZBAT::soc() const {
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.Soc)
  return _internal_soc();
}
inline void EssStatusZBAT::unsafe_arena_set_allocated_soc(
    ::commonmodule::MV* soc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soc_);
  }
  _impl_.soc_ = soc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssStatusZBAT.Soc)
}
inline ::commonmodule::MV* EssStatusZBAT::release_soc() {
  
  ::commonmodule::MV* temp = _impl_.soc_;
  _impl_.soc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* EssStatusZBAT::unsafe_arena_release_soc() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.Soc)
  
  ::commonmodule::MV* temp = _impl_.soc_;
  _impl_.soc_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssStatusZBAT::_internal_mutable_soc() {
  
  if (_impl_.soc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.soc_ = p;
  }
  return _impl_.soc_;
}
inline ::commonmodule::MV* EssStatusZBAT::mutable_soc() {
  ::commonmodule::MV* _msg = _internal_mutable_soc();
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.Soc)
  return _msg;
}
inline void EssStatusZBAT::set_allocated_soc(::commonmodule::MV* soc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soc_);
  }
  if (soc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soc));
    if (message_arena != submessage_arena) {
      soc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soc, submessage_arena);
    }

  } else {

  }
  _impl_.soc_ = soc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.Soc)
}

// .commonmodule.StatusSPS Stdby = 5;
inline bool EssStatusZBAT::_internal_has_stdby() const {
  return this != internal_default_instance() && _impl_.stdby_ != nullptr;
}
inline bool EssStatusZBAT::has_stdby() const {
  return _internal_has_stdby();
}
inline const ::commonmodule::StatusSPS& EssStatusZBAT::_internal_stdby() const {
  const ::commonmodule::StatusSPS* p = _impl_.stdby_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EssStatusZBAT::stdby() const {
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.Stdby)
  return _internal_stdby();
}
inline void EssStatusZBAT::unsafe_arena_set_allocated_stdby(
    ::commonmodule::StatusSPS* stdby) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stdby_);
  }
  _impl_.stdby_ = stdby;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssStatusZBAT.Stdby)
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::release_stdby() {
  
  ::commonmodule::StatusSPS* temp = _impl_.stdby_;
  _impl_.stdby_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::unsafe_arena_release_stdby() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.Stdby)
  
  ::commonmodule::StatusSPS* temp = _impl_.stdby_;
  _impl_.stdby_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::_internal_mutable_stdby() {
  
  if (_impl_.stdby_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.stdby_ = p;
  }
  return _impl_.stdby_;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::mutable_stdby() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_stdby();
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.Stdby)
  return _msg;
}
inline void EssStatusZBAT::set_allocated_stdby(::commonmodule::StatusSPS* stdby) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stdby_);
  }
  if (stdby) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stdby));
    if (message_arena != submessage_arena) {
      stdby = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stdby, submessage_arena);
    }

  } else {

  }
  _impl_.stdby_ = stdby;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.Stdby)
}

// .commonmodule.MV SoH = 6;
inline bool EssStatusZBAT::_internal_has_soh() const {
  return this != internal_default_instance() && _impl_.soh_ != nullptr;
}
inline bool EssStatusZBAT::has_soh() const {
  return _internal_has_soh();
}
inline const ::commonmodule::MV& EssStatusZBAT::_internal_soh() const {
  const ::commonmodule::MV* p = _impl_.soh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EssStatusZBAT::soh() const {
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.SoH)
  return _internal_soh();
}
inline void EssStatusZBAT::unsafe_arena_set_allocated_soh(
    ::commonmodule::MV* soh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soh_);
  }
  _impl_.soh_ = soh;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssStatusZBAT.SoH)
}
inline ::commonmodule::MV* EssStatusZBAT::release_soh() {
  
  ::commonmodule::MV* temp = _impl_.soh_;
  _impl_.soh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* EssStatusZBAT::unsafe_arena_release_soh() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.SoH)
  
  ::commonmodule::MV* temp = _impl_.soh_;
  _impl_.soh_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssStatusZBAT::_internal_mutable_soh() {
  
  if (_impl_.soh_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.soh_ = p;
  }
  return _impl_.soh_;
}
inline ::commonmodule::MV* EssStatusZBAT::mutable_soh() {
  ::commonmodule::MV* _msg = _internal_mutable_soh();
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.SoH)
  return _msg;
}
inline void EssStatusZBAT::set_allocated_soh(::commonmodule::MV* soh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.soh_);
  }
  if (soh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(soh));
    if (message_arena != submessage_arena) {
      soh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, soh, submessage_arena);
    }

  } else {

  }
  _impl_.soh_ = soh;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.SoH)
}

// .commonmodule.MV WHAvail = 7;
inline bool EssStatusZBAT::_internal_has_whavail() const {
  return this != internal_default_instance() && _impl_.whavail_ != nullptr;
}
inline bool EssStatusZBAT::has_whavail() const {
  return _internal_has_whavail();
}
inline const ::commonmodule::MV& EssStatusZBAT::_internal_whavail() const {
  const ::commonmodule::MV* p = _impl_.whavail_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(
      ::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EssStatusZBAT::whavail() const {
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.WHAvail)
  return _internal_whavail();
}
inline void EssStatusZBAT::unsafe_arena_set_allocated_whavail(
    ::commonmodule::MV* whavail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.whavail_);
  }
  _impl_.whavail_ = whavail;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.EssStatusZBAT.WHAvail)
}
inline ::commonmodule::MV* EssStatusZBAT::release_whavail() {
  
  ::commonmodule::MV* temp = _impl_.whavail_;
  _impl_.whavail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::MV* EssStatusZBAT::unsafe_arena_release_whavail() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.WHAvail)
  
  ::commonmodule::MV* temp = _impl_.whavail_;
  _impl_.whavail_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssStatusZBAT::_internal_mutable_whavail() {
  
  if (_impl_.whavail_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaForAllocation());
    _impl_.whavail_ = p;
  }
  return _impl_.whavail_;
}
inline ::commonmodule::MV* EssStatusZBAT::mutable_whavail() {
  ::commonmodule::MV* _msg = _internal_mutable_whavail();
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.WHAvail)
  return _msg;
}
inline void EssStatusZBAT::set_allocated_whavail(::commonmodule::MV* whavail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.whavail_);
  }
  if (whavail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(whavail));
    if (message_arena != submessage_arena) {
      whavail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, whavail, submessage_arena);
    }

  } else {

  }
  _impl_.whavail_ = whavail;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.WHAvail)
}

// -------------------------------------------------------------------

// ESSStatusZGEN

// .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool ESSStatusZGEN::_internal_has_esseventandstatuszgen() const {
  return this != internal_default_instance() && _impl_.esseventandstatuszgen_ != nullptr;
}
inline bool ESSStatusZGEN::has_esseventandstatuszgen() const {
  return _internal_has_esseventandstatuszgen();
}
inline void ESSStatusZGEN::clear_esseventandstatuszgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.esseventandstatuszgen_ != nullptr) {
    delete _impl_.esseventandstatuszgen_;
  }
  _impl_.esseventandstatuszgen_ = nullptr;
}
inline const ::essmodule::ESSEventAndStatusZGEN& ESSStatusZGEN::_internal_esseventandstatuszgen() const {
  const ::essmodule::ESSEventAndStatusZGEN* p = _impl_.esseventandstatuszgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSEventAndStatusZGEN&>(
      ::essmodule::_ESSEventAndStatusZGEN_default_instance_);
}
inline const ::essmodule::ESSEventAndStatusZGEN& ESSStatusZGEN::esseventandstatuszgen() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
  return _internal_esseventandstatuszgen();
}
inline void ESSStatusZGEN::unsafe_arena_set_allocated_esseventandstatuszgen(
    ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.esseventandstatuszgen_);
  }
  _impl_.esseventandstatuszgen_ = esseventandstatuszgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSStatusZGEN::release_esseventandstatuszgen() {
  
  ::essmodule::ESSEventAndStatusZGEN* temp = _impl_.esseventandstatuszgen_;
  _impl_.esseventandstatuszgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSStatusZGEN::unsafe_arena_release_esseventandstatuszgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
  
  ::essmodule::ESSEventAndStatusZGEN* temp = _impl_.esseventandstatuszgen_;
  _impl_.esseventandstatuszgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSStatusZGEN::_internal_mutable_esseventandstatuszgen() {
  
  if (_impl_.esseventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEventAndStatusZGEN>(GetArenaForAllocation());
    _impl_.esseventandstatuszgen_ = p;
  }
  return _impl_.esseventandstatuszgen_;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSStatusZGEN::mutable_esseventandstatuszgen() {
  ::essmodule::ESSEventAndStatusZGEN* _msg = _internal_mutable_esseventandstatuszgen();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
  return _msg;
}
inline void ESSStatusZGEN::set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.esseventandstatuszgen_;
  }
  if (esseventandstatuszgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(esseventandstatuszgen);
    if (message_arena != submessage_arena) {
      esseventandstatuszgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, esseventandstatuszgen, submessage_arena);
    }

  } else {

  }
  _impl_.esseventandstatuszgen_ = esseventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
}

// -------------------------------------------------------------------

// ESSStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSStatus::_internal_has_statusvalue() const {
  return this != internal_default_instance() && _impl_.statusvalue_ != nullptr;
}
inline bool ESSStatus::has_statusvalue() const {
  return _internal_has_statusvalue();
}
inline const ::commonmodule::StatusValue& ESSStatus::_internal_statusvalue() const {
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(
      ::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& ESSStatus::statusvalue() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSStatus.statusValue)
  return _internal_statusvalue();
}
inline void ESSStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* statusvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSStatus.statusValue)
}
inline ::commonmodule::StatusValue* ESSStatus::release_statusvalue() {
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusValue* ESSStatus::unsafe_arena_release_statusvalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* ESSStatus::_internal_mutable_statusvalue() {
  
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaForAllocation());
    _impl_.statusvalue_ = p;
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* ESSStatus::mutable_statusvalue() {
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatus.statusValue)
  return _msg;
}
inline void ESSStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  if (statusvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusvalue));
    if (message_arena != submessage_arena) {
      statusvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }

  } else {

  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatus.statusValue)
}

// .essmodule.EssStatusZBAT essStatusZBAT = 2;
inline bool ESSStatus::_internal_has_essstatuszbat() const {
  return this != internal_default_instance() && _impl_.essstatuszbat_ != nullptr;
}
inline bool ESSStatus::has_essstatuszbat() const {
  return _internal_has_essstatuszbat();
}
inline void ESSStatus::clear_essstatuszbat() {
  if (GetArenaForAllocation() == nullptr && _impl_.essstatuszbat_ != nullptr) {
    delete _impl_.essstatuszbat_;
  }
  _impl_.essstatuszbat_ = nullptr;
}
inline const ::essmodule::EssStatusZBAT& ESSStatus::_internal_essstatuszbat() const {
  const ::essmodule::EssStatusZBAT* p = _impl_.essstatuszbat_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::EssStatusZBAT&>(
      ::essmodule::_EssStatusZBAT_default_instance_);
}
inline const ::essmodule::EssStatusZBAT& ESSStatus::essstatuszbat() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSStatus.essStatusZBAT)
  return _internal_essstatuszbat();
}
inline void ESSStatus::unsafe_arena_set_allocated_essstatuszbat(
    ::essmodule::EssStatusZBAT* essstatuszbat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.essstatuszbat_);
  }
  _impl_.essstatuszbat_ = essstatuszbat;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSStatus.essStatusZBAT)
}
inline ::essmodule::EssStatusZBAT* ESSStatus::release_essstatuszbat() {
  
  ::essmodule::EssStatusZBAT* temp = _impl_.essstatuszbat_;
  _impl_.essstatuszbat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::EssStatusZBAT* ESSStatus::unsafe_arena_release_essstatuszbat() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatus.essStatusZBAT)
  
  ::essmodule::EssStatusZBAT* temp = _impl_.essstatuszbat_;
  _impl_.essstatuszbat_ = nullptr;
  return temp;
}
inline ::essmodule::EssStatusZBAT* ESSStatus::_internal_mutable_essstatuszbat() {
  
  if (_impl_.essstatuszbat_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::EssStatusZBAT>(GetArenaForAllocation());
    _impl_.essstatuszbat_ = p;
  }
  return _impl_.essstatuszbat_;
}
inline ::essmodule::EssStatusZBAT* ESSStatus::mutable_essstatuszbat() {
  ::essmodule::EssStatusZBAT* _msg = _internal_mutable_essstatuszbat();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatus.essStatusZBAT)
  return _msg;
}
inline void ESSStatus::set_allocated_essstatuszbat(::essmodule::EssStatusZBAT* essstatuszbat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.essstatuszbat_;
  }
  if (essstatuszbat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(essstatuszbat);
    if (message_arena != submessage_arena) {
      essstatuszbat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, essstatuszbat, submessage_arena);
    }

  } else {

  }
  _impl_.essstatuszbat_ = essstatuszbat;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatus.essStatusZBAT)
}

// .essmodule.ESSStatusZGEN essStatusZGEN = 3;
inline bool ESSStatus::_internal_has_essstatuszgen() const {
  return this != internal_default_instance() && _impl_.essstatuszgen_ != nullptr;
}
inline bool ESSStatus::has_essstatuszgen() const {
  return _internal_has_essstatuszgen();
}
inline void ESSStatus::clear_essstatuszgen() {
  if (GetArenaForAllocation() == nullptr && _impl_.essstatuszgen_ != nullptr) {
    delete _impl_.essstatuszgen_;
  }
  _impl_.essstatuszgen_ = nullptr;
}
inline const ::essmodule::ESSStatusZGEN& ESSStatus::_internal_essstatuszgen() const {
  const ::essmodule::ESSStatusZGEN* p = _impl_.essstatuszgen_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSStatusZGEN&>(
      ::essmodule::_ESSStatusZGEN_default_instance_);
}
inline const ::essmodule::ESSStatusZGEN& ESSStatus::essstatuszgen() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSStatus.essStatusZGEN)
  return _internal_essstatuszgen();
}
inline void ESSStatus::unsafe_arena_set_allocated_essstatuszgen(
    ::essmodule::ESSStatusZGEN* essstatuszgen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.essstatuszgen_);
  }
  _impl_.essstatuszgen_ = essstatuszgen;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSStatus.essStatusZGEN)
}
inline ::essmodule::ESSStatusZGEN* ESSStatus::release_essstatuszgen() {
  
  ::essmodule::ESSStatusZGEN* temp = _impl_.essstatuszgen_;
  _impl_.essstatuszgen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSStatusZGEN* ESSStatus::unsafe_arena_release_essstatuszgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatus.essStatusZGEN)
  
  ::essmodule::ESSStatusZGEN* temp = _impl_.essstatuszgen_;
  _impl_.essstatuszgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSStatusZGEN* ESSStatus::_internal_mutable_essstatuszgen() {
  
  if (_impl_.essstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSStatusZGEN>(GetArenaForAllocation());
    _impl_.essstatuszgen_ = p;
  }
  return _impl_.essstatuszgen_;
}
inline ::essmodule::ESSStatusZGEN* ESSStatus::mutable_essstatuszgen() {
  ::essmodule::ESSStatusZGEN* _msg = _internal_mutable_essstatuszgen();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatus.essStatusZGEN)
  return _msg;
}
inline void ESSStatus::set_allocated_essstatuszgen(::essmodule::ESSStatusZGEN* essstatuszgen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.essstatuszgen_;
  }
  if (essstatuszgen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(essstatuszgen);
    if (message_arena != submessage_arena) {
      essstatuszgen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, essstatuszgen, submessage_arena);
    }

  } else {

  }
  _impl_.essstatuszgen_ = essstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatus.essStatusZGEN)
}

// -------------------------------------------------------------------

// ESSStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSStatusProfile::_internal_has_statusmessageinfo() const {
  return this != internal_default_instance() && _impl_.statusmessageinfo_ != nullptr;
}
inline bool ESSStatusProfile::has_statusmessageinfo() const {
  return _internal_has_statusmessageinfo();
}
inline const ::commonmodule::StatusMessageInfo& ESSStatusProfile::_internal_statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(
      ::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& ESSStatusProfile::statusmessageinfo() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void ESSStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* statusmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* ESSStatusProfile::release_statusmessageinfo() {
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusMessageInfo* ESSStatusProfile::unsafe_arena_release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* ESSStatusProfile::_internal_mutable_statusmessageinfo() {
  
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaForAllocation());
    _impl_.statusmessageinfo_ = p;
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* ESSStatusProfile::mutable_statusmessageinfo() {
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusProfile.statusMessageInfo)
  return _msg;
}
inline void ESSStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusmessageinfo));
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusProfile.statusMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSStatusProfile::_internal_has_ess() const {
  return this != internal_default_instance() && _impl_.ess_ != nullptr;
}
inline bool ESSStatusProfile::has_ess() const {
  return _internal_has_ess();
}
inline const ::commonmodule::ESS& ESSStatusProfile::_internal_ess() const {
  const ::commonmodule::ESS* p = _impl_.ess_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ESS&>(
      ::commonmodule::_ESS_default_instance_);
}
inline const ::commonmodule::ESS& ESSStatusProfile::ess() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusProfile.ess)
  return _internal_ess();
}
inline void ESSStatusProfile::unsafe_arena_set_allocated_ess(
    ::commonmodule::ESS* ess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSStatusProfile.ess)
}
inline ::commonmodule::ESS* ESSStatusProfile::release_ess() {
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ESS* ESSStatusProfile::unsafe_arena_release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusProfile.ess)
  
  ::commonmodule::ESS* temp = _impl_.ess_;
  _impl_.ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSStatusProfile::_internal_mutable_ess() {
  
  if (_impl_.ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaForAllocation());
    _impl_.ess_ = p;
  }
  return _impl_.ess_;
}
inline ::commonmodule::ESS* ESSStatusProfile::mutable_ess() {
  ::commonmodule::ESS* _msg = _internal_mutable_ess();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusProfile.ess)
  return _msg;
}
inline void ESSStatusProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ess_);
  }
  if (ess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ess));
    if (message_arena != submessage_arena) {
      ess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }

  } else {

  }
  _impl_.ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusProfile.ess)
}

// .essmodule.ESSStatus essStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSStatusProfile::_internal_has_essstatus() const {
  return this != internal_default_instance() && _impl_.essstatus_ != nullptr;
}
inline bool ESSStatusProfile::has_essstatus() const {
  return _internal_has_essstatus();
}
inline void ESSStatusProfile::clear_essstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.essstatus_ != nullptr) {
    delete _impl_.essstatus_;
  }
  _impl_.essstatus_ = nullptr;
}
inline const ::essmodule::ESSStatus& ESSStatusProfile::_internal_essstatus() const {
  const ::essmodule::ESSStatus* p = _impl_.essstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::essmodule::ESSStatus&>(
      ::essmodule::_ESSStatus_default_instance_);
}
inline const ::essmodule::ESSStatus& ESSStatusProfile::essstatus() const {
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusProfile.essStatus)
  return _internal_essstatus();
}
inline void ESSStatusProfile::unsafe_arena_set_allocated_essstatus(
    ::essmodule::ESSStatus* essstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.essstatus_);
  }
  _impl_.essstatus_ = essstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:essmodule.ESSStatusProfile.essStatus)
}
inline ::essmodule::ESSStatus* ESSStatusProfile::release_essstatus() {
  
  ::essmodule::ESSStatus* temp = _impl_.essstatus_;
  _impl_.essstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::essmodule::ESSStatus* ESSStatusProfile::unsafe_arena_release_essstatus() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusProfile.essStatus)
  
  ::essmodule::ESSStatus* temp = _impl_.essstatus_;
  _impl_.essstatus_ = nullptr;
  return temp;
}
inline ::essmodule::ESSStatus* ESSStatusProfile::_internal_mutable_essstatus() {
  
  if (_impl_.essstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSStatus>(GetArenaForAllocation());
    _impl_.essstatus_ = p;
  }
  return _impl_.essstatus_;
}
inline ::essmodule::ESSStatus* ESSStatusProfile::mutable_essstatus() {
  ::essmodule::ESSStatus* _msg = _internal_mutable_essstatus();
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusProfile.essStatus)
  return _msg;
}
inline void ESSStatusProfile::set_allocated_essstatus(::essmodule::ESSStatus* essstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.essstatus_;
  }
  if (essstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(essstatus);
    if (message_arena != submessage_arena) {
      essstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, essstatus, submessage_arena);
    }

  } else {

  }
  _impl_.essstatus_ = essstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusProfile.essStatus)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace essmodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_essmodule_2fessmodule_2eproto_2epb_2eh
