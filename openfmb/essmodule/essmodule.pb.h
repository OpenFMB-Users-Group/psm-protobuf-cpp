// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: essmodule/essmodule.proto

#ifndef PROTOBUF_INCLUDED_essmodule_2fessmodule_2eproto
#define PROTOBUF_INCLUDED_essmodule_2fessmodule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "uml.pb.h"
#include <google/protobuf/wrappers.pb.h>
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_essmodule_2fessmodule_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_essmodule_2fessmodule_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_essmodule_2fessmodule_2eproto();
namespace essmodule {
class CapacityFirming;
class CapacityFirmingDefaultTypeInternal;
extern CapacityFirmingDefaultTypeInternal _CapacityFirming_default_instance_;
class ESSCSG;
class ESSCSGDefaultTypeInternal;
extern ESSCSGDefaultTypeInternal _ESSCSG_default_instance_;
class ESSControl;
class ESSControlDefaultTypeInternal;
extern ESSControlDefaultTypeInternal _ESSControl_default_instance_;
class ESSControlProfile;
class ESSControlProfileDefaultTypeInternal;
extern ESSControlProfileDefaultTypeInternal _ESSControlProfile_default_instance_;
class ESSControlScheduleFSCH;
class ESSControlScheduleFSCHDefaultTypeInternal;
extern ESSControlScheduleFSCHDefaultTypeInternal _ESSControlScheduleFSCH_default_instance_;
class ESSEvent;
class ESSEventDefaultTypeInternal;
extern ESSEventDefaultTypeInternal _ESSEvent_default_instance_;
class ESSEventAndStatusZGEN;
class ESSEventAndStatusZGENDefaultTypeInternal;
extern ESSEventAndStatusZGENDefaultTypeInternal _ESSEventAndStatusZGEN_default_instance_;
class ESSEventProfile;
class ESSEventProfileDefaultTypeInternal;
extern ESSEventProfileDefaultTypeInternal _ESSEventProfile_default_instance_;
class ESSEventZGEN;
class ESSEventZGENDefaultTypeInternal;
extern ESSEventZGENDefaultTypeInternal _ESSEventZGEN_default_instance_;
class ESSFunction;
class ESSFunctionDefaultTypeInternal;
extern ESSFunctionDefaultTypeInternal _ESSFunction_default_instance_;
class ESSPoint;
class ESSPointDefaultTypeInternal;
extern ESSPointDefaultTypeInternal _ESSPoint_default_instance_;
class ESSPointStatus;
class ESSPointStatusDefaultTypeInternal;
extern ESSPointStatusDefaultTypeInternal _ESSPointStatus_default_instance_;
class ESSReading;
class ESSReadingDefaultTypeInternal;
extern ESSReadingDefaultTypeInternal _ESSReading_default_instance_;
class ESSReadingProfile;
class ESSReadingProfileDefaultTypeInternal;
extern ESSReadingProfileDefaultTypeInternal _ESSReadingProfile_default_instance_;
class ESSStatus;
class ESSStatusDefaultTypeInternal;
extern ESSStatusDefaultTypeInternal _ESSStatus_default_instance_;
class ESSStatusProfile;
class ESSStatusProfileDefaultTypeInternal;
extern ESSStatusProfileDefaultTypeInternal _ESSStatusProfile_default_instance_;
class ESSStatusZGEN;
class ESSStatusZGENDefaultTypeInternal;
extern ESSStatusZGENDefaultTypeInternal _ESSStatusZGEN_default_instance_;
class EssControlFSCC;
class EssControlFSCCDefaultTypeInternal;
extern EssControlFSCCDefaultTypeInternal _EssControlFSCC_default_instance_;
class EssEventZBAT;
class EssEventZBATDefaultTypeInternal;
extern EssEventZBATDefaultTypeInternal _EssEventZBAT_default_instance_;
class EssStatusZBAT;
class EssStatusZBATDefaultTypeInternal;
extern EssStatusZBATDefaultTypeInternal _EssStatusZBAT_default_instance_;
class FrequencyRegulation;
class FrequencyRegulationDefaultTypeInternal;
extern FrequencyRegulationDefaultTypeInternal _FrequencyRegulation_default_instance_;
class PeakShaving;
class PeakShavingDefaultTypeInternal;
extern PeakShavingDefaultTypeInternal _PeakShaving_default_instance_;
class SOCManagement;
class SOCManagementDefaultTypeInternal;
extern SOCManagementDefaultTypeInternal _SOCManagement_default_instance_;
class SocLimit;
class SocLimitDefaultTypeInternal;
extern SocLimitDefaultTypeInternal _SocLimit_default_instance_;
class VoltageDroop;
class VoltageDroopDefaultTypeInternal;
extern VoltageDroopDefaultTypeInternal _VoltageDroop_default_instance_;
class VoltagePI;
class VoltagePIDefaultTypeInternal;
extern VoltagePIDefaultTypeInternal _VoltagePI_default_instance_;
class VoltageRegulation;
class VoltageRegulationDefaultTypeInternal;
extern VoltageRegulationDefaultTypeInternal _VoltageRegulation_default_instance_;
}  // namespace essmodule
namespace google {
namespace protobuf {
template<> ::essmodule::CapacityFirming* Arena::CreateMaybeMessage<::essmodule::CapacityFirming>(Arena*);
template<> ::essmodule::ESSCSG* Arena::CreateMaybeMessage<::essmodule::ESSCSG>(Arena*);
template<> ::essmodule::ESSControl* Arena::CreateMaybeMessage<::essmodule::ESSControl>(Arena*);
template<> ::essmodule::ESSControlProfile* Arena::CreateMaybeMessage<::essmodule::ESSControlProfile>(Arena*);
template<> ::essmodule::ESSControlScheduleFSCH* Arena::CreateMaybeMessage<::essmodule::ESSControlScheduleFSCH>(Arena*);
template<> ::essmodule::ESSEvent* Arena::CreateMaybeMessage<::essmodule::ESSEvent>(Arena*);
template<> ::essmodule::ESSEventAndStatusZGEN* Arena::CreateMaybeMessage<::essmodule::ESSEventAndStatusZGEN>(Arena*);
template<> ::essmodule::ESSEventProfile* Arena::CreateMaybeMessage<::essmodule::ESSEventProfile>(Arena*);
template<> ::essmodule::ESSEventZGEN* Arena::CreateMaybeMessage<::essmodule::ESSEventZGEN>(Arena*);
template<> ::essmodule::ESSFunction* Arena::CreateMaybeMessage<::essmodule::ESSFunction>(Arena*);
template<> ::essmodule::ESSPoint* Arena::CreateMaybeMessage<::essmodule::ESSPoint>(Arena*);
template<> ::essmodule::ESSPointStatus* Arena::CreateMaybeMessage<::essmodule::ESSPointStatus>(Arena*);
template<> ::essmodule::ESSReading* Arena::CreateMaybeMessage<::essmodule::ESSReading>(Arena*);
template<> ::essmodule::ESSReadingProfile* Arena::CreateMaybeMessage<::essmodule::ESSReadingProfile>(Arena*);
template<> ::essmodule::ESSStatus* Arena::CreateMaybeMessage<::essmodule::ESSStatus>(Arena*);
template<> ::essmodule::ESSStatusProfile* Arena::CreateMaybeMessage<::essmodule::ESSStatusProfile>(Arena*);
template<> ::essmodule::ESSStatusZGEN* Arena::CreateMaybeMessage<::essmodule::ESSStatusZGEN>(Arena*);
template<> ::essmodule::EssControlFSCC* Arena::CreateMaybeMessage<::essmodule::EssControlFSCC>(Arena*);
template<> ::essmodule::EssEventZBAT* Arena::CreateMaybeMessage<::essmodule::EssEventZBAT>(Arena*);
template<> ::essmodule::EssStatusZBAT* Arena::CreateMaybeMessage<::essmodule::EssStatusZBAT>(Arena*);
template<> ::essmodule::FrequencyRegulation* Arena::CreateMaybeMessage<::essmodule::FrequencyRegulation>(Arena*);
template<> ::essmodule::PeakShaving* Arena::CreateMaybeMessage<::essmodule::PeakShaving>(Arena*);
template<> ::essmodule::SOCManagement* Arena::CreateMaybeMessage<::essmodule::SOCManagement>(Arena*);
template<> ::essmodule::SocLimit* Arena::CreateMaybeMessage<::essmodule::SocLimit>(Arena*);
template<> ::essmodule::VoltageDroop* Arena::CreateMaybeMessage<::essmodule::VoltageDroop>(Arena*);
template<> ::essmodule::VoltagePI* Arena::CreateMaybeMessage<::essmodule::VoltagePI>(Arena*);
template<> ::essmodule::VoltageRegulation* Arena::CreateMaybeMessage<::essmodule::VoltageRegulation>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace essmodule {

// ===================================================================

class EssEventZBAT :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.EssEventZBAT) */ {
 public:
  EssEventZBAT();
  virtual ~EssEventZBAT();

  EssEventZBAT(const EssEventZBAT& from);

  inline EssEventZBAT& operator=(const EssEventZBAT& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EssEventZBAT(EssEventZBAT&& from) noexcept
    : EssEventZBAT() {
    *this = ::std::move(from);
  }

  inline EssEventZBAT& operator=(EssEventZBAT&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EssEventZBAT& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EssEventZBAT* internal_default_instance() {
    return reinterpret_cast<const EssEventZBAT*>(
               &_EssEventZBAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EssEventZBAT* other);
  friend void swap(EssEventZBAT& a, EssEventZBAT& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EssEventZBAT* New() const final {
    return CreateMaybeMessage<EssEventZBAT>(nullptr);
  }

  EssEventZBAT* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EssEventZBAT>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EssEventZBAT& from);
  void MergeFrom(const EssEventZBAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EssEventZBAT* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.StatusSPS BatHi = 2;
  bool has_bathi() const;
  void clear_bathi();
  static const int kBatHiFieldNumber = 2;
  const ::commonmodule::StatusSPS& bathi() const;
  ::commonmodule::StatusSPS* release_bathi();
  ::commonmodule::StatusSPS* mutable_bathi();
  void set_allocated_bathi(::commonmodule::StatusSPS* bathi);

  // .commonmodule.StatusSPS BatLo = 3;
  bool has_batlo() const;
  void clear_batlo();
  static const int kBatLoFieldNumber = 3;
  const ::commonmodule::StatusSPS& batlo() const;
  ::commonmodule::StatusSPS* release_batlo();
  ::commonmodule::StatusSPS* mutable_batlo();
  void set_allocated_batlo(::commonmodule::StatusSPS* batlo);

  // .commonmodule.StatusSPS BatSt = 4;
  bool has_batst() const;
  void clear_batst();
  static const int kBatStFieldNumber = 4;
  const ::commonmodule::StatusSPS& batst() const;
  ::commonmodule::StatusSPS* release_batst();
  ::commonmodule::StatusSPS* mutable_batst();
  void set_allocated_batst(::commonmodule::StatusSPS* batst);

  // .commonmodule.MV Soc = 5;
  bool has_soc() const;
  void clear_soc();
  static const int kSocFieldNumber = 5;
  const ::commonmodule::MV& soc() const;
  ::commonmodule::MV* release_soc();
  ::commonmodule::MV* mutable_soc();
  void set_allocated_soc(::commonmodule::MV* soc);

  // .commonmodule.StatusSPS Stdby = 6;
  bool has_stdby() const;
  void clear_stdby();
  static const int kStdbyFieldNumber = 6;
  const ::commonmodule::StatusSPS& stdby() const;
  ::commonmodule::StatusSPS* release_stdby();
  ::commonmodule::StatusSPS* mutable_stdby();
  void set_allocated_stdby(::commonmodule::StatusSPS* stdby);

  // @@protoc_insertion_point(class_scope:essmodule.EssEventZBAT)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::StatusSPS* bathi_;
  ::commonmodule::StatusSPS* batlo_;
  ::commonmodule::StatusSPS* batst_;
  ::commonmodule::MV* soc_;
  ::commonmodule::StatusSPS* stdby_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class FrequencyRegulation :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.FrequencyRegulation) */ {
 public:
  FrequencyRegulation();
  virtual ~FrequencyRegulation();

  FrequencyRegulation(const FrequencyRegulation& from);

  inline FrequencyRegulation& operator=(const FrequencyRegulation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrequencyRegulation(FrequencyRegulation&& from) noexcept
    : FrequencyRegulation() {
    *this = ::std::move(from);
  }

  inline FrequencyRegulation& operator=(FrequencyRegulation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FrequencyRegulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrequencyRegulation* internal_default_instance() {
    return reinterpret_cast<const FrequencyRegulation*>(
               &_FrequencyRegulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FrequencyRegulation* other);
  friend void swap(FrequencyRegulation& a, FrequencyRegulation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrequencyRegulation* New() const final {
    return CreateMaybeMessage<FrequencyRegulation>(nullptr);
  }

  FrequencyRegulation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FrequencyRegulation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FrequencyRegulation& from);
  void MergeFrom(const FrequencyRegulation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrequencyRegulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue frequencyDeadBandMinus = 1;
  bool has_frequencydeadbandminus() const;
  void clear_frequencydeadbandminus();
  static const int kFrequencyDeadBandMinusFieldNumber = 1;
  const ::google::protobuf::FloatValue& frequencydeadbandminus() const;
  ::google::protobuf::FloatValue* release_frequencydeadbandminus();
  ::google::protobuf::FloatValue* mutable_frequencydeadbandminus();
  void set_allocated_frequencydeadbandminus(::google::protobuf::FloatValue* frequencydeadbandminus);

  // .google.protobuf.FloatValue frequencyDeadBandPlus = 2;
  bool has_frequencydeadbandplus() const;
  void clear_frequencydeadbandplus();
  static const int kFrequencyDeadBandPlusFieldNumber = 2;
  const ::google::protobuf::FloatValue& frequencydeadbandplus() const;
  ::google::protobuf::FloatValue* release_frequencydeadbandplus();
  ::google::protobuf::FloatValue* mutable_frequencydeadbandplus();
  void set_allocated_frequencydeadbandplus(::google::protobuf::FloatValue* frequencydeadbandplus);

  // .google.protobuf.BoolValue frequencyRegulationCtl = 3;
  bool has_frequencyregulationctl() const;
  void clear_frequencyregulationctl();
  static const int kFrequencyRegulationCtlFieldNumber = 3;
  const ::google::protobuf::BoolValue& frequencyregulationctl() const;
  ::google::protobuf::BoolValue* release_frequencyregulationctl();
  ::google::protobuf::BoolValue* mutable_frequencyregulationctl();
  void set_allocated_frequencyregulationctl(::google::protobuf::BoolValue* frequencyregulationctl);

  // .google.protobuf.FloatValue frequencySetPoint = 4;
  bool has_frequencysetpoint() const;
  void clear_frequencysetpoint();
  static const int kFrequencySetPointFieldNumber = 4;
  const ::google::protobuf::FloatValue& frequencysetpoint() const;
  ::google::protobuf::FloatValue* release_frequencysetpoint();
  ::google::protobuf::FloatValue* mutable_frequencysetpoint();
  void set_allocated_frequencysetpoint(::google::protobuf::FloatValue* frequencysetpoint);

  // .google.protobuf.FloatValue gridFrequencyStableBandMinus = 5;
  bool has_gridfrequencystablebandminus() const;
  void clear_gridfrequencystablebandminus();
  static const int kGridFrequencyStableBandMinusFieldNumber = 5;
  const ::google::protobuf::FloatValue& gridfrequencystablebandminus() const;
  ::google::protobuf::FloatValue* release_gridfrequencystablebandminus();
  ::google::protobuf::FloatValue* mutable_gridfrequencystablebandminus();
  void set_allocated_gridfrequencystablebandminus(::google::protobuf::FloatValue* gridfrequencystablebandminus);

  // .google.protobuf.FloatValue gridFrequencyStableBandPlus = 6;
  bool has_gridfrequencystablebandplus() const;
  void clear_gridfrequencystablebandplus();
  static const int kGridFrequencyStableBandPlusFieldNumber = 6;
  const ::google::protobuf::FloatValue& gridfrequencystablebandplus() const;
  ::google::protobuf::FloatValue* release_gridfrequencystablebandplus();
  ::google::protobuf::FloatValue* mutable_gridfrequencystablebandplus();
  void set_allocated_gridfrequencystablebandplus(::google::protobuf::FloatValue* gridfrequencystablebandplus);

  // .google.protobuf.FloatValue overFrequencyDroop = 7;
  bool has_overfrequencydroop() const;
  void clear_overfrequencydroop();
  static const int kOverFrequencyDroopFieldNumber = 7;
  const ::google::protobuf::FloatValue& overfrequencydroop() const;
  ::google::protobuf::FloatValue* release_overfrequencydroop();
  ::google::protobuf::FloatValue* mutable_overfrequencydroop();
  void set_allocated_overfrequencydroop(::google::protobuf::FloatValue* overfrequencydroop);

  // .google.protobuf.FloatValue underFrequencyDroop = 8;
  bool has_underfrequencydroop() const;
  void clear_underfrequencydroop();
  static const int kUnderFrequencyDroopFieldNumber = 8;
  const ::google::protobuf::FloatValue& underfrequencydroop() const;
  ::google::protobuf::FloatValue* release_underfrequencydroop();
  ::google::protobuf::FloatValue* mutable_underfrequencydroop();
  void set_allocated_underfrequencydroop(::google::protobuf::FloatValue* underfrequencydroop);

  // @@protoc_insertion_point(class_scope:essmodule.FrequencyRegulation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* frequencydeadbandminus_;
  ::google::protobuf::FloatValue* frequencydeadbandplus_;
  ::google::protobuf::BoolValue* frequencyregulationctl_;
  ::google::protobuf::FloatValue* frequencysetpoint_;
  ::google::protobuf::FloatValue* gridfrequencystablebandminus_;
  ::google::protobuf::FloatValue* gridfrequencystablebandplus_;
  ::google::protobuf::FloatValue* overfrequencydroop_;
  ::google::protobuf::FloatValue* underfrequencydroop_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class PeakShaving :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.PeakShaving) */ {
 public:
  PeakShaving();
  virtual ~PeakShaving();

  PeakShaving(const PeakShaving& from);

  inline PeakShaving& operator=(const PeakShaving& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PeakShaving(PeakShaving&& from) noexcept
    : PeakShaving() {
    *this = ::std::move(from);
  }

  inline PeakShaving& operator=(PeakShaving&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PeakShaving& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeakShaving* internal_default_instance() {
    return reinterpret_cast<const PeakShaving*>(
               &_PeakShaving_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PeakShaving* other);
  friend void swap(PeakShaving& a, PeakShaving& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PeakShaving* New() const final {
    return CreateMaybeMessage<PeakShaving>(nullptr);
  }

  PeakShaving* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PeakShaving>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PeakShaving& from);
  void MergeFrom(const PeakShaving& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeakShaving* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue baseShavingLimit = 1;
  bool has_baseshavinglimit() const;
  void clear_baseshavinglimit();
  static const int kBaseShavingLimitFieldNumber = 1;
  const ::google::protobuf::FloatValue& baseshavinglimit() const;
  ::google::protobuf::FloatValue* release_baseshavinglimit();
  ::google::protobuf::FloatValue* mutable_baseshavinglimit();
  void set_allocated_baseshavinglimit(::google::protobuf::FloatValue* baseshavinglimit);

  // .google.protobuf.BoolValue peakShavingCtl = 2;
  bool has_peakshavingctl() const;
  void clear_peakshavingctl();
  static const int kPeakShavingCtlFieldNumber = 2;
  const ::google::protobuf::BoolValue& peakshavingctl() const;
  ::google::protobuf::BoolValue* release_peakshavingctl();
  ::google::protobuf::BoolValue* mutable_peakshavingctl();
  void set_allocated_peakshavingctl(::google::protobuf::BoolValue* peakshavingctl);

  // .google.protobuf.FloatValue peakShavingLimit = 3;
  bool has_peakshavinglimit() const;
  void clear_peakshavinglimit();
  static const int kPeakShavingLimitFieldNumber = 3;
  const ::google::protobuf::FloatValue& peakshavinglimit() const;
  ::google::protobuf::FloatValue* release_peakshavinglimit();
  ::google::protobuf::FloatValue* mutable_peakshavinglimit();
  void set_allocated_peakshavinglimit(::google::protobuf::FloatValue* peakshavinglimit);

  // .google.protobuf.FloatValue socManagementAllowedHighLimit = 4;
  bool has_socmanagementallowedhighlimit() const;
  void clear_socmanagementallowedhighlimit();
  static const int kSocManagementAllowedHighLimitFieldNumber = 4;
  const ::google::protobuf::FloatValue& socmanagementallowedhighlimit() const;
  ::google::protobuf::FloatValue* release_socmanagementallowedhighlimit();
  ::google::protobuf::FloatValue* mutable_socmanagementallowedhighlimit();
  void set_allocated_socmanagementallowedhighlimit(::google::protobuf::FloatValue* socmanagementallowedhighlimit);

  // .google.protobuf.FloatValue socManagementAllowedLowLimit = 5;
  bool has_socmanagementallowedlowlimit() const;
  void clear_socmanagementallowedlowlimit();
  static const int kSocManagementAllowedLowLimitFieldNumber = 5;
  const ::google::protobuf::FloatValue& socmanagementallowedlowlimit() const;
  ::google::protobuf::FloatValue* release_socmanagementallowedlowlimit();
  ::google::protobuf::FloatValue* mutable_socmanagementallowedlowlimit();
  void set_allocated_socmanagementallowedlowlimit(::google::protobuf::FloatValue* socmanagementallowedlowlimit);

  // @@protoc_insertion_point(class_scope:essmodule.PeakShaving)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* baseshavinglimit_;
  ::google::protobuf::BoolValue* peakshavingctl_;
  ::google::protobuf::FloatValue* peakshavinglimit_;
  ::google::protobuf::FloatValue* socmanagementallowedhighlimit_;
  ::google::protobuf::FloatValue* socmanagementallowedlowlimit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class SocLimit :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.SocLimit) */ {
 public:
  SocLimit();
  virtual ~SocLimit();

  SocLimit(const SocLimit& from);

  inline SocLimit& operator=(const SocLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SocLimit(SocLimit&& from) noexcept
    : SocLimit() {
    *this = ::std::move(from);
  }

  inline SocLimit& operator=(SocLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SocLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SocLimit* internal_default_instance() {
    return reinterpret_cast<const SocLimit*>(
               &_SocLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SocLimit* other);
  friend void swap(SocLimit& a, SocLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SocLimit* New() const final {
    return CreateMaybeMessage<SocLimit>(nullptr);
  }

  SocLimit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SocLimit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SocLimit& from);
  void MergeFrom(const SocLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SocLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue socHighLimit = 1;
  bool has_sochighlimit() const;
  void clear_sochighlimit();
  static const int kSocHighLimitFieldNumber = 1;
  const ::google::protobuf::FloatValue& sochighlimit() const;
  ::google::protobuf::FloatValue* release_sochighlimit();
  ::google::protobuf::FloatValue* mutable_sochighlimit();
  void set_allocated_sochighlimit(::google::protobuf::FloatValue* sochighlimit);

  // .google.protobuf.FloatValue socHighLimitHysteresis = 2;
  bool has_sochighlimithysteresis() const;
  void clear_sochighlimithysteresis();
  static const int kSocHighLimitHysteresisFieldNumber = 2;
  const ::google::protobuf::FloatValue& sochighlimithysteresis() const;
  ::google::protobuf::FloatValue* release_sochighlimithysteresis();
  ::google::protobuf::FloatValue* mutable_sochighlimithysteresis();
  void set_allocated_sochighlimithysteresis(::google::protobuf::FloatValue* sochighlimithysteresis);

  // .google.protobuf.BoolValue socLimitCtl = 3;
  bool has_soclimitctl() const;
  void clear_soclimitctl();
  static const int kSocLimitCtlFieldNumber = 3;
  const ::google::protobuf::BoolValue& soclimitctl() const;
  ::google::protobuf::BoolValue* release_soclimitctl();
  ::google::protobuf::BoolValue* mutable_soclimitctl();
  void set_allocated_soclimitctl(::google::protobuf::BoolValue* soclimitctl);

  // .google.protobuf.FloatValue socLowLimit = 4;
  bool has_soclowlimit() const;
  void clear_soclowlimit();
  static const int kSocLowLimitFieldNumber = 4;
  const ::google::protobuf::FloatValue& soclowlimit() const;
  ::google::protobuf::FloatValue* release_soclowlimit();
  ::google::protobuf::FloatValue* mutable_soclowlimit();
  void set_allocated_soclowlimit(::google::protobuf::FloatValue* soclowlimit);

  // .google.protobuf.FloatValue socLowLimitHysteresis = 5;
  bool has_soclowlimithysteresis() const;
  void clear_soclowlimithysteresis();
  static const int kSocLowLimitHysteresisFieldNumber = 5;
  const ::google::protobuf::FloatValue& soclowlimithysteresis() const;
  ::google::protobuf::FloatValue* release_soclowlimithysteresis();
  ::google::protobuf::FloatValue* mutable_soclowlimithysteresis();
  void set_allocated_soclowlimithysteresis(::google::protobuf::FloatValue* soclowlimithysteresis);

  // @@protoc_insertion_point(class_scope:essmodule.SocLimit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* sochighlimit_;
  ::google::protobuf::FloatValue* sochighlimithysteresis_;
  ::google::protobuf::BoolValue* soclimitctl_;
  ::google::protobuf::FloatValue* soclowlimit_;
  ::google::protobuf::FloatValue* soclowlimithysteresis_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class SOCManagement :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.SOCManagement) */ {
 public:
  SOCManagement();
  virtual ~SOCManagement();

  SOCManagement(const SOCManagement& from);

  inline SOCManagement& operator=(const SOCManagement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SOCManagement(SOCManagement&& from) noexcept
    : SOCManagement() {
    *this = ::std::move(from);
  }

  inline SOCManagement& operator=(SOCManagement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SOCManagement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SOCManagement* internal_default_instance() {
    return reinterpret_cast<const SOCManagement*>(
               &_SOCManagement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SOCManagement* other);
  friend void swap(SOCManagement& a, SOCManagement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SOCManagement* New() const final {
    return CreateMaybeMessage<SOCManagement>(nullptr);
  }

  SOCManagement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SOCManagement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SOCManagement& from);
  void MergeFrom(const SOCManagement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SOCManagement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue socDeadBandMinus = 1;
  bool has_socdeadbandminus() const;
  void clear_socdeadbandminus();
  static const int kSocDeadBandMinusFieldNumber = 1;
  const ::google::protobuf::FloatValue& socdeadbandminus() const;
  ::google::protobuf::FloatValue* release_socdeadbandminus();
  ::google::protobuf::FloatValue* mutable_socdeadbandminus();
  void set_allocated_socdeadbandminus(::google::protobuf::FloatValue* socdeadbandminus);

  // .google.protobuf.FloatValue socDeadBandPlus = 2;
  bool has_socdeadbandplus() const;
  void clear_socdeadbandplus();
  static const int kSocDeadBandPlusFieldNumber = 2;
  const ::google::protobuf::FloatValue& socdeadbandplus() const;
  ::google::protobuf::FloatValue* release_socdeadbandplus();
  ::google::protobuf::FloatValue* mutable_socdeadbandplus();
  void set_allocated_socdeadbandplus(::google::protobuf::FloatValue* socdeadbandplus);

  // .google.protobuf.BoolValue socManagementCtl = 3;
  bool has_socmanagementctl() const;
  void clear_socmanagementctl();
  static const int kSocManagementCtlFieldNumber = 3;
  const ::google::protobuf::BoolValue& socmanagementctl() const;
  ::google::protobuf::BoolValue* release_socmanagementctl();
  ::google::protobuf::BoolValue* mutable_socmanagementctl();
  void set_allocated_socmanagementctl(::google::protobuf::BoolValue* socmanagementctl);

  // .google.protobuf.FloatValue socPowerSetPoint = 4;
  bool has_socpowersetpoint() const;
  void clear_socpowersetpoint();
  static const int kSocPowerSetPointFieldNumber = 4;
  const ::google::protobuf::FloatValue& socpowersetpoint() const;
  ::google::protobuf::FloatValue* release_socpowersetpoint();
  ::google::protobuf::FloatValue* mutable_socpowersetpoint();
  void set_allocated_socpowersetpoint(::google::protobuf::FloatValue* socpowersetpoint);

  // .google.protobuf.FloatValue socSetPoint = 5;
  bool has_socsetpoint() const;
  void clear_socsetpoint();
  static const int kSocSetPointFieldNumber = 5;
  const ::google::protobuf::FloatValue& socsetpoint() const;
  ::google::protobuf::FloatValue* release_socsetpoint();
  ::google::protobuf::FloatValue* mutable_socsetpoint();
  void set_allocated_socsetpoint(::google::protobuf::FloatValue* socsetpoint);

  // @@protoc_insertion_point(class_scope:essmodule.SOCManagement)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* socdeadbandminus_;
  ::google::protobuf::FloatValue* socdeadbandplus_;
  ::google::protobuf::BoolValue* socmanagementctl_;
  ::google::protobuf::FloatValue* socpowersetpoint_;
  ::google::protobuf::FloatValue* socsetpoint_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class VoltageRegulation :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.VoltageRegulation) */ {
 public:
  VoltageRegulation();
  virtual ~VoltageRegulation();

  VoltageRegulation(const VoltageRegulation& from);

  inline VoltageRegulation& operator=(const VoltageRegulation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoltageRegulation(VoltageRegulation&& from) noexcept
    : VoltageRegulation() {
    *this = ::std::move(from);
  }

  inline VoltageRegulation& operator=(VoltageRegulation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VoltageRegulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoltageRegulation* internal_default_instance() {
    return reinterpret_cast<const VoltageRegulation*>(
               &_VoltageRegulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(VoltageRegulation* other);
  friend void swap(VoltageRegulation& a, VoltageRegulation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoltageRegulation* New() const final {
    return CreateMaybeMessage<VoltageRegulation>(nullptr);
  }

  VoltageRegulation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoltageRegulation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VoltageRegulation& from);
  void MergeFrom(const VoltageRegulation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltageRegulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.FloatValue overVoltageDroop = 1;
  bool has_overvoltagedroop() const;
  void clear_overvoltagedroop();
  static const int kOverVoltageDroopFieldNumber = 1;
  const ::google::protobuf::FloatValue& overvoltagedroop() const;
  ::google::protobuf::FloatValue* release_overvoltagedroop();
  ::google::protobuf::FloatValue* mutable_overvoltagedroop();
  void set_allocated_overvoltagedroop(::google::protobuf::FloatValue* overvoltagedroop);

  // .google.protobuf.FloatValue underVoltageDroop = 2;
  bool has_undervoltagedroop() const;
  void clear_undervoltagedroop();
  static const int kUnderVoltageDroopFieldNumber = 2;
  const ::google::protobuf::FloatValue& undervoltagedroop() const;
  ::google::protobuf::FloatValue* release_undervoltagedroop();
  ::google::protobuf::FloatValue* mutable_undervoltagedroop();
  void set_allocated_undervoltagedroop(::google::protobuf::FloatValue* undervoltagedroop);

  // .google.protobuf.FloatValue voltageDeadBandMinus = 3;
  bool has_voltagedeadbandminus() const;
  void clear_voltagedeadbandminus();
  static const int kVoltageDeadBandMinusFieldNumber = 3;
  const ::google::protobuf::FloatValue& voltagedeadbandminus() const;
  ::google::protobuf::FloatValue* release_voltagedeadbandminus();
  ::google::protobuf::FloatValue* mutable_voltagedeadbandminus();
  void set_allocated_voltagedeadbandminus(::google::protobuf::FloatValue* voltagedeadbandminus);

  // .google.protobuf.FloatValue voltageDeadBandPlus = 4;
  bool has_voltagedeadbandplus() const;
  void clear_voltagedeadbandplus();
  static const int kVoltageDeadBandPlusFieldNumber = 4;
  const ::google::protobuf::FloatValue& voltagedeadbandplus() const;
  ::google::protobuf::FloatValue* release_voltagedeadbandplus();
  ::google::protobuf::FloatValue* mutable_voltagedeadbandplus();
  void set_allocated_voltagedeadbandplus(::google::protobuf::FloatValue* voltagedeadbandplus);

  // .google.protobuf.FloatValue voltageSetPoint = 5;
  bool has_voltagesetpoint() const;
  void clear_voltagesetpoint();
  static const int kVoltageSetPointFieldNumber = 5;
  const ::google::protobuf::FloatValue& voltagesetpoint() const;
  ::google::protobuf::FloatValue* release_voltagesetpoint();
  ::google::protobuf::FloatValue* mutable_voltagesetpoint();
  void set_allocated_voltagesetpoint(::google::protobuf::FloatValue* voltagesetpoint);

  // @@protoc_insertion_point(class_scope:essmodule.VoltageRegulation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::FloatValue* overvoltagedroop_;
  ::google::protobuf::FloatValue* undervoltagedroop_;
  ::google::protobuf::FloatValue* voltagedeadbandminus_;
  ::google::protobuf::FloatValue* voltagedeadbandplus_;
  ::google::protobuf::FloatValue* voltagesetpoint_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class VoltageDroop :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.VoltageDroop) */ {
 public:
  VoltageDroop();
  virtual ~VoltageDroop();

  VoltageDroop(const VoltageDroop& from);

  inline VoltageDroop& operator=(const VoltageDroop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoltageDroop(VoltageDroop&& from) noexcept
    : VoltageDroop() {
    *this = ::std::move(from);
  }

  inline VoltageDroop& operator=(VoltageDroop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VoltageDroop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoltageDroop* internal_default_instance() {
    return reinterpret_cast<const VoltageDroop*>(
               &_VoltageDroop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(VoltageDroop* other);
  friend void swap(VoltageDroop& a, VoltageDroop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoltageDroop* New() const final {
    return CreateMaybeMessage<VoltageDroop>(nullptr);
  }

  VoltageDroop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoltageDroop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VoltageDroop& from);
  void MergeFrom(const VoltageDroop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltageDroop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.BoolValue voltageDroopCtl = 1;
  bool has_voltagedroopctl() const;
  void clear_voltagedroopctl();
  static const int kVoltageDroopCtlFieldNumber = 1;
  const ::google::protobuf::BoolValue& voltagedroopctl() const;
  ::google::protobuf::BoolValue* release_voltagedroopctl();
  ::google::protobuf::BoolValue* mutable_voltagedroopctl();
  void set_allocated_voltagedroopctl(::google::protobuf::BoolValue* voltagedroopctl);

  // .essmodule.VoltageRegulation voltageRegulation = 2;
  bool has_voltageregulation() const;
  void clear_voltageregulation();
  static const int kVoltageRegulationFieldNumber = 2;
  const ::essmodule::VoltageRegulation& voltageregulation() const;
  ::essmodule::VoltageRegulation* release_voltageregulation();
  ::essmodule::VoltageRegulation* mutable_voltageregulation();
  void set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation);

  // @@protoc_insertion_point(class_scope:essmodule.VoltageDroop)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::BoolValue* voltagedroopctl_;
  ::essmodule::VoltageRegulation* voltageregulation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class VoltagePI :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.VoltagePI) */ {
 public:
  VoltagePI();
  virtual ~VoltagePI();

  VoltagePI(const VoltagePI& from);

  inline VoltagePI& operator=(const VoltagePI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoltagePI(VoltagePI&& from) noexcept
    : VoltagePI() {
    *this = ::std::move(from);
  }

  inline VoltagePI& operator=(VoltagePI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VoltagePI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoltagePI* internal_default_instance() {
    return reinterpret_cast<const VoltagePI*>(
               &_VoltagePI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(VoltagePI* other);
  friend void swap(VoltagePI& a, VoltagePI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoltagePI* New() const final {
    return CreateMaybeMessage<VoltagePI>(nullptr);
  }

  VoltagePI* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoltagePI>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VoltagePI& from);
  void MergeFrom(const VoltagePI& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoltagePI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.BoolValue voltagePICtl = 1;
  bool has_voltagepictl() const;
  void clear_voltagepictl();
  static const int kVoltagePICtlFieldNumber = 1;
  const ::google::protobuf::BoolValue& voltagepictl() const;
  ::google::protobuf::BoolValue* release_voltagepictl();
  ::google::protobuf::BoolValue* mutable_voltagepictl();
  void set_allocated_voltagepictl(::google::protobuf::BoolValue* voltagepictl);

  // .essmodule.VoltageRegulation voltageRegulation = 2;
  bool has_voltageregulation() const;
  void clear_voltageregulation();
  static const int kVoltageRegulationFieldNumber = 2;
  const ::essmodule::VoltageRegulation& voltageregulation() const;
  ::essmodule::VoltageRegulation* release_voltageregulation();
  ::essmodule::VoltageRegulation* mutable_voltageregulation();
  void set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation);

  // @@protoc_insertion_point(class_scope:essmodule.VoltagePI)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::BoolValue* voltagepictl_;
  ::essmodule::VoltageRegulation* voltageregulation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class CapacityFirming :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.CapacityFirming) */ {
 public:
  CapacityFirming();
  virtual ~CapacityFirming();

  CapacityFirming(const CapacityFirming& from);

  inline CapacityFirming& operator=(const CapacityFirming& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CapacityFirming(CapacityFirming&& from) noexcept
    : CapacityFirming() {
    *this = ::std::move(from);
  }

  inline CapacityFirming& operator=(CapacityFirming&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CapacityFirming& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CapacityFirming* internal_default_instance() {
    return reinterpret_cast<const CapacityFirming*>(
               &_CapacityFirming_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CapacityFirming* other);
  friend void swap(CapacityFirming& a, CapacityFirming& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CapacityFirming* New() const final {
    return CreateMaybeMessage<CapacityFirming>(nullptr);
  }

  CapacityFirming* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CapacityFirming>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CapacityFirming& from);
  void MergeFrom(const CapacityFirming& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapacityFirming* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.BoolValue capacityFirmingCtl = 1;
  bool has_capacityfirmingctl() const;
  void clear_capacityfirmingctl();
  static const int kCapacityFirmingCtlFieldNumber = 1;
  const ::google::protobuf::BoolValue& capacityfirmingctl() const;
  ::google::protobuf::BoolValue* release_capacityfirmingctl();
  ::google::protobuf::BoolValue* mutable_capacityfirmingctl();
  void set_allocated_capacityfirmingctl(::google::protobuf::BoolValue* capacityfirmingctl);

  // .google.protobuf.FloatValue limitNegative_dp_dt = 2;
  bool has_limitnegative_dp_dt() const;
  void clear_limitnegative_dp_dt();
  static const int kLimitNegativeDpDtFieldNumber = 2;
  const ::google::protobuf::FloatValue& limitnegative_dp_dt() const;
  ::google::protobuf::FloatValue* release_limitnegative_dp_dt();
  ::google::protobuf::FloatValue* mutable_limitnegative_dp_dt();
  void set_allocated_limitnegative_dp_dt(::google::protobuf::FloatValue* limitnegative_dp_dt);

  // .google.protobuf.FloatValue limitPositive_dp_dt = 3;
  bool has_limitpositive_dp_dt() const;
  void clear_limitpositive_dp_dt();
  static const int kLimitPositiveDpDtFieldNumber = 3;
  const ::google::protobuf::FloatValue& limitpositive_dp_dt() const;
  ::google::protobuf::FloatValue* release_limitpositive_dp_dt();
  ::google::protobuf::FloatValue* mutable_limitpositive_dp_dt();
  void set_allocated_limitpositive_dp_dt(::google::protobuf::FloatValue* limitpositive_dp_dt);

  // @@protoc_insertion_point(class_scope:essmodule.CapacityFirming)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::BoolValue* capacityfirmingctl_;
  ::google::protobuf::FloatValue* limitnegative_dp_dt_;
  ::google::protobuf::FloatValue* limitpositive_dp_dt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSFunction :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSFunction) */ {
 public:
  ESSFunction();
  virtual ~ESSFunction();

  ESSFunction(const ESSFunction& from);

  inline ESSFunction& operator=(const ESSFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSFunction(ESSFunction&& from) noexcept
    : ESSFunction() {
    *this = ::std::move(from);
  }

  inline ESSFunction& operator=(ESSFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSFunction* internal_default_instance() {
    return reinterpret_cast<const ESSFunction*>(
               &_ESSFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ESSFunction* other);
  friend void swap(ESSFunction& a, ESSFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSFunction* New() const final {
    return CreateMaybeMessage<ESSFunction>(nullptr);
  }

  ESSFunction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSFunction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSFunction& from);
  void MergeFrom(const ESSFunction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .essmodule.CapacityFirming capacityFirming = 1;
  bool has_capacityfirming() const;
  void clear_capacityfirming();
  static const int kCapacityFirmingFieldNumber = 1;
  const ::essmodule::CapacityFirming& capacityfirming() const;
  ::essmodule::CapacityFirming* release_capacityfirming();
  ::essmodule::CapacityFirming* mutable_capacityfirming();
  void set_allocated_capacityfirming(::essmodule::CapacityFirming* capacityfirming);

  // .essmodule.FrequencyRegulation frequencyRegulation = 2;
  bool has_frequencyregulation() const;
  void clear_frequencyregulation();
  static const int kFrequencyRegulationFieldNumber = 2;
  const ::essmodule::FrequencyRegulation& frequencyregulation() const;
  ::essmodule::FrequencyRegulation* release_frequencyregulation();
  ::essmodule::FrequencyRegulation* mutable_frequencyregulation();
  void set_allocated_frequencyregulation(::essmodule::FrequencyRegulation* frequencyregulation);

  // .essmodule.PeakShaving peakShaving = 3;
  bool has_peakshaving() const;
  void clear_peakshaving();
  static const int kPeakShavingFieldNumber = 3;
  const ::essmodule::PeakShaving& peakshaving() const;
  ::essmodule::PeakShaving* release_peakshaving();
  ::essmodule::PeakShaving* mutable_peakshaving();
  void set_allocated_peakshaving(::essmodule::PeakShaving* peakshaving);

  // .essmodule.SocLimit socLimit = 4;
  bool has_soclimit() const;
  void clear_soclimit();
  static const int kSocLimitFieldNumber = 4;
  const ::essmodule::SocLimit& soclimit() const;
  ::essmodule::SocLimit* release_soclimit();
  ::essmodule::SocLimit* mutable_soclimit();
  void set_allocated_soclimit(::essmodule::SocLimit* soclimit);

  // .essmodule.SOCManagement socManagement = 5;
  bool has_socmanagement() const;
  void clear_socmanagement();
  static const int kSocManagementFieldNumber = 5;
  const ::essmodule::SOCManagement& socmanagement() const;
  ::essmodule::SOCManagement* release_socmanagement();
  ::essmodule::SOCManagement* mutable_socmanagement();
  void set_allocated_socmanagement(::essmodule::SOCManagement* socmanagement);

  // .essmodule.VoltageDroop voltageDroop = 6;
  bool has_voltagedroop() const;
  void clear_voltagedroop();
  static const int kVoltageDroopFieldNumber = 6;
  const ::essmodule::VoltageDroop& voltagedroop() const;
  ::essmodule::VoltageDroop* release_voltagedroop();
  ::essmodule::VoltageDroop* mutable_voltagedroop();
  void set_allocated_voltagedroop(::essmodule::VoltageDroop* voltagedroop);

  // .essmodule.VoltagePI voltagePI = 7;
  bool has_voltagepi() const;
  void clear_voltagepi();
  static const int kVoltagePIFieldNumber = 7;
  const ::essmodule::VoltagePI& voltagepi() const;
  ::essmodule::VoltagePI* release_voltagepi();
  ::essmodule::VoltagePI* mutable_voltagepi();
  void set_allocated_voltagepi(::essmodule::VoltagePI* voltagepi);

  // @@protoc_insertion_point(class_scope:essmodule.ESSFunction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::essmodule::CapacityFirming* capacityfirming_;
  ::essmodule::FrequencyRegulation* frequencyregulation_;
  ::essmodule::PeakShaving* peakshaving_;
  ::essmodule::SocLimit* soclimit_;
  ::essmodule::SOCManagement* socmanagement_;
  ::essmodule::VoltageDroop* voltagedroop_;
  ::essmodule::VoltagePI* voltagepi_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSPointStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSPointStatus) */ {
 public:
  ESSPointStatus();
  virtual ~ESSPointStatus();

  ESSPointStatus(const ESSPointStatus& from);

  inline ESSPointStatus& operator=(const ESSPointStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSPointStatus(ESSPointStatus&& from) noexcept
    : ESSPointStatus() {
    *this = ::std::move(from);
  }

  inline ESSPointStatus& operator=(ESSPointStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSPointStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSPointStatus* internal_default_instance() {
    return reinterpret_cast<const ESSPointStatus*>(
               &_ESSPointStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ESSPointStatus* other);
  friend void swap(ESSPointStatus& a, ESSPointStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSPointStatus* New() const final {
    return CreateMaybeMessage<ESSPointStatus>(nullptr);
  }

  ESSPointStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSPointStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSPointStatus& from);
  void MergeFrom(const ESSPointStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSPointStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlDPC blackStartEnabled = 1;
  bool has_blackstartenabled() const;
  void clear_blackstartenabled();
  static const int kBlackStartEnabledFieldNumber = 1;
  const ::commonmodule::ControlDPC& blackstartenabled() const;
  ::commonmodule::ControlDPC* release_blackstartenabled();
  ::commonmodule::ControlDPC* mutable_blackstartenabled();
  void set_allocated_blackstartenabled(::commonmodule::ControlDPC* blackstartenabled);

  // .commonmodule.ControlDPC frequencySetPointEnabled = 2;
  bool has_frequencysetpointenabled() const;
  void clear_frequencysetpointenabled();
  static const int kFrequencySetPointEnabledFieldNumber = 2;
  const ::commonmodule::ControlDPC& frequencysetpointenabled() const;
  ::commonmodule::ControlDPC* release_frequencysetpointenabled();
  ::commonmodule::ControlDPC* mutable_frequencysetpointenabled();
  void set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled);

  // .essmodule.ESSFunction function = 3;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 3;
  const ::essmodule::ESSFunction& function() const;
  ::essmodule::ESSFunction* release_function();
  ::essmodule::ESSFunction* mutable_function();
  void set_allocated_function(::essmodule::ESSFunction* function);

  // .commonmodule.ENG_GridConnectModeKind mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);

  // .google.protobuf.FloatValue pctHzDroop = 5;
  bool has_pcthzdroop() const;
  void clear_pcthzdroop();
  static const int kPctHzDroopFieldNumber = 5;
  const ::google::protobuf::FloatValue& pcthzdroop() const;
  ::google::protobuf::FloatValue* release_pcthzdroop();
  ::google::protobuf::FloatValue* mutable_pcthzdroop();
  void set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop);

  // .google.protobuf.FloatValue pctVDroop = 6;
  bool has_pctvdroop() const;
  void clear_pctvdroop();
  static const int kPctVDroopFieldNumber = 6;
  const ::google::protobuf::FloatValue& pctvdroop() const;
  ::google::protobuf::FloatValue* release_pctvdroop();
  ::google::protobuf::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop);

  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  void clear_ramprates();
  static const int kRampRatesFieldNumber = 7;
  const ::commonmodule::RampRate& ramprates() const;
  ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);

  // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 8;
  bool has_reactivepwrsetpointenabled() const;
  void clear_reactivepwrsetpointenabled();
  static const int kReactivePwrSetPointEnabledFieldNumber = 8;
  const ::commonmodule::ControlDPC& reactivepwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_reactivepwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled);

  // .commonmodule.ControlDPC realPwrSetPointEnabled = 9;
  bool has_realpwrsetpointenabled() const;
  void clear_realpwrsetpointenabled();
  static const int kRealPwrSetPointEnabledFieldNumber = 9;
  const ::commonmodule::ControlDPC& realpwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_realpwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled);

  // .commonmodule.Optional_StateKind state = 10;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 10;
  const ::commonmodule::Optional_StateKind& state() const;
  ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);

  // .commonmodule.ControlDPC syncBackToGrid = 11;
  bool has_syncbacktogrid() const;
  void clear_syncbacktogrid();
  static const int kSyncBackToGridFieldNumber = 11;
  const ::commonmodule::ControlDPC& syncbacktogrid() const;
  ::commonmodule::ControlDPC* release_syncbacktogrid();
  ::commonmodule::ControlDPC* mutable_syncbacktogrid();
  void set_allocated_syncbacktogrid(::commonmodule::ControlDPC* syncbacktogrid);

  // .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 12;
  bool has_transtoislndongridlossenabled() const;
  void clear_transtoislndongridlossenabled();
  static const int kTransToIslndOnGridLossEnabledFieldNumber = 12;
  const ::commonmodule::ControlDPC& transtoislndongridlossenabled() const;
  ::commonmodule::ControlDPC* release_transtoislndongridlossenabled();
  ::commonmodule::ControlDPC* mutable_transtoislndongridlossenabled();
  void set_allocated_transtoislndongridlossenabled(::commonmodule::ControlDPC* transtoislndongridlossenabled);

  // .commonmodule.ControlDPC voltageSetPointEnabled = 13;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled();
  static const int kVoltageSetPointEnabledFieldNumber = 13;
  const ::commonmodule::ControlDPC& voltagesetpointenabled() const;
  ::commonmodule::ControlDPC* release_voltagesetpointenabled();
  ::commonmodule::ControlDPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled);

  // @@protoc_insertion_point(class_scope:essmodule.ESSPointStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlDPC* blackstartenabled_;
  ::commonmodule::ControlDPC* frequencysetpointenabled_;
  ::essmodule::ESSFunction* function_;
  ::commonmodule::ENG_GridConnectModeKind* mode_;
  ::google::protobuf::FloatValue* pcthzdroop_;
  ::google::protobuf::FloatValue* pctvdroop_;
  ::commonmodule::RampRate* ramprates_;
  ::commonmodule::ControlDPC* reactivepwrsetpointenabled_;
  ::commonmodule::ControlDPC* realpwrsetpointenabled_;
  ::commonmodule::Optional_StateKind* state_;
  ::commonmodule::ControlDPC* syncbacktogrid_;
  ::commonmodule::ControlDPC* transtoislndongridlossenabled_;
  ::commonmodule::ControlDPC* voltagesetpointenabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSEventAndStatusZGEN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEventAndStatusZGEN) */ {
 public:
  ESSEventAndStatusZGEN();
  virtual ~ESSEventAndStatusZGEN();

  ESSEventAndStatusZGEN(const ESSEventAndStatusZGEN& from);

  inline ESSEventAndStatusZGEN& operator=(const ESSEventAndStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSEventAndStatusZGEN(ESSEventAndStatusZGEN&& from) noexcept
    : ESSEventAndStatusZGEN() {
    *this = ::std::move(from);
  }

  inline ESSEventAndStatusZGEN& operator=(ESSEventAndStatusZGEN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSEventAndStatusZGEN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSEventAndStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const ESSEventAndStatusZGEN*>(
               &_ESSEventAndStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ESSEventAndStatusZGEN* other);
  friend void swap(ESSEventAndStatusZGEN& a, ESSEventAndStatusZGEN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSEventAndStatusZGEN* New() const final {
    return CreateMaybeMessage<ESSEventAndStatusZGEN>(nullptr);
  }

  ESSEventAndStatusZGEN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSEventAndStatusZGEN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSEventAndStatusZGEN& from);
  void MergeFrom(const ESSEventAndStatusZGEN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEventAndStatusZGEN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.StatusSPS AuxPwrSt = 2;
  bool has_auxpwrst() const;
  void clear_auxpwrst();
  static const int kAuxPwrStFieldNumber = 2;
  const ::commonmodule::StatusSPS& auxpwrst() const;
  ::commonmodule::StatusSPS* release_auxpwrst();
  ::commonmodule::StatusSPS* mutable_auxpwrst();
  void set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst);

  // .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
  bool has_dynamictest() const;
  void clear_dynamictest();
  static const int kDynamicTestFieldNumber = 3;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);

  // .commonmodule.StatusSPS EmgStop = 4;
  bool has_emgstop() const;
  void clear_emgstop();
  static const int kEmgStopFieldNumber = 4;
  const ::commonmodule::StatusSPS& emgstop() const;
  ::commonmodule::StatusSPS* release_emgstop();
  ::commonmodule::StatusSPS* mutable_emgstop();
  void set_allocated_emgstop(::commonmodule::StatusSPS* emgstop);

  // .commonmodule.StatusSPS GnSynSt = 5;
  bool has_gnsynst() const;
  void clear_gnsynst();
  static const int kGnSynStFieldNumber = 5;
  const ::commonmodule::StatusSPS& gnsynst() const;
  ::commonmodule::StatusSPS* release_gnsynst();
  ::commonmodule::StatusSPS* mutable_gnsynst();
  void set_allocated_gnsynst(::commonmodule::StatusSPS* gnsynst);

  // .essmodule.ESSPointStatus PointStatus = 6;
  bool has_pointstatus() const;
  void clear_pointstatus();
  static const int kPointStatusFieldNumber = 6;
  const ::essmodule::ESSPointStatus& pointstatus() const;
  ::essmodule::ESSPointStatus* release_pointstatus();
  ::essmodule::ESSPointStatus* mutable_pointstatus();
  void set_allocated_pointstatus(::essmodule::ESSPointStatus* pointstatus);

  // @@protoc_insertion_point(class_scope:essmodule.ESSEventAndStatusZGEN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::StatusSPS* auxpwrst_;
  ::commonmodule::ENS_DynamicTestKind* dynamictest_;
  ::commonmodule::StatusSPS* emgstop_;
  ::commonmodule::StatusSPS* gnsynst_;
  ::essmodule::ESSPointStatus* pointstatus_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSEventZGEN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEventZGEN) */ {
 public:
  ESSEventZGEN();
  virtual ~ESSEventZGEN();

  ESSEventZGEN(const ESSEventZGEN& from);

  inline ESSEventZGEN& operator=(const ESSEventZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSEventZGEN(ESSEventZGEN&& from) noexcept
    : ESSEventZGEN() {
    *this = ::std::move(from);
  }

  inline ESSEventZGEN& operator=(ESSEventZGEN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSEventZGEN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSEventZGEN* internal_default_instance() {
    return reinterpret_cast<const ESSEventZGEN*>(
               &_ESSEventZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ESSEventZGEN* other);
  friend void swap(ESSEventZGEN& a, ESSEventZGEN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSEventZGEN* New() const final {
    return CreateMaybeMessage<ESSEventZGEN>(nullptr);
  }

  ESSEventZGEN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSEventZGEN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSEventZGEN& from);
  void MergeFrom(const ESSEventZGEN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEventZGEN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_esseventandstatuszgen() const;
  void clear_esseventandstatuszgen();
  static const int kESSEventAndStatusZGENFieldNumber = 1;
  const ::essmodule::ESSEventAndStatusZGEN& esseventandstatuszgen() const;
  ::essmodule::ESSEventAndStatusZGEN* release_esseventandstatuszgen();
  ::essmodule::ESSEventAndStatusZGEN* mutable_esseventandstatuszgen();
  void set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen);

  // @@protoc_insertion_point(class_scope:essmodule.ESSEventZGEN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSEvent :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEvent) */ {
 public:
  ESSEvent();
  virtual ~ESSEvent();

  ESSEvent(const ESSEvent& from);

  inline ESSEvent& operator=(const ESSEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSEvent(ESSEvent&& from) noexcept
    : ESSEvent() {
    *this = ::std::move(from);
  }

  inline ESSEvent& operator=(ESSEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSEvent* internal_default_instance() {
    return reinterpret_cast<const ESSEvent*>(
               &_ESSEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ESSEvent* other);
  friend void swap(ESSEvent& a, ESSEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSEvent* New() const final {
    return CreateMaybeMessage<ESSEvent>(nullptr);
  }

  ESSEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSEvent& from);
  void MergeFrom(const ESSEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  void clear_eventvalue();
  static const int kEventValueFieldNumber = 1;
  const ::commonmodule::EventValue& eventvalue() const;
  ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);

  // .essmodule.EssEventZBAT essEventZBAT = 2;
  bool has_esseventzbat() const;
  void clear_esseventzbat();
  static const int kEssEventZBATFieldNumber = 2;
  const ::essmodule::EssEventZBAT& esseventzbat() const;
  ::essmodule::EssEventZBAT* release_esseventzbat();
  ::essmodule::EssEventZBAT* mutable_esseventzbat();
  void set_allocated_esseventzbat(::essmodule::EssEventZBAT* esseventzbat);

  // .essmodule.ESSEventZGEN essEventZGEN = 3;
  bool has_esseventzgen() const;
  void clear_esseventzgen();
  static const int kEssEventZGENFieldNumber = 3;
  const ::essmodule::ESSEventZGEN& esseventzgen() const;
  ::essmodule::ESSEventZGEN* release_esseventzgen();
  ::essmodule::ESSEventZGEN* mutable_esseventzgen();
  void set_allocated_esseventzgen(::essmodule::ESSEventZGEN* esseventzgen);

  // @@protoc_insertion_point(class_scope:essmodule.ESSEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventValue* eventvalue_;
  ::essmodule::EssEventZBAT* esseventzbat_;
  ::essmodule::ESSEventZGEN* esseventzgen_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSEventProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSEventProfile) */ {
 public:
  ESSEventProfile();
  virtual ~ESSEventProfile();

  ESSEventProfile(const ESSEventProfile& from);

  inline ESSEventProfile& operator=(const ESSEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSEventProfile(ESSEventProfile&& from) noexcept
    : ESSEventProfile() {
    *this = ::std::move(from);
  }

  inline ESSEventProfile& operator=(ESSEventProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSEventProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSEventProfile* internal_default_instance() {
    return reinterpret_cast<const ESSEventProfile*>(
               &_ESSEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ESSEventProfile* other);
  friend void swap(ESSEventProfile& a, ESSEventProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSEventProfile* New() const final {
    return CreateMaybeMessage<ESSEventProfile>(nullptr);
  }

  ESSEventProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSEventProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSEventProfile& from);
  void MergeFrom(const ESSEventProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSEventProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  void clear_eventmessageinfo();
  static const int kEventMessageInfoFieldNumber = 1;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);

  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  void clear_ess();
  static const int kEssFieldNumber = 2;
  const ::commonmodule::ESS& ess() const;
  ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);

  // .essmodule.ESSEvent essEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_essevent() const;
  void clear_essevent();
  static const int kEssEventFieldNumber = 3;
  const ::essmodule::ESSEvent& essevent() const;
  ::essmodule::ESSEvent* release_essevent();
  ::essmodule::ESSEvent* mutable_essevent();
  void set_allocated_essevent(::essmodule::ESSEvent* essevent);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:essmodule.ESSEventProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::EventMessageInfo* eventmessageinfo_;
  ::commonmodule::ESS* ess_;
  ::essmodule::ESSEvent* essevent_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSReading :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSReading) */ {
 public:
  ESSReading();
  virtual ~ESSReading();

  ESSReading(const ESSReading& from);

  inline ESSReading& operator=(const ESSReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSReading(ESSReading&& from) noexcept
    : ESSReading() {
    *this = ::std::move(from);
  }

  inline ESSReading& operator=(ESSReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSReading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSReading* internal_default_instance() {
    return reinterpret_cast<const ESSReading*>(
               &_ESSReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ESSReading* other);
  friend void swap(ESSReading& a, ESSReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSReading* New() const final {
    return CreateMaybeMessage<ESSReading>(nullptr);
  }

  ESSReading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSReading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSReading& from);
  void MergeFrom(const ESSReading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  void clear_conductingequipmentterminalreading();
  static const int kConductingEquipmentTerminalReadingFieldNumber = 1;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);

  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  void clear_phasemmtn();
  static const int kPhaseMMTNFieldNumber = 2;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);

  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  void clear_readingmmtr();
  static const int kReadingMMTRFieldNumber = 3;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);

  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  void clear_readingmmxu();
  static const int kReadingMMXUFieldNumber = 4;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);

  // @@protoc_insertion_point(class_scope:essmodule.ESSReading)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
  ::commonmodule::PhaseMMTN* phasemmtn_;
  ::commonmodule::ReadingMMTR* readingmmtr_;
  ::commonmodule::ReadingMMXU* readingmmxu_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSReadingProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSReadingProfile) */ {
 public:
  ESSReadingProfile();
  virtual ~ESSReadingProfile();

  ESSReadingProfile(const ESSReadingProfile& from);

  inline ESSReadingProfile& operator=(const ESSReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSReadingProfile(ESSReadingProfile&& from) noexcept
    : ESSReadingProfile() {
    *this = ::std::move(from);
  }

  inline ESSReadingProfile& operator=(ESSReadingProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSReadingProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSReadingProfile* internal_default_instance() {
    return reinterpret_cast<const ESSReadingProfile*>(
               &_ESSReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ESSReadingProfile* other);
  friend void swap(ESSReadingProfile& a, ESSReadingProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSReadingProfile* New() const final {
    return CreateMaybeMessage<ESSReadingProfile>(nullptr);
  }

  ESSReadingProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSReadingProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSReadingProfile& from);
  void MergeFrom(const ESSReadingProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSReadingProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  void clear_readingmessageinfo();
  static const int kReadingMessageInfoFieldNumber = 1;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);

  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  void clear_ess();
  static const int kEssFieldNumber = 2;
  const ::commonmodule::ESS& ess() const;
  ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);

  // .essmodule.ESSReading essReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_essreading() const;
  void clear_essreading();
  static const int kEssReadingFieldNumber = 3;
  const ::essmodule::ESSReading& essreading() const;
  ::essmodule::ESSReading* release_essreading();
  ::essmodule::ESSReading* mutable_essreading();
  void set_allocated_essreading(::essmodule::ESSReading* essreading);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:essmodule.ESSReadingProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
  ::commonmodule::ESS* ess_;
  ::essmodule::ESSReading* essreading_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class EssStatusZBAT :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.EssStatusZBAT) */ {
 public:
  EssStatusZBAT();
  virtual ~EssStatusZBAT();

  EssStatusZBAT(const EssStatusZBAT& from);

  inline EssStatusZBAT& operator=(const EssStatusZBAT& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EssStatusZBAT(EssStatusZBAT&& from) noexcept
    : EssStatusZBAT() {
    *this = ::std::move(from);
  }

  inline EssStatusZBAT& operator=(EssStatusZBAT&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EssStatusZBAT& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EssStatusZBAT* internal_default_instance() {
    return reinterpret_cast<const EssStatusZBAT*>(
               &_EssStatusZBAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(EssStatusZBAT* other);
  friend void swap(EssStatusZBAT& a, EssStatusZBAT& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EssStatusZBAT* New() const final {
    return CreateMaybeMessage<EssStatusZBAT>(nullptr);
  }

  EssStatusZBAT* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EssStatusZBAT>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EssStatusZBAT& from);
  void MergeFrom(const EssStatusZBAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EssStatusZBAT* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus();
  static const int kLogicalNodeForEventAndStatusFieldNumber = 1;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);

  // .commonmodule.StatusSPS BatSt = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_batst() const;
  void clear_batst();
  static const int kBatStFieldNumber = 2;
  const ::commonmodule::StatusSPS& batst() const;
  ::commonmodule::StatusSPS* release_batst();
  ::commonmodule::StatusSPS* mutable_batst();
  void set_allocated_batst(::commonmodule::StatusSPS* batst);

  // .commonmodule.ENG_GridConnectModeKind GriMod = 3;
  bool has_grimod() const;
  void clear_grimod();
  static const int kGriModFieldNumber = 3;
  const ::commonmodule::ENG_GridConnectModeKind& grimod() const;
  ::commonmodule::ENG_GridConnectModeKind* release_grimod();
  ::commonmodule::ENG_GridConnectModeKind* mutable_grimod();
  void set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod);

  // .commonmodule.MV Soc = 4;
  bool has_soc() const;
  void clear_soc();
  static const int kSocFieldNumber = 4;
  const ::commonmodule::MV& soc() const;
  ::commonmodule::MV* release_soc();
  ::commonmodule::MV* mutable_soc();
  void set_allocated_soc(::commonmodule::MV* soc);

  // .commonmodule.StatusSPS Stdby = 5;
  bool has_stdby() const;
  void clear_stdby();
  static const int kStdbyFieldNumber = 5;
  const ::commonmodule::StatusSPS& stdby() const;
  ::commonmodule::StatusSPS* release_stdby();
  ::commonmodule::StatusSPS* mutable_stdby();
  void set_allocated_stdby(::commonmodule::StatusSPS* stdby);

  // @@protoc_insertion_point(class_scope:essmodule.EssStatusZBAT)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
  ::commonmodule::StatusSPS* batst_;
  ::commonmodule::ENG_GridConnectModeKind* grimod_;
  ::commonmodule::MV* soc_;
  ::commonmodule::StatusSPS* stdby_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSStatusZGEN :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSStatusZGEN) */ {
 public:
  ESSStatusZGEN();
  virtual ~ESSStatusZGEN();

  ESSStatusZGEN(const ESSStatusZGEN& from);

  inline ESSStatusZGEN& operator=(const ESSStatusZGEN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSStatusZGEN(ESSStatusZGEN&& from) noexcept
    : ESSStatusZGEN() {
    *this = ::std::move(from);
  }

  inline ESSStatusZGEN& operator=(ESSStatusZGEN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSStatusZGEN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSStatusZGEN* internal_default_instance() {
    return reinterpret_cast<const ESSStatusZGEN*>(
               &_ESSStatusZGEN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ESSStatusZGEN* other);
  friend void swap(ESSStatusZGEN& a, ESSStatusZGEN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSStatusZGEN* New() const final {
    return CreateMaybeMessage<ESSStatusZGEN>(nullptr);
  }

  ESSStatusZGEN* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSStatusZGEN>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSStatusZGEN& from);
  void MergeFrom(const ESSStatusZGEN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSStatusZGEN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
  bool has_esseventandstatuszgen() const;
  void clear_esseventandstatuszgen();
  static const int kESSEventAndStatusZGENFieldNumber = 1;
  const ::essmodule::ESSEventAndStatusZGEN& esseventandstatuszgen() const;
  ::essmodule::ESSEventAndStatusZGEN* release_esseventandstatuszgen();
  ::essmodule::ESSEventAndStatusZGEN* mutable_esseventandstatuszgen();
  void set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen);

  // @@protoc_insertion_point(class_scope:essmodule.ESSStatusZGEN)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSStatus) */ {
 public:
  ESSStatus();
  virtual ~ESSStatus();

  ESSStatus(const ESSStatus& from);

  inline ESSStatus& operator=(const ESSStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSStatus(ESSStatus&& from) noexcept
    : ESSStatus() {
    *this = ::std::move(from);
  }

  inline ESSStatus& operator=(ESSStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSStatus* internal_default_instance() {
    return reinterpret_cast<const ESSStatus*>(
               &_ESSStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ESSStatus* other);
  friend void swap(ESSStatus& a, ESSStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSStatus* New() const final {
    return CreateMaybeMessage<ESSStatus>(nullptr);
  }

  ESSStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSStatus& from);
  void MergeFrom(const ESSStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  void clear_statusvalue();
  static const int kStatusValueFieldNumber = 1;
  const ::commonmodule::StatusValue& statusvalue() const;
  ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);

  // .essmodule.EssStatusZBAT essStatusZBAT = 2;
  bool has_essstatuszbat() const;
  void clear_essstatuszbat();
  static const int kEssStatusZBATFieldNumber = 2;
  const ::essmodule::EssStatusZBAT& essstatuszbat() const;
  ::essmodule::EssStatusZBAT* release_essstatuszbat();
  ::essmodule::EssStatusZBAT* mutable_essstatuszbat();
  void set_allocated_essstatuszbat(::essmodule::EssStatusZBAT* essstatuszbat);

  // .essmodule.ESSStatusZGEN essStatusZGEN = 3;
  bool has_essstatuszgen() const;
  void clear_essstatuszgen();
  static const int kEssStatusZGENFieldNumber = 3;
  const ::essmodule::ESSStatusZGEN& essstatuszgen() const;
  ::essmodule::ESSStatusZGEN* release_essstatuszgen();
  ::essmodule::ESSStatusZGEN* mutable_essstatuszgen();
  void set_allocated_essstatuszgen(::essmodule::ESSStatusZGEN* essstatuszgen);

  // @@protoc_insertion_point(class_scope:essmodule.ESSStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusValue* statusvalue_;
  ::essmodule::EssStatusZBAT* essstatuszbat_;
  ::essmodule::ESSStatusZGEN* essstatuszgen_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSStatusProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSStatusProfile) */ {
 public:
  ESSStatusProfile();
  virtual ~ESSStatusProfile();

  ESSStatusProfile(const ESSStatusProfile& from);

  inline ESSStatusProfile& operator=(const ESSStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSStatusProfile(ESSStatusProfile&& from) noexcept
    : ESSStatusProfile() {
    *this = ::std::move(from);
  }

  inline ESSStatusProfile& operator=(ESSStatusProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSStatusProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSStatusProfile* internal_default_instance() {
    return reinterpret_cast<const ESSStatusProfile*>(
               &_ESSStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ESSStatusProfile* other);
  friend void swap(ESSStatusProfile& a, ESSStatusProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSStatusProfile* New() const final {
    return CreateMaybeMessage<ESSStatusProfile>(nullptr);
  }

  ESSStatusProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSStatusProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSStatusProfile& from);
  void MergeFrom(const ESSStatusProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSStatusProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  void clear_statusmessageinfo();
  static const int kStatusMessageInfoFieldNumber = 1;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);

  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  void clear_ess();
  static const int kEssFieldNumber = 2;
  const ::commonmodule::ESS& ess() const;
  ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);

  // .essmodule.ESSStatus essStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_essstatus() const;
  void clear_essstatus();
  static const int kEssStatusFieldNumber = 3;
  const ::essmodule::ESSStatus& essstatus() const;
  ::essmodule::ESSStatus* release_essstatus();
  ::essmodule::ESSStatus* mutable_essstatus();
  void set_allocated_essstatus(::essmodule::ESSStatus* essstatus);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:essmodule.ESSStatusProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::StatusMessageInfo* statusmessageinfo_;
  ::commonmodule::ESS* ess_;
  ::essmodule::ESSStatus* essstatus_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSPoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSPoint) */ {
 public:
  ESSPoint();
  virtual ~ESSPoint();

  ESSPoint(const ESSPoint& from);

  inline ESSPoint& operator=(const ESSPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSPoint(ESSPoint&& from) noexcept
    : ESSPoint() {
    *this = ::std::move(from);
  }

  inline ESSPoint& operator=(ESSPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSPoint* internal_default_instance() {
    return reinterpret_cast<const ESSPoint*>(
               &_ESSPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ESSPoint* other);
  friend void swap(ESSPoint& a, ESSPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSPoint* New() const final {
    return CreateMaybeMessage<ESSPoint>(nullptr);
  }

  ESSPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSPoint& from);
  void MergeFrom(const ESSPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlDPC blackStartEnabled = 1;
  bool has_blackstartenabled() const;
  void clear_blackstartenabled();
  static const int kBlackStartEnabledFieldNumber = 1;
  const ::commonmodule::ControlDPC& blackstartenabled() const;
  ::commonmodule::ControlDPC* release_blackstartenabled();
  ::commonmodule::ControlDPC* mutable_blackstartenabled();
  void set_allocated_blackstartenabled(::commonmodule::ControlDPC* blackstartenabled);

  // .commonmodule.ControlDPC frequencySetPointEnabled = 2;
  bool has_frequencysetpointenabled() const;
  void clear_frequencysetpointenabled();
  static const int kFrequencySetPointEnabledFieldNumber = 2;
  const ::commonmodule::ControlDPC& frequencysetpointenabled() const;
  ::commonmodule::ControlDPC* release_frequencysetpointenabled();
  ::commonmodule::ControlDPC* mutable_frequencysetpointenabled();
  void set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled);

  // .essmodule.ESSFunction function = 3;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 3;
  const ::essmodule::ESSFunction& function() const;
  ::essmodule::ESSFunction* release_function();
  ::essmodule::ESSFunction* mutable_function();
  void set_allocated_function(::essmodule::ESSFunction* function);

  // .commonmodule.ENG_GridConnectModeKind mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  ::commonmodule::ENG_GridConnectModeKind* release_mode();
  ::commonmodule::ENG_GridConnectModeKind* mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode);

  // .google.protobuf.FloatValue pctHzDroop = 5;
  bool has_pcthzdroop() const;
  void clear_pcthzdroop();
  static const int kPctHzDroopFieldNumber = 5;
  const ::google::protobuf::FloatValue& pcthzdroop() const;
  ::google::protobuf::FloatValue* release_pcthzdroop();
  ::google::protobuf::FloatValue* mutable_pcthzdroop();
  void set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop);

  // .google.protobuf.FloatValue pctVDroop = 6;
  bool has_pctvdroop() const;
  void clear_pctvdroop();
  static const int kPctVDroopFieldNumber = 6;
  const ::google::protobuf::FloatValue& pctvdroop() const;
  ::google::protobuf::FloatValue* release_pctvdroop();
  ::google::protobuf::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop);

  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  void clear_ramprates();
  static const int kRampRatesFieldNumber = 7;
  const ::commonmodule::RampRate& ramprates() const;
  ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);

  // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 8;
  bool has_reactivepwrsetpointenabled() const;
  void clear_reactivepwrsetpointenabled();
  static const int kReactivePwrSetPointEnabledFieldNumber = 8;
  const ::commonmodule::ControlDPC& reactivepwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_reactivepwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled);

  // .commonmodule.ControlDPC realPwrSetPointEnabled = 9;
  bool has_realpwrsetpointenabled() const;
  void clear_realpwrsetpointenabled();
  static const int kRealPwrSetPointEnabledFieldNumber = 9;
  const ::commonmodule::ControlDPC& realpwrsetpointenabled() const;
  ::commonmodule::ControlDPC* release_realpwrsetpointenabled();
  ::commonmodule::ControlDPC* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled);

  // .commonmodule.ControlDPC reset = 10;
  bool has_reset() const;
  void clear_reset();
  static const int kResetFieldNumber = 10;
  const ::commonmodule::ControlDPC& reset() const;
  ::commonmodule::ControlDPC* release_reset();
  ::commonmodule::ControlDPC* mutable_reset();
  void set_allocated_reset(::commonmodule::ControlDPC* reset);

  // .commonmodule.Optional_StateKind state = 11;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 11;
  const ::commonmodule::Optional_StateKind& state() const;
  ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);

  // .commonmodule.ControlDPC syncBackToGrid = 12;
  bool has_syncbacktogrid() const;
  void clear_syncbacktogrid();
  static const int kSyncBackToGridFieldNumber = 12;
  const ::commonmodule::ControlDPC& syncbacktogrid() const;
  ::commonmodule::ControlDPC* release_syncbacktogrid();
  ::commonmodule::ControlDPC* mutable_syncbacktogrid();
  void set_allocated_syncbacktogrid(::commonmodule::ControlDPC* syncbacktogrid);

  // .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 13;
  bool has_transtoislndongridlossenabled() const;
  void clear_transtoislndongridlossenabled();
  static const int kTransToIslndOnGridLossEnabledFieldNumber = 13;
  const ::commonmodule::ControlDPC& transtoislndongridlossenabled() const;
  ::commonmodule::ControlDPC* release_transtoislndongridlossenabled();
  ::commonmodule::ControlDPC* mutable_transtoislndongridlossenabled();
  void set_allocated_transtoislndongridlossenabled(::commonmodule::ControlDPC* transtoislndongridlossenabled);

  // .commonmodule.ControlDPC voltageSetPointEnabled = 14;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled();
  static const int kVoltageSetPointEnabledFieldNumber = 14;
  const ::commonmodule::ControlDPC& voltagesetpointenabled() const;
  ::commonmodule::ControlDPC* release_voltagesetpointenabled();
  ::commonmodule::ControlDPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled);

  // .commonmodule.ControlTimestamp startTime = 15 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 15;
  const ::commonmodule::ControlTimestamp& starttime() const;
  ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);

  // @@protoc_insertion_point(class_scope:essmodule.ESSPoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlDPC* blackstartenabled_;
  ::commonmodule::ControlDPC* frequencysetpointenabled_;
  ::essmodule::ESSFunction* function_;
  ::commonmodule::ENG_GridConnectModeKind* mode_;
  ::google::protobuf::FloatValue* pcthzdroop_;
  ::google::protobuf::FloatValue* pctvdroop_;
  ::commonmodule::RampRate* ramprates_;
  ::commonmodule::ControlDPC* reactivepwrsetpointenabled_;
  ::commonmodule::ControlDPC* realpwrsetpointenabled_;
  ::commonmodule::ControlDPC* reset_;
  ::commonmodule::Optional_StateKind* state_;
  ::commonmodule::ControlDPC* syncbacktogrid_;
  ::commonmodule::ControlDPC* transtoislndongridlossenabled_;
  ::commonmodule::ControlDPC* voltagesetpointenabled_;
  ::commonmodule::ControlTimestamp* starttime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSCSG :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSCSG) */ {
 public:
  ESSCSG();
  virtual ~ESSCSG();

  ESSCSG(const ESSCSG& from);

  inline ESSCSG& operator=(const ESSCSG& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSCSG(ESSCSG&& from) noexcept
    : ESSCSG() {
    *this = ::std::move(from);
  }

  inline ESSCSG& operator=(ESSCSG&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSCSG& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSCSG* internal_default_instance() {
    return reinterpret_cast<const ESSCSG*>(
               &_ESSCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ESSCSG* other);
  friend void swap(ESSCSG& a, ESSCSG& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSCSG* New() const final {
    return CreateMaybeMessage<ESSCSG>(nullptr);
  }

  ESSCSG* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSCSG>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSCSG& from);
  void MergeFrom(const ESSCSG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSCSG* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .essmodule.ESSPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  void clear_crvpts();
  static const int kCrvPtsFieldNumber = 1;
  ::essmodule::ESSPoint* mutable_crvpts(int index);
  ::google::protobuf::RepeatedPtrField< ::essmodule::ESSPoint >*
      mutable_crvpts();
  const ::essmodule::ESSPoint& crvpts(int index) const;
  ::essmodule::ESSPoint* add_crvpts();
  const ::google::protobuf::RepeatedPtrField< ::essmodule::ESSPoint >&
      crvpts() const;

  // @@protoc_insertion_point(class_scope:essmodule.ESSCSG)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::essmodule::ESSPoint > crvpts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSControlScheduleFSCH :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSControlScheduleFSCH) */ {
 public:
  ESSControlScheduleFSCH();
  virtual ~ESSControlScheduleFSCH();

  ESSControlScheduleFSCH(const ESSControlScheduleFSCH& from);

  inline ESSControlScheduleFSCH& operator=(const ESSControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSControlScheduleFSCH(ESSControlScheduleFSCH&& from) noexcept
    : ESSControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline ESSControlScheduleFSCH& operator=(ESSControlScheduleFSCH&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSControlScheduleFSCH& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const ESSControlScheduleFSCH*>(
               &_ESSControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ESSControlScheduleFSCH* other);
  friend void swap(ESSControlScheduleFSCH& a, ESSControlScheduleFSCH& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSControlScheduleFSCH* New() const final {
    return CreateMaybeMessage<ESSControlScheduleFSCH>(nullptr);
  }

  ESSControlScheduleFSCH* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSControlScheduleFSCH>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSControlScheduleFSCH& from);
  void MergeFrom(const ESSControlScheduleFSCH& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSControlScheduleFSCH* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .essmodule.ESSCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  void clear_valdcsg();
  static const int kValDCSGFieldNumber = 1;
  const ::essmodule::ESSCSG& valdcsg() const;
  ::essmodule::ESSCSG* release_valdcsg();
  ::essmodule::ESSCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::essmodule::ESSCSG* valdcsg);

  // @@protoc_insertion_point(class_scope:essmodule.ESSControlScheduleFSCH)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::essmodule::ESSCSG* valdcsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class EssControlFSCC :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.EssControlFSCC) */ {
 public:
  EssControlFSCC();
  virtual ~EssControlFSCC();

  EssControlFSCC(const EssControlFSCC& from);

  inline EssControlFSCC& operator=(const EssControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EssControlFSCC(EssControlFSCC&& from) noexcept
    : EssControlFSCC() {
    *this = ::std::move(from);
  }

  inline EssControlFSCC& operator=(EssControlFSCC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EssControlFSCC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EssControlFSCC* internal_default_instance() {
    return reinterpret_cast<const EssControlFSCC*>(
               &_EssControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(EssControlFSCC* other);
  friend void swap(EssControlFSCC& a, EssControlFSCC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EssControlFSCC* New() const final {
    return CreateMaybeMessage<EssControlFSCC>(nullptr);
  }

  EssControlFSCC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EssControlFSCC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EssControlFSCC& from);
  void MergeFrom(const EssControlFSCC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EssControlFSCC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  void clear_controlfscc();
  static const int kControlFSCCFieldNumber = 1;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);

  // .essmodule.ESSControlScheduleFSCH essControlScheduleFSCH = 2;
  bool has_esscontrolschedulefsch() const;
  void clear_esscontrolschedulefsch();
  static const int kEssControlScheduleFSCHFieldNumber = 2;
  const ::essmodule::ESSControlScheduleFSCH& esscontrolschedulefsch() const;
  ::essmodule::ESSControlScheduleFSCH* release_esscontrolschedulefsch();
  ::essmodule::ESSControlScheduleFSCH* mutable_esscontrolschedulefsch();
  void set_allocated_esscontrolschedulefsch(::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch);

  // @@protoc_insertion_point(class_scope:essmodule.EssControlFSCC)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlFSCC* controlfscc_;
  ::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSControl :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSControl) */ {
 public:
  ESSControl();
  virtual ~ESSControl();

  ESSControl(const ESSControl& from);

  inline ESSControl& operator=(const ESSControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSControl(ESSControl&& from) noexcept
    : ESSControl() {
    *this = ::std::move(from);
  }

  inline ESSControl& operator=(ESSControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSControl* internal_default_instance() {
    return reinterpret_cast<const ESSControl*>(
               &_ESSControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ESSControl* other);
  friend void swap(ESSControl& a, ESSControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSControl* New() const final {
    return CreateMaybeMessage<ESSControl>(nullptr);
  }

  ESSControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSControl& from);
  void MergeFrom(const ESSControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue();
  static const int kControlValueFieldNumber = 1;
  const ::commonmodule::ControlValue& controlvalue() const;
  ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);

  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 2;
  const ::commonmodule::CheckConditions& check() const;
  ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);

  // .essmodule.EssControlFSCC essControlFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_esscontrolfscc() const;
  void clear_esscontrolfscc();
  static const int kEssControlFSCCFieldNumber = 3;
  const ::essmodule::EssControlFSCC& esscontrolfscc() const;
  ::essmodule::EssControlFSCC* release_esscontrolfscc();
  ::essmodule::EssControlFSCC* mutable_esscontrolfscc();
  void set_allocated_esscontrolfscc(::essmodule::EssControlFSCC* esscontrolfscc);

  // @@protoc_insertion_point(class_scope:essmodule.ESSControl)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlValue* controlvalue_;
  ::commonmodule::CheckConditions* check_;
  ::essmodule::EssControlFSCC* esscontrolfscc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// -------------------------------------------------------------------

class ESSControlProfile :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:essmodule.ESSControlProfile) */ {
 public:
  ESSControlProfile();
  virtual ~ESSControlProfile();

  ESSControlProfile(const ESSControlProfile& from);

  inline ESSControlProfile& operator=(const ESSControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESSControlProfile(ESSControlProfile&& from) noexcept
    : ESSControlProfile() {
    *this = ::std::move(from);
  }

  inline ESSControlProfile& operator=(ESSControlProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ESSControlProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESSControlProfile* internal_default_instance() {
    return reinterpret_cast<const ESSControlProfile*>(
               &_ESSControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ESSControlProfile* other);
  friend void swap(ESSControlProfile& a, ESSControlProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESSControlProfile* New() const final {
    return CreateMaybeMessage<ESSControlProfile>(nullptr);
  }

  ESSControlProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESSControlProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESSControlProfile& from);
  void MergeFrom(const ESSControlProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESSControlProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo();
  static const int kControlMessageInfoFieldNumber = 1;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);

  // .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ess() const;
  void clear_ess();
  static const int kEssFieldNumber = 2;
  const ::commonmodule::ESS& ess() const;
  ::commonmodule::ESS* release_ess();
  ::commonmodule::ESS* mutable_ess();
  void set_allocated_ess(::commonmodule::ESS* ess);

  // .essmodule.ESSControl essControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_esscontrol() const;
  void clear_esscontrol();
  static const int kEssControlFieldNumber = 3;
  const ::essmodule::ESSControl& esscontrol() const;
  ::essmodule::ESSControl* release_esscontrol();
  ::essmodule::ESSControl* mutable_esscontrol();
  void set_allocated_esscontrol(::essmodule::ESSControl* esscontrol);

  // .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_ied() const;
  void clear_ied();
  static const int kIedFieldNumber = 4;
  const ::commonmodule::IED& ied() const;
  ::commonmodule::IED* release_ied();
  ::commonmodule::IED* mutable_ied();
  void set_allocated_ied(::commonmodule::IED* ied);

  // @@protoc_insertion_point(class_scope:essmodule.ESSControlProfile)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::commonmodule::ControlMessageInfo* controlmessageinfo_;
  ::commonmodule::ESS* ess_;
  ::essmodule::ESSControl* esscontrol_;
  ::commonmodule::IED* ied_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_essmodule_2fessmodule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EssEventZBAT

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EssEventZBAT::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EssEventZBAT::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssEventZBAT::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssEventZBAT::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void EssEventZBAT::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS BatHi = 2;
inline bool EssEventZBAT::has_bathi() const {
  return this != internal_default_instance() && bathi_ != nullptr;
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::bathi() const {
  const ::commonmodule::StatusSPS* p = bathi_;
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.BatHi)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_bathi() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.BatHi)
  
  ::commonmodule::StatusSPS* temp = bathi_;
  bathi_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_bathi() {
  
  if (bathi_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    bathi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.BatHi)
  return bathi_;
}
inline void EssEventZBAT::set_allocated_bathi(::commonmodule::StatusSPS* bathi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bathi_);
  }
  if (bathi) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bathi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bathi, submessage_arena);
    }
    
  } else {
    
  }
  bathi_ = bathi;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.BatHi)
}

// .commonmodule.StatusSPS BatLo = 3;
inline bool EssEventZBAT::has_batlo() const {
  return this != internal_default_instance() && batlo_ != nullptr;
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::batlo() const {
  const ::commonmodule::StatusSPS* p = batlo_;
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.BatLo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_batlo() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.BatLo)
  
  ::commonmodule::StatusSPS* temp = batlo_;
  batlo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_batlo() {
  
  if (batlo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    batlo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.BatLo)
  return batlo_;
}
inline void EssEventZBAT::set_allocated_batlo(::commonmodule::StatusSPS* batlo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(batlo_);
  }
  if (batlo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      batlo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, batlo, submessage_arena);
    }
    
  } else {
    
  }
  batlo_ = batlo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.BatLo)
}

// .commonmodule.StatusSPS BatSt = 4;
inline bool EssEventZBAT::has_batst() const {
  return this != internal_default_instance() && batst_ != nullptr;
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::batst() const {
  const ::commonmodule::StatusSPS* p = batst_;
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.BatSt)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_batst() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.BatSt)
  
  ::commonmodule::StatusSPS* temp = batst_;
  batst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_batst() {
  
  if (batst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    batst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.BatSt)
  return batst_;
}
inline void EssEventZBAT::set_allocated_batst(::commonmodule::StatusSPS* batst) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(batst_);
  }
  if (batst) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      batst = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, batst, submessage_arena);
    }
    
  } else {
    
  }
  batst_ = batst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.BatSt)
}

// .commonmodule.MV Soc = 5;
inline bool EssEventZBAT::has_soc() const {
  return this != internal_default_instance() && soc_ != nullptr;
}
inline const ::commonmodule::MV& EssEventZBAT::soc() const {
  const ::commonmodule::MV* p = soc_;
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.Soc)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MV*>(
      &::commonmodule::_MV_default_instance_);
}
inline ::commonmodule::MV* EssEventZBAT::release_soc() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.Soc)
  
  ::commonmodule::MV* temp = soc_;
  soc_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssEventZBAT::mutable_soc() {
  
  if (soc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaNoVirtual());
    soc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.Soc)
  return soc_;
}
inline void EssEventZBAT::set_allocated_soc(::commonmodule::MV* soc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(soc_);
  }
  if (soc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      soc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, soc, submessage_arena);
    }
    
  } else {
    
  }
  soc_ = soc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.Soc)
}

// .commonmodule.StatusSPS Stdby = 6;
inline bool EssEventZBAT::has_stdby() const {
  return this != internal_default_instance() && stdby_ != nullptr;
}
inline const ::commonmodule::StatusSPS& EssEventZBAT::stdby() const {
  const ::commonmodule::StatusSPS* p = stdby_;
  // @@protoc_insertion_point(field_get:essmodule.EssEventZBAT.Stdby)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* EssEventZBAT::release_stdby() {
  // @@protoc_insertion_point(field_release:essmodule.EssEventZBAT.Stdby)
  
  ::commonmodule::StatusSPS* temp = stdby_;
  stdby_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssEventZBAT::mutable_stdby() {
  
  if (stdby_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    stdby_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssEventZBAT.Stdby)
  return stdby_;
}
inline void EssEventZBAT::set_allocated_stdby(::commonmodule::StatusSPS* stdby) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(stdby_);
  }
  if (stdby) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stdby = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stdby, submessage_arena);
    }
    
  } else {
    
  }
  stdby_ = stdby;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssEventZBAT.Stdby)
}

// -------------------------------------------------------------------

// FrequencyRegulation

// .google.protobuf.FloatValue frequencyDeadBandMinus = 1;
inline bool FrequencyRegulation::has_frequencydeadbandminus() const {
  return this != internal_default_instance() && frequencydeadbandminus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& FrequencyRegulation::frequencydeadbandminus() const {
  const ::google::protobuf::FloatValue* p = frequencydeadbandminus_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::release_frequencydeadbandminus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
  
  ::google::protobuf::FloatValue* temp = frequencydeadbandminus_;
  frequencydeadbandminus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::mutable_frequencydeadbandminus() {
  
  if (frequencydeadbandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    frequencydeadbandminus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
  return frequencydeadbandminus_;
}
inline void FrequencyRegulation::set_allocated_frequencydeadbandminus(::google::protobuf::FloatValue* frequencydeadbandminus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencydeadbandminus_);
  }
  if (frequencydeadbandminus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(frequencydeadbandminus)->GetArena();
    if (message_arena != submessage_arena) {
      frequencydeadbandminus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencydeadbandminus, submessage_arena);
    }
    
  } else {
    
  }
  frequencydeadbandminus_ = frequencydeadbandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencyDeadBandMinus)
}

// .google.protobuf.FloatValue frequencyDeadBandPlus = 2;
inline bool FrequencyRegulation::has_frequencydeadbandplus() const {
  return this != internal_default_instance() && frequencydeadbandplus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& FrequencyRegulation::frequencydeadbandplus() const {
  const ::google::protobuf::FloatValue* p = frequencydeadbandplus_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::release_frequencydeadbandplus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
  
  ::google::protobuf::FloatValue* temp = frequencydeadbandplus_;
  frequencydeadbandplus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::mutable_frequencydeadbandplus() {
  
  if (frequencydeadbandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    frequencydeadbandplus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
  return frequencydeadbandplus_;
}
inline void FrequencyRegulation::set_allocated_frequencydeadbandplus(::google::protobuf::FloatValue* frequencydeadbandplus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencydeadbandplus_);
  }
  if (frequencydeadbandplus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(frequencydeadbandplus)->GetArena();
    if (message_arena != submessage_arena) {
      frequencydeadbandplus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencydeadbandplus, submessage_arena);
    }
    
  } else {
    
  }
  frequencydeadbandplus_ = frequencydeadbandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencyDeadBandPlus)
}

// .google.protobuf.BoolValue frequencyRegulationCtl = 3;
inline bool FrequencyRegulation::has_frequencyregulationctl() const {
  return this != internal_default_instance() && frequencyregulationctl_ != nullptr;
}
inline const ::google::protobuf::BoolValue& FrequencyRegulation::frequencyregulationctl() const {
  const ::google::protobuf::BoolValue* p = frequencyregulationctl_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencyRegulationCtl)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* FrequencyRegulation::release_frequencyregulationctl() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencyRegulationCtl)
  
  ::google::protobuf::BoolValue* temp = frequencyregulationctl_;
  frequencyregulationctl_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* FrequencyRegulation::mutable_frequencyregulationctl() {
  
  if (frequencyregulationctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    frequencyregulationctl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencyRegulationCtl)
  return frequencyregulationctl_;
}
inline void FrequencyRegulation::set_allocated_frequencyregulationctl(::google::protobuf::BoolValue* frequencyregulationctl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencyregulationctl_);
  }
  if (frequencyregulationctl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(frequencyregulationctl)->GetArena();
    if (message_arena != submessage_arena) {
      frequencyregulationctl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencyregulationctl, submessage_arena);
    }
    
  } else {
    
  }
  frequencyregulationctl_ = frequencyregulationctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencyRegulationCtl)
}

// .google.protobuf.FloatValue frequencySetPoint = 4;
inline bool FrequencyRegulation::has_frequencysetpoint() const {
  return this != internal_default_instance() && frequencysetpoint_ != nullptr;
}
inline const ::google::protobuf::FloatValue& FrequencyRegulation::frequencysetpoint() const {
  const ::google::protobuf::FloatValue* p = frequencysetpoint_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.frequencySetPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::release_frequencysetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.frequencySetPoint)
  
  ::google::protobuf::FloatValue* temp = frequencysetpoint_;
  frequencysetpoint_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::mutable_frequencysetpoint() {
  
  if (frequencysetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    frequencysetpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.frequencySetPoint)
  return frequencysetpoint_;
}
inline void FrequencyRegulation::set_allocated_frequencysetpoint(::google::protobuf::FloatValue* frequencysetpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencysetpoint_);
  }
  if (frequencysetpoint) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(frequencysetpoint)->GetArena();
    if (message_arena != submessage_arena) {
      frequencysetpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencysetpoint, submessage_arena);
    }
    
  } else {
    
  }
  frequencysetpoint_ = frequencysetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.frequencySetPoint)
}

// .google.protobuf.FloatValue gridFrequencyStableBandMinus = 5;
inline bool FrequencyRegulation::has_gridfrequencystablebandminus() const {
  return this != internal_default_instance() && gridfrequencystablebandminus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& FrequencyRegulation::gridfrequencystablebandminus() const {
  const ::google::protobuf::FloatValue* p = gridfrequencystablebandminus_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::release_gridfrequencystablebandminus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
  
  ::google::protobuf::FloatValue* temp = gridfrequencystablebandminus_;
  gridfrequencystablebandminus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::mutable_gridfrequencystablebandminus() {
  
  if (gridfrequencystablebandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    gridfrequencystablebandminus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
  return gridfrequencystablebandminus_;
}
inline void FrequencyRegulation::set_allocated_gridfrequencystablebandminus(::google::protobuf::FloatValue* gridfrequencystablebandminus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gridfrequencystablebandminus_);
  }
  if (gridfrequencystablebandminus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(gridfrequencystablebandminus)->GetArena();
    if (message_arena != submessage_arena) {
      gridfrequencystablebandminus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gridfrequencystablebandminus, submessage_arena);
    }
    
  } else {
    
  }
  gridfrequencystablebandminus_ = gridfrequencystablebandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.gridFrequencyStableBandMinus)
}

// .google.protobuf.FloatValue gridFrequencyStableBandPlus = 6;
inline bool FrequencyRegulation::has_gridfrequencystablebandplus() const {
  return this != internal_default_instance() && gridfrequencystablebandplus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& FrequencyRegulation::gridfrequencystablebandplus() const {
  const ::google::protobuf::FloatValue* p = gridfrequencystablebandplus_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::release_gridfrequencystablebandplus() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
  
  ::google::protobuf::FloatValue* temp = gridfrequencystablebandplus_;
  gridfrequencystablebandplus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::mutable_gridfrequencystablebandplus() {
  
  if (gridfrequencystablebandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    gridfrequencystablebandplus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
  return gridfrequencystablebandplus_;
}
inline void FrequencyRegulation::set_allocated_gridfrequencystablebandplus(::google::protobuf::FloatValue* gridfrequencystablebandplus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gridfrequencystablebandplus_);
  }
  if (gridfrequencystablebandplus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(gridfrequencystablebandplus)->GetArena();
    if (message_arena != submessage_arena) {
      gridfrequencystablebandplus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gridfrequencystablebandplus, submessage_arena);
    }
    
  } else {
    
  }
  gridfrequencystablebandplus_ = gridfrequencystablebandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.gridFrequencyStableBandPlus)
}

// .google.protobuf.FloatValue overFrequencyDroop = 7;
inline bool FrequencyRegulation::has_overfrequencydroop() const {
  return this != internal_default_instance() && overfrequencydroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& FrequencyRegulation::overfrequencydroop() const {
  const ::google::protobuf::FloatValue* p = overfrequencydroop_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.overFrequencyDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::release_overfrequencydroop() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.overFrequencyDroop)
  
  ::google::protobuf::FloatValue* temp = overfrequencydroop_;
  overfrequencydroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::mutable_overfrequencydroop() {
  
  if (overfrequencydroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    overfrequencydroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.overFrequencyDroop)
  return overfrequencydroop_;
}
inline void FrequencyRegulation::set_allocated_overfrequencydroop(::google::protobuf::FloatValue* overfrequencydroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(overfrequencydroop_);
  }
  if (overfrequencydroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(overfrequencydroop)->GetArena();
    if (message_arena != submessage_arena) {
      overfrequencydroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, overfrequencydroop, submessage_arena);
    }
    
  } else {
    
  }
  overfrequencydroop_ = overfrequencydroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.overFrequencyDroop)
}

// .google.protobuf.FloatValue underFrequencyDroop = 8;
inline bool FrequencyRegulation::has_underfrequencydroop() const {
  return this != internal_default_instance() && underfrequencydroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& FrequencyRegulation::underfrequencydroop() const {
  const ::google::protobuf::FloatValue* p = underfrequencydroop_;
  // @@protoc_insertion_point(field_get:essmodule.FrequencyRegulation.underFrequencyDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::release_underfrequencydroop() {
  // @@protoc_insertion_point(field_release:essmodule.FrequencyRegulation.underFrequencyDroop)
  
  ::google::protobuf::FloatValue* temp = underfrequencydroop_;
  underfrequencydroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* FrequencyRegulation::mutable_underfrequencydroop() {
  
  if (underfrequencydroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    underfrequencydroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.FrequencyRegulation.underFrequencyDroop)
  return underfrequencydroop_;
}
inline void FrequencyRegulation::set_allocated_underfrequencydroop(::google::protobuf::FloatValue* underfrequencydroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(underfrequencydroop_);
  }
  if (underfrequencydroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(underfrequencydroop)->GetArena();
    if (message_arena != submessage_arena) {
      underfrequencydroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, underfrequencydroop, submessage_arena);
    }
    
  } else {
    
  }
  underfrequencydroop_ = underfrequencydroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.FrequencyRegulation.underFrequencyDroop)
}

// -------------------------------------------------------------------

// PeakShaving

// .google.protobuf.FloatValue baseShavingLimit = 1;
inline bool PeakShaving::has_baseshavinglimit() const {
  return this != internal_default_instance() && baseshavinglimit_ != nullptr;
}
inline const ::google::protobuf::FloatValue& PeakShaving::baseshavinglimit() const {
  const ::google::protobuf::FloatValue* p = baseshavinglimit_;
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.baseShavingLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* PeakShaving::release_baseshavinglimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.baseShavingLimit)
  
  ::google::protobuf::FloatValue* temp = baseshavinglimit_;
  baseshavinglimit_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* PeakShaving::mutable_baseshavinglimit() {
  
  if (baseshavinglimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    baseshavinglimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.baseShavingLimit)
  return baseshavinglimit_;
}
inline void PeakShaving::set_allocated_baseshavinglimit(::google::protobuf::FloatValue* baseshavinglimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(baseshavinglimit_);
  }
  if (baseshavinglimit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(baseshavinglimit)->GetArena();
    if (message_arena != submessage_arena) {
      baseshavinglimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baseshavinglimit, submessage_arena);
    }
    
  } else {
    
  }
  baseshavinglimit_ = baseshavinglimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.baseShavingLimit)
}

// .google.protobuf.BoolValue peakShavingCtl = 2;
inline bool PeakShaving::has_peakshavingctl() const {
  return this != internal_default_instance() && peakshavingctl_ != nullptr;
}
inline const ::google::protobuf::BoolValue& PeakShaving::peakshavingctl() const {
  const ::google::protobuf::BoolValue* p = peakshavingctl_;
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.peakShavingCtl)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* PeakShaving::release_peakshavingctl() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.peakShavingCtl)
  
  ::google::protobuf::BoolValue* temp = peakshavingctl_;
  peakshavingctl_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* PeakShaving::mutable_peakshavingctl() {
  
  if (peakshavingctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    peakshavingctl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.peakShavingCtl)
  return peakshavingctl_;
}
inline void PeakShaving::set_allocated_peakshavingctl(::google::protobuf::BoolValue* peakshavingctl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peakshavingctl_);
  }
  if (peakshavingctl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(peakshavingctl)->GetArena();
    if (message_arena != submessage_arena) {
      peakshavingctl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peakshavingctl, submessage_arena);
    }
    
  } else {
    
  }
  peakshavingctl_ = peakshavingctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.peakShavingCtl)
}

// .google.protobuf.FloatValue peakShavingLimit = 3;
inline bool PeakShaving::has_peakshavinglimit() const {
  return this != internal_default_instance() && peakshavinglimit_ != nullptr;
}
inline const ::google::protobuf::FloatValue& PeakShaving::peakshavinglimit() const {
  const ::google::protobuf::FloatValue* p = peakshavinglimit_;
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.peakShavingLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* PeakShaving::release_peakshavinglimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.peakShavingLimit)
  
  ::google::protobuf::FloatValue* temp = peakshavinglimit_;
  peakshavinglimit_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* PeakShaving::mutable_peakshavinglimit() {
  
  if (peakshavinglimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    peakshavinglimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.peakShavingLimit)
  return peakshavinglimit_;
}
inline void PeakShaving::set_allocated_peakshavinglimit(::google::protobuf::FloatValue* peakshavinglimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peakshavinglimit_);
  }
  if (peakshavinglimit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(peakshavinglimit)->GetArena();
    if (message_arena != submessage_arena) {
      peakshavinglimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peakshavinglimit, submessage_arena);
    }
    
  } else {
    
  }
  peakshavinglimit_ = peakshavinglimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.peakShavingLimit)
}

// .google.protobuf.FloatValue socManagementAllowedHighLimit = 4;
inline bool PeakShaving::has_socmanagementallowedhighlimit() const {
  return this != internal_default_instance() && socmanagementallowedhighlimit_ != nullptr;
}
inline const ::google::protobuf::FloatValue& PeakShaving::socmanagementallowedhighlimit() const {
  const ::google::protobuf::FloatValue* p = socmanagementallowedhighlimit_;
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.socManagementAllowedHighLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* PeakShaving::release_socmanagementallowedhighlimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.socManagementAllowedHighLimit)
  
  ::google::protobuf::FloatValue* temp = socmanagementallowedhighlimit_;
  socmanagementallowedhighlimit_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* PeakShaving::mutable_socmanagementallowedhighlimit() {
  
  if (socmanagementallowedhighlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    socmanagementallowedhighlimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.socManagementAllowedHighLimit)
  return socmanagementallowedhighlimit_;
}
inline void PeakShaving::set_allocated_socmanagementallowedhighlimit(::google::protobuf::FloatValue* socmanagementallowedhighlimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(socmanagementallowedhighlimit_);
  }
  if (socmanagementallowedhighlimit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(socmanagementallowedhighlimit)->GetArena();
    if (message_arena != submessage_arena) {
      socmanagementallowedhighlimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socmanagementallowedhighlimit, submessage_arena);
    }
    
  } else {
    
  }
  socmanagementallowedhighlimit_ = socmanagementallowedhighlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.socManagementAllowedHighLimit)
}

// .google.protobuf.FloatValue socManagementAllowedLowLimit = 5;
inline bool PeakShaving::has_socmanagementallowedlowlimit() const {
  return this != internal_default_instance() && socmanagementallowedlowlimit_ != nullptr;
}
inline const ::google::protobuf::FloatValue& PeakShaving::socmanagementallowedlowlimit() const {
  const ::google::protobuf::FloatValue* p = socmanagementallowedlowlimit_;
  // @@protoc_insertion_point(field_get:essmodule.PeakShaving.socManagementAllowedLowLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* PeakShaving::release_socmanagementallowedlowlimit() {
  // @@protoc_insertion_point(field_release:essmodule.PeakShaving.socManagementAllowedLowLimit)
  
  ::google::protobuf::FloatValue* temp = socmanagementallowedlowlimit_;
  socmanagementallowedlowlimit_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* PeakShaving::mutable_socmanagementallowedlowlimit() {
  
  if (socmanagementallowedlowlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    socmanagementallowedlowlimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.PeakShaving.socManagementAllowedLowLimit)
  return socmanagementallowedlowlimit_;
}
inline void PeakShaving::set_allocated_socmanagementallowedlowlimit(::google::protobuf::FloatValue* socmanagementallowedlowlimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(socmanagementallowedlowlimit_);
  }
  if (socmanagementallowedlowlimit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(socmanagementallowedlowlimit)->GetArena();
    if (message_arena != submessage_arena) {
      socmanagementallowedlowlimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socmanagementallowedlowlimit, submessage_arena);
    }
    
  } else {
    
  }
  socmanagementallowedlowlimit_ = socmanagementallowedlowlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.PeakShaving.socManagementAllowedLowLimit)
}

// -------------------------------------------------------------------

// SocLimit

// .google.protobuf.FloatValue socHighLimit = 1;
inline bool SocLimit::has_sochighlimit() const {
  return this != internal_default_instance() && sochighlimit_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SocLimit::sochighlimit() const {
  const ::google::protobuf::FloatValue* p = sochighlimit_;
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socHighLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SocLimit::release_sochighlimit() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socHighLimit)
  
  ::google::protobuf::FloatValue* temp = sochighlimit_;
  sochighlimit_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SocLimit::mutable_sochighlimit() {
  
  if (sochighlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    sochighlimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socHighLimit)
  return sochighlimit_;
}
inline void SocLimit::set_allocated_sochighlimit(::google::protobuf::FloatValue* sochighlimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sochighlimit_);
  }
  if (sochighlimit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(sochighlimit)->GetArena();
    if (message_arena != submessage_arena) {
      sochighlimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sochighlimit, submessage_arena);
    }
    
  } else {
    
  }
  sochighlimit_ = sochighlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socHighLimit)
}

// .google.protobuf.FloatValue socHighLimitHysteresis = 2;
inline bool SocLimit::has_sochighlimithysteresis() const {
  return this != internal_default_instance() && sochighlimithysteresis_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SocLimit::sochighlimithysteresis() const {
  const ::google::protobuf::FloatValue* p = sochighlimithysteresis_;
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socHighLimitHysteresis)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SocLimit::release_sochighlimithysteresis() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socHighLimitHysteresis)
  
  ::google::protobuf::FloatValue* temp = sochighlimithysteresis_;
  sochighlimithysteresis_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SocLimit::mutable_sochighlimithysteresis() {
  
  if (sochighlimithysteresis_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    sochighlimithysteresis_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socHighLimitHysteresis)
  return sochighlimithysteresis_;
}
inline void SocLimit::set_allocated_sochighlimithysteresis(::google::protobuf::FloatValue* sochighlimithysteresis) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sochighlimithysteresis_);
  }
  if (sochighlimithysteresis) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(sochighlimithysteresis)->GetArena();
    if (message_arena != submessage_arena) {
      sochighlimithysteresis = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sochighlimithysteresis, submessage_arena);
    }
    
  } else {
    
  }
  sochighlimithysteresis_ = sochighlimithysteresis;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socHighLimitHysteresis)
}

// .google.protobuf.BoolValue socLimitCtl = 3;
inline bool SocLimit::has_soclimitctl() const {
  return this != internal_default_instance() && soclimitctl_ != nullptr;
}
inline const ::google::protobuf::BoolValue& SocLimit::soclimitctl() const {
  const ::google::protobuf::BoolValue* p = soclimitctl_;
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socLimitCtl)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* SocLimit::release_soclimitctl() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socLimitCtl)
  
  ::google::protobuf::BoolValue* temp = soclimitctl_;
  soclimitctl_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* SocLimit::mutable_soclimitctl() {
  
  if (soclimitctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    soclimitctl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socLimitCtl)
  return soclimitctl_;
}
inline void SocLimit::set_allocated_soclimitctl(::google::protobuf::BoolValue* soclimitctl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(soclimitctl_);
  }
  if (soclimitctl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(soclimitctl)->GetArena();
    if (message_arena != submessage_arena) {
      soclimitctl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, soclimitctl, submessage_arena);
    }
    
  } else {
    
  }
  soclimitctl_ = soclimitctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socLimitCtl)
}

// .google.protobuf.FloatValue socLowLimit = 4;
inline bool SocLimit::has_soclowlimit() const {
  return this != internal_default_instance() && soclowlimit_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SocLimit::soclowlimit() const {
  const ::google::protobuf::FloatValue* p = soclowlimit_;
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socLowLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SocLimit::release_soclowlimit() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socLowLimit)
  
  ::google::protobuf::FloatValue* temp = soclowlimit_;
  soclowlimit_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SocLimit::mutable_soclowlimit() {
  
  if (soclowlimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    soclowlimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socLowLimit)
  return soclowlimit_;
}
inline void SocLimit::set_allocated_soclowlimit(::google::protobuf::FloatValue* soclowlimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(soclowlimit_);
  }
  if (soclowlimit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(soclowlimit)->GetArena();
    if (message_arena != submessage_arena) {
      soclowlimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, soclowlimit, submessage_arena);
    }
    
  } else {
    
  }
  soclowlimit_ = soclowlimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socLowLimit)
}

// .google.protobuf.FloatValue socLowLimitHysteresis = 5;
inline bool SocLimit::has_soclowlimithysteresis() const {
  return this != internal_default_instance() && soclowlimithysteresis_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SocLimit::soclowlimithysteresis() const {
  const ::google::protobuf::FloatValue* p = soclowlimithysteresis_;
  // @@protoc_insertion_point(field_get:essmodule.SocLimit.socLowLimitHysteresis)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SocLimit::release_soclowlimithysteresis() {
  // @@protoc_insertion_point(field_release:essmodule.SocLimit.socLowLimitHysteresis)
  
  ::google::protobuf::FloatValue* temp = soclowlimithysteresis_;
  soclowlimithysteresis_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SocLimit::mutable_soclowlimithysteresis() {
  
  if (soclowlimithysteresis_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    soclowlimithysteresis_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SocLimit.socLowLimitHysteresis)
  return soclowlimithysteresis_;
}
inline void SocLimit::set_allocated_soclowlimithysteresis(::google::protobuf::FloatValue* soclowlimithysteresis) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(soclowlimithysteresis_);
  }
  if (soclowlimithysteresis) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(soclowlimithysteresis)->GetArena();
    if (message_arena != submessage_arena) {
      soclowlimithysteresis = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, soclowlimithysteresis, submessage_arena);
    }
    
  } else {
    
  }
  soclowlimithysteresis_ = soclowlimithysteresis;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SocLimit.socLowLimitHysteresis)
}

// -------------------------------------------------------------------

// SOCManagement

// .google.protobuf.FloatValue socDeadBandMinus = 1;
inline bool SOCManagement::has_socdeadbandminus() const {
  return this != internal_default_instance() && socdeadbandminus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SOCManagement::socdeadbandminus() const {
  const ::google::protobuf::FloatValue* p = socdeadbandminus_;
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socDeadBandMinus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SOCManagement::release_socdeadbandminus() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socDeadBandMinus)
  
  ::google::protobuf::FloatValue* temp = socdeadbandminus_;
  socdeadbandminus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SOCManagement::mutable_socdeadbandminus() {
  
  if (socdeadbandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    socdeadbandminus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socDeadBandMinus)
  return socdeadbandminus_;
}
inline void SOCManagement::set_allocated_socdeadbandminus(::google::protobuf::FloatValue* socdeadbandminus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(socdeadbandminus_);
  }
  if (socdeadbandminus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(socdeadbandminus)->GetArena();
    if (message_arena != submessage_arena) {
      socdeadbandminus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socdeadbandminus, submessage_arena);
    }
    
  } else {
    
  }
  socdeadbandminus_ = socdeadbandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socDeadBandMinus)
}

// .google.protobuf.FloatValue socDeadBandPlus = 2;
inline bool SOCManagement::has_socdeadbandplus() const {
  return this != internal_default_instance() && socdeadbandplus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SOCManagement::socdeadbandplus() const {
  const ::google::protobuf::FloatValue* p = socdeadbandplus_;
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socDeadBandPlus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SOCManagement::release_socdeadbandplus() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socDeadBandPlus)
  
  ::google::protobuf::FloatValue* temp = socdeadbandplus_;
  socdeadbandplus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SOCManagement::mutable_socdeadbandplus() {
  
  if (socdeadbandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    socdeadbandplus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socDeadBandPlus)
  return socdeadbandplus_;
}
inline void SOCManagement::set_allocated_socdeadbandplus(::google::protobuf::FloatValue* socdeadbandplus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(socdeadbandplus_);
  }
  if (socdeadbandplus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(socdeadbandplus)->GetArena();
    if (message_arena != submessage_arena) {
      socdeadbandplus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socdeadbandplus, submessage_arena);
    }
    
  } else {
    
  }
  socdeadbandplus_ = socdeadbandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socDeadBandPlus)
}

// .google.protobuf.BoolValue socManagementCtl = 3;
inline bool SOCManagement::has_socmanagementctl() const {
  return this != internal_default_instance() && socmanagementctl_ != nullptr;
}
inline const ::google::protobuf::BoolValue& SOCManagement::socmanagementctl() const {
  const ::google::protobuf::BoolValue* p = socmanagementctl_;
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socManagementCtl)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* SOCManagement::release_socmanagementctl() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socManagementCtl)
  
  ::google::protobuf::BoolValue* temp = socmanagementctl_;
  socmanagementctl_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* SOCManagement::mutable_socmanagementctl() {
  
  if (socmanagementctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    socmanagementctl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socManagementCtl)
  return socmanagementctl_;
}
inline void SOCManagement::set_allocated_socmanagementctl(::google::protobuf::BoolValue* socmanagementctl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(socmanagementctl_);
  }
  if (socmanagementctl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(socmanagementctl)->GetArena();
    if (message_arena != submessage_arena) {
      socmanagementctl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socmanagementctl, submessage_arena);
    }
    
  } else {
    
  }
  socmanagementctl_ = socmanagementctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socManagementCtl)
}

// .google.protobuf.FloatValue socPowerSetPoint = 4;
inline bool SOCManagement::has_socpowersetpoint() const {
  return this != internal_default_instance() && socpowersetpoint_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SOCManagement::socpowersetpoint() const {
  const ::google::protobuf::FloatValue* p = socpowersetpoint_;
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socPowerSetPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SOCManagement::release_socpowersetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socPowerSetPoint)
  
  ::google::protobuf::FloatValue* temp = socpowersetpoint_;
  socpowersetpoint_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SOCManagement::mutable_socpowersetpoint() {
  
  if (socpowersetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    socpowersetpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socPowerSetPoint)
  return socpowersetpoint_;
}
inline void SOCManagement::set_allocated_socpowersetpoint(::google::protobuf::FloatValue* socpowersetpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(socpowersetpoint_);
  }
  if (socpowersetpoint) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(socpowersetpoint)->GetArena();
    if (message_arena != submessage_arena) {
      socpowersetpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socpowersetpoint, submessage_arena);
    }
    
  } else {
    
  }
  socpowersetpoint_ = socpowersetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socPowerSetPoint)
}

// .google.protobuf.FloatValue socSetPoint = 5;
inline bool SOCManagement::has_socsetpoint() const {
  return this != internal_default_instance() && socsetpoint_ != nullptr;
}
inline const ::google::protobuf::FloatValue& SOCManagement::socsetpoint() const {
  const ::google::protobuf::FloatValue* p = socsetpoint_;
  // @@protoc_insertion_point(field_get:essmodule.SOCManagement.socSetPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* SOCManagement::release_socsetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.SOCManagement.socSetPoint)
  
  ::google::protobuf::FloatValue* temp = socsetpoint_;
  socsetpoint_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* SOCManagement::mutable_socsetpoint() {
  
  if (socsetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    socsetpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.SOCManagement.socSetPoint)
  return socsetpoint_;
}
inline void SOCManagement::set_allocated_socsetpoint(::google::protobuf::FloatValue* socsetpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(socsetpoint_);
  }
  if (socsetpoint) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(socsetpoint)->GetArena();
    if (message_arena != submessage_arena) {
      socsetpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socsetpoint, submessage_arena);
    }
    
  } else {
    
  }
  socsetpoint_ = socsetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.SOCManagement.socSetPoint)
}

// -------------------------------------------------------------------

// VoltageRegulation

// .google.protobuf.FloatValue overVoltageDroop = 1;
inline bool VoltageRegulation::has_overvoltagedroop() const {
  return this != internal_default_instance() && overvoltagedroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& VoltageRegulation::overvoltagedroop() const {
  const ::google::protobuf::FloatValue* p = overvoltagedroop_;
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.overVoltageDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* VoltageRegulation::release_overvoltagedroop() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.overVoltageDroop)
  
  ::google::protobuf::FloatValue* temp = overvoltagedroop_;
  overvoltagedroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* VoltageRegulation::mutable_overvoltagedroop() {
  
  if (overvoltagedroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    overvoltagedroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.overVoltageDroop)
  return overvoltagedroop_;
}
inline void VoltageRegulation::set_allocated_overvoltagedroop(::google::protobuf::FloatValue* overvoltagedroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(overvoltagedroop_);
  }
  if (overvoltagedroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(overvoltagedroop)->GetArena();
    if (message_arena != submessage_arena) {
      overvoltagedroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, overvoltagedroop, submessage_arena);
    }
    
  } else {
    
  }
  overvoltagedroop_ = overvoltagedroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.overVoltageDroop)
}

// .google.protobuf.FloatValue underVoltageDroop = 2;
inline bool VoltageRegulation::has_undervoltagedroop() const {
  return this != internal_default_instance() && undervoltagedroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& VoltageRegulation::undervoltagedroop() const {
  const ::google::protobuf::FloatValue* p = undervoltagedroop_;
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.underVoltageDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* VoltageRegulation::release_undervoltagedroop() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.underVoltageDroop)
  
  ::google::protobuf::FloatValue* temp = undervoltagedroop_;
  undervoltagedroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* VoltageRegulation::mutable_undervoltagedroop() {
  
  if (undervoltagedroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    undervoltagedroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.underVoltageDroop)
  return undervoltagedroop_;
}
inline void VoltageRegulation::set_allocated_undervoltagedroop(::google::protobuf::FloatValue* undervoltagedroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(undervoltagedroop_);
  }
  if (undervoltagedroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(undervoltagedroop)->GetArena();
    if (message_arena != submessage_arena) {
      undervoltagedroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, undervoltagedroop, submessage_arena);
    }
    
  } else {
    
  }
  undervoltagedroop_ = undervoltagedroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.underVoltageDroop)
}

// .google.protobuf.FloatValue voltageDeadBandMinus = 3;
inline bool VoltageRegulation::has_voltagedeadbandminus() const {
  return this != internal_default_instance() && voltagedeadbandminus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& VoltageRegulation::voltagedeadbandminus() const {
  const ::google::protobuf::FloatValue* p = voltagedeadbandminus_;
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.voltageDeadBandMinus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* VoltageRegulation::release_voltagedeadbandminus() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.voltageDeadBandMinus)
  
  ::google::protobuf::FloatValue* temp = voltagedeadbandminus_;
  voltagedeadbandminus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* VoltageRegulation::mutable_voltagedeadbandminus() {
  
  if (voltagedeadbandminus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    voltagedeadbandminus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.voltageDeadBandMinus)
  return voltagedeadbandminus_;
}
inline void VoltageRegulation::set_allocated_voltagedeadbandminus(::google::protobuf::FloatValue* voltagedeadbandminus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagedeadbandminus_);
  }
  if (voltagedeadbandminus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(voltagedeadbandminus)->GetArena();
    if (message_arena != submessage_arena) {
      voltagedeadbandminus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagedeadbandminus, submessage_arena);
    }
    
  } else {
    
  }
  voltagedeadbandminus_ = voltagedeadbandminus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.voltageDeadBandMinus)
}

// .google.protobuf.FloatValue voltageDeadBandPlus = 4;
inline bool VoltageRegulation::has_voltagedeadbandplus() const {
  return this != internal_default_instance() && voltagedeadbandplus_ != nullptr;
}
inline const ::google::protobuf::FloatValue& VoltageRegulation::voltagedeadbandplus() const {
  const ::google::protobuf::FloatValue* p = voltagedeadbandplus_;
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.voltageDeadBandPlus)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* VoltageRegulation::release_voltagedeadbandplus() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.voltageDeadBandPlus)
  
  ::google::protobuf::FloatValue* temp = voltagedeadbandplus_;
  voltagedeadbandplus_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* VoltageRegulation::mutable_voltagedeadbandplus() {
  
  if (voltagedeadbandplus_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    voltagedeadbandplus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.voltageDeadBandPlus)
  return voltagedeadbandplus_;
}
inline void VoltageRegulation::set_allocated_voltagedeadbandplus(::google::protobuf::FloatValue* voltagedeadbandplus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagedeadbandplus_);
  }
  if (voltagedeadbandplus) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(voltagedeadbandplus)->GetArena();
    if (message_arena != submessage_arena) {
      voltagedeadbandplus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagedeadbandplus, submessage_arena);
    }
    
  } else {
    
  }
  voltagedeadbandplus_ = voltagedeadbandplus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.voltageDeadBandPlus)
}

// .google.protobuf.FloatValue voltageSetPoint = 5;
inline bool VoltageRegulation::has_voltagesetpoint() const {
  return this != internal_default_instance() && voltagesetpoint_ != nullptr;
}
inline const ::google::protobuf::FloatValue& VoltageRegulation::voltagesetpoint() const {
  const ::google::protobuf::FloatValue* p = voltagesetpoint_;
  // @@protoc_insertion_point(field_get:essmodule.VoltageRegulation.voltageSetPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* VoltageRegulation::release_voltagesetpoint() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageRegulation.voltageSetPoint)
  
  ::google::protobuf::FloatValue* temp = voltagesetpoint_;
  voltagesetpoint_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* VoltageRegulation::mutable_voltagesetpoint() {
  
  if (voltagesetpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    voltagesetpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageRegulation.voltageSetPoint)
  return voltagesetpoint_;
}
inline void VoltageRegulation::set_allocated_voltagesetpoint(::google::protobuf::FloatValue* voltagesetpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagesetpoint_);
  }
  if (voltagesetpoint) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(voltagesetpoint)->GetArena();
    if (message_arena != submessage_arena) {
      voltagesetpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagesetpoint, submessage_arena);
    }
    
  } else {
    
  }
  voltagesetpoint_ = voltagesetpoint;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageRegulation.voltageSetPoint)
}

// -------------------------------------------------------------------

// VoltageDroop

// .google.protobuf.BoolValue voltageDroopCtl = 1;
inline bool VoltageDroop::has_voltagedroopctl() const {
  return this != internal_default_instance() && voltagedroopctl_ != nullptr;
}
inline const ::google::protobuf::BoolValue& VoltageDroop::voltagedroopctl() const {
  const ::google::protobuf::BoolValue* p = voltagedroopctl_;
  // @@protoc_insertion_point(field_get:essmodule.VoltageDroop.voltageDroopCtl)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* VoltageDroop::release_voltagedroopctl() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageDroop.voltageDroopCtl)
  
  ::google::protobuf::BoolValue* temp = voltagedroopctl_;
  voltagedroopctl_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* VoltageDroop::mutable_voltagedroopctl() {
  
  if (voltagedroopctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    voltagedroopctl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageDroop.voltageDroopCtl)
  return voltagedroopctl_;
}
inline void VoltageDroop::set_allocated_voltagedroopctl(::google::protobuf::BoolValue* voltagedroopctl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagedroopctl_);
  }
  if (voltagedroopctl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(voltagedroopctl)->GetArena();
    if (message_arena != submessage_arena) {
      voltagedroopctl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagedroopctl, submessage_arena);
    }
    
  } else {
    
  }
  voltagedroopctl_ = voltagedroopctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageDroop.voltageDroopCtl)
}

// .essmodule.VoltageRegulation voltageRegulation = 2;
inline bool VoltageDroop::has_voltageregulation() const {
  return this != internal_default_instance() && voltageregulation_ != nullptr;
}
inline void VoltageDroop::clear_voltageregulation() {
  if (GetArenaNoVirtual() == nullptr && voltageregulation_ != nullptr) {
    delete voltageregulation_;
  }
  voltageregulation_ = nullptr;
}
inline const ::essmodule::VoltageRegulation& VoltageDroop::voltageregulation() const {
  const ::essmodule::VoltageRegulation* p = voltageregulation_;
  // @@protoc_insertion_point(field_get:essmodule.VoltageDroop.voltageRegulation)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::VoltageRegulation*>(
      &::essmodule::_VoltageRegulation_default_instance_);
}
inline ::essmodule::VoltageRegulation* VoltageDroop::release_voltageregulation() {
  // @@protoc_insertion_point(field_release:essmodule.VoltageDroop.voltageRegulation)
  
  ::essmodule::VoltageRegulation* temp = voltageregulation_;
  voltageregulation_ = nullptr;
  return temp;
}
inline ::essmodule::VoltageRegulation* VoltageDroop::mutable_voltageregulation() {
  
  if (voltageregulation_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltageRegulation>(GetArenaNoVirtual());
    voltageregulation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltageDroop.voltageRegulation)
  return voltageregulation_;
}
inline void VoltageDroop::set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voltageregulation_;
  }
  if (voltageregulation) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltageregulation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltageregulation, submessage_arena);
    }
    
  } else {
    
  }
  voltageregulation_ = voltageregulation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltageDroop.voltageRegulation)
}

// -------------------------------------------------------------------

// VoltagePI

// .google.protobuf.BoolValue voltagePICtl = 1;
inline bool VoltagePI::has_voltagepictl() const {
  return this != internal_default_instance() && voltagepictl_ != nullptr;
}
inline const ::google::protobuf::BoolValue& VoltagePI::voltagepictl() const {
  const ::google::protobuf::BoolValue* p = voltagepictl_;
  // @@protoc_insertion_point(field_get:essmodule.VoltagePI.voltagePICtl)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* VoltagePI::release_voltagepictl() {
  // @@protoc_insertion_point(field_release:essmodule.VoltagePI.voltagePICtl)
  
  ::google::protobuf::BoolValue* temp = voltagepictl_;
  voltagepictl_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* VoltagePI::mutable_voltagepictl() {
  
  if (voltagepictl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    voltagepictl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltagePI.voltagePICtl)
  return voltagepictl_;
}
inline void VoltagePI::set_allocated_voltagepictl(::google::protobuf::BoolValue* voltagepictl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagepictl_);
  }
  if (voltagepictl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(voltagepictl)->GetArena();
    if (message_arena != submessage_arena) {
      voltagepictl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagepictl, submessage_arena);
    }
    
  } else {
    
  }
  voltagepictl_ = voltagepictl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltagePI.voltagePICtl)
}

// .essmodule.VoltageRegulation voltageRegulation = 2;
inline bool VoltagePI::has_voltageregulation() const {
  return this != internal_default_instance() && voltageregulation_ != nullptr;
}
inline void VoltagePI::clear_voltageregulation() {
  if (GetArenaNoVirtual() == nullptr && voltageregulation_ != nullptr) {
    delete voltageregulation_;
  }
  voltageregulation_ = nullptr;
}
inline const ::essmodule::VoltageRegulation& VoltagePI::voltageregulation() const {
  const ::essmodule::VoltageRegulation* p = voltageregulation_;
  // @@protoc_insertion_point(field_get:essmodule.VoltagePI.voltageRegulation)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::VoltageRegulation*>(
      &::essmodule::_VoltageRegulation_default_instance_);
}
inline ::essmodule::VoltageRegulation* VoltagePI::release_voltageregulation() {
  // @@protoc_insertion_point(field_release:essmodule.VoltagePI.voltageRegulation)
  
  ::essmodule::VoltageRegulation* temp = voltageregulation_;
  voltageregulation_ = nullptr;
  return temp;
}
inline ::essmodule::VoltageRegulation* VoltagePI::mutable_voltageregulation() {
  
  if (voltageregulation_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltageRegulation>(GetArenaNoVirtual());
    voltageregulation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.VoltagePI.voltageRegulation)
  return voltageregulation_;
}
inline void VoltagePI::set_allocated_voltageregulation(::essmodule::VoltageRegulation* voltageregulation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voltageregulation_;
  }
  if (voltageregulation) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltageregulation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltageregulation, submessage_arena);
    }
    
  } else {
    
  }
  voltageregulation_ = voltageregulation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.VoltagePI.voltageRegulation)
}

// -------------------------------------------------------------------

// CapacityFirming

// .google.protobuf.BoolValue capacityFirmingCtl = 1;
inline bool CapacityFirming::has_capacityfirmingctl() const {
  return this != internal_default_instance() && capacityfirmingctl_ != nullptr;
}
inline const ::google::protobuf::BoolValue& CapacityFirming::capacityfirmingctl() const {
  const ::google::protobuf::BoolValue* p = capacityfirmingctl_;
  // @@protoc_insertion_point(field_get:essmodule.CapacityFirming.capacityFirmingCtl)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* CapacityFirming::release_capacityfirmingctl() {
  // @@protoc_insertion_point(field_release:essmodule.CapacityFirming.capacityFirmingCtl)
  
  ::google::protobuf::BoolValue* temp = capacityfirmingctl_;
  capacityfirmingctl_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* CapacityFirming::mutable_capacityfirmingctl() {
  
  if (capacityfirmingctl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArenaNoVirtual());
    capacityfirmingctl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.CapacityFirming.capacityFirmingCtl)
  return capacityfirmingctl_;
}
inline void CapacityFirming::set_allocated_capacityfirmingctl(::google::protobuf::BoolValue* capacityfirmingctl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(capacityfirmingctl_);
  }
  if (capacityfirmingctl) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(capacityfirmingctl)->GetArena();
    if (message_arena != submessage_arena) {
      capacityfirmingctl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capacityfirmingctl, submessage_arena);
    }
    
  } else {
    
  }
  capacityfirmingctl_ = capacityfirmingctl;
  // @@protoc_insertion_point(field_set_allocated:essmodule.CapacityFirming.capacityFirmingCtl)
}

// .google.protobuf.FloatValue limitNegative_dp_dt = 2;
inline bool CapacityFirming::has_limitnegative_dp_dt() const {
  return this != internal_default_instance() && limitnegative_dp_dt_ != nullptr;
}
inline const ::google::protobuf::FloatValue& CapacityFirming::limitnegative_dp_dt() const {
  const ::google::protobuf::FloatValue* p = limitnegative_dp_dt_;
  // @@protoc_insertion_point(field_get:essmodule.CapacityFirming.limitNegative_dp_dt)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* CapacityFirming::release_limitnegative_dp_dt() {
  // @@protoc_insertion_point(field_release:essmodule.CapacityFirming.limitNegative_dp_dt)
  
  ::google::protobuf::FloatValue* temp = limitnegative_dp_dt_;
  limitnegative_dp_dt_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* CapacityFirming::mutable_limitnegative_dp_dt() {
  
  if (limitnegative_dp_dt_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    limitnegative_dp_dt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.CapacityFirming.limitNegative_dp_dt)
  return limitnegative_dp_dt_;
}
inline void CapacityFirming::set_allocated_limitnegative_dp_dt(::google::protobuf::FloatValue* limitnegative_dp_dt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limitnegative_dp_dt_);
  }
  if (limitnegative_dp_dt) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limitnegative_dp_dt)->GetArena();
    if (message_arena != submessage_arena) {
      limitnegative_dp_dt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limitnegative_dp_dt, submessage_arena);
    }
    
  } else {
    
  }
  limitnegative_dp_dt_ = limitnegative_dp_dt;
  // @@protoc_insertion_point(field_set_allocated:essmodule.CapacityFirming.limitNegative_dp_dt)
}

// .google.protobuf.FloatValue limitPositive_dp_dt = 3;
inline bool CapacityFirming::has_limitpositive_dp_dt() const {
  return this != internal_default_instance() && limitpositive_dp_dt_ != nullptr;
}
inline const ::google::protobuf::FloatValue& CapacityFirming::limitpositive_dp_dt() const {
  const ::google::protobuf::FloatValue* p = limitpositive_dp_dt_;
  // @@protoc_insertion_point(field_get:essmodule.CapacityFirming.limitPositive_dp_dt)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* CapacityFirming::release_limitpositive_dp_dt() {
  // @@protoc_insertion_point(field_release:essmodule.CapacityFirming.limitPositive_dp_dt)
  
  ::google::protobuf::FloatValue* temp = limitpositive_dp_dt_;
  limitpositive_dp_dt_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* CapacityFirming::mutable_limitpositive_dp_dt() {
  
  if (limitpositive_dp_dt_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    limitpositive_dp_dt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.CapacityFirming.limitPositive_dp_dt)
  return limitpositive_dp_dt_;
}
inline void CapacityFirming::set_allocated_limitpositive_dp_dt(::google::protobuf::FloatValue* limitpositive_dp_dt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(limitpositive_dp_dt_);
  }
  if (limitpositive_dp_dt) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(limitpositive_dp_dt)->GetArena();
    if (message_arena != submessage_arena) {
      limitpositive_dp_dt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limitpositive_dp_dt, submessage_arena);
    }
    
  } else {
    
  }
  limitpositive_dp_dt_ = limitpositive_dp_dt;
  // @@protoc_insertion_point(field_set_allocated:essmodule.CapacityFirming.limitPositive_dp_dt)
}

// -------------------------------------------------------------------

// ESSFunction

// .essmodule.CapacityFirming capacityFirming = 1;
inline bool ESSFunction::has_capacityfirming() const {
  return this != internal_default_instance() && capacityfirming_ != nullptr;
}
inline void ESSFunction::clear_capacityfirming() {
  if (GetArenaNoVirtual() == nullptr && capacityfirming_ != nullptr) {
    delete capacityfirming_;
  }
  capacityfirming_ = nullptr;
}
inline const ::essmodule::CapacityFirming& ESSFunction::capacityfirming() const {
  const ::essmodule::CapacityFirming* p = capacityfirming_;
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.capacityFirming)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::CapacityFirming*>(
      &::essmodule::_CapacityFirming_default_instance_);
}
inline ::essmodule::CapacityFirming* ESSFunction::release_capacityfirming() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.capacityFirming)
  
  ::essmodule::CapacityFirming* temp = capacityfirming_;
  capacityfirming_ = nullptr;
  return temp;
}
inline ::essmodule::CapacityFirming* ESSFunction::mutable_capacityfirming() {
  
  if (capacityfirming_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::CapacityFirming>(GetArenaNoVirtual());
    capacityfirming_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.capacityFirming)
  return capacityfirming_;
}
inline void ESSFunction::set_allocated_capacityfirming(::essmodule::CapacityFirming* capacityfirming) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete capacityfirming_;
  }
  if (capacityfirming) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      capacityfirming = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capacityfirming, submessage_arena);
    }
    
  } else {
    
  }
  capacityfirming_ = capacityfirming;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.capacityFirming)
}

// .essmodule.FrequencyRegulation frequencyRegulation = 2;
inline bool ESSFunction::has_frequencyregulation() const {
  return this != internal_default_instance() && frequencyregulation_ != nullptr;
}
inline void ESSFunction::clear_frequencyregulation() {
  if (GetArenaNoVirtual() == nullptr && frequencyregulation_ != nullptr) {
    delete frequencyregulation_;
  }
  frequencyregulation_ = nullptr;
}
inline const ::essmodule::FrequencyRegulation& ESSFunction::frequencyregulation() const {
  const ::essmodule::FrequencyRegulation* p = frequencyregulation_;
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.frequencyRegulation)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::FrequencyRegulation*>(
      &::essmodule::_FrequencyRegulation_default_instance_);
}
inline ::essmodule::FrequencyRegulation* ESSFunction::release_frequencyregulation() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.frequencyRegulation)
  
  ::essmodule::FrequencyRegulation* temp = frequencyregulation_;
  frequencyregulation_ = nullptr;
  return temp;
}
inline ::essmodule::FrequencyRegulation* ESSFunction::mutable_frequencyregulation() {
  
  if (frequencyregulation_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::FrequencyRegulation>(GetArenaNoVirtual());
    frequencyregulation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.frequencyRegulation)
  return frequencyregulation_;
}
inline void ESSFunction::set_allocated_frequencyregulation(::essmodule::FrequencyRegulation* frequencyregulation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete frequencyregulation_;
  }
  if (frequencyregulation) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      frequencyregulation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencyregulation, submessage_arena);
    }
    
  } else {
    
  }
  frequencyregulation_ = frequencyregulation;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.frequencyRegulation)
}

// .essmodule.PeakShaving peakShaving = 3;
inline bool ESSFunction::has_peakshaving() const {
  return this != internal_default_instance() && peakshaving_ != nullptr;
}
inline void ESSFunction::clear_peakshaving() {
  if (GetArenaNoVirtual() == nullptr && peakshaving_ != nullptr) {
    delete peakshaving_;
  }
  peakshaving_ = nullptr;
}
inline const ::essmodule::PeakShaving& ESSFunction::peakshaving() const {
  const ::essmodule::PeakShaving* p = peakshaving_;
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.peakShaving)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::PeakShaving*>(
      &::essmodule::_PeakShaving_default_instance_);
}
inline ::essmodule::PeakShaving* ESSFunction::release_peakshaving() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.peakShaving)
  
  ::essmodule::PeakShaving* temp = peakshaving_;
  peakshaving_ = nullptr;
  return temp;
}
inline ::essmodule::PeakShaving* ESSFunction::mutable_peakshaving() {
  
  if (peakshaving_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::PeakShaving>(GetArenaNoVirtual());
    peakshaving_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.peakShaving)
  return peakshaving_;
}
inline void ESSFunction::set_allocated_peakshaving(::essmodule::PeakShaving* peakshaving) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete peakshaving_;
  }
  if (peakshaving) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      peakshaving = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peakshaving, submessage_arena);
    }
    
  } else {
    
  }
  peakshaving_ = peakshaving;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.peakShaving)
}

// .essmodule.SocLimit socLimit = 4;
inline bool ESSFunction::has_soclimit() const {
  return this != internal_default_instance() && soclimit_ != nullptr;
}
inline void ESSFunction::clear_soclimit() {
  if (GetArenaNoVirtual() == nullptr && soclimit_ != nullptr) {
    delete soclimit_;
  }
  soclimit_ = nullptr;
}
inline const ::essmodule::SocLimit& ESSFunction::soclimit() const {
  const ::essmodule::SocLimit* p = soclimit_;
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.socLimit)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::SocLimit*>(
      &::essmodule::_SocLimit_default_instance_);
}
inline ::essmodule::SocLimit* ESSFunction::release_soclimit() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.socLimit)
  
  ::essmodule::SocLimit* temp = soclimit_;
  soclimit_ = nullptr;
  return temp;
}
inline ::essmodule::SocLimit* ESSFunction::mutable_soclimit() {
  
  if (soclimit_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::SocLimit>(GetArenaNoVirtual());
    soclimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.socLimit)
  return soclimit_;
}
inline void ESSFunction::set_allocated_soclimit(::essmodule::SocLimit* soclimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete soclimit_;
  }
  if (soclimit) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      soclimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, soclimit, submessage_arena);
    }
    
  } else {
    
  }
  soclimit_ = soclimit;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.socLimit)
}

// .essmodule.SOCManagement socManagement = 5;
inline bool ESSFunction::has_socmanagement() const {
  return this != internal_default_instance() && socmanagement_ != nullptr;
}
inline void ESSFunction::clear_socmanagement() {
  if (GetArenaNoVirtual() == nullptr && socmanagement_ != nullptr) {
    delete socmanagement_;
  }
  socmanagement_ = nullptr;
}
inline const ::essmodule::SOCManagement& ESSFunction::socmanagement() const {
  const ::essmodule::SOCManagement* p = socmanagement_;
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.socManagement)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::SOCManagement*>(
      &::essmodule::_SOCManagement_default_instance_);
}
inline ::essmodule::SOCManagement* ESSFunction::release_socmanagement() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.socManagement)
  
  ::essmodule::SOCManagement* temp = socmanagement_;
  socmanagement_ = nullptr;
  return temp;
}
inline ::essmodule::SOCManagement* ESSFunction::mutable_socmanagement() {
  
  if (socmanagement_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::SOCManagement>(GetArenaNoVirtual());
    socmanagement_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.socManagement)
  return socmanagement_;
}
inline void ESSFunction::set_allocated_socmanagement(::essmodule::SOCManagement* socmanagement) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete socmanagement_;
  }
  if (socmanagement) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      socmanagement = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socmanagement, submessage_arena);
    }
    
  } else {
    
  }
  socmanagement_ = socmanagement;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.socManagement)
}

// .essmodule.VoltageDroop voltageDroop = 6;
inline bool ESSFunction::has_voltagedroop() const {
  return this != internal_default_instance() && voltagedroop_ != nullptr;
}
inline void ESSFunction::clear_voltagedroop() {
  if (GetArenaNoVirtual() == nullptr && voltagedroop_ != nullptr) {
    delete voltagedroop_;
  }
  voltagedroop_ = nullptr;
}
inline const ::essmodule::VoltageDroop& ESSFunction::voltagedroop() const {
  const ::essmodule::VoltageDroop* p = voltagedroop_;
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.voltageDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::VoltageDroop*>(
      &::essmodule::_VoltageDroop_default_instance_);
}
inline ::essmodule::VoltageDroop* ESSFunction::release_voltagedroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.voltageDroop)
  
  ::essmodule::VoltageDroop* temp = voltagedroop_;
  voltagedroop_ = nullptr;
  return temp;
}
inline ::essmodule::VoltageDroop* ESSFunction::mutable_voltagedroop() {
  
  if (voltagedroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltageDroop>(GetArenaNoVirtual());
    voltagedroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.voltageDroop)
  return voltagedroop_;
}
inline void ESSFunction::set_allocated_voltagedroop(::essmodule::VoltageDroop* voltagedroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voltagedroop_;
  }
  if (voltagedroop) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagedroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagedroop, submessage_arena);
    }
    
  } else {
    
  }
  voltagedroop_ = voltagedroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.voltageDroop)
}

// .essmodule.VoltagePI voltagePI = 7;
inline bool ESSFunction::has_voltagepi() const {
  return this != internal_default_instance() && voltagepi_ != nullptr;
}
inline void ESSFunction::clear_voltagepi() {
  if (GetArenaNoVirtual() == nullptr && voltagepi_ != nullptr) {
    delete voltagepi_;
  }
  voltagepi_ = nullptr;
}
inline const ::essmodule::VoltagePI& ESSFunction::voltagepi() const {
  const ::essmodule::VoltagePI* p = voltagepi_;
  // @@protoc_insertion_point(field_get:essmodule.ESSFunction.voltagePI)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::VoltagePI*>(
      &::essmodule::_VoltagePI_default_instance_);
}
inline ::essmodule::VoltagePI* ESSFunction::release_voltagepi() {
  // @@protoc_insertion_point(field_release:essmodule.ESSFunction.voltagePI)
  
  ::essmodule::VoltagePI* temp = voltagepi_;
  voltagepi_ = nullptr;
  return temp;
}
inline ::essmodule::VoltagePI* ESSFunction::mutable_voltagepi() {
  
  if (voltagepi_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::VoltagePI>(GetArenaNoVirtual());
    voltagepi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSFunction.voltagePI)
  return voltagepi_;
}
inline void ESSFunction::set_allocated_voltagepi(::essmodule::VoltagePI* voltagepi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voltagepi_;
  }
  if (voltagepi) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagepi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagepi, submessage_arena);
    }
    
  } else {
    
  }
  voltagepi_ = voltagepi;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSFunction.voltagePI)
}

// -------------------------------------------------------------------

// ESSPointStatus

// .commonmodule.ControlDPC blackStartEnabled = 1;
inline bool ESSPointStatus::has_blackstartenabled() const {
  return this != internal_default_instance() && blackstartenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPointStatus::blackstartenabled() const {
  const ::commonmodule::ControlDPC* p = blackstartenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.blackStartEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPointStatus::release_blackstartenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.blackStartEnabled)
  
  ::commonmodule::ControlDPC* temp = blackstartenabled_;
  blackstartenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPointStatus::mutable_blackstartenabled() {
  
  if (blackstartenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    blackstartenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.blackStartEnabled)
  return blackstartenabled_;
}
inline void ESSPointStatus::set_allocated_blackstartenabled(::commonmodule::ControlDPC* blackstartenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(blackstartenabled_);
  }
  if (blackstartenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      blackstartenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blackstartenabled, submessage_arena);
    }
    
  } else {
    
  }
  blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.blackStartEnabled)
}

// .commonmodule.ControlDPC frequencySetPointEnabled = 2;
inline bool ESSPointStatus::has_frequencysetpointenabled() const {
  return this != internal_default_instance() && frequencysetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPointStatus::frequencysetpointenabled() const {
  const ::commonmodule::ControlDPC* p = frequencysetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.frequencySetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPointStatus::release_frequencysetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.frequencySetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = frequencysetpointenabled_;
  frequencysetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPointStatus::mutable_frequencysetpointenabled() {
  
  if (frequencysetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    frequencysetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.frequencySetPointEnabled)
  return frequencysetpointenabled_;
}
inline void ESSPointStatus::set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencysetpointenabled_);
  }
  if (frequencysetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      frequencysetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencysetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.frequencySetPointEnabled)
}

// .essmodule.ESSFunction function = 3;
inline bool ESSPointStatus::has_function() const {
  return this != internal_default_instance() && function_ != nullptr;
}
inline void ESSPointStatus::clear_function() {
  if (GetArenaNoVirtual() == nullptr && function_ != nullptr) {
    delete function_;
  }
  function_ = nullptr;
}
inline const ::essmodule::ESSFunction& ESSPointStatus::function() const {
  const ::essmodule::ESSFunction* p = function_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.function)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSFunction*>(
      &::essmodule::_ESSFunction_default_instance_);
}
inline ::essmodule::ESSFunction* ESSPointStatus::release_function() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.function)
  
  ::essmodule::ESSFunction* temp = function_;
  function_ = nullptr;
  return temp;
}
inline ::essmodule::ESSFunction* ESSPointStatus::mutable_function() {
  
  if (function_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSFunction>(GetArenaNoVirtual());
    function_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.function)
  return function_;
}
inline void ESSPointStatus::set_allocated_function(::essmodule::ESSFunction* function) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete function_;
  }
  if (function) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      function = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  function_ = function;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.function)
}

// .commonmodule.ENG_GridConnectModeKind mode = 4;
inline bool ESSPointStatus::has_mode() const {
  return this != internal_default_instance() && mode_ != nullptr;
}
inline const ::commonmodule::ENG_GridConnectModeKind& ESSPointStatus::mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = mode_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.mode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind*>(
      &::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPointStatus::release_mode() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = mode_;
  mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPointStatus::mutable_mode() {
  
  if (mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaNoVirtual());
    mode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.mode)
  return mode_;
}
inline void ESSPointStatus::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mode_);
  }
  if (mode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }
    
  } else {
    
  }
  mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.mode)
}

// .google.protobuf.FloatValue pctHzDroop = 5;
inline bool ESSPointStatus::has_pcthzdroop() const {
  return this != internal_default_instance() && pcthzdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& ESSPointStatus::pcthzdroop() const {
  const ::google::protobuf::FloatValue* p = pcthzdroop_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.pctHzDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* ESSPointStatus::release_pcthzdroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.pctHzDroop)
  
  ::google::protobuf::FloatValue* temp = pcthzdroop_;
  pcthzdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ESSPointStatus::mutable_pcthzdroop() {
  
  if (pcthzdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pcthzdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.pctHzDroop)
  return pcthzdroop_;
}
inline void ESSPointStatus::set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pcthzdroop_);
  }
  if (pcthzdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pcthzdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pcthzdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pcthzdroop, submessage_arena);
    }
    
  } else {
    
  }
  pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.pctHzDroop)
}

// .google.protobuf.FloatValue pctVDroop = 6;
inline bool ESSPointStatus::has_pctvdroop() const {
  return this != internal_default_instance() && pctvdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& ESSPointStatus::pctvdroop() const {
  const ::google::protobuf::FloatValue* p = pctvdroop_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.pctVDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* ESSPointStatus::release_pctvdroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.pctVDroop)
  
  ::google::protobuf::FloatValue* temp = pctvdroop_;
  pctvdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ESSPointStatus::mutable_pctvdroop() {
  
  if (pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pctvdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.pctVDroop)
  return pctvdroop_;
}
inline void ESSPointStatus::set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pctvdroop_);
  }
  if (pctvdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pctvdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pctvdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }
    
  } else {
    
  }
  pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.pctVDroop)
}

// .commonmodule.RampRate rampRates = 7;
inline bool ESSPointStatus::has_ramprates() const {
  return this != internal_default_instance() && ramprates_ != nullptr;
}
inline const ::commonmodule::RampRate& ESSPointStatus::ramprates() const {
  const ::commonmodule::RampRate* p = ramprates_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.rampRates)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::RampRate*>(
      &::commonmodule::_RampRate_default_instance_);
}
inline ::commonmodule::RampRate* ESSPointStatus::release_ramprates() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.rampRates)
  
  ::commonmodule::RampRate* temp = ramprates_;
  ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* ESSPointStatus::mutable_ramprates() {
  
  if (ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaNoVirtual());
    ramprates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.rampRates)
  return ramprates_;
}
inline void ESSPointStatus::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ramprates_);
  }
  if (ramprates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ramprates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }
    
  } else {
    
  }
  ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.rampRates)
}

// .commonmodule.ControlDPC reactivePwrSetPointEnabled = 8;
inline bool ESSPointStatus::has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && reactivepwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPointStatus::reactivepwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = reactivepwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPointStatus::release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = reactivepwrsetpointenabled_;
  reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPointStatus::mutable_reactivepwrsetpointenabled() {
  
  if (reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reactivepwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
  return reactivepwrsetpointenabled_;
}
inline void ESSPointStatus::set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.reactivePwrSetPointEnabled)
}

// .commonmodule.ControlDPC realPwrSetPointEnabled = 9;
inline bool ESSPointStatus::has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && realpwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPointStatus::realpwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = realpwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.realPwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPointStatus::release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.realPwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = realpwrsetpointenabled_;
  realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPointStatus::mutable_realpwrsetpointenabled() {
  
  if (realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    realpwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.realPwrSetPointEnabled)
  return realpwrsetpointenabled_;
}
inline void ESSPointStatus::set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.realPwrSetPointEnabled)
}

// .commonmodule.Optional_StateKind state = 10;
inline bool ESSPointStatus::has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline const ::commonmodule::Optional_StateKind& ESSPointStatus::state() const {
  const ::commonmodule::Optional_StateKind* p = state_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.state)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_StateKind*>(
      &::commonmodule::_Optional_StateKind_default_instance_);
}
inline ::commonmodule::Optional_StateKind* ESSPointStatus::release_state() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.state)
  
  ::commonmodule::Optional_StateKind* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* ESSPointStatus::mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.state)
  return state_;
}
inline void ESSPointStatus::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.state)
}

// .commonmodule.ControlDPC syncBackToGrid = 11;
inline bool ESSPointStatus::has_syncbacktogrid() const {
  return this != internal_default_instance() && syncbacktogrid_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPointStatus::syncbacktogrid() const {
  const ::commonmodule::ControlDPC* p = syncbacktogrid_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.syncBackToGrid)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPointStatus::release_syncbacktogrid() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.syncBackToGrid)
  
  ::commonmodule::ControlDPC* temp = syncbacktogrid_;
  syncbacktogrid_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPointStatus::mutable_syncbacktogrid() {
  
  if (syncbacktogrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    syncbacktogrid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.syncBackToGrid)
  return syncbacktogrid_;
}
inline void ESSPointStatus::set_allocated_syncbacktogrid(::commonmodule::ControlDPC* syncbacktogrid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(syncbacktogrid_);
  }
  if (syncbacktogrid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      syncbacktogrid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, syncbacktogrid, submessage_arena);
    }
    
  } else {
    
  }
  syncbacktogrid_ = syncbacktogrid;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.syncBackToGrid)
}

// .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 12;
inline bool ESSPointStatus::has_transtoislndongridlossenabled() const {
  return this != internal_default_instance() && transtoislndongridlossenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPointStatus::transtoislndongridlossenabled() const {
  const ::commonmodule::ControlDPC* p = transtoislndongridlossenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPointStatus::release_transtoislndongridlossenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
  
  ::commonmodule::ControlDPC* temp = transtoislndongridlossenabled_;
  transtoislndongridlossenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPointStatus::mutable_transtoislndongridlossenabled() {
  
  if (transtoislndongridlossenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    transtoislndongridlossenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
  return transtoislndongridlossenabled_;
}
inline void ESSPointStatus::set_allocated_transtoislndongridlossenabled(::commonmodule::ControlDPC* transtoislndongridlossenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transtoislndongridlossenabled_);
  }
  if (transtoislndongridlossenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transtoislndongridlossenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transtoislndongridlossenabled, submessage_arena);
    }
    
  } else {
    
  }
  transtoislndongridlossenabled_ = transtoislndongridlossenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.transToIslndOnGridLossEnabled)
}

// .commonmodule.ControlDPC voltageSetPointEnabled = 13;
inline bool ESSPointStatus::has_voltagesetpointenabled() const {
  return this != internal_default_instance() && voltagesetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPointStatus::voltagesetpointenabled() const {
  const ::commonmodule::ControlDPC* p = voltagesetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPointStatus.voltageSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPointStatus::release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPointStatus.voltageSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = voltagesetpointenabled_;
  voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPointStatus::mutable_voltagesetpointenabled() {
  
  if (voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    voltagesetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPointStatus.voltageSetPointEnabled)
  return voltagesetpointenabled_;
}
inline void ESSPointStatus::set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPointStatus.voltageSetPointEnabled)
}

// -------------------------------------------------------------------

// ESSEventAndStatusZGEN

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool ESSEventAndStatusZGEN::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& ESSEventAndStatusZGEN::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* ESSEventAndStatusZGEN::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* ESSEventAndStatusZGEN::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void ESSEventAndStatusZGEN::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS AuxPwrSt = 2;
inline bool ESSEventAndStatusZGEN::has_auxpwrst() const {
  return this != internal_default_instance() && auxpwrst_ != nullptr;
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::auxpwrst() const {
  const ::commonmodule::StatusSPS* p = auxpwrst_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::release_auxpwrst() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
  
  ::commonmodule::StatusSPS* temp = auxpwrst_;
  auxpwrst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::mutable_auxpwrst() {
  
  if (auxpwrst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    auxpwrst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
  return auxpwrst_;
}
inline void ESSEventAndStatusZGEN::set_allocated_auxpwrst(::commonmodule::StatusSPS* auxpwrst) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(auxpwrst_);
  }
  if (auxpwrst) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      auxpwrst = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, auxpwrst, submessage_arena);
    }
    
  } else {
    
  }
  auxpwrst_ = auxpwrst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.AuxPwrSt)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 3;
inline bool ESSEventAndStatusZGEN::has_dynamictest() const {
  return this != internal_default_instance() && dynamictest_ != nullptr;
}
inline const ::commonmodule::ENS_DynamicTestKind& ESSEventAndStatusZGEN::dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = dynamictest_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.DynamicTest)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind*>(
      &::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline ::commonmodule::ENS_DynamicTestKind* ESSEventAndStatusZGEN::release_dynamictest() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = dynamictest_;
  dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* ESSEventAndStatusZGEN::mutable_dynamictest() {
  
  if (dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaNoVirtual());
    dynamictest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.DynamicTest)
  return dynamictest_;
}
inline void ESSEventAndStatusZGEN::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dynamictest_);
  }
  if (dynamictest) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamictest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }
    
  } else {
    
  }
  dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.DynamicTest)
}

// .commonmodule.StatusSPS EmgStop = 4;
inline bool ESSEventAndStatusZGEN::has_emgstop() const {
  return this != internal_default_instance() && emgstop_ != nullptr;
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::emgstop() const {
  const ::commonmodule::StatusSPS* p = emgstop_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.EmgStop)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::release_emgstop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.EmgStop)
  
  ::commonmodule::StatusSPS* temp = emgstop_;
  emgstop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::mutable_emgstop() {
  
  if (emgstop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    emgstop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.EmgStop)
  return emgstop_;
}
inline void ESSEventAndStatusZGEN::set_allocated_emgstop(::commonmodule::StatusSPS* emgstop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emgstop_);
  }
  if (emgstop) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      emgstop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emgstop, submessage_arena);
    }
    
  } else {
    
  }
  emgstop_ = emgstop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.EmgStop)
}

// .commonmodule.StatusSPS GnSynSt = 5;
inline bool ESSEventAndStatusZGEN::has_gnsynst() const {
  return this != internal_default_instance() && gnsynst_ != nullptr;
}
inline const ::commonmodule::StatusSPS& ESSEventAndStatusZGEN::gnsynst() const {
  const ::commonmodule::StatusSPS* p = gnsynst_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.GnSynSt)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::release_gnsynst() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.GnSynSt)
  
  ::commonmodule::StatusSPS* temp = gnsynst_;
  gnsynst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* ESSEventAndStatusZGEN::mutable_gnsynst() {
  
  if (gnsynst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    gnsynst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.GnSynSt)
  return gnsynst_;
}
inline void ESSEventAndStatusZGEN::set_allocated_gnsynst(::commonmodule::StatusSPS* gnsynst) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gnsynst_);
  }
  if (gnsynst) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gnsynst = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gnsynst, submessage_arena);
    }
    
  } else {
    
  }
  gnsynst_ = gnsynst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.GnSynSt)
}

// .essmodule.ESSPointStatus PointStatus = 6;
inline bool ESSEventAndStatusZGEN::has_pointstatus() const {
  return this != internal_default_instance() && pointstatus_ != nullptr;
}
inline void ESSEventAndStatusZGEN::clear_pointstatus() {
  if (GetArenaNoVirtual() == nullptr && pointstatus_ != nullptr) {
    delete pointstatus_;
  }
  pointstatus_ = nullptr;
}
inline const ::essmodule::ESSPointStatus& ESSEventAndStatusZGEN::pointstatus() const {
  const ::essmodule::ESSPointStatus* p = pointstatus_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventAndStatusZGEN.PointStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSPointStatus*>(
      &::essmodule::_ESSPointStatus_default_instance_);
}
inline ::essmodule::ESSPointStatus* ESSEventAndStatusZGEN::release_pointstatus() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventAndStatusZGEN.PointStatus)
  
  ::essmodule::ESSPointStatus* temp = pointstatus_;
  pointstatus_ = nullptr;
  return temp;
}
inline ::essmodule::ESSPointStatus* ESSEventAndStatusZGEN::mutable_pointstatus() {
  
  if (pointstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSPointStatus>(GetArenaNoVirtual());
    pointstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventAndStatusZGEN.PointStatus)
  return pointstatus_;
}
inline void ESSEventAndStatusZGEN::set_allocated_pointstatus(::essmodule::ESSPointStatus* pointstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pointstatus_;
  }
  if (pointstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pointstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pointstatus, submessage_arena);
    }
    
  } else {
    
  }
  pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventAndStatusZGEN.PointStatus)
}

// -------------------------------------------------------------------

// ESSEventZGEN

// .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool ESSEventZGEN::has_esseventandstatuszgen() const {
  return this != internal_default_instance() && esseventandstatuszgen_ != nullptr;
}
inline void ESSEventZGEN::clear_esseventandstatuszgen() {
  if (GetArenaNoVirtual() == nullptr && esseventandstatuszgen_ != nullptr) {
    delete esseventandstatuszgen_;
  }
  esseventandstatuszgen_ = nullptr;
}
inline const ::essmodule::ESSEventAndStatusZGEN& ESSEventZGEN::esseventandstatuszgen() const {
  const ::essmodule::ESSEventAndStatusZGEN* p = esseventandstatuszgen_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSEventAndStatusZGEN*>(
      &::essmodule::_ESSEventAndStatusZGEN_default_instance_);
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSEventZGEN::release_esseventandstatuszgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
  
  ::essmodule::ESSEventAndStatusZGEN* temp = esseventandstatuszgen_;
  esseventandstatuszgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSEventZGEN::mutable_esseventandstatuszgen() {
  
  if (esseventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEventAndStatusZGEN>(GetArenaNoVirtual());
    esseventandstatuszgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
  return esseventandstatuszgen_;
}
inline void ESSEventZGEN::set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esseventandstatuszgen_;
  }
  if (esseventandstatuszgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esseventandstatuszgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, esseventandstatuszgen, submessage_arena);
    }
    
  } else {
    
  }
  esseventandstatuszgen_ = esseventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventZGEN.eSSEventAndStatusZGEN)
}

// -------------------------------------------------------------------

// ESSEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSEvent::has_eventvalue() const {
  return this != internal_default_instance() && eventvalue_ != nullptr;
}
inline const ::commonmodule::EventValue& ESSEvent::eventvalue() const {
  const ::commonmodule::EventValue* p = eventvalue_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEvent.eventValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventValue*>(
      &::commonmodule::_EventValue_default_instance_);
}
inline ::commonmodule::EventValue* ESSEvent::release_eventvalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEvent.eventValue)
  
  ::commonmodule::EventValue* temp = eventvalue_;
  eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* ESSEvent::mutable_eventvalue() {
  
  if (eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaNoVirtual());
    eventvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEvent.eventValue)
  return eventvalue_;
}
inline void ESSEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventvalue_);
  }
  if (eventvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }
    
  } else {
    
  }
  eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEvent.eventValue)
}

// .essmodule.EssEventZBAT essEventZBAT = 2;
inline bool ESSEvent::has_esseventzbat() const {
  return this != internal_default_instance() && esseventzbat_ != nullptr;
}
inline void ESSEvent::clear_esseventzbat() {
  if (GetArenaNoVirtual() == nullptr && esseventzbat_ != nullptr) {
    delete esseventzbat_;
  }
  esseventzbat_ = nullptr;
}
inline const ::essmodule::EssEventZBAT& ESSEvent::esseventzbat() const {
  const ::essmodule::EssEventZBAT* p = esseventzbat_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEvent.essEventZBAT)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::EssEventZBAT*>(
      &::essmodule::_EssEventZBAT_default_instance_);
}
inline ::essmodule::EssEventZBAT* ESSEvent::release_esseventzbat() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEvent.essEventZBAT)
  
  ::essmodule::EssEventZBAT* temp = esseventzbat_;
  esseventzbat_ = nullptr;
  return temp;
}
inline ::essmodule::EssEventZBAT* ESSEvent::mutable_esseventzbat() {
  
  if (esseventzbat_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::EssEventZBAT>(GetArenaNoVirtual());
    esseventzbat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEvent.essEventZBAT)
  return esseventzbat_;
}
inline void ESSEvent::set_allocated_esseventzbat(::essmodule::EssEventZBAT* esseventzbat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esseventzbat_;
  }
  if (esseventzbat) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esseventzbat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, esseventzbat, submessage_arena);
    }
    
  } else {
    
  }
  esseventzbat_ = esseventzbat;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEvent.essEventZBAT)
}

// .essmodule.ESSEventZGEN essEventZGEN = 3;
inline bool ESSEvent::has_esseventzgen() const {
  return this != internal_default_instance() && esseventzgen_ != nullptr;
}
inline void ESSEvent::clear_esseventzgen() {
  if (GetArenaNoVirtual() == nullptr && esseventzgen_ != nullptr) {
    delete esseventzgen_;
  }
  esseventzgen_ = nullptr;
}
inline const ::essmodule::ESSEventZGEN& ESSEvent::esseventzgen() const {
  const ::essmodule::ESSEventZGEN* p = esseventzgen_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEvent.essEventZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSEventZGEN*>(
      &::essmodule::_ESSEventZGEN_default_instance_);
}
inline ::essmodule::ESSEventZGEN* ESSEvent::release_esseventzgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEvent.essEventZGEN)
  
  ::essmodule::ESSEventZGEN* temp = esseventzgen_;
  esseventzgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEventZGEN* ESSEvent::mutable_esseventzgen() {
  
  if (esseventzgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEventZGEN>(GetArenaNoVirtual());
    esseventzgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEvent.essEventZGEN)
  return esseventzgen_;
}
inline void ESSEvent::set_allocated_esseventzgen(::essmodule::ESSEventZGEN* esseventzgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esseventzgen_;
  }
  if (esseventzgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esseventzgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, esseventzgen, submessage_arena);
    }
    
  } else {
    
  }
  esseventzgen_ = esseventzgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEvent.essEventZGEN)
}

// -------------------------------------------------------------------

// ESSEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSEventProfile::has_eventmessageinfo() const {
  return this != internal_default_instance() && eventmessageinfo_ != nullptr;
}
inline const ::commonmodule::EventMessageInfo& ESSEventProfile::eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = eventmessageinfo_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventProfile.eventMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::EventMessageInfo*>(
      &::commonmodule::_EventMessageInfo_default_instance_);
}
inline ::commonmodule::EventMessageInfo* ESSEventProfile::release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = eventmessageinfo_;
  eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* ESSEventProfile::mutable_eventmessageinfo() {
  
  if (eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaNoVirtual());
    eventmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventProfile.eventMessageInfo)
  return eventmessageinfo_;
}
inline void ESSEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventProfile.eventMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSEventProfile::has_ess() const {
  return this != internal_default_instance() && ess_ != nullptr;
}
inline const ::commonmodule::ESS& ESSEventProfile::ess() const {
  const ::commonmodule::ESS* p = ess_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventProfile.ess)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ESS*>(
      &::commonmodule::_ESS_default_instance_);
}
inline ::commonmodule::ESS* ESSEventProfile::release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventProfile.ess)
  
  ::commonmodule::ESS* temp = ess_;
  ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSEventProfile::mutable_ess() {
  
  if (ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaNoVirtual());
    ess_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventProfile.ess)
  return ess_;
}
inline void ESSEventProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ess_);
  }
  if (ess) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ess = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }
    
  } else {
    
  }
  ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventProfile.ess)
}

// .essmodule.ESSEvent essEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSEventProfile::has_essevent() const {
  return this != internal_default_instance() && essevent_ != nullptr;
}
inline void ESSEventProfile::clear_essevent() {
  if (GetArenaNoVirtual() == nullptr && essevent_ != nullptr) {
    delete essevent_;
  }
  essevent_ = nullptr;
}
inline const ::essmodule::ESSEvent& ESSEventProfile::essevent() const {
  const ::essmodule::ESSEvent* p = essevent_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventProfile.essEvent)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSEvent*>(
      &::essmodule::_ESSEvent_default_instance_);
}
inline ::essmodule::ESSEvent* ESSEventProfile::release_essevent() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventProfile.essEvent)
  
  ::essmodule::ESSEvent* temp = essevent_;
  essevent_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEvent* ESSEventProfile::mutable_essevent() {
  
  if (essevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEvent>(GetArenaNoVirtual());
    essevent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventProfile.essEvent)
  return essevent_;
}
inline void ESSEventProfile::set_allocated_essevent(::essmodule::ESSEvent* essevent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete essevent_;
  }
  if (essevent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      essevent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, essevent, submessage_arena);
    }
    
  } else {
    
  }
  essevent_ = essevent;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventProfile.essEvent)
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSEventProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& ESSEventProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:essmodule.ESSEventProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* ESSEventProfile::release_ied() {
  // @@protoc_insertion_point(field_release:essmodule.ESSEventProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* ESSEventProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSEventProfile.ied)
  return ied_;
}
inline void ESSEventProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSEventProfile.ied)
}

// -------------------------------------------------------------------

// ESSReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool ESSReading::has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && conductingequipmentterminalreading_ != nullptr;
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& ESSReading::conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = conductingequipmentterminalreading_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.conductingEquipmentTerminalReading)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading*>(
      &::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline ::commonmodule::ConductingEquipmentTerminalReading* ESSReading::release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = conductingequipmentterminalreading_;
  conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* ESSReading::mutable_conductingequipmentterminalreading() {
  
  if (conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaNoVirtual());
    conductingequipmentterminalreading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.conductingEquipmentTerminalReading)
  return conductingequipmentterminalreading_;
}
inline void ESSReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }
    
  } else {
    
  }
  conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool ESSReading::has_phasemmtn() const {
  return this != internal_default_instance() && phasemmtn_ != nullptr;
}
inline const ::commonmodule::PhaseMMTN& ESSReading::phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = phasemmtn_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.phaseMMTN)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::PhaseMMTN*>(
      &::commonmodule::_PhaseMMTN_default_instance_);
}
inline ::commonmodule::PhaseMMTN* ESSReading::release_phasemmtn() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = phasemmtn_;
  phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* ESSReading::mutable_phasemmtn() {
  
  if (phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaNoVirtual());
    phasemmtn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.phaseMMTN)
  return phasemmtn_;
}
inline void ESSReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(phasemmtn_);
  }
  if (phasemmtn) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phasemmtn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }
    
  } else {
    
  }
  phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool ESSReading::has_readingmmtr() const {
  return this != internal_default_instance() && readingmmtr_ != nullptr;
}
inline const ::commonmodule::ReadingMMTR& ESSReading::readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = readingmmtr_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.readingMMTR)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMTR*>(
      &::commonmodule::_ReadingMMTR_default_instance_);
}
inline ::commonmodule::ReadingMMTR* ESSReading::release_readingmmtr() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = readingmmtr_;
  readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* ESSReading::mutable_readingmmtr() {
  
  if (readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaNoVirtual());
    readingmmtr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.readingMMTR)
  return readingmmtr_;
}
inline void ESSReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmtr_);
  }
  if (readingmmtr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmtr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }
    
  } else {
    
  }
  readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool ESSReading::has_readingmmxu() const {
  return this != internal_default_instance() && readingmmxu_ != nullptr;
}
inline const ::commonmodule::ReadingMMXU& ESSReading::readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = readingmmxu_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReading.readingMMXU)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMMXU*>(
      &::commonmodule::_ReadingMMXU_default_instance_);
}
inline ::commonmodule::ReadingMMXU* ESSReading::release_readingmmxu() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = readingmmxu_;
  readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* ESSReading::mutable_readingmmxu() {
  
  if (readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaNoVirtual());
    readingmmxu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReading.readingMMXU)
  return readingmmxu_;
}
inline void ESSReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmmxu_);
  }
  if (readingmmxu) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmmxu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }
    
  } else {
    
  }
  readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReading.readingMMXU)
}

// -------------------------------------------------------------------

// ESSReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSReadingProfile::has_readingmessageinfo() const {
  return this != internal_default_instance() && readingmessageinfo_ != nullptr;
}
inline const ::commonmodule::ReadingMessageInfo& ESSReadingProfile::readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = readingmessageinfo_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReadingProfile.readingMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ReadingMessageInfo*>(
      &::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline ::commonmodule::ReadingMessageInfo* ESSReadingProfile::release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = readingmessageinfo_;
  readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* ESSReadingProfile::mutable_readingmessageinfo() {
  
  if (readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaNoVirtual());
    readingmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReadingProfile.readingMessageInfo)
  return readingmessageinfo_;
}
inline void ESSReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReadingProfile.readingMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSReadingProfile::has_ess() const {
  return this != internal_default_instance() && ess_ != nullptr;
}
inline const ::commonmodule::ESS& ESSReadingProfile::ess() const {
  const ::commonmodule::ESS* p = ess_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReadingProfile.ess)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ESS*>(
      &::commonmodule::_ESS_default_instance_);
}
inline ::commonmodule::ESS* ESSReadingProfile::release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReadingProfile.ess)
  
  ::commonmodule::ESS* temp = ess_;
  ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSReadingProfile::mutable_ess() {
  
  if (ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaNoVirtual());
    ess_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReadingProfile.ess)
  return ess_;
}
inline void ESSReadingProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ess_);
  }
  if (ess) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ess = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }
    
  } else {
    
  }
  ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReadingProfile.ess)
}

// .essmodule.ESSReading essReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSReadingProfile::has_essreading() const {
  return this != internal_default_instance() && essreading_ != nullptr;
}
inline void ESSReadingProfile::clear_essreading() {
  if (GetArenaNoVirtual() == nullptr && essreading_ != nullptr) {
    delete essreading_;
  }
  essreading_ = nullptr;
}
inline const ::essmodule::ESSReading& ESSReadingProfile::essreading() const {
  const ::essmodule::ESSReading* p = essreading_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReadingProfile.essReading)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSReading*>(
      &::essmodule::_ESSReading_default_instance_);
}
inline ::essmodule::ESSReading* ESSReadingProfile::release_essreading() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReadingProfile.essReading)
  
  ::essmodule::ESSReading* temp = essreading_;
  essreading_ = nullptr;
  return temp;
}
inline ::essmodule::ESSReading* ESSReadingProfile::mutable_essreading() {
  
  if (essreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSReading>(GetArenaNoVirtual());
    essreading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReadingProfile.essReading)
  return essreading_;
}
inline void ESSReadingProfile::set_allocated_essreading(::essmodule::ESSReading* essreading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete essreading_;
  }
  if (essreading) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      essreading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, essreading, submessage_arena);
    }
    
  } else {
    
  }
  essreading_ = essreading;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReadingProfile.essReading)
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSReadingProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& ESSReadingProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:essmodule.ESSReadingProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* ESSReadingProfile::release_ied() {
  // @@protoc_insertion_point(field_release:essmodule.ESSReadingProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* ESSReadingProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSReadingProfile.ied)
  return ied_;
}
inline void ESSReadingProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSReadingProfile.ied)
}

// -------------------------------------------------------------------

// EssStatusZBAT

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EssStatusZBAT::has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && logicalnodeforeventandstatus_ != nullptr;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EssStatusZBAT::logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = logicalnodeforeventandstatus_;
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus*>(
      &::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssStatusZBAT::release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = logicalnodeforeventandstatus_;
  logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* EssStatusZBAT::mutable_logicalnodeforeventandstatus() {
  
  if (logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaNoVirtual());
    logicalnodeforeventandstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
  return logicalnodeforeventandstatus_;
}
inline void EssStatusZBAT::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }
    
  } else {
    
  }
  logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.logicalNodeForEventAndStatus)
}

// .commonmodule.StatusSPS BatSt = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EssStatusZBAT::has_batst() const {
  return this != internal_default_instance() && batst_ != nullptr;
}
inline const ::commonmodule::StatusSPS& EssStatusZBAT::batst() const {
  const ::commonmodule::StatusSPS* p = batst_;
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.BatSt)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::release_batst() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.BatSt)
  
  ::commonmodule::StatusSPS* temp = batst_;
  batst_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::mutable_batst() {
  
  if (batst_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    batst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.BatSt)
  return batst_;
}
inline void EssStatusZBAT::set_allocated_batst(::commonmodule::StatusSPS* batst) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(batst_);
  }
  if (batst) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      batst = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, batst, submessage_arena);
    }
    
  } else {
    
  }
  batst_ = batst;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.BatSt)
}

// .commonmodule.ENG_GridConnectModeKind GriMod = 3;
inline bool EssStatusZBAT::has_grimod() const {
  return this != internal_default_instance() && grimod_ != nullptr;
}
inline const ::commonmodule::ENG_GridConnectModeKind& EssStatusZBAT::grimod() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = grimod_;
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.GriMod)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind*>(
      &::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline ::commonmodule::ENG_GridConnectModeKind* EssStatusZBAT::release_grimod() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.GriMod)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = grimod_;
  grimod_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* EssStatusZBAT::mutable_grimod() {
  
  if (grimod_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaNoVirtual());
    grimod_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.GriMod)
  return grimod_;
}
inline void EssStatusZBAT::set_allocated_grimod(::commonmodule::ENG_GridConnectModeKind* grimod) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(grimod_);
  }
  if (grimod) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      grimod = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grimod, submessage_arena);
    }
    
  } else {
    
  }
  grimod_ = grimod;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.GriMod)
}

// .commonmodule.MV Soc = 4;
inline bool EssStatusZBAT::has_soc() const {
  return this != internal_default_instance() && soc_ != nullptr;
}
inline const ::commonmodule::MV& EssStatusZBAT::soc() const {
  const ::commonmodule::MV* p = soc_;
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.Soc)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::MV*>(
      &::commonmodule::_MV_default_instance_);
}
inline ::commonmodule::MV* EssStatusZBAT::release_soc() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.Soc)
  
  ::commonmodule::MV* temp = soc_;
  soc_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* EssStatusZBAT::mutable_soc() {
  
  if (soc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::MV>(GetArenaNoVirtual());
    soc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.Soc)
  return soc_;
}
inline void EssStatusZBAT::set_allocated_soc(::commonmodule::MV* soc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(soc_);
  }
  if (soc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      soc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, soc, submessage_arena);
    }
    
  } else {
    
  }
  soc_ = soc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.Soc)
}

// .commonmodule.StatusSPS Stdby = 5;
inline bool EssStatusZBAT::has_stdby() const {
  return this != internal_default_instance() && stdby_ != nullptr;
}
inline const ::commonmodule::StatusSPS& EssStatusZBAT::stdby() const {
  const ::commonmodule::StatusSPS* p = stdby_;
  // @@protoc_insertion_point(field_get:essmodule.EssStatusZBAT.Stdby)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusSPS*>(
      &::commonmodule::_StatusSPS_default_instance_);
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::release_stdby() {
  // @@protoc_insertion_point(field_release:essmodule.EssStatusZBAT.Stdby)
  
  ::commonmodule::StatusSPS* temp = stdby_;
  stdby_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* EssStatusZBAT::mutable_stdby() {
  
  if (stdby_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaNoVirtual());
    stdby_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssStatusZBAT.Stdby)
  return stdby_;
}
inline void EssStatusZBAT::set_allocated_stdby(::commonmodule::StatusSPS* stdby) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(stdby_);
  }
  if (stdby) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stdby = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stdby, submessage_arena);
    }
    
  } else {
    
  }
  stdby_ = stdby;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssStatusZBAT.Stdby)
}

// -------------------------------------------------------------------

// ESSStatusZGEN

// .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1 [(.uml.option_parent_message) = true];
inline bool ESSStatusZGEN::has_esseventandstatuszgen() const {
  return this != internal_default_instance() && esseventandstatuszgen_ != nullptr;
}
inline void ESSStatusZGEN::clear_esseventandstatuszgen() {
  if (GetArenaNoVirtual() == nullptr && esseventandstatuszgen_ != nullptr) {
    delete esseventandstatuszgen_;
  }
  esseventandstatuszgen_ = nullptr;
}
inline const ::essmodule::ESSEventAndStatusZGEN& ESSStatusZGEN::esseventandstatuszgen() const {
  const ::essmodule::ESSEventAndStatusZGEN* p = esseventandstatuszgen_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSEventAndStatusZGEN*>(
      &::essmodule::_ESSEventAndStatusZGEN_default_instance_);
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSStatusZGEN::release_esseventandstatuszgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
  
  ::essmodule::ESSEventAndStatusZGEN* temp = esseventandstatuszgen_;
  esseventandstatuszgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSEventAndStatusZGEN* ESSStatusZGEN::mutable_esseventandstatuszgen() {
  
  if (esseventandstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSEventAndStatusZGEN>(GetArenaNoVirtual());
    esseventandstatuszgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
  return esseventandstatuszgen_;
}
inline void ESSStatusZGEN::set_allocated_esseventandstatuszgen(::essmodule::ESSEventAndStatusZGEN* esseventandstatuszgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esseventandstatuszgen_;
  }
  if (esseventandstatuszgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esseventandstatuszgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, esseventandstatuszgen, submessage_arena);
    }
    
  } else {
    
  }
  esseventandstatuszgen_ = esseventandstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusZGEN.eSSEventAndStatusZGEN)
}

// -------------------------------------------------------------------

// ESSStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSStatus::has_statusvalue() const {
  return this != internal_default_instance() && statusvalue_ != nullptr;
}
inline const ::commonmodule::StatusValue& ESSStatus::statusvalue() const {
  const ::commonmodule::StatusValue* p = statusvalue_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatus.statusValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusValue*>(
      &::commonmodule::_StatusValue_default_instance_);
}
inline ::commonmodule::StatusValue* ESSStatus::release_statusvalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = statusvalue_;
  statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* ESSStatus::mutable_statusvalue() {
  
  if (statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaNoVirtual());
    statusvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatus.statusValue)
  return statusvalue_;
}
inline void ESSStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusvalue_);
  }
  if (statusvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }
    
  } else {
    
  }
  statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatus.statusValue)
}

// .essmodule.EssStatusZBAT essStatusZBAT = 2;
inline bool ESSStatus::has_essstatuszbat() const {
  return this != internal_default_instance() && essstatuszbat_ != nullptr;
}
inline void ESSStatus::clear_essstatuszbat() {
  if (GetArenaNoVirtual() == nullptr && essstatuszbat_ != nullptr) {
    delete essstatuszbat_;
  }
  essstatuszbat_ = nullptr;
}
inline const ::essmodule::EssStatusZBAT& ESSStatus::essstatuszbat() const {
  const ::essmodule::EssStatusZBAT* p = essstatuszbat_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatus.essStatusZBAT)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::EssStatusZBAT*>(
      &::essmodule::_EssStatusZBAT_default_instance_);
}
inline ::essmodule::EssStatusZBAT* ESSStatus::release_essstatuszbat() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatus.essStatusZBAT)
  
  ::essmodule::EssStatusZBAT* temp = essstatuszbat_;
  essstatuszbat_ = nullptr;
  return temp;
}
inline ::essmodule::EssStatusZBAT* ESSStatus::mutable_essstatuszbat() {
  
  if (essstatuszbat_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::EssStatusZBAT>(GetArenaNoVirtual());
    essstatuszbat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatus.essStatusZBAT)
  return essstatuszbat_;
}
inline void ESSStatus::set_allocated_essstatuszbat(::essmodule::EssStatusZBAT* essstatuszbat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete essstatuszbat_;
  }
  if (essstatuszbat) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      essstatuszbat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, essstatuszbat, submessage_arena);
    }
    
  } else {
    
  }
  essstatuszbat_ = essstatuszbat;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatus.essStatusZBAT)
}

// .essmodule.ESSStatusZGEN essStatusZGEN = 3;
inline bool ESSStatus::has_essstatuszgen() const {
  return this != internal_default_instance() && essstatuszgen_ != nullptr;
}
inline void ESSStatus::clear_essstatuszgen() {
  if (GetArenaNoVirtual() == nullptr && essstatuszgen_ != nullptr) {
    delete essstatuszgen_;
  }
  essstatuszgen_ = nullptr;
}
inline const ::essmodule::ESSStatusZGEN& ESSStatus::essstatuszgen() const {
  const ::essmodule::ESSStatusZGEN* p = essstatuszgen_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatus.essStatusZGEN)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSStatusZGEN*>(
      &::essmodule::_ESSStatusZGEN_default_instance_);
}
inline ::essmodule::ESSStatusZGEN* ESSStatus::release_essstatuszgen() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatus.essStatusZGEN)
  
  ::essmodule::ESSStatusZGEN* temp = essstatuszgen_;
  essstatuszgen_ = nullptr;
  return temp;
}
inline ::essmodule::ESSStatusZGEN* ESSStatus::mutable_essstatuszgen() {
  
  if (essstatuszgen_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSStatusZGEN>(GetArenaNoVirtual());
    essstatuszgen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatus.essStatusZGEN)
  return essstatuszgen_;
}
inline void ESSStatus::set_allocated_essstatuszgen(::essmodule::ESSStatusZGEN* essstatuszgen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete essstatuszgen_;
  }
  if (essstatuszgen) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      essstatuszgen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, essstatuszgen, submessage_arena);
    }
    
  } else {
    
  }
  essstatuszgen_ = essstatuszgen;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatus.essStatusZGEN)
}

// -------------------------------------------------------------------

// ESSStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSStatusProfile::has_statusmessageinfo() const {
  return this != internal_default_instance() && statusmessageinfo_ != nullptr;
}
inline const ::commonmodule::StatusMessageInfo& ESSStatusProfile::statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = statusmessageinfo_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusProfile.statusMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::StatusMessageInfo*>(
      &::commonmodule::_StatusMessageInfo_default_instance_);
}
inline ::commonmodule::StatusMessageInfo* ESSStatusProfile::release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = statusmessageinfo_;
  statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* ESSStatusProfile::mutable_statusmessageinfo() {
  
  if (statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaNoVirtual());
    statusmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusProfile.statusMessageInfo)
  return statusmessageinfo_;
}
inline void ESSStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusProfile.statusMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSStatusProfile::has_ess() const {
  return this != internal_default_instance() && ess_ != nullptr;
}
inline const ::commonmodule::ESS& ESSStatusProfile::ess() const {
  const ::commonmodule::ESS* p = ess_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusProfile.ess)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ESS*>(
      &::commonmodule::_ESS_default_instance_);
}
inline ::commonmodule::ESS* ESSStatusProfile::release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusProfile.ess)
  
  ::commonmodule::ESS* temp = ess_;
  ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSStatusProfile::mutable_ess() {
  
  if (ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaNoVirtual());
    ess_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusProfile.ess)
  return ess_;
}
inline void ESSStatusProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ess_);
  }
  if (ess) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ess = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }
    
  } else {
    
  }
  ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusProfile.ess)
}

// .essmodule.ESSStatus essStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSStatusProfile::has_essstatus() const {
  return this != internal_default_instance() && essstatus_ != nullptr;
}
inline void ESSStatusProfile::clear_essstatus() {
  if (GetArenaNoVirtual() == nullptr && essstatus_ != nullptr) {
    delete essstatus_;
  }
  essstatus_ = nullptr;
}
inline const ::essmodule::ESSStatus& ESSStatusProfile::essstatus() const {
  const ::essmodule::ESSStatus* p = essstatus_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusProfile.essStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSStatus*>(
      &::essmodule::_ESSStatus_default_instance_);
}
inline ::essmodule::ESSStatus* ESSStatusProfile::release_essstatus() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusProfile.essStatus)
  
  ::essmodule::ESSStatus* temp = essstatus_;
  essstatus_ = nullptr;
  return temp;
}
inline ::essmodule::ESSStatus* ESSStatusProfile::mutable_essstatus() {
  
  if (essstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSStatus>(GetArenaNoVirtual());
    essstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusProfile.essStatus)
  return essstatus_;
}
inline void ESSStatusProfile::set_allocated_essstatus(::essmodule::ESSStatus* essstatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete essstatus_;
  }
  if (essstatus) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      essstatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, essstatus, submessage_arena);
    }
    
  } else {
    
  }
  essstatus_ = essstatus;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusProfile.essStatus)
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSStatusProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& ESSStatusProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:essmodule.ESSStatusProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* ESSStatusProfile::release_ied() {
  // @@protoc_insertion_point(field_release:essmodule.ESSStatusProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* ESSStatusProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSStatusProfile.ied)
  return ied_;
}
inline void ESSStatusProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSStatusProfile.ied)
}

// -------------------------------------------------------------------

// ESSPoint

// .commonmodule.ControlDPC blackStartEnabled = 1;
inline bool ESSPoint::has_blackstartenabled() const {
  return this != internal_default_instance() && blackstartenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::blackstartenabled() const {
  const ::commonmodule::ControlDPC* p = blackstartenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.blackStartEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_blackstartenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.blackStartEnabled)
  
  ::commonmodule::ControlDPC* temp = blackstartenabled_;
  blackstartenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_blackstartenabled() {
  
  if (blackstartenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    blackstartenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.blackStartEnabled)
  return blackstartenabled_;
}
inline void ESSPoint::set_allocated_blackstartenabled(::commonmodule::ControlDPC* blackstartenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(blackstartenabled_);
  }
  if (blackstartenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      blackstartenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blackstartenabled, submessage_arena);
    }
    
  } else {
    
  }
  blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.blackStartEnabled)
}

// .commonmodule.ControlDPC frequencySetPointEnabled = 2;
inline bool ESSPoint::has_frequencysetpointenabled() const {
  return this != internal_default_instance() && frequencysetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::frequencysetpointenabled() const {
  const ::commonmodule::ControlDPC* p = frequencysetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.frequencySetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_frequencysetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.frequencySetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = frequencysetpointenabled_;
  frequencysetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_frequencysetpointenabled() {
  
  if (frequencysetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    frequencysetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.frequencySetPointEnabled)
  return frequencysetpointenabled_;
}
inline void ESSPoint::set_allocated_frequencysetpointenabled(::commonmodule::ControlDPC* frequencysetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(frequencysetpointenabled_);
  }
  if (frequencysetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      frequencysetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frequencysetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.frequencySetPointEnabled)
}

// .essmodule.ESSFunction function = 3;
inline bool ESSPoint::has_function() const {
  return this != internal_default_instance() && function_ != nullptr;
}
inline void ESSPoint::clear_function() {
  if (GetArenaNoVirtual() == nullptr && function_ != nullptr) {
    delete function_;
  }
  function_ = nullptr;
}
inline const ::essmodule::ESSFunction& ESSPoint::function() const {
  const ::essmodule::ESSFunction* p = function_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.function)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSFunction*>(
      &::essmodule::_ESSFunction_default_instance_);
}
inline ::essmodule::ESSFunction* ESSPoint::release_function() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.function)
  
  ::essmodule::ESSFunction* temp = function_;
  function_ = nullptr;
  return temp;
}
inline ::essmodule::ESSFunction* ESSPoint::mutable_function() {
  
  if (function_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSFunction>(GetArenaNoVirtual());
    function_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.function)
  return function_;
}
inline void ESSPoint::set_allocated_function(::essmodule::ESSFunction* function) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete function_;
  }
  if (function) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      function = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    
  } else {
    
  }
  function_ = function;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.function)
}

// .commonmodule.ENG_GridConnectModeKind mode = 4;
inline bool ESSPoint::has_mode() const {
  return this != internal_default_instance() && mode_ != nullptr;
}
inline const ::commonmodule::ENG_GridConnectModeKind& ESSPoint::mode() const {
  const ::commonmodule::ENG_GridConnectModeKind* p = mode_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.mode)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind*>(
      &::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPoint::release_mode() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.mode)
  
  ::commonmodule::ENG_GridConnectModeKind* temp = mode_;
  mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* ESSPoint::mutable_mode() {
  
  if (mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENG_GridConnectModeKind>(GetArenaNoVirtual());
    mode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.mode)
  return mode_;
}
inline void ESSPoint::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* mode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mode_);
  }
  if (mode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mode, submessage_arena);
    }
    
  } else {
    
  }
  mode_ = mode;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.mode)
}

// .google.protobuf.FloatValue pctHzDroop = 5;
inline bool ESSPoint::has_pcthzdroop() const {
  return this != internal_default_instance() && pcthzdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& ESSPoint::pcthzdroop() const {
  const ::google::protobuf::FloatValue* p = pcthzdroop_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.pctHzDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* ESSPoint::release_pcthzdroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.pctHzDroop)
  
  ::google::protobuf::FloatValue* temp = pcthzdroop_;
  pcthzdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ESSPoint::mutable_pcthzdroop() {
  
  if (pcthzdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pcthzdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.pctHzDroop)
  return pcthzdroop_;
}
inline void ESSPoint::set_allocated_pcthzdroop(::google::protobuf::FloatValue* pcthzdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pcthzdroop_);
  }
  if (pcthzdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pcthzdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pcthzdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pcthzdroop, submessage_arena);
    }
    
  } else {
    
  }
  pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.pctHzDroop)
}

// .google.protobuf.FloatValue pctVDroop = 6;
inline bool ESSPoint::has_pctvdroop() const {
  return this != internal_default_instance() && pctvdroop_ != nullptr;
}
inline const ::google::protobuf::FloatValue& ESSPoint::pctvdroop() const {
  const ::google::protobuf::FloatValue* p = pctvdroop_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.pctVDroop)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* ESSPoint::release_pctvdroop() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.pctVDroop)
  
  ::google::protobuf::FloatValue* temp = pctvdroop_;
  pctvdroop_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* ESSPoint::mutable_pctvdroop() {
  
  if (pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    pctvdroop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.pctVDroop)
  return pctvdroop_;
}
inline void ESSPoint::set_allocated_pctvdroop(::google::protobuf::FloatValue* pctvdroop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pctvdroop_);
  }
  if (pctvdroop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pctvdroop)->GetArena();
    if (message_arena != submessage_arena) {
      pctvdroop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }
    
  } else {
    
  }
  pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.pctVDroop)
}

// .commonmodule.RampRate rampRates = 7;
inline bool ESSPoint::has_ramprates() const {
  return this != internal_default_instance() && ramprates_ != nullptr;
}
inline const ::commonmodule::RampRate& ESSPoint::ramprates() const {
  const ::commonmodule::RampRate* p = ramprates_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.rampRates)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::RampRate*>(
      &::commonmodule::_RampRate_default_instance_);
}
inline ::commonmodule::RampRate* ESSPoint::release_ramprates() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.rampRates)
  
  ::commonmodule::RampRate* temp = ramprates_;
  ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* ESSPoint::mutable_ramprates() {
  
  if (ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaNoVirtual());
    ramprates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.rampRates)
  return ramprates_;
}
inline void ESSPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ramprates_);
  }
  if (ramprates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ramprates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }
    
  } else {
    
  }
  ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.rampRates)
}

// .commonmodule.ControlDPC reactivePwrSetPointEnabled = 8;
inline bool ESSPoint::has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && reactivepwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::reactivepwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = reactivepwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.reactivePwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.reactivePwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = reactivepwrsetpointenabled_;
  reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_reactivepwrsetpointenabled() {
  
  if (reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reactivepwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.reactivePwrSetPointEnabled)
  return reactivepwrsetpointenabled_;
}
inline void ESSPoint::set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlDPC* reactivepwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.reactivePwrSetPointEnabled)
}

// .commonmodule.ControlDPC realPwrSetPointEnabled = 9;
inline bool ESSPoint::has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && realpwrsetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::realpwrsetpointenabled() const {
  const ::commonmodule::ControlDPC* p = realpwrsetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.realPwrSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.realPwrSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = realpwrsetpointenabled_;
  realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_realpwrsetpointenabled() {
  
  if (realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    realpwrsetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.realPwrSetPointEnabled)
  return realpwrsetpointenabled_;
}
inline void ESSPoint::set_allocated_realpwrsetpointenabled(::commonmodule::ControlDPC* realpwrsetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.realPwrSetPointEnabled)
}

// .commonmodule.ControlDPC reset = 10;
inline bool ESSPoint::has_reset() const {
  return this != internal_default_instance() && reset_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::reset() const {
  const ::commonmodule::ControlDPC* p = reset_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.reset)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_reset() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.reset)
  
  ::commonmodule::ControlDPC* temp = reset_;
  reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_reset() {
  
  if (reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    reset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.reset)
  return reset_;
}
inline void ESSPoint::set_allocated_reset(::commonmodule::ControlDPC* reset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reset_);
  }
  if (reset) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }
    
  } else {
    
  }
  reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.reset)
}

// .commonmodule.Optional_StateKind state = 11;
inline bool ESSPoint::has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline const ::commonmodule::Optional_StateKind& ESSPoint::state() const {
  const ::commonmodule::Optional_StateKind* p = state_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.state)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::Optional_StateKind*>(
      &::commonmodule::_Optional_StateKind_default_instance_);
}
inline ::commonmodule::Optional_StateKind* ESSPoint::release_state() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.state)
  
  ::commonmodule::Optional_StateKind* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* ESSPoint::mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.state)
  return state_;
}
inline void ESSPoint::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.state)
}

// .commonmodule.ControlDPC syncBackToGrid = 12;
inline bool ESSPoint::has_syncbacktogrid() const {
  return this != internal_default_instance() && syncbacktogrid_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::syncbacktogrid() const {
  const ::commonmodule::ControlDPC* p = syncbacktogrid_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.syncBackToGrid)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_syncbacktogrid() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.syncBackToGrid)
  
  ::commonmodule::ControlDPC* temp = syncbacktogrid_;
  syncbacktogrid_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_syncbacktogrid() {
  
  if (syncbacktogrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    syncbacktogrid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.syncBackToGrid)
  return syncbacktogrid_;
}
inline void ESSPoint::set_allocated_syncbacktogrid(::commonmodule::ControlDPC* syncbacktogrid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(syncbacktogrid_);
  }
  if (syncbacktogrid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      syncbacktogrid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, syncbacktogrid, submessage_arena);
    }
    
  } else {
    
  }
  syncbacktogrid_ = syncbacktogrid;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.syncBackToGrid)
}

// .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 13;
inline bool ESSPoint::has_transtoislndongridlossenabled() const {
  return this != internal_default_instance() && transtoislndongridlossenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::transtoislndongridlossenabled() const {
  const ::commonmodule::ControlDPC* p = transtoislndongridlossenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_transtoislndongridlossenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
  
  ::commonmodule::ControlDPC* temp = transtoislndongridlossenabled_;
  transtoislndongridlossenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_transtoislndongridlossenabled() {
  
  if (transtoislndongridlossenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    transtoislndongridlossenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
  return transtoislndongridlossenabled_;
}
inline void ESSPoint::set_allocated_transtoislndongridlossenabled(::commonmodule::ControlDPC* transtoislndongridlossenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transtoislndongridlossenabled_);
  }
  if (transtoislndongridlossenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transtoislndongridlossenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transtoislndongridlossenabled, submessage_arena);
    }
    
  } else {
    
  }
  transtoislndongridlossenabled_ = transtoislndongridlossenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.transToIslndOnGridLossEnabled)
}

// .commonmodule.ControlDPC voltageSetPointEnabled = 14;
inline bool ESSPoint::has_voltagesetpointenabled() const {
  return this != internal_default_instance() && voltagesetpointenabled_ != nullptr;
}
inline const ::commonmodule::ControlDPC& ESSPoint::voltagesetpointenabled() const {
  const ::commonmodule::ControlDPC* p = voltagesetpointenabled_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.voltageSetPointEnabled)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlDPC*>(
      &::commonmodule::_ControlDPC_default_instance_);
}
inline ::commonmodule::ControlDPC* ESSPoint::release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.voltageSetPointEnabled)
  
  ::commonmodule::ControlDPC* temp = voltagesetpointenabled_;
  voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlDPC* ESSPoint::mutable_voltagesetpointenabled() {
  
  if (voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlDPC>(GetArenaNoVirtual());
    voltagesetpointenabled_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.voltageSetPointEnabled)
  return voltagesetpointenabled_;
}
inline void ESSPoint::set_allocated_voltagesetpointenabled(::commonmodule::ControlDPC* voltagesetpointenabled) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }
    
  } else {
    
  }
  voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.voltageSetPointEnabled)
}

// .commonmodule.ControlTimestamp startTime = 15 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSPoint::has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline const ::commonmodule::ControlTimestamp& ESSPoint::starttime() const {
  const ::commonmodule::ControlTimestamp* p = starttime_;
  // @@protoc_insertion_point(field_get:essmodule.ESSPoint.startTime)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlTimestamp*>(
      &::commonmodule::_ControlTimestamp_default_instance_);
}
inline ::commonmodule::ControlTimestamp* ESSPoint::release_starttime() {
  // @@protoc_insertion_point(field_release:essmodule.ESSPoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* ESSPoint::mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaNoVirtual());
    starttime_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSPoint.startTime)
  return starttime_;
}
inline void ESSPoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starttime = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSPoint.startTime)
}

// -------------------------------------------------------------------

// ESSCSG

// repeated .essmodule.ESSPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int ESSCSG::crvpts_size() const {
  return crvpts_.size();
}
inline void ESSCSG::clear_crvpts() {
  crvpts_.Clear();
}
inline ::essmodule::ESSPoint* ESSCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:essmodule.ESSCSG.crvPts)
  return crvpts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::essmodule::ESSPoint >*
ESSCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:essmodule.ESSCSG.crvPts)
  return &crvpts_;
}
inline const ::essmodule::ESSPoint& ESSCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:essmodule.ESSCSG.crvPts)
  return crvpts_.Get(index);
}
inline ::essmodule::ESSPoint* ESSCSG::add_crvpts() {
  // @@protoc_insertion_point(field_add:essmodule.ESSCSG.crvPts)
  return crvpts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::essmodule::ESSPoint >&
ESSCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:essmodule.ESSCSG.crvPts)
  return crvpts_;
}

// -------------------------------------------------------------------

// ESSControlScheduleFSCH

// .essmodule.ESSCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControlScheduleFSCH::has_valdcsg() const {
  return this != internal_default_instance() && valdcsg_ != nullptr;
}
inline void ESSControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaNoVirtual() == nullptr && valdcsg_ != nullptr) {
    delete valdcsg_;
  }
  valdcsg_ = nullptr;
}
inline const ::essmodule::ESSCSG& ESSControlScheduleFSCH::valdcsg() const {
  const ::essmodule::ESSCSG* p = valdcsg_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControlScheduleFSCH.ValDCSG)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSCSG*>(
      &::essmodule::_ESSCSG_default_instance_);
}
inline ::essmodule::ESSCSG* ESSControlScheduleFSCH::release_valdcsg() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlScheduleFSCH.ValDCSG)
  
  ::essmodule::ESSCSG* temp = valdcsg_;
  valdcsg_ = nullptr;
  return temp;
}
inline ::essmodule::ESSCSG* ESSControlScheduleFSCH::mutable_valdcsg() {
  
  if (valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSCSG>(GetArenaNoVirtual());
    valdcsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlScheduleFSCH.ValDCSG)
  return valdcsg_;
}
inline void ESSControlScheduleFSCH::set_allocated_valdcsg(::essmodule::ESSCSG* valdcsg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete valdcsg_;
  }
  if (valdcsg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      valdcsg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }
    
  } else {
    
  }
  valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// EssControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool EssControlFSCC::has_controlfscc() const {
  return this != internal_default_instance() && controlfscc_ != nullptr;
}
inline const ::commonmodule::ControlFSCC& EssControlFSCC::controlfscc() const {
  const ::commonmodule::ControlFSCC* p = controlfscc_;
  // @@protoc_insertion_point(field_get:essmodule.EssControlFSCC.controlFSCC)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlFSCC*>(
      &::commonmodule::_ControlFSCC_default_instance_);
}
inline ::commonmodule::ControlFSCC* EssControlFSCC::release_controlfscc() {
  // @@protoc_insertion_point(field_release:essmodule.EssControlFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = controlfscc_;
  controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* EssControlFSCC::mutable_controlfscc() {
  
  if (controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaNoVirtual());
    controlfscc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssControlFSCC.controlFSCC)
  return controlfscc_;
}
inline void EssControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlfscc_);
  }
  if (controlfscc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlfscc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }
    
  } else {
    
  }
  controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssControlFSCC.controlFSCC)
}

// .essmodule.ESSControlScheduleFSCH essControlScheduleFSCH = 2;
inline bool EssControlFSCC::has_esscontrolschedulefsch() const {
  return this != internal_default_instance() && esscontrolschedulefsch_ != nullptr;
}
inline void EssControlFSCC::clear_esscontrolschedulefsch() {
  if (GetArenaNoVirtual() == nullptr && esscontrolschedulefsch_ != nullptr) {
    delete esscontrolschedulefsch_;
  }
  esscontrolschedulefsch_ = nullptr;
}
inline const ::essmodule::ESSControlScheduleFSCH& EssControlFSCC::esscontrolschedulefsch() const {
  const ::essmodule::ESSControlScheduleFSCH* p = esscontrolschedulefsch_;
  // @@protoc_insertion_point(field_get:essmodule.EssControlFSCC.essControlScheduleFSCH)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSControlScheduleFSCH*>(
      &::essmodule::_ESSControlScheduleFSCH_default_instance_);
}
inline ::essmodule::ESSControlScheduleFSCH* EssControlFSCC::release_esscontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:essmodule.EssControlFSCC.essControlScheduleFSCH)
  
  ::essmodule::ESSControlScheduleFSCH* temp = esscontrolschedulefsch_;
  esscontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::essmodule::ESSControlScheduleFSCH* EssControlFSCC::mutable_esscontrolschedulefsch() {
  
  if (esscontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSControlScheduleFSCH>(GetArenaNoVirtual());
    esscontrolschedulefsch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.EssControlFSCC.essControlScheduleFSCH)
  return esscontrolschedulefsch_;
}
inline void EssControlFSCC::set_allocated_esscontrolschedulefsch(::essmodule::ESSControlScheduleFSCH* esscontrolschedulefsch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esscontrolschedulefsch_;
  }
  if (esscontrolschedulefsch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esscontrolschedulefsch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, esscontrolschedulefsch, submessage_arena);
    }
    
  } else {
    
  }
  esscontrolschedulefsch_ = esscontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:essmodule.EssControlFSCC.essControlScheduleFSCH)
}

// -------------------------------------------------------------------

// ESSControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool ESSControl::has_controlvalue() const {
  return this != internal_default_instance() && controlvalue_ != nullptr;
}
inline const ::commonmodule::ControlValue& ESSControl::controlvalue() const {
  const ::commonmodule::ControlValue* p = controlvalue_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControl.controlValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlValue*>(
      &::commonmodule::_ControlValue_default_instance_);
}
inline ::commonmodule::ControlValue* ESSControl::release_controlvalue() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControl.controlValue)
  
  ::commonmodule::ControlValue* temp = controlvalue_;
  controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* ESSControl::mutable_controlvalue() {
  
  if (controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaNoVirtual());
    controlvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControl.controlValue)
  return controlvalue_;
}
inline void ESSControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlvalue_);
  }
  if (controlvalue) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }
    
  } else {
    
  }
  controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool ESSControl::has_check() const {
  return this != internal_default_instance() && check_ != nullptr;
}
inline const ::commonmodule::CheckConditions& ESSControl::check() const {
  const ::commonmodule::CheckConditions* p = check_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControl.check)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::CheckConditions*>(
      &::commonmodule::_CheckConditions_default_instance_);
}
inline ::commonmodule::CheckConditions* ESSControl::release_check() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControl.check)
  
  ::commonmodule::CheckConditions* temp = check_;
  check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* ESSControl::mutable_check() {
  
  if (check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaNoVirtual());
    check_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControl.check)
  return check_;
}
inline void ESSControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(check_);
  }
  if (check) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      check = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  check_ = check;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControl.check)
}

// .essmodule.EssControlFSCC essControlFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControl::has_esscontrolfscc() const {
  return this != internal_default_instance() && esscontrolfscc_ != nullptr;
}
inline void ESSControl::clear_esscontrolfscc() {
  if (GetArenaNoVirtual() == nullptr && esscontrolfscc_ != nullptr) {
    delete esscontrolfscc_;
  }
  esscontrolfscc_ = nullptr;
}
inline const ::essmodule::EssControlFSCC& ESSControl::esscontrolfscc() const {
  const ::essmodule::EssControlFSCC* p = esscontrolfscc_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControl.essControlFSCC)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::EssControlFSCC*>(
      &::essmodule::_EssControlFSCC_default_instance_);
}
inline ::essmodule::EssControlFSCC* ESSControl::release_esscontrolfscc() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControl.essControlFSCC)
  
  ::essmodule::EssControlFSCC* temp = esscontrolfscc_;
  esscontrolfscc_ = nullptr;
  return temp;
}
inline ::essmodule::EssControlFSCC* ESSControl::mutable_esscontrolfscc() {
  
  if (esscontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::EssControlFSCC>(GetArenaNoVirtual());
    esscontrolfscc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControl.essControlFSCC)
  return esscontrolfscc_;
}
inline void ESSControl::set_allocated_esscontrolfscc(::essmodule::EssControlFSCC* esscontrolfscc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esscontrolfscc_;
  }
  if (esscontrolfscc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esscontrolfscc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, esscontrolfscc, submessage_arena);
    }
    
  } else {
    
  }
  esscontrolfscc_ = esscontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControl.essControlFSCC)
}

// -------------------------------------------------------------------

// ESSControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool ESSControlProfile::has_controlmessageinfo() const {
  return this != internal_default_instance() && controlmessageinfo_ != nullptr;
}
inline const ::commonmodule::ControlMessageInfo& ESSControlProfile::controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = controlmessageinfo_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControlProfile.controlMessageInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ControlMessageInfo*>(
      &::commonmodule::_ControlMessageInfo_default_instance_);
}
inline ::commonmodule::ControlMessageInfo* ESSControlProfile::release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = controlmessageinfo_;
  controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* ESSControlProfile::mutable_controlmessageinfo() {
  
  if (controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaNoVirtual());
    controlmessageinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlProfile.controlMessageInfo)
  return controlmessageinfo_;
}
inline void ESSControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }
    
  } else {
    
  }
  controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlProfile.controlMessageInfo)
}

// .commonmodule.ESS ess = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControlProfile::has_ess() const {
  return this != internal_default_instance() && ess_ != nullptr;
}
inline const ::commonmodule::ESS& ESSControlProfile::ess() const {
  const ::commonmodule::ESS* p = ess_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControlProfile.ess)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::ESS*>(
      &::commonmodule::_ESS_default_instance_);
}
inline ::commonmodule::ESS* ESSControlProfile::release_ess() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlProfile.ess)
  
  ::commonmodule::ESS* temp = ess_;
  ess_ = nullptr;
  return temp;
}
inline ::commonmodule::ESS* ESSControlProfile::mutable_ess() {
  
  if (ess_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ESS>(GetArenaNoVirtual());
    ess_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlProfile.ess)
  return ess_;
}
inline void ESSControlProfile::set_allocated_ess(::commonmodule::ESS* ess) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ess_);
  }
  if (ess) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ess = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ess, submessage_arena);
    }
    
  } else {
    
  }
  ess_ = ess;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlProfile.ess)
}

// .essmodule.ESSControl essControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControlProfile::has_esscontrol() const {
  return this != internal_default_instance() && esscontrol_ != nullptr;
}
inline void ESSControlProfile::clear_esscontrol() {
  if (GetArenaNoVirtual() == nullptr && esscontrol_ != nullptr) {
    delete esscontrol_;
  }
  esscontrol_ = nullptr;
}
inline const ::essmodule::ESSControl& ESSControlProfile::esscontrol() const {
  const ::essmodule::ESSControl* p = esscontrol_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControlProfile.essControl)
  return p != nullptr ? *p : *reinterpret_cast<const ::essmodule::ESSControl*>(
      &::essmodule::_ESSControl_default_instance_);
}
inline ::essmodule::ESSControl* ESSControlProfile::release_esscontrol() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlProfile.essControl)
  
  ::essmodule::ESSControl* temp = esscontrol_;
  esscontrol_ = nullptr;
  return temp;
}
inline ::essmodule::ESSControl* ESSControlProfile::mutable_esscontrol() {
  
  if (esscontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::essmodule::ESSControl>(GetArenaNoVirtual());
    esscontrol_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlProfile.essControl)
  return esscontrol_;
}
inline void ESSControlProfile::set_allocated_esscontrol(::essmodule::ESSControl* esscontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete esscontrol_;
  }
  if (esscontrol) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      esscontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, esscontrol, submessage_arena);
    }
    
  } else {
    
  }
  esscontrol_ = esscontrol;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlProfile.essControl)
}

// .commonmodule.IED ied = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool ESSControlProfile::has_ied() const {
  return this != internal_default_instance() && ied_ != nullptr;
}
inline const ::commonmodule::IED& ESSControlProfile::ied() const {
  const ::commonmodule::IED* p = ied_;
  // @@protoc_insertion_point(field_get:essmodule.ESSControlProfile.ied)
  return p != nullptr ? *p : *reinterpret_cast<const ::commonmodule::IED*>(
      &::commonmodule::_IED_default_instance_);
}
inline ::commonmodule::IED* ESSControlProfile::release_ied() {
  // @@protoc_insertion_point(field_release:essmodule.ESSControlProfile.ied)
  
  ::commonmodule::IED* temp = ied_;
  ied_ = nullptr;
  return temp;
}
inline ::commonmodule::IED* ESSControlProfile::mutable_ied() {
  
  if (ied_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IED>(GetArenaNoVirtual());
    ied_ = p;
  }
  // @@protoc_insertion_point(field_mutable:essmodule.ESSControlProfile.ied)
  return ied_;
}
inline void ESSControlProfile::set_allocated_ied(::commonmodule::IED* ied) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ied_);
  }
  if (ied) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ied = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ied, submessage_arena);
    }
    
  } else {
    
  }
  ied_ = ied;
  // @@protoc_insertion_point(field_set_allocated:essmodule.ESSControlProfile.ied)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace essmodule

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_essmodule_2fessmodule_2eproto
