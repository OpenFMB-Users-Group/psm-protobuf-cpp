// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: evsemodule/evsemodule.proto
// Protobuf C++ Version: 6.31.1

#ifndef evsemodule_2fevsemodule_2eproto_2epb_2eh
#define evsemodule_2fevsemodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_evsemodule_2fevsemodule_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_evsemodule_2fevsemodule_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_evsemodule_2fevsemodule_2eproto;
}  // extern "C"
namespace evsemodule {
enum ChargingStateKind : int;
extern const uint32_t ChargingStateKind_internal_data_[];
enum EVACCableCapabilityKind : int;
extern const uint32_t EVACCableCapabilityKind_internal_data_[];
enum EVACConnectionStateKind : int;
extern const uint32_t EVACConnectionStateKind_internal_data_[];
enum EVACPlugStateKind : int;
extern const uint32_t EVACPlugStateKind_internal_data_[];
enum EVConnectionChargingKind : int;
extern const uint32_t EVConnectionChargingKind_internal_data_[];
enum EVDCCableCapabilityKind : int;
extern const uint32_t EVDCCableCapabilityKind_internal_data_[];
enum EVDCConnectionStateAKind : int;
extern const uint32_t EVDCConnectionStateAKind_internal_data_[];
enum EVDCConnectionStateCKind : int;
extern const uint32_t EVDCConnectionStateCKind_internal_data_[];
enum EVDCPlugStateKind : int;
extern const uint32_t EVDCPlugStateKind_internal_data_[];
class CapabilityConfigurationDEAO;
struct CapabilityConfigurationDEAODefaultTypeInternal;
extern CapabilityConfigurationDEAODefaultTypeInternal _CapabilityConfigurationDEAO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CapabilityConfigurationDEAO_class_data_;
class CapabilityConfigurationDEDO;
struct CapabilityConfigurationDEDODefaultTypeInternal;
extern CapabilityConfigurationDEDODefaultTypeInternal _CapabilityConfigurationDEDO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CapabilityConfigurationDEDO_class_data_;
class CapabilityConfigurationDESE;
struct CapabilityConfigurationDESEDefaultTypeInternal;
extern CapabilityConfigurationDESEDefaultTypeInternal _CapabilityConfigurationDESE_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CapabilityConfigurationDESE_class_data_;
class CapabilityRatingsDEAO;
struct CapabilityRatingsDEAODefaultTypeInternal;
extern CapabilityRatingsDEAODefaultTypeInternal _CapabilityRatingsDEAO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsDEAO_class_data_;
class CapabilityRatingsDEDO;
struct CapabilityRatingsDEDODefaultTypeInternal;
extern CapabilityRatingsDEDODefaultTypeInternal _CapabilityRatingsDEDO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsDEDO_class_data_;
class CapabilityRatingsDESE;
struct CapabilityRatingsDESEDefaultTypeInternal;
extern CapabilityRatingsDESEDefaultTypeInternal _CapabilityRatingsDESE_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsDESE_class_data_;
class CapabilityRatingsZCAB;
struct CapabilityRatingsZCABDefaultTypeInternal;
extern CapabilityRatingsZCABDefaultTypeInternal _CapabilityRatingsZCAB_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsZCAB_class_data_;
class ControlDEAO;
struct ControlDEAODefaultTypeInternal;
extern ControlDEAODefaultTypeInternal _ControlDEAO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ControlDEAO_class_data_;
class ControlDEDO;
struct ControlDEDODefaultTypeInternal;
extern ControlDEDODefaultTypeInternal _ControlDEDO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ControlDEDO_class_data_;
class ControlDEEV;
struct ControlDEEVDefaultTypeInternal;
extern ControlDEEVDefaultTypeInternal _ControlDEEV_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ControlDEEV_class_data_;
class ControlDESE;
struct ControlDESEDefaultTypeInternal;
extern ControlDESEDefaultTypeInternal _ControlDESE_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ControlDESE_class_data_;
class DEEVControlScheduleFSCH;
struct DEEVControlScheduleFSCHDefaultTypeInternal;
extern DEEVControlScheduleFSCHDefaultTypeInternal _DEEVControlScheduleFSCH_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DEEVControlScheduleFSCH_class_data_;
class DESEControlScheduleFSCH;
struct DESEControlScheduleFSCHDefaultTypeInternal;
extern DESEControlScheduleFSCHDefaultTypeInternal _DESEControlScheduleFSCH_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DESEControlScheduleFSCH_class_data_;
class DiscreteControlDESE;
struct DiscreteControlDESEDefaultTypeInternal;
extern DiscreteControlDESEDefaultTypeInternal _DiscreteControlDESE_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscreteControlDESE_class_data_;
class ENS_EVACCableCapabilityKind;
struct ENS_EVACCableCapabilityKindDefaultTypeInternal;
extern ENS_EVACCableCapabilityKindDefaultTypeInternal _ENS_EVACCableCapabilityKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVACCableCapabilityKind_class_data_;
class ENS_EVACConnectionStateKind;
struct ENS_EVACConnectionStateKindDefaultTypeInternal;
extern ENS_EVACConnectionStateKindDefaultTypeInternal _ENS_EVACConnectionStateKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVACConnectionStateKind_class_data_;
class ENS_EVACPlugStateKind;
struct ENS_EVACPlugStateKindDefaultTypeInternal;
extern ENS_EVACPlugStateKindDefaultTypeInternal _ENS_EVACPlugStateKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVACPlugStateKind_class_data_;
class ENS_EVConnectionChargingKind;
struct ENS_EVConnectionChargingKindDefaultTypeInternal;
extern ENS_EVConnectionChargingKindDefaultTypeInternal _ENS_EVConnectionChargingKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVConnectionChargingKind_class_data_;
class ENS_EVDCCableCapabilityKind;
struct ENS_EVDCCableCapabilityKindDefaultTypeInternal;
extern ENS_EVDCCableCapabilityKindDefaultTypeInternal _ENS_EVDCCableCapabilityKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCCableCapabilityKind_class_data_;
class ENS_EVDCConnectionStateAKind;
struct ENS_EVDCConnectionStateAKindDefaultTypeInternal;
extern ENS_EVDCConnectionStateAKindDefaultTypeInternal _ENS_EVDCConnectionStateAKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCConnectionStateAKind_class_data_;
class ENS_EVDCConnectionStateCKind;
struct ENS_EVDCConnectionStateCKindDefaultTypeInternal;
extern ENS_EVDCConnectionStateCKindDefaultTypeInternal _ENS_EVDCConnectionStateCKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCConnectionStateCKind_class_data_;
class ENS_EVDCPlugStateKind;
struct ENS_EVDCPlugStateKindDefaultTypeInternal;
extern ENS_EVDCPlugStateKindDefaultTypeInternal _ENS_EVDCPlugStateKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCPlugStateKind_class_data_;
class EVSE;
struct EVSEDefaultTypeInternal;
extern EVSEDefaultTypeInternal _EVSE_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSE_class_data_;
class EVSECSG;
struct EVSECSGDefaultTypeInternal;
extern EVSECSGDefaultTypeInternal _EVSECSG_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSECSG_class_data_;
class EVSECapability;
struct EVSECapabilityDefaultTypeInternal;
extern EVSECapabilityDefaultTypeInternal _EVSECapability_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSECapability_class_data_;
class EVSECapabilityOverride;
struct EVSECapabilityOverrideDefaultTypeInternal;
extern EVSECapabilityOverrideDefaultTypeInternal _EVSECapabilityOverride_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSECapabilityOverride_class_data_;
class EVSECapabilityOverrideProfile;
struct EVSECapabilityOverrideProfileDefaultTypeInternal;
extern EVSECapabilityOverrideProfileDefaultTypeInternal _EVSECapabilityOverrideProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSECapabilityOverrideProfile_class_data_;
class EVSECapabilityProfile;
struct EVSECapabilityProfileDefaultTypeInternal;
extern EVSECapabilityProfileDefaultTypeInternal _EVSECapabilityProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSECapabilityProfile_class_data_;
class EVSEControl;
struct EVSEControlDefaultTypeInternal;
extern EVSEControlDefaultTypeInternal _EVSEControl_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEControl_class_data_;
class EVSEControlProfile;
struct EVSEControlProfileDefaultTypeInternal;
extern EVSEControlProfileDefaultTypeInternal _EVSEControlProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEControlProfile_class_data_;
class EVSECurvePoint;
struct EVSECurvePointDefaultTypeInternal;
extern EVSECurvePointDefaultTypeInternal _EVSECurvePoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSECurvePoint_class_data_;
class EVSEDiscreteControl;
struct EVSEDiscreteControlDefaultTypeInternal;
extern EVSEDiscreteControlDefaultTypeInternal _EVSEDiscreteControl_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEDiscreteControl_class_data_;
class EVSEDiscreteControlProfile;
struct EVSEDiscreteControlProfileDefaultTypeInternal;
extern EVSEDiscreteControlProfileDefaultTypeInternal _EVSEDiscreteControlProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEDiscreteControlProfile_class_data_;
class EVSEEvent;
struct EVSEEventDefaultTypeInternal;
extern EVSEEventDefaultTypeInternal _EVSEEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEEvent_class_data_;
class EVSEEventProfile;
struct EVSEEventProfileDefaultTypeInternal;
extern EVSEEventProfileDefaultTypeInternal _EVSEEventProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEEventProfile_class_data_;
class EVSEFunction;
struct EVSEFunctionDefaultTypeInternal;
extern EVSEFunctionDefaultTypeInternal _EVSEFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEFunction_class_data_;
class EVSEPoint;
struct EVSEPointDefaultTypeInternal;
extern EVSEPointDefaultTypeInternal _EVSEPoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEPoint_class_data_;
class EVSEPointStatus;
struct EVSEPointStatusDefaultTypeInternal;
extern EVSEPointStatusDefaultTypeInternal _EVSEPointStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEPointStatus_class_data_;
class EVSEReading;
struct EVSEReadingDefaultTypeInternal;
extern EVSEReadingDefaultTypeInternal _EVSEReading_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEReading_class_data_;
class EVSEReadingDESE;
struct EVSEReadingDESEDefaultTypeInternal;
extern EVSEReadingDESEDefaultTypeInternal _EVSEReadingDESE_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEReadingDESE_class_data_;
class EVSEReadingProfile;
struct EVSEReadingProfileDefaultTypeInternal;
extern EVSEReadingProfileDefaultTypeInternal _EVSEReadingProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEReadingProfile_class_data_;
class EVSEStatus;
struct EVSEStatusDefaultTypeInternal;
extern EVSEStatusDefaultTypeInternal _EVSEStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEStatus_class_data_;
class EVSEStatusProfile;
struct EVSEStatusProfileDefaultTypeInternal;
extern EVSEStatusProfileDefaultTypeInternal _EVSEStatusProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EVSEStatusProfile_class_data_;
class EventAndStatusDEAO;
struct EventAndStatusDEAODefaultTypeInternal;
extern EventAndStatusDEAODefaultTypeInternal _EventAndStatusDEAO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDEAO_class_data_;
class EventAndStatusDEDO;
struct EventAndStatusDEDODefaultTypeInternal;
extern EventAndStatusDEDODefaultTypeInternal _EventAndStatusDEDO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDEDO_class_data_;
class EventAndStatusDEEV;
struct EventAndStatusDEEVDefaultTypeInternal;
extern EventAndStatusDEEVDefaultTypeInternal _EventAndStatusDEEV_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDEEV_class_data_;
class EventAndStatusDESE;
struct EventAndStatusDESEDefaultTypeInternal;
extern EventAndStatusDESEDefaultTypeInternal _EventAndStatusDESE_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDESE_class_data_;
class Optional_ChargingStateKind;
struct Optional_ChargingStateKindDefaultTypeInternal;
extern Optional_ChargingStateKindDefaultTypeInternal _Optional_ChargingStateKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_ChargingStateKind_class_data_;
class Optional_EVACCableCapabilityKind;
struct Optional_EVACCableCapabilityKindDefaultTypeInternal;
extern Optional_EVACCableCapabilityKindDefaultTypeInternal _Optional_EVACCableCapabilityKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVACCableCapabilityKind_class_data_;
class Optional_EVACConnectionStateKind;
struct Optional_EVACConnectionStateKindDefaultTypeInternal;
extern Optional_EVACConnectionStateKindDefaultTypeInternal _Optional_EVACConnectionStateKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVACConnectionStateKind_class_data_;
class Optional_EVACPlugStateKind;
struct Optional_EVACPlugStateKindDefaultTypeInternal;
extern Optional_EVACPlugStateKindDefaultTypeInternal _Optional_EVACPlugStateKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVACPlugStateKind_class_data_;
class Optional_EVConnectionChargingKind;
struct Optional_EVConnectionChargingKindDefaultTypeInternal;
extern Optional_EVConnectionChargingKindDefaultTypeInternal _Optional_EVConnectionChargingKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVConnectionChargingKind_class_data_;
class Optional_EVDCCableCapabilityKind;
struct Optional_EVDCCableCapabilityKindDefaultTypeInternal;
extern Optional_EVDCCableCapabilityKindDefaultTypeInternal _Optional_EVDCCableCapabilityKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCCableCapabilityKind_class_data_;
class Optional_EVDCConnectionStateAKind;
struct Optional_EVDCConnectionStateAKindDefaultTypeInternal;
extern Optional_EVDCConnectionStateAKindDefaultTypeInternal _Optional_EVDCConnectionStateAKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCConnectionStateAKind_class_data_;
class Optional_EVDCConnectionStateCKind;
struct Optional_EVDCConnectionStateCKindDefaultTypeInternal;
extern Optional_EVDCConnectionStateCKindDefaultTypeInternal _Optional_EVDCConnectionStateCKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCConnectionStateCKind_class_data_;
class Optional_EVDCPlugStateKind;
struct Optional_EVDCPlugStateKindDefaultTypeInternal;
extern Optional_EVDCPlugStateKindDefaultTypeInternal _Optional_EVDCPlugStateKind_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCPlugStateKind_class_data_;
class ReadingDEAO;
struct ReadingDEAODefaultTypeInternal;
extern ReadingDEAODefaultTypeInternal _ReadingDEAO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadingDEAO_class_data_;
class ReadingDEDO;
struct ReadingDEDODefaultTypeInternal;
extern ReadingDEDODefaultTypeInternal _ReadingDEDO_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadingDEDO_class_data_;
class ReadingDEEV;
struct ReadingDEEVDefaultTypeInternal;
extern ReadingDEEVDefaultTypeInternal _ReadingDEEV_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadingDEEV_class_data_;
}  // namespace evsemodule
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::evsemodule::ChargingStateKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::ChargingStateKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVACCableCapabilityKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVACCableCapabilityKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVACConnectionStateKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVACConnectionStateKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVACPlugStateKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVACPlugStateKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVConnectionChargingKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVConnectionChargingKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVDCCableCapabilityKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVDCCableCapabilityKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVDCConnectionStateAKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVDCConnectionStateAKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVDCConnectionStateCKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVDCConnectionStateCKind>;
template <>
internal::EnumTraitsT<::evsemodule::EVDCPlugStateKind_internal_data_>
    internal::EnumTraitsImpl::value<::evsemodule::EVDCPlugStateKind>;
}  // namespace protobuf
}  // namespace google

namespace evsemodule {
enum ChargingStateKind : int {
  ChargingStateKind_UNDEFINED = 0,
  ChargingStateKind_Idle = 1,
  ChargingStateKind_Charging = 2,
  ChargingStateKind_EVConnected = 3,
  ChargingStateKind_SuspendedEV = 4,
  ChargingStateKind_SuspendedEVSE = 5,
  ChargingStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChargingStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChargingStateKind_internal_data_[];
inline constexpr ChargingStateKind ChargingStateKind_MIN =
    static_cast<ChargingStateKind>(0);
inline constexpr ChargingStateKind ChargingStateKind_MAX =
    static_cast<ChargingStateKind>(5);
inline bool ChargingStateKind_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int ChargingStateKind_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChargingStateKind_descriptor();
template <typename T>
const ::std::string& ChargingStateKind_Name(T value) {
  static_assert(::std::is_same<T, ChargingStateKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChargingStateKind_Name().");
  return ChargingStateKind_Name(static_cast<ChargingStateKind>(value));
}
template <>
inline const ::std::string& ChargingStateKind_Name(ChargingStateKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChargingStateKind_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool ChargingStateKind_Parse(
    ::absl::string_view name, ChargingStateKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChargingStateKind>(ChargingStateKind_descriptor(), name,
                                           value);
}
enum EVACConnectionStateKind : int {
  EVACConnectionStateKind_UNDEFINED = 0,
  EVACConnectionStateKind_StateA = 1,
  EVACConnectionStateKind_StateB = 2,
  EVACConnectionStateKind_StateC = 3,
  EVACConnectionStateKind_StateD = 4,
  EVACConnectionStateKind_StateE = 5,
  EVACConnectionStateKind_StateF = 6,
  EVACConnectionStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVACConnectionStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVACConnectionStateKind_internal_data_[];
inline constexpr EVACConnectionStateKind EVACConnectionStateKind_MIN =
    static_cast<EVACConnectionStateKind>(0);
inline constexpr EVACConnectionStateKind EVACConnectionStateKind_MAX =
    static_cast<EVACConnectionStateKind>(6);
inline bool EVACConnectionStateKind_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int EVACConnectionStateKind_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVACConnectionStateKind_descriptor();
template <typename T>
const ::std::string& EVACConnectionStateKind_Name(T value) {
  static_assert(::std::is_same<T, EVACConnectionStateKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVACConnectionStateKind_Name().");
  return EVACConnectionStateKind_Name(static_cast<EVACConnectionStateKind>(value));
}
template <>
inline const ::std::string& EVACConnectionStateKind_Name(EVACConnectionStateKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVACConnectionStateKind_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool EVACConnectionStateKind_Parse(
    ::absl::string_view name, EVACConnectionStateKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVACConnectionStateKind>(EVACConnectionStateKind_descriptor(), name,
                                           value);
}
enum EVACPlugStateKind : int {
  EVACPlugStateKind_UNDEFINED = 0,
  EVACPlugStateKind_Disconnected = 1,
  EVACPlugStateKind_ConnectedandUnlocked = 2,
  EVACPlugStateKind_ConnectedandLocked = 3,
  EVACPlugStateKind_Connected = 4,
  EVACPlugStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVACPlugStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVACPlugStateKind_internal_data_[];
inline constexpr EVACPlugStateKind EVACPlugStateKind_MIN =
    static_cast<EVACPlugStateKind>(0);
inline constexpr EVACPlugStateKind EVACPlugStateKind_MAX =
    static_cast<EVACPlugStateKind>(4);
inline bool EVACPlugStateKind_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int EVACPlugStateKind_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVACPlugStateKind_descriptor();
template <typename T>
const ::std::string& EVACPlugStateKind_Name(T value) {
  static_assert(::std::is_same<T, EVACPlugStateKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVACPlugStateKind_Name().");
  return EVACPlugStateKind_Name(static_cast<EVACPlugStateKind>(value));
}
template <>
inline const ::std::string& EVACPlugStateKind_Name(EVACPlugStateKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVACPlugStateKind_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool EVACPlugStateKind_Parse(
    ::absl::string_view name, EVACPlugStateKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVACPlugStateKind>(EVACPlugStateKind_descriptor(), name,
                                           value);
}
enum EVACCableCapabilityKind : int {
  EVACCableCapabilityKind_UNDEFINED = 0,
  EVACCableCapabilityKind_13A = 1,
  EVACCableCapabilityKind_20A = 2,
  EVACCableCapabilityKind_32A = 3,
  EVACCableCapabilityKind_63to70A = 4,
  EVACCableCapabilityKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVACCableCapabilityKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVACCableCapabilityKind_internal_data_[];
inline constexpr EVACCableCapabilityKind EVACCableCapabilityKind_MIN =
    static_cast<EVACCableCapabilityKind>(0);
inline constexpr EVACCableCapabilityKind EVACCableCapabilityKind_MAX =
    static_cast<EVACCableCapabilityKind>(4);
inline bool EVACCableCapabilityKind_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int EVACCableCapabilityKind_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVACCableCapabilityKind_descriptor();
template <typename T>
const ::std::string& EVACCableCapabilityKind_Name(T value) {
  static_assert(::std::is_same<T, EVACCableCapabilityKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVACCableCapabilityKind_Name().");
  return EVACCableCapabilityKind_Name(static_cast<EVACCableCapabilityKind>(value));
}
template <>
inline const ::std::string& EVACCableCapabilityKind_Name(EVACCableCapabilityKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVACCableCapabilityKind_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool EVACCableCapabilityKind_Parse(
    ::absl::string_view name, EVACCableCapabilityKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVACCableCapabilityKind>(EVACCableCapabilityKind_descriptor(), name,
                                           value);
}
enum EVConnectionChargingKind : int {
  EVConnectionChargingKind_UNDEFINED = 0,
  EVConnectionChargingKind_SinglePhase = 1,
  EVConnectionChargingKind_ThreePhase = 2,
  EVConnectionChargingKind_SystemA = 3,
  EVConnectionChargingKind_SystemB = 4,
  EVConnectionChargingKind_SystemC = 5,
  EVConnectionChargingKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVConnectionChargingKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVConnectionChargingKind_internal_data_[];
inline constexpr EVConnectionChargingKind EVConnectionChargingKind_MIN =
    static_cast<EVConnectionChargingKind>(0);
inline constexpr EVConnectionChargingKind EVConnectionChargingKind_MAX =
    static_cast<EVConnectionChargingKind>(5);
inline bool EVConnectionChargingKind_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int EVConnectionChargingKind_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVConnectionChargingKind_descriptor();
template <typename T>
const ::std::string& EVConnectionChargingKind_Name(T value) {
  static_assert(::std::is_same<T, EVConnectionChargingKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVConnectionChargingKind_Name().");
  return EVConnectionChargingKind_Name(static_cast<EVConnectionChargingKind>(value));
}
template <>
inline const ::std::string& EVConnectionChargingKind_Name(EVConnectionChargingKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVConnectionChargingKind_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool EVConnectionChargingKind_Parse(
    ::absl::string_view name, EVConnectionChargingKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVConnectionChargingKind>(EVConnectionChargingKind_descriptor(), name,
                                           value);
}
enum EVDCCableCapabilityKind : int {
  EVDCCableCapabilityKind_UNDEFINED = 0,
  EVDCCableCapabilityKind_13A = 1,
  EVDCCableCapabilityKind_16to20A = 2,
  EVDCCableCapabilityKind_30to32A = 3,
  EVDCCableCapabilityKind_60to63A = 4,
  EVDCCableCapabilityKind_70A = 5,
  EVDCCableCapabilityKind_80A = 6,
  EVDCCableCapabilityKind_125A = 7,
  EVDCCableCapabilityKind_200A = 8,
  EVDCCableCapabilityKind_250A = 9,
  EVDCCableCapabilityKind_400A = 10,
  EVDCCableCapabilityKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVDCCableCapabilityKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVDCCableCapabilityKind_internal_data_[];
inline constexpr EVDCCableCapabilityKind EVDCCableCapabilityKind_MIN =
    static_cast<EVDCCableCapabilityKind>(0);
inline constexpr EVDCCableCapabilityKind EVDCCableCapabilityKind_MAX =
    static_cast<EVDCCableCapabilityKind>(10);
inline bool EVDCCableCapabilityKind_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int EVDCCableCapabilityKind_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVDCCableCapabilityKind_descriptor();
template <typename T>
const ::std::string& EVDCCableCapabilityKind_Name(T value) {
  static_assert(::std::is_same<T, EVDCCableCapabilityKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVDCCableCapabilityKind_Name().");
  return EVDCCableCapabilityKind_Name(static_cast<EVDCCableCapabilityKind>(value));
}
template <>
inline const ::std::string& EVDCCableCapabilityKind_Name(EVDCCableCapabilityKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVDCCableCapabilityKind_descriptor, 0, 10>(
      static_cast<int>(value));
}
inline bool EVDCCableCapabilityKind_Parse(
    ::absl::string_view name, EVDCCableCapabilityKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVDCCableCapabilityKind>(EVDCCableCapabilityKind_descriptor(), name,
                                           value);
}
enum EVDCConnectionStateAKind : int {
  EVDCConnectionStateAKind_UNDEFINED = 0,
  EVDCConnectionStateAKind_DC_A = 1,
  EVDCConnectionStateAKind_DC_B1 = 2,
  EVDCConnectionStateAKind_DC_B2 = 3,
  EVDCConnectionStateAKind_DC_B3 = 4,
  EVDCConnectionStateAKind_DC_C = 5,
  EVDCConnectionStateAKind_DC_D = 6,
  EVDCConnectionStateAKind_DC_B_S1 = 7,
  EVDCConnectionStateAKind_DC_B_S2 = 8,
  EVDCConnectionStateAKind_DC_B_S3 = 9,
  EVDCConnectionStateAKind_DC_B_S4 = 10,
  EVDCConnectionStateAKind_DC_E = 11,
  EVDCConnectionStateAKind_DC_F = 12,
  EVDCConnectionStateAKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVDCConnectionStateAKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVDCConnectionStateAKind_internal_data_[];
inline constexpr EVDCConnectionStateAKind EVDCConnectionStateAKind_MIN =
    static_cast<EVDCConnectionStateAKind>(0);
inline constexpr EVDCConnectionStateAKind EVDCConnectionStateAKind_MAX =
    static_cast<EVDCConnectionStateAKind>(12);
inline bool EVDCConnectionStateAKind_IsValid(int value) {
  return 0 <= value && value <= 12;
}
inline constexpr int EVDCConnectionStateAKind_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVDCConnectionStateAKind_descriptor();
template <typename T>
const ::std::string& EVDCConnectionStateAKind_Name(T value) {
  static_assert(::std::is_same<T, EVDCConnectionStateAKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVDCConnectionStateAKind_Name().");
  return EVDCConnectionStateAKind_Name(static_cast<EVDCConnectionStateAKind>(value));
}
template <>
inline const ::std::string& EVDCConnectionStateAKind_Name(EVDCConnectionStateAKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVDCConnectionStateAKind_descriptor, 0, 12>(
      static_cast<int>(value));
}
inline bool EVDCConnectionStateAKind_Parse(
    ::absl::string_view name, EVDCConnectionStateAKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVDCConnectionStateAKind>(EVDCConnectionStateAKind_descriptor(), name,
                                           value);
}
enum EVDCConnectionStateCKind : int {
  EVDCConnectionStateCKind_UNDEFINED = 0,
  EVDCConnectionStateCKind_StateA = 1,
  EVDCConnectionStateCKind_StateB = 2,
  EVDCConnectionStateCKind_StateC = 3,
  EVDCConnectionStateCKind_StateD = 4,
  EVDCConnectionStateCKind_StateE = 5,
  EVDCConnectionStateCKind_StateF = 6,
  EVDCConnectionStateCKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVDCConnectionStateCKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVDCConnectionStateCKind_internal_data_[];
inline constexpr EVDCConnectionStateCKind EVDCConnectionStateCKind_MIN =
    static_cast<EVDCConnectionStateCKind>(0);
inline constexpr EVDCConnectionStateCKind EVDCConnectionStateCKind_MAX =
    static_cast<EVDCConnectionStateCKind>(6);
inline bool EVDCConnectionStateCKind_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int EVDCConnectionStateCKind_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVDCConnectionStateCKind_descriptor();
template <typename T>
const ::std::string& EVDCConnectionStateCKind_Name(T value) {
  static_assert(::std::is_same<T, EVDCConnectionStateCKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVDCConnectionStateCKind_Name().");
  return EVDCConnectionStateCKind_Name(static_cast<EVDCConnectionStateCKind>(value));
}
template <>
inline const ::std::string& EVDCConnectionStateCKind_Name(EVDCConnectionStateCKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVDCConnectionStateCKind_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool EVDCConnectionStateCKind_Parse(
    ::absl::string_view name, EVDCConnectionStateCKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVDCConnectionStateCKind>(EVDCConnectionStateCKind_descriptor(), name,
                                           value);
}
enum EVDCPlugStateKind : int {
  EVDCPlugStateKind_UNDEFINED = 0,
  EVDCPlugStateKind_Disconnected = 1,
  EVDCPlugStateKind_ConnectedandUnlocked = 2,
  EVDCPlugStateKind_ConnectedandLocked = 3,
  EVDCPlugStateKind_Connected = 4,
  EVDCPlugStateKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EVDCPlugStateKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EVDCPlugStateKind_internal_data_[];
inline constexpr EVDCPlugStateKind EVDCPlugStateKind_MIN =
    static_cast<EVDCPlugStateKind>(0);
inline constexpr EVDCPlugStateKind EVDCPlugStateKind_MAX =
    static_cast<EVDCPlugStateKind>(4);
inline bool EVDCPlugStateKind_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int EVDCPlugStateKind_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EVDCPlugStateKind_descriptor();
template <typename T>
const ::std::string& EVDCPlugStateKind_Name(T value) {
  static_assert(::std::is_same<T, EVDCPlugStateKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EVDCPlugStateKind_Name().");
  return EVDCPlugStateKind_Name(static_cast<EVDCPlugStateKind>(value));
}
template <>
inline const ::std::string& EVDCPlugStateKind_Name(EVDCPlugStateKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EVDCPlugStateKind_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool EVDCPlugStateKind_Parse(
    ::absl::string_view name, EVDCPlugStateKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVDCPlugStateKind>(EVDCPlugStateKind_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class Optional_EVDCPlugStateKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVDCPlugStateKind) */ {
 public:
  inline Optional_EVDCPlugStateKind() : Optional_EVDCPlugStateKind(nullptr) {}
  ~Optional_EVDCPlugStateKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVDCPlugStateKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVDCPlugStateKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVDCPlugStateKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVDCPlugStateKind(const Optional_EVDCPlugStateKind& from) : Optional_EVDCPlugStateKind(nullptr, from) {}
  inline Optional_EVDCPlugStateKind(Optional_EVDCPlugStateKind&& from) noexcept
      : Optional_EVDCPlugStateKind(nullptr, ::std::move(from)) {}
  inline Optional_EVDCPlugStateKind& operator=(const Optional_EVDCPlugStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVDCPlugStateKind& operator=(Optional_EVDCPlugStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVDCPlugStateKind& default_instance() {
    return *reinterpret_cast<const Optional_EVDCPlugStateKind*>(
        &_Optional_EVDCPlugStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(Optional_EVDCPlugStateKind& a, Optional_EVDCPlugStateKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVDCPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVDCPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVDCPlugStateKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVDCPlugStateKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVDCPlugStateKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVDCPlugStateKind& from) { Optional_EVDCPlugStateKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVDCPlugStateKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVDCPlugStateKind"; }

 protected:
  explicit Optional_EVDCPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVDCPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVDCPlugStateKind& from);
  Optional_EVDCPlugStateKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVDCPlugStateKind&& from) noexcept
      : Optional_EVDCPlugStateKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVDCPlugStateKind value = 1;
  void clear_value() ;
  ::evsemodule::EVDCPlugStateKind value() const;
  void set_value(::evsemodule::EVDCPlugStateKind value);

  private:
  ::evsemodule::EVDCPlugStateKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVDCPlugStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVDCPlugStateKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVDCPlugStateKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCPlugStateKind_class_data_;
// -------------------------------------------------------------------

class Optional_EVDCConnectionStateCKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVDCConnectionStateCKind) */ {
 public:
  inline Optional_EVDCConnectionStateCKind() : Optional_EVDCConnectionStateCKind(nullptr) {}
  ~Optional_EVDCConnectionStateCKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVDCConnectionStateCKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVDCConnectionStateCKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVDCConnectionStateCKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVDCConnectionStateCKind(const Optional_EVDCConnectionStateCKind& from) : Optional_EVDCConnectionStateCKind(nullptr, from) {}
  inline Optional_EVDCConnectionStateCKind(Optional_EVDCConnectionStateCKind&& from) noexcept
      : Optional_EVDCConnectionStateCKind(nullptr, ::std::move(from)) {}
  inline Optional_EVDCConnectionStateCKind& operator=(const Optional_EVDCConnectionStateCKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVDCConnectionStateCKind& operator=(Optional_EVDCConnectionStateCKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVDCConnectionStateCKind& default_instance() {
    return *reinterpret_cast<const Optional_EVDCConnectionStateCKind*>(
        &_Optional_EVDCConnectionStateCKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(Optional_EVDCConnectionStateCKind& a, Optional_EVDCConnectionStateCKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVDCConnectionStateCKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVDCConnectionStateCKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVDCConnectionStateCKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVDCConnectionStateCKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVDCConnectionStateCKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVDCConnectionStateCKind& from) { Optional_EVDCConnectionStateCKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVDCConnectionStateCKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVDCConnectionStateCKind"; }

 protected:
  explicit Optional_EVDCConnectionStateCKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVDCConnectionStateCKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVDCConnectionStateCKind& from);
  Optional_EVDCConnectionStateCKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVDCConnectionStateCKind&& from) noexcept
      : Optional_EVDCConnectionStateCKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVDCConnectionStateCKind value = 1;
  void clear_value() ;
  ::evsemodule::EVDCConnectionStateCKind value() const;
  void set_value(::evsemodule::EVDCConnectionStateCKind value);

  private:
  ::evsemodule::EVDCConnectionStateCKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVDCConnectionStateCKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVDCConnectionStateCKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVDCConnectionStateCKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCConnectionStateCKind_class_data_;
// -------------------------------------------------------------------

class Optional_EVDCConnectionStateAKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVDCConnectionStateAKind) */ {
 public:
  inline Optional_EVDCConnectionStateAKind() : Optional_EVDCConnectionStateAKind(nullptr) {}
  ~Optional_EVDCConnectionStateAKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVDCConnectionStateAKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVDCConnectionStateAKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVDCConnectionStateAKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVDCConnectionStateAKind(const Optional_EVDCConnectionStateAKind& from) : Optional_EVDCConnectionStateAKind(nullptr, from) {}
  inline Optional_EVDCConnectionStateAKind(Optional_EVDCConnectionStateAKind&& from) noexcept
      : Optional_EVDCConnectionStateAKind(nullptr, ::std::move(from)) {}
  inline Optional_EVDCConnectionStateAKind& operator=(const Optional_EVDCConnectionStateAKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVDCConnectionStateAKind& operator=(Optional_EVDCConnectionStateAKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVDCConnectionStateAKind& default_instance() {
    return *reinterpret_cast<const Optional_EVDCConnectionStateAKind*>(
        &_Optional_EVDCConnectionStateAKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(Optional_EVDCConnectionStateAKind& a, Optional_EVDCConnectionStateAKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVDCConnectionStateAKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVDCConnectionStateAKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVDCConnectionStateAKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVDCConnectionStateAKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVDCConnectionStateAKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVDCConnectionStateAKind& from) { Optional_EVDCConnectionStateAKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVDCConnectionStateAKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVDCConnectionStateAKind"; }

 protected:
  explicit Optional_EVDCConnectionStateAKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVDCConnectionStateAKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVDCConnectionStateAKind& from);
  Optional_EVDCConnectionStateAKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVDCConnectionStateAKind&& from) noexcept
      : Optional_EVDCConnectionStateAKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVDCConnectionStateAKind value = 1;
  void clear_value() ;
  ::evsemodule::EVDCConnectionStateAKind value() const;
  void set_value(::evsemodule::EVDCConnectionStateAKind value);

  private:
  ::evsemodule::EVDCConnectionStateAKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVDCConnectionStateAKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVDCConnectionStateAKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVDCConnectionStateAKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCConnectionStateAKind_class_data_;
// -------------------------------------------------------------------

class Optional_EVDCCableCapabilityKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVDCCableCapabilityKind) */ {
 public:
  inline Optional_EVDCCableCapabilityKind() : Optional_EVDCCableCapabilityKind(nullptr) {}
  ~Optional_EVDCCableCapabilityKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVDCCableCapabilityKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVDCCableCapabilityKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVDCCableCapabilityKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVDCCableCapabilityKind(const Optional_EVDCCableCapabilityKind& from) : Optional_EVDCCableCapabilityKind(nullptr, from) {}
  inline Optional_EVDCCableCapabilityKind(Optional_EVDCCableCapabilityKind&& from) noexcept
      : Optional_EVDCCableCapabilityKind(nullptr, ::std::move(from)) {}
  inline Optional_EVDCCableCapabilityKind& operator=(const Optional_EVDCCableCapabilityKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVDCCableCapabilityKind& operator=(Optional_EVDCCableCapabilityKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVDCCableCapabilityKind& default_instance() {
    return *reinterpret_cast<const Optional_EVDCCableCapabilityKind*>(
        &_Optional_EVDCCableCapabilityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(Optional_EVDCCableCapabilityKind& a, Optional_EVDCCableCapabilityKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVDCCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVDCCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVDCCableCapabilityKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVDCCableCapabilityKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVDCCableCapabilityKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVDCCableCapabilityKind& from) { Optional_EVDCCableCapabilityKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVDCCableCapabilityKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVDCCableCapabilityKind"; }

 protected:
  explicit Optional_EVDCCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVDCCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVDCCableCapabilityKind& from);
  Optional_EVDCCableCapabilityKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVDCCableCapabilityKind&& from) noexcept
      : Optional_EVDCCableCapabilityKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVDCCableCapabilityKind value = 1;
  void clear_value() ;
  ::evsemodule::EVDCCableCapabilityKind value() const;
  void set_value(::evsemodule::EVDCCableCapabilityKind value);

  private:
  ::evsemodule::EVDCCableCapabilityKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVDCCableCapabilityKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVDCCableCapabilityKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVDCCableCapabilityKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVDCCableCapabilityKind_class_data_;
// -------------------------------------------------------------------

class Optional_EVConnectionChargingKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVConnectionChargingKind) */ {
 public:
  inline Optional_EVConnectionChargingKind() : Optional_EVConnectionChargingKind(nullptr) {}
  ~Optional_EVConnectionChargingKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVConnectionChargingKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVConnectionChargingKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVConnectionChargingKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVConnectionChargingKind(const Optional_EVConnectionChargingKind& from) : Optional_EVConnectionChargingKind(nullptr, from) {}
  inline Optional_EVConnectionChargingKind(Optional_EVConnectionChargingKind&& from) noexcept
      : Optional_EVConnectionChargingKind(nullptr, ::std::move(from)) {}
  inline Optional_EVConnectionChargingKind& operator=(const Optional_EVConnectionChargingKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVConnectionChargingKind& operator=(Optional_EVConnectionChargingKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVConnectionChargingKind& default_instance() {
    return *reinterpret_cast<const Optional_EVConnectionChargingKind*>(
        &_Optional_EVConnectionChargingKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(Optional_EVConnectionChargingKind& a, Optional_EVConnectionChargingKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVConnectionChargingKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVConnectionChargingKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVConnectionChargingKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVConnectionChargingKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVConnectionChargingKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVConnectionChargingKind& from) { Optional_EVConnectionChargingKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVConnectionChargingKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVConnectionChargingKind"; }

 protected:
  explicit Optional_EVConnectionChargingKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVConnectionChargingKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVConnectionChargingKind& from);
  Optional_EVConnectionChargingKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVConnectionChargingKind&& from) noexcept
      : Optional_EVConnectionChargingKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVConnectionChargingKind value = 1;
  void clear_value() ;
  ::evsemodule::EVConnectionChargingKind value() const;
  void set_value(::evsemodule::EVConnectionChargingKind value);

  private:
  ::evsemodule::EVConnectionChargingKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVConnectionChargingKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVConnectionChargingKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVConnectionChargingKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVConnectionChargingKind_class_data_;
// -------------------------------------------------------------------

class Optional_EVACPlugStateKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVACPlugStateKind) */ {
 public:
  inline Optional_EVACPlugStateKind() : Optional_EVACPlugStateKind(nullptr) {}
  ~Optional_EVACPlugStateKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVACPlugStateKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVACPlugStateKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVACPlugStateKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVACPlugStateKind(const Optional_EVACPlugStateKind& from) : Optional_EVACPlugStateKind(nullptr, from) {}
  inline Optional_EVACPlugStateKind(Optional_EVACPlugStateKind&& from) noexcept
      : Optional_EVACPlugStateKind(nullptr, ::std::move(from)) {}
  inline Optional_EVACPlugStateKind& operator=(const Optional_EVACPlugStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVACPlugStateKind& operator=(Optional_EVACPlugStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVACPlugStateKind& default_instance() {
    return *reinterpret_cast<const Optional_EVACPlugStateKind*>(
        &_Optional_EVACPlugStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(Optional_EVACPlugStateKind& a, Optional_EVACPlugStateKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVACPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVACPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVACPlugStateKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVACPlugStateKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVACPlugStateKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVACPlugStateKind& from) { Optional_EVACPlugStateKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVACPlugStateKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVACPlugStateKind"; }

 protected:
  explicit Optional_EVACPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVACPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVACPlugStateKind& from);
  Optional_EVACPlugStateKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVACPlugStateKind&& from) noexcept
      : Optional_EVACPlugStateKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVACPlugStateKind value = 1;
  void clear_value() ;
  ::evsemodule::EVACPlugStateKind value() const;
  void set_value(::evsemodule::EVACPlugStateKind value);

  private:
  ::evsemodule::EVACPlugStateKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVACPlugStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVACPlugStateKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVACPlugStateKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVACPlugStateKind_class_data_;
// -------------------------------------------------------------------

class Optional_EVACConnectionStateKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVACConnectionStateKind) */ {
 public:
  inline Optional_EVACConnectionStateKind() : Optional_EVACConnectionStateKind(nullptr) {}
  ~Optional_EVACConnectionStateKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVACConnectionStateKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVACConnectionStateKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVACConnectionStateKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVACConnectionStateKind(const Optional_EVACConnectionStateKind& from) : Optional_EVACConnectionStateKind(nullptr, from) {}
  inline Optional_EVACConnectionStateKind(Optional_EVACConnectionStateKind&& from) noexcept
      : Optional_EVACConnectionStateKind(nullptr, ::std::move(from)) {}
  inline Optional_EVACConnectionStateKind& operator=(const Optional_EVACConnectionStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVACConnectionStateKind& operator=(Optional_EVACConnectionStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVACConnectionStateKind& default_instance() {
    return *reinterpret_cast<const Optional_EVACConnectionStateKind*>(
        &_Optional_EVACConnectionStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(Optional_EVACConnectionStateKind& a, Optional_EVACConnectionStateKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVACConnectionStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVACConnectionStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVACConnectionStateKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVACConnectionStateKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVACConnectionStateKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVACConnectionStateKind& from) { Optional_EVACConnectionStateKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVACConnectionStateKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVACConnectionStateKind"; }

 protected:
  explicit Optional_EVACConnectionStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVACConnectionStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVACConnectionStateKind& from);
  Optional_EVACConnectionStateKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVACConnectionStateKind&& from) noexcept
      : Optional_EVACConnectionStateKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVACConnectionStateKind value = 1;
  void clear_value() ;
  ::evsemodule::EVACConnectionStateKind value() const;
  void set_value(::evsemodule::EVACConnectionStateKind value);

  private:
  ::evsemodule::EVACConnectionStateKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVACConnectionStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVACConnectionStateKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVACConnectionStateKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVACConnectionStateKind_class_data_;
// -------------------------------------------------------------------

class Optional_EVACCableCapabilityKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_EVACCableCapabilityKind) */ {
 public:
  inline Optional_EVACCableCapabilityKind() : Optional_EVACCableCapabilityKind(nullptr) {}
  ~Optional_EVACCableCapabilityKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_EVACCableCapabilityKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_EVACCableCapabilityKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_EVACCableCapabilityKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_EVACCableCapabilityKind(const Optional_EVACCableCapabilityKind& from) : Optional_EVACCableCapabilityKind(nullptr, from) {}
  inline Optional_EVACCableCapabilityKind(Optional_EVACCableCapabilityKind&& from) noexcept
      : Optional_EVACCableCapabilityKind(nullptr, ::std::move(from)) {}
  inline Optional_EVACCableCapabilityKind& operator=(const Optional_EVACCableCapabilityKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_EVACCableCapabilityKind& operator=(Optional_EVACCableCapabilityKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_EVACCableCapabilityKind& default_instance() {
    return *reinterpret_cast<const Optional_EVACCableCapabilityKind*>(
        &_Optional_EVACCableCapabilityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(Optional_EVACCableCapabilityKind& a, Optional_EVACCableCapabilityKind& b) { a.Swap(&b); }
  inline void Swap(Optional_EVACCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_EVACCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_EVACCableCapabilityKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_EVACCableCapabilityKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_EVACCableCapabilityKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_EVACCableCapabilityKind& from) { Optional_EVACCableCapabilityKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_EVACCableCapabilityKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_EVACCableCapabilityKind"; }

 protected:
  explicit Optional_EVACCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_EVACCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_EVACCableCapabilityKind& from);
  Optional_EVACCableCapabilityKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_EVACCableCapabilityKind&& from) noexcept
      : Optional_EVACCableCapabilityKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.EVACCableCapabilityKind value = 1;
  void clear_value() ;
  ::evsemodule::EVACCableCapabilityKind value() const;
  void set_value(::evsemodule::EVACCableCapabilityKind value);

  private:
  ::evsemodule::EVACCableCapabilityKind _internal_value() const;
  void _internal_set_value(::evsemodule::EVACCableCapabilityKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_EVACCableCapabilityKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_EVACCableCapabilityKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_EVACCableCapabilityKind_class_data_;
// -------------------------------------------------------------------

class Optional_ChargingStateKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.Optional_ChargingStateKind) */ {
 public:
  inline Optional_ChargingStateKind() : Optional_ChargingStateKind(nullptr) {}
  ~Optional_ChargingStateKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Optional_ChargingStateKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Optional_ChargingStateKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Optional_ChargingStateKind(::google::protobuf::internal::ConstantInitialized);

  inline Optional_ChargingStateKind(const Optional_ChargingStateKind& from) : Optional_ChargingStateKind(nullptr, from) {}
  inline Optional_ChargingStateKind(Optional_ChargingStateKind&& from) noexcept
      : Optional_ChargingStateKind(nullptr, ::std::move(from)) {}
  inline Optional_ChargingStateKind& operator=(const Optional_ChargingStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optional_ChargingStateKind& operator=(Optional_ChargingStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optional_ChargingStateKind& default_instance() {
    return *reinterpret_cast<const Optional_ChargingStateKind*>(
        &_Optional_ChargingStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Optional_ChargingStateKind& a, Optional_ChargingStateKind& b) { a.Swap(&b); }
  inline void Swap(Optional_ChargingStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optional_ChargingStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Optional_ChargingStateKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Optional_ChargingStateKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Optional_ChargingStateKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Optional_ChargingStateKind& from) { Optional_ChargingStateKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Optional_ChargingStateKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.Optional_ChargingStateKind"; }

 protected:
  explicit Optional_ChargingStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Optional_ChargingStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Optional_ChargingStateKind& from);
  Optional_ChargingStateKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Optional_ChargingStateKind&& from) noexcept
      : Optional_ChargingStateKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .evsemodule.ChargingStateKind value = 1;
  void clear_value() ;
  ::evsemodule::ChargingStateKind value() const;
  void set_value(::evsemodule::ChargingStateKind value);

  private:
  ::evsemodule::ChargingStateKind _internal_value() const;
  void _internal_set_value(::evsemodule::ChargingStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.Optional_ChargingStateKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Optional_ChargingStateKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Optional_ChargingStateKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVDCPlugStateKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVDCPlugStateKind) */ {
 public:
  inline ENS_EVDCPlugStateKind() : ENS_EVDCPlugStateKind(nullptr) {}
  ~ENS_EVDCPlugStateKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVDCPlugStateKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVDCPlugStateKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVDCPlugStateKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVDCPlugStateKind(const ENS_EVDCPlugStateKind& from) : ENS_EVDCPlugStateKind(nullptr, from) {}
  inline ENS_EVDCPlugStateKind(ENS_EVDCPlugStateKind&& from) noexcept
      : ENS_EVDCPlugStateKind(nullptr, ::std::move(from)) {}
  inline ENS_EVDCPlugStateKind& operator=(const ENS_EVDCPlugStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVDCPlugStateKind& operator=(ENS_EVDCPlugStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVDCPlugStateKind& default_instance() {
    return *reinterpret_cast<const ENS_EVDCPlugStateKind*>(
        &_ENS_EVDCPlugStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(ENS_EVDCPlugStateKind& a, ENS_EVDCPlugStateKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVDCPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVDCPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVDCPlugStateKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVDCPlugStateKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVDCPlugStateKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVDCPlugStateKind& from) { ENS_EVDCPlugStateKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVDCPlugStateKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVDCPlugStateKind"; }

 protected:
  explicit ENS_EVDCPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVDCPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVDCPlugStateKind& from);
  ENS_EVDCPlugStateKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVDCPlugStateKind&& from) noexcept
      : ENS_EVDCPlugStateKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVDCPlugStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVDCPlugStateKind stval() const;
  void set_stval(::evsemodule::EVDCPlugStateKind value);

  private:
  ::evsemodule::EVDCPlugStateKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVDCPlugStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVDCPlugStateKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVDCPlugStateKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCPlugStateKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVDCConnectionStateCKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVDCConnectionStateCKind) */ {
 public:
  inline ENS_EVDCConnectionStateCKind() : ENS_EVDCConnectionStateCKind(nullptr) {}
  ~ENS_EVDCConnectionStateCKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVDCConnectionStateCKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVDCConnectionStateCKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVDCConnectionStateCKind(const ENS_EVDCConnectionStateCKind& from) : ENS_EVDCConnectionStateCKind(nullptr, from) {}
  inline ENS_EVDCConnectionStateCKind(ENS_EVDCConnectionStateCKind&& from) noexcept
      : ENS_EVDCConnectionStateCKind(nullptr, ::std::move(from)) {}
  inline ENS_EVDCConnectionStateCKind& operator=(const ENS_EVDCConnectionStateCKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVDCConnectionStateCKind& operator=(ENS_EVDCConnectionStateCKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVDCConnectionStateCKind& default_instance() {
    return *reinterpret_cast<const ENS_EVDCConnectionStateCKind*>(
        &_ENS_EVDCConnectionStateCKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(ENS_EVDCConnectionStateCKind& a, ENS_EVDCConnectionStateCKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVDCConnectionStateCKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVDCConnectionStateCKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVDCConnectionStateCKind& from) { ENS_EVDCConnectionStateCKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVDCConnectionStateCKind"; }

 protected:
  explicit ENS_EVDCConnectionStateCKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVDCConnectionStateCKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVDCConnectionStateCKind& from);
  ENS_EVDCConnectionStateCKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVDCConnectionStateCKind&& from) noexcept
      : ENS_EVDCConnectionStateCKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVDCConnectionStateCKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVDCConnectionStateCKind stval() const;
  void set_stval(::evsemodule::EVDCConnectionStateCKind value);

  private:
  ::evsemodule::EVDCConnectionStateCKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVDCConnectionStateCKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVDCConnectionStateCKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVDCConnectionStateCKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCConnectionStateCKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVDCConnectionStateAKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVDCConnectionStateAKind) */ {
 public:
  inline ENS_EVDCConnectionStateAKind() : ENS_EVDCConnectionStateAKind(nullptr) {}
  ~ENS_EVDCConnectionStateAKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVDCConnectionStateAKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVDCConnectionStateAKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVDCConnectionStateAKind(const ENS_EVDCConnectionStateAKind& from) : ENS_EVDCConnectionStateAKind(nullptr, from) {}
  inline ENS_EVDCConnectionStateAKind(ENS_EVDCConnectionStateAKind&& from) noexcept
      : ENS_EVDCConnectionStateAKind(nullptr, ::std::move(from)) {}
  inline ENS_EVDCConnectionStateAKind& operator=(const ENS_EVDCConnectionStateAKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVDCConnectionStateAKind& operator=(ENS_EVDCConnectionStateAKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVDCConnectionStateAKind& default_instance() {
    return *reinterpret_cast<const ENS_EVDCConnectionStateAKind*>(
        &_ENS_EVDCConnectionStateAKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(ENS_EVDCConnectionStateAKind& a, ENS_EVDCConnectionStateAKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVDCConnectionStateAKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVDCConnectionStateAKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVDCConnectionStateAKind& from) { ENS_EVDCConnectionStateAKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVDCConnectionStateAKind"; }

 protected:
  explicit ENS_EVDCConnectionStateAKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVDCConnectionStateAKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVDCConnectionStateAKind& from);
  ENS_EVDCConnectionStateAKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVDCConnectionStateAKind&& from) noexcept
      : ENS_EVDCConnectionStateAKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVDCConnectionStateAKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVDCConnectionStateAKind stval() const;
  void set_stval(::evsemodule::EVDCConnectionStateAKind value);

  private:
  ::evsemodule::EVDCConnectionStateAKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVDCConnectionStateAKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVDCConnectionStateAKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVDCConnectionStateAKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCConnectionStateAKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVDCCableCapabilityKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVDCCableCapabilityKind) */ {
 public:
  inline ENS_EVDCCableCapabilityKind() : ENS_EVDCCableCapabilityKind(nullptr) {}
  ~ENS_EVDCCableCapabilityKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVDCCableCapabilityKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVDCCableCapabilityKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVDCCableCapabilityKind(const ENS_EVDCCableCapabilityKind& from) : ENS_EVDCCableCapabilityKind(nullptr, from) {}
  inline ENS_EVDCCableCapabilityKind(ENS_EVDCCableCapabilityKind&& from) noexcept
      : ENS_EVDCCableCapabilityKind(nullptr, ::std::move(from)) {}
  inline ENS_EVDCCableCapabilityKind& operator=(const ENS_EVDCCableCapabilityKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVDCCableCapabilityKind& operator=(ENS_EVDCCableCapabilityKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVDCCableCapabilityKind& default_instance() {
    return *reinterpret_cast<const ENS_EVDCCableCapabilityKind*>(
        &_ENS_EVDCCableCapabilityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(ENS_EVDCCableCapabilityKind& a, ENS_EVDCCableCapabilityKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVDCCableCapabilityKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVDCCableCapabilityKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVDCCableCapabilityKind& from) { ENS_EVDCCableCapabilityKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVDCCableCapabilityKind"; }

 protected:
  explicit ENS_EVDCCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVDCCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVDCCableCapabilityKind& from);
  ENS_EVDCCableCapabilityKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVDCCableCapabilityKind&& from) noexcept
      : ENS_EVDCCableCapabilityKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVDCCableCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVDCCableCapabilityKind stval() const;
  void set_stval(::evsemodule::EVDCCableCapabilityKind value);

  private:
  ::evsemodule::EVDCCableCapabilityKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVDCCableCapabilityKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVDCCableCapabilityKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVDCCableCapabilityKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVDCCableCapabilityKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVConnectionChargingKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVConnectionChargingKind) */ {
 public:
  inline ENS_EVConnectionChargingKind() : ENS_EVConnectionChargingKind(nullptr) {}
  ~ENS_EVConnectionChargingKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVConnectionChargingKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVConnectionChargingKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVConnectionChargingKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVConnectionChargingKind(const ENS_EVConnectionChargingKind& from) : ENS_EVConnectionChargingKind(nullptr, from) {}
  inline ENS_EVConnectionChargingKind(ENS_EVConnectionChargingKind&& from) noexcept
      : ENS_EVConnectionChargingKind(nullptr, ::std::move(from)) {}
  inline ENS_EVConnectionChargingKind& operator=(const ENS_EVConnectionChargingKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVConnectionChargingKind& operator=(ENS_EVConnectionChargingKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVConnectionChargingKind& default_instance() {
    return *reinterpret_cast<const ENS_EVConnectionChargingKind*>(
        &_ENS_EVConnectionChargingKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(ENS_EVConnectionChargingKind& a, ENS_EVConnectionChargingKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVConnectionChargingKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVConnectionChargingKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVConnectionChargingKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVConnectionChargingKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVConnectionChargingKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVConnectionChargingKind& from) { ENS_EVConnectionChargingKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVConnectionChargingKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVConnectionChargingKind"; }

 protected:
  explicit ENS_EVConnectionChargingKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVConnectionChargingKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVConnectionChargingKind& from);
  ENS_EVConnectionChargingKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVConnectionChargingKind&& from) noexcept
      : ENS_EVConnectionChargingKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVConnectionChargingKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVConnectionChargingKind stval() const;
  void set_stval(::evsemodule::EVConnectionChargingKind value);

  private:
  ::evsemodule::EVConnectionChargingKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVConnectionChargingKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVConnectionChargingKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVConnectionChargingKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVConnectionChargingKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVACPlugStateKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVACPlugStateKind) */ {
 public:
  inline ENS_EVACPlugStateKind() : ENS_EVACPlugStateKind(nullptr) {}
  ~ENS_EVACPlugStateKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVACPlugStateKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVACPlugStateKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVACPlugStateKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVACPlugStateKind(const ENS_EVACPlugStateKind& from) : ENS_EVACPlugStateKind(nullptr, from) {}
  inline ENS_EVACPlugStateKind(ENS_EVACPlugStateKind&& from) noexcept
      : ENS_EVACPlugStateKind(nullptr, ::std::move(from)) {}
  inline ENS_EVACPlugStateKind& operator=(const ENS_EVACPlugStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVACPlugStateKind& operator=(ENS_EVACPlugStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVACPlugStateKind& default_instance() {
    return *reinterpret_cast<const ENS_EVACPlugStateKind*>(
        &_ENS_EVACPlugStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(ENS_EVACPlugStateKind& a, ENS_EVACPlugStateKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVACPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVACPlugStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVACPlugStateKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVACPlugStateKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVACPlugStateKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVACPlugStateKind& from) { ENS_EVACPlugStateKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVACPlugStateKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVACPlugStateKind"; }

 protected:
  explicit ENS_EVACPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVACPlugStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVACPlugStateKind& from);
  ENS_EVACPlugStateKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVACPlugStateKind&& from) noexcept
      : ENS_EVACPlugStateKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVACPlugStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVACPlugStateKind stval() const;
  void set_stval(::evsemodule::EVACPlugStateKind value);

  private:
  ::evsemodule::EVACPlugStateKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVACPlugStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVACPlugStateKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVACPlugStateKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVACPlugStateKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVACConnectionStateKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVACConnectionStateKind) */ {
 public:
  inline ENS_EVACConnectionStateKind() : ENS_EVACConnectionStateKind(nullptr) {}
  ~ENS_EVACConnectionStateKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVACConnectionStateKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVACConnectionStateKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVACConnectionStateKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVACConnectionStateKind(const ENS_EVACConnectionStateKind& from) : ENS_EVACConnectionStateKind(nullptr, from) {}
  inline ENS_EVACConnectionStateKind(ENS_EVACConnectionStateKind&& from) noexcept
      : ENS_EVACConnectionStateKind(nullptr, ::std::move(from)) {}
  inline ENS_EVACConnectionStateKind& operator=(const ENS_EVACConnectionStateKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVACConnectionStateKind& operator=(ENS_EVACConnectionStateKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVACConnectionStateKind& default_instance() {
    return *reinterpret_cast<const ENS_EVACConnectionStateKind*>(
        &_ENS_EVACConnectionStateKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(ENS_EVACConnectionStateKind& a, ENS_EVACConnectionStateKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVACConnectionStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVACConnectionStateKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVACConnectionStateKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVACConnectionStateKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVACConnectionStateKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVACConnectionStateKind& from) { ENS_EVACConnectionStateKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVACConnectionStateKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVACConnectionStateKind"; }

 protected:
  explicit ENS_EVACConnectionStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVACConnectionStateKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVACConnectionStateKind& from);
  ENS_EVACConnectionStateKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVACConnectionStateKind&& from) noexcept
      : ENS_EVACConnectionStateKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVACConnectionStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVACConnectionStateKind stval() const;
  void set_stval(::evsemodule::EVACConnectionStateKind value);

  private:
  ::evsemodule::EVACConnectionStateKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVACConnectionStateKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVACConnectionStateKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVACConnectionStateKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVACConnectionStateKind_class_data_;
// -------------------------------------------------------------------

class ENS_EVACCableCapabilityKind final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ENS_EVACCableCapabilityKind) */ {
 public:
  inline ENS_EVACCableCapabilityKind() : ENS_EVACCableCapabilityKind(nullptr) {}
  ~ENS_EVACCableCapabilityKind() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ENS_EVACCableCapabilityKind));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ENS_EVACCableCapabilityKind(::google::protobuf::internal::ConstantInitialized);

  inline ENS_EVACCableCapabilityKind(const ENS_EVACCableCapabilityKind& from) : ENS_EVACCableCapabilityKind(nullptr, from) {}
  inline ENS_EVACCableCapabilityKind(ENS_EVACCableCapabilityKind&& from) noexcept
      : ENS_EVACCableCapabilityKind(nullptr, ::std::move(from)) {}
  inline ENS_EVACCableCapabilityKind& operator=(const ENS_EVACCableCapabilityKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline ENS_EVACCableCapabilityKind& operator=(ENS_EVACCableCapabilityKind&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ENS_EVACCableCapabilityKind& default_instance() {
    return *reinterpret_cast<const ENS_EVACCableCapabilityKind*>(
        &_ENS_EVACCableCapabilityKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(ENS_EVACCableCapabilityKind& a, ENS_EVACCableCapabilityKind& b) { a.Swap(&b); }
  inline void Swap(ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ENS_EVACCableCapabilityKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ENS_EVACCableCapabilityKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ENS_EVACCableCapabilityKind& from) { ENS_EVACCableCapabilityKind::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ENS_EVACCableCapabilityKind"; }

 protected:
  explicit ENS_EVACCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ENS_EVACCableCapabilityKind(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ENS_EVACCableCapabilityKind& from);
  ENS_EVACCableCapabilityKind(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ENS_EVACCableCapabilityKind&& from) noexcept
      : ENS_EVACCableCapabilityKind(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQFieldNumber = 1,
    kTFieldNumber = 3,
    kStValFieldNumber = 2,
  };
  // .commonmodule.Quality q = 1;
  bool has_q() const;
  void clear_q() ;
  const ::commonmodule::Quality& q() const;
  [[nodiscard]] ::commonmodule::Quality* PROTOBUF_NULLABLE release_q();
  ::commonmodule::Quality* PROTOBUF_NONNULL mutable_q();
  void set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value);
  ::commonmodule::Quality* PROTOBUF_NULLABLE unsafe_arena_release_q();

  private:
  const ::commonmodule::Quality& _internal_q() const;
  ::commonmodule::Quality* PROTOBUF_NONNULL _internal_mutable_q();

  public:
  // .commonmodule.Timestamp t = 3;
  bool has_t() const;
  void clear_t() ;
  const ::commonmodule::Timestamp& t() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_t();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_t();
  void set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_t();

  private:
  const ::commonmodule::Timestamp& _internal_t() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_t();

  public:
  // .evsemodule.EVACCableCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stval() ;
  ::evsemodule::EVACCableCapabilityKind stval() const;
  void set_stval(::evsemodule::EVACCableCapabilityKind value);

  private:
  ::evsemodule::EVACCableCapabilityKind _internal_stval() const;
  void _internal_set_stval(::evsemodule::EVACCableCapabilityKind value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ENS_EVACCableCapabilityKind)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ENS_EVACCableCapabilityKind& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::Quality* PROTOBUF_NULLABLE q_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE t_;
    int stval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ENS_EVACCableCapabilityKind_class_data_;
// -------------------------------------------------------------------

class ReadingDEEV final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ReadingDEEV) */ {
 public:
  inline ReadingDEEV() : ReadingDEEV(nullptr) {}
  ~ReadingDEEV() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadingDEEV* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadingDEEV));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadingDEEV(::google::protobuf::internal::ConstantInitialized);

  inline ReadingDEEV(const ReadingDEEV& from) : ReadingDEEV(nullptr, from) {}
  inline ReadingDEEV(ReadingDEEV&& from) noexcept
      : ReadingDEEV(nullptr, ::std::move(from)) {}
  inline ReadingDEEV& operator=(const ReadingDEEV& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadingDEEV& operator=(ReadingDEEV&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadingDEEV& default_instance() {
    return *reinterpret_cast<const ReadingDEEV*>(
        &_ReadingDEEV_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(ReadingDEEV& a, ReadingDEEV& b) { a.Swap(&b); }
  inline void Swap(ReadingDEEV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadingDEEV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadingDEEV* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadingDEEV>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadingDEEV& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadingDEEV& from) { ReadingDEEV::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadingDEEV* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ReadingDEEV"; }

 protected:
  explicit ReadingDEEV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReadingDEEV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReadingDEEV& from);
  ReadingDEEV(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReadingDEEV&& from) noexcept
      : ReadingDEEV(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
    kSocFieldNumber = 2,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // .commonmodule.MV Soc = 2;
  bool has_soc() const;
  void clear_soc() ;
  const ::commonmodule::MV& soc() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_soc();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_soc();
  void set_allocated_soc(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_soc(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_soc();

  private:
  const ::commonmodule::MV& _internal_soc() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_soc();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ReadingDEEV)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReadingDEEV& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    ::commonmodule::MV* PROTOBUF_NULLABLE soc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadingDEEV_class_data_;
// -------------------------------------------------------------------

class EVSEFunction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEFunction) */ {
 public:
  inline EVSEFunction() : EVSEFunction(nullptr) {}
  ~EVSEFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEFunction* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEFunction(::google::protobuf::internal::ConstantInitialized);

  inline EVSEFunction(const EVSEFunction& from) : EVSEFunction(nullptr, from) {}
  inline EVSEFunction(EVSEFunction&& from) noexcept
      : EVSEFunction(nullptr, ::std::move(from)) {}
  inline EVSEFunction& operator=(const EVSEFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEFunction& operator=(EVSEFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEFunction& default_instance() {
    return *reinterpret_cast<const EVSEFunction*>(
        &_EVSEFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(EVSEFunction& a, EVSEFunction& b) { a.Swap(&b); }
  inline void Swap(EVSEFunction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEFunction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEFunction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEFunction& from) { EVSEFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEFunction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEFunction"; }

 protected:
  explicit EVSEFunction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEFunction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEFunction& from);
  EVSEFunction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEFunction&& from) noexcept
      : EVSEFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapacityFirmingFieldNumber = 1,
    kFrequencyRegulationFieldNumber = 2,
    kPeakShavingFieldNumber = 3,
    kSocLimitFieldNumber = 4,
    kSocManagementFieldNumber = 5,
    kVoltageDroopFieldNumber = 6,
    kVoltagePIFieldNumber = 7,
  };
  // .commonmodule.CapacityFirming capacityFirming = 1;
  bool has_capacityfirming() const;
  void clear_capacityfirming() ;
  const ::commonmodule::CapacityFirming& capacityfirming() const;
  [[nodiscard]] ::commonmodule::CapacityFirming* PROTOBUF_NULLABLE release_capacityfirming();
  ::commonmodule::CapacityFirming* PROTOBUF_NONNULL mutable_capacityfirming();
  void set_allocated_capacityfirming(::commonmodule::CapacityFirming* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_capacityfirming(::commonmodule::CapacityFirming* PROTOBUF_NULLABLE value);
  ::commonmodule::CapacityFirming* PROTOBUF_NULLABLE unsafe_arena_release_capacityfirming();

  private:
  const ::commonmodule::CapacityFirming& _internal_capacityfirming() const;
  ::commonmodule::CapacityFirming* PROTOBUF_NONNULL _internal_mutable_capacityfirming();

  public:
  // .commonmodule.FrequencyRegulation frequencyRegulation = 2;
  bool has_frequencyregulation() const;
  void clear_frequencyregulation() ;
  const ::commonmodule::FrequencyRegulation& frequencyregulation() const;
  [[nodiscard]] ::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE release_frequencyregulation();
  ::commonmodule::FrequencyRegulation* PROTOBUF_NONNULL mutable_frequencyregulation();
  void set_allocated_frequencyregulation(::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_frequencyregulation(::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE value);
  ::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE unsafe_arena_release_frequencyregulation();

  private:
  const ::commonmodule::FrequencyRegulation& _internal_frequencyregulation() const;
  ::commonmodule::FrequencyRegulation* PROTOBUF_NONNULL _internal_mutable_frequencyregulation();

  public:
  // .commonmodule.PeakShaving peakShaving = 3;
  bool has_peakshaving() const;
  void clear_peakshaving() ;
  const ::commonmodule::PeakShaving& peakshaving() const;
  [[nodiscard]] ::commonmodule::PeakShaving* PROTOBUF_NULLABLE release_peakshaving();
  ::commonmodule::PeakShaving* PROTOBUF_NONNULL mutable_peakshaving();
  void set_allocated_peakshaving(::commonmodule::PeakShaving* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_peakshaving(::commonmodule::PeakShaving* PROTOBUF_NULLABLE value);
  ::commonmodule::PeakShaving* PROTOBUF_NULLABLE unsafe_arena_release_peakshaving();

  private:
  const ::commonmodule::PeakShaving& _internal_peakshaving() const;
  ::commonmodule::PeakShaving* PROTOBUF_NONNULL _internal_mutable_peakshaving();

  public:
  // .commonmodule.SocLimit socLimit = 4;
  bool has_soclimit() const;
  void clear_soclimit() ;
  const ::commonmodule::SocLimit& soclimit() const;
  [[nodiscard]] ::commonmodule::SocLimit* PROTOBUF_NULLABLE release_soclimit();
  ::commonmodule::SocLimit* PROTOBUF_NONNULL mutable_soclimit();
  void set_allocated_soclimit(::commonmodule::SocLimit* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_soclimit(::commonmodule::SocLimit* PROTOBUF_NULLABLE value);
  ::commonmodule::SocLimit* PROTOBUF_NULLABLE unsafe_arena_release_soclimit();

  private:
  const ::commonmodule::SocLimit& _internal_soclimit() const;
  ::commonmodule::SocLimit* PROTOBUF_NONNULL _internal_mutable_soclimit();

  public:
  // .commonmodule.SOCManagement socManagement = 5;
  bool has_socmanagement() const;
  void clear_socmanagement() ;
  const ::commonmodule::SOCManagement& socmanagement() const;
  [[nodiscard]] ::commonmodule::SOCManagement* PROTOBUF_NULLABLE release_socmanagement();
  ::commonmodule::SOCManagement* PROTOBUF_NONNULL mutable_socmanagement();
  void set_allocated_socmanagement(::commonmodule::SOCManagement* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_socmanagement(::commonmodule::SOCManagement* PROTOBUF_NULLABLE value);
  ::commonmodule::SOCManagement* PROTOBUF_NULLABLE unsafe_arena_release_socmanagement();

  private:
  const ::commonmodule::SOCManagement& _internal_socmanagement() const;
  ::commonmodule::SOCManagement* PROTOBUF_NONNULL _internal_mutable_socmanagement();

  public:
  // .commonmodule.VoltageDroop voltageDroop = 6;
  bool has_voltagedroop() const;
  void clear_voltagedroop() ;
  const ::commonmodule::VoltageDroop& voltagedroop() const;
  [[nodiscard]] ::commonmodule::VoltageDroop* PROTOBUF_NULLABLE release_voltagedroop();
  ::commonmodule::VoltageDroop* PROTOBUF_NONNULL mutable_voltagedroop();
  void set_allocated_voltagedroop(::commonmodule::VoltageDroop* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltagedroop(::commonmodule::VoltageDroop* PROTOBUF_NULLABLE value);
  ::commonmodule::VoltageDroop* PROTOBUF_NULLABLE unsafe_arena_release_voltagedroop();

  private:
  const ::commonmodule::VoltageDroop& _internal_voltagedroop() const;
  ::commonmodule::VoltageDroop* PROTOBUF_NONNULL _internal_mutable_voltagedroop();

  public:
  // .commonmodule.VoltagePI voltagePI = 7;
  bool has_voltagepi() const;
  void clear_voltagepi() ;
  const ::commonmodule::VoltagePI& voltagepi() const;
  [[nodiscard]] ::commonmodule::VoltagePI* PROTOBUF_NULLABLE release_voltagepi();
  ::commonmodule::VoltagePI* PROTOBUF_NONNULL mutable_voltagepi();
  void set_allocated_voltagepi(::commonmodule::VoltagePI* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltagepi(::commonmodule::VoltagePI* PROTOBUF_NULLABLE value);
  ::commonmodule::VoltagePI* PROTOBUF_NULLABLE unsafe_arena_release_voltagepi();

  private:
  const ::commonmodule::VoltagePI& _internal_voltagepi() const;
  ::commonmodule::VoltagePI* PROTOBUF_NONNULL _internal_mutable_voltagepi();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::CapacityFirming* PROTOBUF_NULLABLE capacityfirming_;
    ::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE frequencyregulation_;
    ::commonmodule::PeakShaving* PROTOBUF_NULLABLE peakshaving_;
    ::commonmodule::SocLimit* PROTOBUF_NULLABLE soclimit_;
    ::commonmodule::SOCManagement* PROTOBUF_NULLABLE socmanagement_;
    ::commonmodule::VoltageDroop* PROTOBUF_NULLABLE voltagedroop_;
    ::commonmodule::VoltagePI* PROTOBUF_NULLABLE voltagepi_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEFunction_class_data_;
// -------------------------------------------------------------------

class EVSE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSE) */ {
 public:
  inline EVSE() : EVSE(nullptr) {}
  ~EVSE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSE* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSE(::google::protobuf::internal::ConstantInitialized);

  inline EVSE(const EVSE& from) : EVSE(nullptr, from) {}
  inline EVSE(EVSE&& from) noexcept
      : EVSE(nullptr, ::std::move(from)) {}
  inline EVSE& operator=(const EVSE& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSE& operator=(EVSE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSE& default_instance() {
    return *reinterpret_cast<const EVSE*>(
        &_EVSE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(EVSE& a, EVSE& b) { a.Swap(&b); }
  inline void Swap(EVSE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSE* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSE& from) { EVSE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSE* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSE"; }

 protected:
  explicit EVSE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSE& from);
  EVSE(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSE&& from) noexcept
      : EVSE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  [[nodiscard]] ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE release_conductingequipment();
  ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conductingequipment(::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value);
  ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE unsafe_arena_release_conductingequipment();

  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL _internal_mutable_conductingequipment();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE conductingequipment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSE_class_data_;
// -------------------------------------------------------------------

class DEEVControlScheduleFSCH final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.DEEVControlScheduleFSCH) */ {
 public:
  inline DEEVControlScheduleFSCH() : DEEVControlScheduleFSCH(nullptr) {}
  ~DEEVControlScheduleFSCH() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DEEVControlScheduleFSCH* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DEEVControlScheduleFSCH));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DEEVControlScheduleFSCH(::google::protobuf::internal::ConstantInitialized);

  inline DEEVControlScheduleFSCH(const DEEVControlScheduleFSCH& from) : DEEVControlScheduleFSCH(nullptr, from) {}
  inline DEEVControlScheduleFSCH(DEEVControlScheduleFSCH&& from) noexcept
      : DEEVControlScheduleFSCH(nullptr, ::std::move(from)) {}
  inline DEEVControlScheduleFSCH& operator=(const DEEVControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline DEEVControlScheduleFSCH& operator=(DEEVControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DEEVControlScheduleFSCH& default_instance() {
    return *reinterpret_cast<const DEEVControlScheduleFSCH*>(
        &_DEEVControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(DEEVControlScheduleFSCH& a, DEEVControlScheduleFSCH& b) { a.Swap(&b); }
  inline void Swap(DEEVControlScheduleFSCH* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DEEVControlScheduleFSCH* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DEEVControlScheduleFSCH* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DEEVControlScheduleFSCH>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DEEVControlScheduleFSCH& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DEEVControlScheduleFSCH& from) { DEEVControlScheduleFSCH::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DEEVControlScheduleFSCH* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.DEEVControlScheduleFSCH"; }

 protected:
  explicit DEEVControlScheduleFSCH(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DEEVControlScheduleFSCH(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DEEVControlScheduleFSCH& from);
  DEEVControlScheduleFSCH(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DEEVControlScheduleFSCH&& from) noexcept
      : DEEVControlScheduleFSCH(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValACSGFieldNumber = 1,
  };
  // .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valacsg() const;
  void clear_valacsg() ;
  const ::commonmodule::ScheduleCSG& valacsg() const;
  [[nodiscard]] ::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE release_valacsg();
  ::commonmodule::ScheduleCSG* PROTOBUF_NONNULL mutable_valacsg();
  void set_allocated_valacsg(::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_valacsg(::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE unsafe_arena_release_valacsg();

  private:
  const ::commonmodule::ScheduleCSG& _internal_valacsg() const;
  ::commonmodule::ScheduleCSG* PROTOBUF_NONNULL _internal_mutable_valacsg();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.DEEVControlScheduleFSCH)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DEEVControlScheduleFSCH& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE valacsg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DEEVControlScheduleFSCH_class_data_;
// -------------------------------------------------------------------

class CapabilityRatingsZCAB final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.CapabilityRatingsZCAB) */ {
 public:
  inline CapabilityRatingsZCAB() : CapabilityRatingsZCAB(nullptr) {}
  ~CapabilityRatingsZCAB() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapabilityRatingsZCAB* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapabilityRatingsZCAB));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapabilityRatingsZCAB(::google::protobuf::internal::ConstantInitialized);

  inline CapabilityRatingsZCAB(const CapabilityRatingsZCAB& from) : CapabilityRatingsZCAB(nullptr, from) {}
  inline CapabilityRatingsZCAB(CapabilityRatingsZCAB&& from) noexcept
      : CapabilityRatingsZCAB(nullptr, ::std::move(from)) {}
  inline CapabilityRatingsZCAB& operator=(const CapabilityRatingsZCAB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityRatingsZCAB& operator=(CapabilityRatingsZCAB&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityRatingsZCAB& default_instance() {
    return *reinterpret_cast<const CapabilityRatingsZCAB*>(
        &_CapabilityRatingsZCAB_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CapabilityRatingsZCAB& a, CapabilityRatingsZCAB& b) { a.Swap(&b); }
  inline void Swap(CapabilityRatingsZCAB* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityRatingsZCAB* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityRatingsZCAB* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapabilityRatingsZCAB>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapabilityRatingsZCAB& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapabilityRatingsZCAB& from) { CapabilityRatingsZCAB::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapabilityRatingsZCAB* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.CapabilityRatingsZCAB"; }

 protected:
  explicit CapabilityRatingsZCAB(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapabilityRatingsZCAB(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapabilityRatingsZCAB& from);
  CapabilityRatingsZCAB(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapabilityRatingsZCAB&& from) noexcept
      : CapabilityRatingsZCAB(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
    kARtgFieldNumber = 2,
    kOvlMaxPctFieldNumber = 3,
    kOvlMaxTmFieldNumber = 4,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // .commonmodule.ASG ARtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_artg() const;
  void clear_artg() ;
  const ::commonmodule::ASG& artg() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_artg();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_artg();
  void set_allocated_artg(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_artg(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_artg();

  private:
  const ::commonmodule::ASG& _internal_artg() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_artg();

  public:
  // .commonmodule.ASG OvlMaxPct = 3;
  bool has_ovlmaxpct() const;
  void clear_ovlmaxpct() ;
  const ::commonmodule::ASG& ovlmaxpct() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_ovlmaxpct();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_ovlmaxpct();
  void set_allocated_ovlmaxpct(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ovlmaxpct(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_ovlmaxpct();

  private:
  const ::commonmodule::ASG& _internal_ovlmaxpct() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_ovlmaxpct();

  public:
  // .commonmodule.ControlING OvlMaxTm = 4;
  bool has_ovlmaxtm() const;
  void clear_ovlmaxtm() ;
  const ::commonmodule::ControlING& ovlmaxtm() const;
  [[nodiscard]] ::commonmodule::ControlING* PROTOBUF_NULLABLE release_ovlmaxtm();
  ::commonmodule::ControlING* PROTOBUF_NONNULL mutable_ovlmaxtm();
  void set_allocated_ovlmaxtm(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ovlmaxtm(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlING* PROTOBUF_NULLABLE unsafe_arena_release_ovlmaxtm();

  private:
  const ::commonmodule::ControlING& _internal_ovlmaxtm() const;
  ::commonmodule::ControlING* PROTOBUF_NONNULL _internal_mutable_ovlmaxtm();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.CapabilityRatingsZCAB)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapabilityRatingsZCAB& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE artg_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE ovlmaxpct_;
    ::commonmodule::ControlING* PROTOBUF_NULLABLE ovlmaxtm_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsZCAB_class_data_;
// -------------------------------------------------------------------

class CapabilityRatingsDEDO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.CapabilityRatingsDEDO) */ {
 public:
  inline CapabilityRatingsDEDO() : CapabilityRatingsDEDO(nullptr) {}
  ~CapabilityRatingsDEDO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapabilityRatingsDEDO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapabilityRatingsDEDO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapabilityRatingsDEDO(::google::protobuf::internal::ConstantInitialized);

  inline CapabilityRatingsDEDO(const CapabilityRatingsDEDO& from) : CapabilityRatingsDEDO(nullptr, from) {}
  inline CapabilityRatingsDEDO(CapabilityRatingsDEDO&& from) noexcept
      : CapabilityRatingsDEDO(nullptr, ::std::move(from)) {}
  inline CapabilityRatingsDEDO& operator=(const CapabilityRatingsDEDO& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityRatingsDEDO& operator=(CapabilityRatingsDEDO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityRatingsDEDO& default_instance() {
    return *reinterpret_cast<const CapabilityRatingsDEDO*>(
        &_CapabilityRatingsDEDO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CapabilityRatingsDEDO& a, CapabilityRatingsDEDO& b) { a.Swap(&b); }
  inline void Swap(CapabilityRatingsDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityRatingsDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityRatingsDEDO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapabilityRatingsDEDO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapabilityRatingsDEDO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapabilityRatingsDEDO& from) { CapabilityRatingsDEDO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapabilityRatingsDEDO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.CapabilityRatingsDEDO"; }

 protected:
  explicit CapabilityRatingsDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapabilityRatingsDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapabilityRatingsDEDO& from);
  CapabilityRatingsDEDO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapabilityRatingsDEDO&& from) noexcept
      : CapabilityRatingsDEDO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.CapabilityRatingsDEDO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapabilityRatingsDEDO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsDEDO_class_data_;
// -------------------------------------------------------------------

class CapabilityRatingsDEAO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.CapabilityRatingsDEAO) */ {
 public:
  inline CapabilityRatingsDEAO() : CapabilityRatingsDEAO(nullptr) {}
  ~CapabilityRatingsDEAO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapabilityRatingsDEAO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapabilityRatingsDEAO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapabilityRatingsDEAO(::google::protobuf::internal::ConstantInitialized);

  inline CapabilityRatingsDEAO(const CapabilityRatingsDEAO& from) : CapabilityRatingsDEAO(nullptr, from) {}
  inline CapabilityRatingsDEAO(CapabilityRatingsDEAO&& from) noexcept
      : CapabilityRatingsDEAO(nullptr, ::std::move(from)) {}
  inline CapabilityRatingsDEAO& operator=(const CapabilityRatingsDEAO& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityRatingsDEAO& operator=(CapabilityRatingsDEAO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityRatingsDEAO& default_instance() {
    return *reinterpret_cast<const CapabilityRatingsDEAO*>(
        &_CapabilityRatingsDEAO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CapabilityRatingsDEAO& a, CapabilityRatingsDEAO& b) { a.Swap(&b); }
  inline void Swap(CapabilityRatingsDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityRatingsDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityRatingsDEAO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapabilityRatingsDEAO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapabilityRatingsDEAO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapabilityRatingsDEAO& from) { CapabilityRatingsDEAO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapabilityRatingsDEAO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.CapabilityRatingsDEAO"; }

 protected:
  explicit CapabilityRatingsDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapabilityRatingsDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapabilityRatingsDEAO& from);
  CapabilityRatingsDEAO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapabilityRatingsDEAO&& from) noexcept
      : CapabilityRatingsDEAO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
    kChaARtgFieldNumber = 3,
    kChaAMaxFieldNumber = 4,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // .commonmodule.ControlING ChaARtg = 3;
  bool has_chaartg() const;
  void clear_chaartg() ;
  const ::commonmodule::ControlING& chaartg() const;
  [[nodiscard]] ::commonmodule::ControlING* PROTOBUF_NULLABLE release_chaartg();
  ::commonmodule::ControlING* PROTOBUF_NONNULL mutable_chaartg();
  void set_allocated_chaartg(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chaartg(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlING* PROTOBUF_NULLABLE unsafe_arena_release_chaartg();

  private:
  const ::commonmodule::ControlING& _internal_chaartg() const;
  ::commonmodule::ControlING* PROTOBUF_NONNULL _internal_mutable_chaartg();

  public:
  // .commonmodule.ControlING ChaAMax = 4;
  bool has_chaamax() const;
  void clear_chaamax() ;
  const ::commonmodule::ControlING& chaamax() const;
  [[nodiscard]] ::commonmodule::ControlING* PROTOBUF_NULLABLE release_chaamax();
  ::commonmodule::ControlING* PROTOBUF_NONNULL mutable_chaamax();
  void set_allocated_chaamax(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chaamax(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlING* PROTOBUF_NULLABLE unsafe_arena_release_chaamax();

  private:
  const ::commonmodule::ControlING& _internal_chaamax() const;
  ::commonmodule::ControlING* PROTOBUF_NONNULL _internal_mutable_chaamax();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.CapabilityRatingsDEAO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapabilityRatingsDEAO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    ::commonmodule::ControlING* PROTOBUF_NULLABLE chaartg_;
    ::commonmodule::ControlING* PROTOBUF_NULLABLE chaamax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsDEAO_class_data_;
// -------------------------------------------------------------------

class CapabilityConfigurationDEDO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.CapabilityConfigurationDEDO) */ {
 public:
  inline CapabilityConfigurationDEDO() : CapabilityConfigurationDEDO(nullptr) {}
  ~CapabilityConfigurationDEDO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapabilityConfigurationDEDO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapabilityConfigurationDEDO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapabilityConfigurationDEDO(::google::protobuf::internal::ConstantInitialized);

  inline CapabilityConfigurationDEDO(const CapabilityConfigurationDEDO& from) : CapabilityConfigurationDEDO(nullptr, from) {}
  inline CapabilityConfigurationDEDO(CapabilityConfigurationDEDO&& from) noexcept
      : CapabilityConfigurationDEDO(nullptr, ::std::move(from)) {}
  inline CapabilityConfigurationDEDO& operator=(const CapabilityConfigurationDEDO& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityConfigurationDEDO& operator=(CapabilityConfigurationDEDO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityConfigurationDEDO& default_instance() {
    return *reinterpret_cast<const CapabilityConfigurationDEDO*>(
        &_CapabilityConfigurationDEDO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CapabilityConfigurationDEDO& a, CapabilityConfigurationDEDO& b) { a.Swap(&b); }
  inline void Swap(CapabilityConfigurationDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityConfigurationDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityConfigurationDEDO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapabilityConfigurationDEDO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapabilityConfigurationDEDO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapabilityConfigurationDEDO& from) { CapabilityConfigurationDEDO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapabilityConfigurationDEDO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.CapabilityConfigurationDEDO"; }

 protected:
  explicit CapabilityConfigurationDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapabilityConfigurationDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapabilityConfigurationDEDO& from);
  CapabilityConfigurationDEDO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapabilityConfigurationDEDO&& from) noexcept
      : CapabilityConfigurationDEDO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.CapabilityConfigurationDEDO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapabilityConfigurationDEDO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CapabilityConfigurationDEDO_class_data_;
// -------------------------------------------------------------------

class CapabilityConfigurationDEAO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.CapabilityConfigurationDEAO) */ {
 public:
  inline CapabilityConfigurationDEAO() : CapabilityConfigurationDEAO(nullptr) {}
  ~CapabilityConfigurationDEAO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapabilityConfigurationDEAO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapabilityConfigurationDEAO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapabilityConfigurationDEAO(::google::protobuf::internal::ConstantInitialized);

  inline CapabilityConfigurationDEAO(const CapabilityConfigurationDEAO& from) : CapabilityConfigurationDEAO(nullptr, from) {}
  inline CapabilityConfigurationDEAO(CapabilityConfigurationDEAO&& from) noexcept
      : CapabilityConfigurationDEAO(nullptr, ::std::move(from)) {}
  inline CapabilityConfigurationDEAO& operator=(const CapabilityConfigurationDEAO& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityConfigurationDEAO& operator=(CapabilityConfigurationDEAO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityConfigurationDEAO& default_instance() {
    return *reinterpret_cast<const CapabilityConfigurationDEAO*>(
        &_CapabilityConfigurationDEAO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CapabilityConfigurationDEAO& a, CapabilityConfigurationDEAO& b) { a.Swap(&b); }
  inline void Swap(CapabilityConfigurationDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityConfigurationDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityConfigurationDEAO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapabilityConfigurationDEAO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapabilityConfigurationDEAO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapabilityConfigurationDEAO& from) { CapabilityConfigurationDEAO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapabilityConfigurationDEAO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.CapabilityConfigurationDEAO"; }

 protected:
  explicit CapabilityConfigurationDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapabilityConfigurationDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapabilityConfigurationDEAO& from);
  CapabilityConfigurationDEAO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapabilityConfigurationDEAO&& from) noexcept
      : CapabilityConfigurationDEAO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
    kChaARtgFieldNumber = 3,
    kChaAMaxFieldNumber = 4,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // .commonmodule.ControlING ChaARtg = 3;
  bool has_chaartg() const;
  void clear_chaartg() ;
  const ::commonmodule::ControlING& chaartg() const;
  [[nodiscard]] ::commonmodule::ControlING* PROTOBUF_NULLABLE release_chaartg();
  ::commonmodule::ControlING* PROTOBUF_NONNULL mutable_chaartg();
  void set_allocated_chaartg(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chaartg(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlING* PROTOBUF_NULLABLE unsafe_arena_release_chaartg();

  private:
  const ::commonmodule::ControlING& _internal_chaartg() const;
  ::commonmodule::ControlING* PROTOBUF_NONNULL _internal_mutable_chaartg();

  public:
  // .commonmodule.ControlING ChaAMax = 4;
  bool has_chaamax() const;
  void clear_chaamax() ;
  const ::commonmodule::ControlING& chaamax() const;
  [[nodiscard]] ::commonmodule::ControlING* PROTOBUF_NULLABLE release_chaamax();
  ::commonmodule::ControlING* PROTOBUF_NONNULL mutable_chaamax();
  void set_allocated_chaamax(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chaamax(::commonmodule::ControlING* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlING* PROTOBUF_NULLABLE unsafe_arena_release_chaamax();

  private:
  const ::commonmodule::ControlING& _internal_chaamax() const;
  ::commonmodule::ControlING* PROTOBUF_NONNULL _internal_mutable_chaamax();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.CapabilityConfigurationDEAO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapabilityConfigurationDEAO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    ::commonmodule::ControlING* PROTOBUF_NULLABLE chaartg_;
    ::commonmodule::ControlING* PROTOBUF_NULLABLE chaamax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CapabilityConfigurationDEAO_class_data_;
// -------------------------------------------------------------------

class ReadingDEDO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ReadingDEDO) */ {
 public:
  inline ReadingDEDO() : ReadingDEDO(nullptr) {}
  ~ReadingDEDO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadingDEDO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadingDEDO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadingDEDO(::google::protobuf::internal::ConstantInitialized);

  inline ReadingDEDO(const ReadingDEDO& from) : ReadingDEDO(nullptr, from) {}
  inline ReadingDEDO(ReadingDEDO&& from) noexcept
      : ReadingDEDO(nullptr, ::std::move(from)) {}
  inline ReadingDEDO& operator=(const ReadingDEDO& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadingDEDO& operator=(ReadingDEDO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadingDEDO& default_instance() {
    return *reinterpret_cast<const ReadingDEDO*>(
        &_ReadingDEDO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(ReadingDEDO& a, ReadingDEDO& b) { a.Swap(&b); }
  inline void Swap(ReadingDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadingDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadingDEDO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadingDEDO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadingDEDO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadingDEDO& from) { ReadingDEDO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadingDEDO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ReadingDEDO"; }

 protected:
  explicit ReadingDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReadingDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReadingDEDO& from);
  ReadingDEDO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReadingDEDO&& from) noexcept
      : ReadingDEDO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
    kReadingDEEVFieldNumber = 2,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // .evsemodule.ReadingDEEV readingDEEV = 2;
  bool has_readingdeev() const;
  void clear_readingdeev() ;
  const ::evsemodule::ReadingDEEV& readingdeev() const;
  [[nodiscard]] ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE release_readingdeev();
  ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL mutable_readingdeev();
  void set_allocated_readingdeev(::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingdeev(::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value);
  ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE unsafe_arena_release_readingdeev();

  private:
  const ::evsemodule::ReadingDEEV& _internal_readingdeev() const;
  ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL _internal_mutable_readingdeev();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ReadingDEDO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReadingDEDO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE readingdeev_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadingDEDO_class_data_;
// -------------------------------------------------------------------

class ReadingDEAO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ReadingDEAO) */ {
 public:
  inline ReadingDEAO() : ReadingDEAO(nullptr) {}
  ~ReadingDEAO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadingDEAO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadingDEAO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadingDEAO(::google::protobuf::internal::ConstantInitialized);

  inline ReadingDEAO(const ReadingDEAO& from) : ReadingDEAO(nullptr, from) {}
  inline ReadingDEAO(ReadingDEAO&& from) noexcept
      : ReadingDEAO(nullptr, ::std::move(from)) {}
  inline ReadingDEAO& operator=(const ReadingDEAO& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadingDEAO& operator=(ReadingDEAO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadingDEAO& default_instance() {
    return *reinterpret_cast<const ReadingDEAO*>(
        &_ReadingDEAO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(ReadingDEAO& a, ReadingDEAO& b) { a.Swap(&b); }
  inline void Swap(ReadingDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadingDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadingDEAO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadingDEAO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadingDEAO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadingDEAO& from) { ReadingDEAO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadingDEAO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ReadingDEAO"; }

 protected:
  explicit ReadingDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReadingDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReadingDEAO& from);
  ReadingDEAO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReadingDEAO&& from) noexcept
      : ReadingDEAO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
    kReadingDEEVFieldNumber = 2,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // .evsemodule.ReadingDEEV readingDEEV = 2;
  bool has_readingdeev() const;
  void clear_readingdeev() ;
  const ::evsemodule::ReadingDEEV& readingdeev() const;
  [[nodiscard]] ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE release_readingdeev();
  ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL mutable_readingdeev();
  void set_allocated_readingdeev(::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingdeev(::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value);
  ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE unsafe_arena_release_readingdeev();

  private:
  const ::evsemodule::ReadingDEEV& _internal_readingdeev() const;
  ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL _internal_mutable_readingdeev();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ReadingDEAO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReadingDEAO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE readingdeev_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadingDEAO_class_data_;
// -------------------------------------------------------------------

class EventAndStatusDEEV final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EventAndStatusDEEV) */ {
 public:
  inline EventAndStatusDEEV() : EventAndStatusDEEV(nullptr) {}
  ~EventAndStatusDEEV() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventAndStatusDEEV* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventAndStatusDEEV));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventAndStatusDEEV(::google::protobuf::internal::ConstantInitialized);

  inline EventAndStatusDEEV(const EventAndStatusDEEV& from) : EventAndStatusDEEV(nullptr, from) {}
  inline EventAndStatusDEEV(EventAndStatusDEEV&& from) noexcept
      : EventAndStatusDEEV(nullptr, ::std::move(from)) {}
  inline EventAndStatusDEEV& operator=(const EventAndStatusDEEV& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAndStatusDEEV& operator=(EventAndStatusDEEV&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAndStatusDEEV& default_instance() {
    return *reinterpret_cast<const EventAndStatusDEEV*>(
        &_EventAndStatusDEEV_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(EventAndStatusDEEV& a, EventAndStatusDEEV& b) { a.Swap(&b); }
  inline void Swap(EventAndStatusDEEV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAndStatusDEEV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAndStatusDEEV* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventAndStatusDEEV>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventAndStatusDEEV& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventAndStatusDEEV& from) { EventAndStatusDEEV::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventAndStatusDEEV* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EventAndStatusDEEV"; }

 protected:
  explicit EventAndStatusDEEV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EventAndStatusDEEV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EventAndStatusDEEV& from);
  EventAndStatusDEEV(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EventAndStatusDEEV&& from) noexcept
      : EventAndStatusDEEV(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kEVIdFieldNumber = 2,
    kEMAIdFieldNumber = 3,
    kConnTypSelFieldNumber = 4,
    kDptTmFieldNumber = 5,
    kWHReqFieldNumber = 6,
    kWHAvailFieldNumber = 7,
    kSocFieldNumber = 8,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforeventandstatus();

  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL _internal_mutable_logicalnodeforeventandstatus();

  public:
  // .google.protobuf.StringValue EVId = 2 [(.uml.option_uuid) = true];
  bool has_evid() const;
  void clear_evid() ;
  const ::google::protobuf::StringValue& evid() const;
  [[nodiscard]] ::google::protobuf::StringValue* PROTOBUF_NULLABLE release_evid();
  ::google::protobuf::StringValue* PROTOBUF_NONNULL mutable_evid();
  void set_allocated_evid(::google::protobuf::StringValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evid(::google::protobuf::StringValue* PROTOBUF_NULLABLE value);
  ::google::protobuf::StringValue* PROTOBUF_NULLABLE unsafe_arena_release_evid();

  private:
  const ::google::protobuf::StringValue& _internal_evid() const;
  ::google::protobuf::StringValue* PROTOBUF_NONNULL _internal_mutable_evid();

  public:
  // .google.protobuf.StringValue EMAId = 3 [(.uml.option_uuid) = true];
  bool has_emaid() const;
  void clear_emaid() ;
  const ::google::protobuf::StringValue& emaid() const;
  [[nodiscard]] ::google::protobuf::StringValue* PROTOBUF_NULLABLE release_emaid();
  ::google::protobuf::StringValue* PROTOBUF_NONNULL mutable_emaid();
  void set_allocated_emaid(::google::protobuf::StringValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_emaid(::google::protobuf::StringValue* PROTOBUF_NULLABLE value);
  ::google::protobuf::StringValue* PROTOBUF_NULLABLE unsafe_arena_release_emaid();

  private:
  const ::google::protobuf::StringValue& _internal_emaid() const;
  ::google::protobuf::StringValue* PROTOBUF_NONNULL _internal_mutable_emaid();

  public:
  // .evsemodule.ENS_EVConnectionChargingKind ConnTypSel = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_conntypsel() const;
  void clear_conntypsel() ;
  const ::evsemodule::ENS_EVConnectionChargingKind& conntypsel() const;
  [[nodiscard]] ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE release_conntypsel();
  ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NONNULL mutable_conntypsel();
  void set_allocated_conntypsel(::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conntypsel(::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE unsafe_arena_release_conntypsel();

  private:
  const ::evsemodule::ENS_EVConnectionChargingKind& _internal_conntypsel() const;
  ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NONNULL _internal_mutable_conntypsel();

  public:
  // .commonmodule.ClearingTime DptTm = 5;
  bool has_dpttm() const;
  void clear_dpttm() ;
  const ::commonmodule::ClearingTime& dpttm() const;
  [[nodiscard]] ::commonmodule::ClearingTime* PROTOBUF_NULLABLE release_dpttm();
  ::commonmodule::ClearingTime* PROTOBUF_NONNULL mutable_dpttm();
  void set_allocated_dpttm(::commonmodule::ClearingTime* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dpttm(::commonmodule::ClearingTime* PROTOBUF_NULLABLE value);
  ::commonmodule::ClearingTime* PROTOBUF_NULLABLE unsafe_arena_release_dpttm();

  private:
  const ::commonmodule::ClearingTime& _internal_dpttm() const;
  ::commonmodule::ClearingTime* PROTOBUF_NONNULL _internal_mutable_dpttm();

  public:
  // .commonmodule.MV WHReq = 6;
  bool has_whreq() const;
  void clear_whreq() ;
  const ::commonmodule::MV& whreq() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_whreq();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_whreq();
  void set_allocated_whreq(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_whreq(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_whreq();

  private:
  const ::commonmodule::MV& _internal_whreq() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_whreq();

  public:
  // .commonmodule.MV WHAvail = 7;
  bool has_whavail() const;
  void clear_whavail() ;
  const ::commonmodule::MV& whavail() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_whavail();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_whavail();
  void set_allocated_whavail(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_whavail(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_whavail();

  private:
  const ::commonmodule::MV& _internal_whavail() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_whavail();

  public:
  // .commonmodule.MV Soc = 8;
  bool has_soc() const;
  void clear_soc() ;
  const ::commonmodule::MV& soc() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_soc();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_soc();
  void set_allocated_soc(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_soc(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_soc();

  private:
  const ::commonmodule::MV& _internal_soc() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_soc();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EventAndStatusDEEV)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   8, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EventAndStatusDEEV& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE logicalnodeforeventandstatus_;
    ::google::protobuf::StringValue* PROTOBUF_NULLABLE evid_;
    ::google::protobuf::StringValue* PROTOBUF_NULLABLE emaid_;
    ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE conntypsel_;
    ::commonmodule::ClearingTime* PROTOBUF_NULLABLE dpttm_;
    ::commonmodule::MV* PROTOBUF_NULLABLE whreq_;
    ::commonmodule::MV* PROTOBUF_NULLABLE whavail_;
    ::commonmodule::MV* PROTOBUF_NULLABLE soc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDEEV_class_data_;
// -------------------------------------------------------------------

class ControlDEEV final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ControlDEEV) */ {
 public:
  inline ControlDEEV() : ControlDEEV(nullptr) {}
  ~ControlDEEV() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ControlDEEV* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ControlDEEV));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlDEEV(::google::protobuf::internal::ConstantInitialized);

  inline ControlDEEV(const ControlDEEV& from) : ControlDEEV(nullptr, from) {}
  inline ControlDEEV(ControlDEEV&& from) noexcept
      : ControlDEEV(nullptr, ::std::move(from)) {}
  inline ControlDEEV& operator=(const ControlDEEV& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlDEEV& operator=(ControlDEEV&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlDEEV& default_instance() {
    return *reinterpret_cast<const ControlDEEV*>(
        &_ControlDEEV_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ControlDEEV& a, ControlDEEV& b) { a.Swap(&b); }
  inline void Swap(ControlDEEV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlDEEV* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlDEEV* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ControlDEEV>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlDEEV& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlDEEV& from) { ControlDEEV::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ControlDEEV* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ControlDEEV"; }

 protected:
  explicit ControlDEEV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ControlDEEV(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ControlDEEV& from);
  ControlDEEV(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ControlDEEV&& from) noexcept
      : ControlDEEV(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kDeevControlScheduleFSCHFieldNumber = 2,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforcontrol();

  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL _internal_mutable_logicalnodeforcontrol();

  public:
  // .evsemodule.DEEVControlScheduleFSCH deevControlScheduleFSCH = 2;
  bool has_deevcontrolschedulefsch() const;
  void clear_deevcontrolschedulefsch() ;
  const ::evsemodule::DEEVControlScheduleFSCH& deevcontrolschedulefsch() const;
  [[nodiscard]] ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE release_deevcontrolschedulefsch();
  ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NONNULL mutable_deevcontrolschedulefsch();
  void set_allocated_deevcontrolschedulefsch(::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_deevcontrolschedulefsch(::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE value);
  ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE unsafe_arena_release_deevcontrolschedulefsch();

  private:
  const ::evsemodule::DEEVControlScheduleFSCH& _internal_deevcontrolschedulefsch() const;
  ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NONNULL _internal_mutable_deevcontrolschedulefsch();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ControlDEEV)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ControlDEEV& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE logicalnodeforcontrol_;
    ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE deevcontrolschedulefsch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ControlDEEV_class_data_;
// -------------------------------------------------------------------

class CapabilityRatingsDESE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.CapabilityRatingsDESE) */ {
 public:
  inline CapabilityRatingsDESE() : CapabilityRatingsDESE(nullptr) {}
  ~CapabilityRatingsDESE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapabilityRatingsDESE* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapabilityRatingsDESE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapabilityRatingsDESE(::google::protobuf::internal::ConstantInitialized);

  inline CapabilityRatingsDESE(const CapabilityRatingsDESE& from) : CapabilityRatingsDESE(nullptr, from) {}
  inline CapabilityRatingsDESE(CapabilityRatingsDESE&& from) noexcept
      : CapabilityRatingsDESE(nullptr, ::std::move(from)) {}
  inline CapabilityRatingsDESE& operator=(const CapabilityRatingsDESE& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityRatingsDESE& operator=(CapabilityRatingsDESE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityRatingsDESE& default_instance() {
    return *reinterpret_cast<const CapabilityRatingsDESE*>(
        &_CapabilityRatingsDESE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CapabilityRatingsDESE& a, CapabilityRatingsDESE& b) { a.Swap(&b); }
  inline void Swap(CapabilityRatingsDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityRatingsDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityRatingsDESE* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapabilityRatingsDESE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapabilityRatingsDESE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapabilityRatingsDESE& from) { CapabilityRatingsDESE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapabilityRatingsDESE* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.CapabilityRatingsDESE"; }

 protected:
  explicit CapabilityRatingsDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapabilityRatingsDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapabilityRatingsDESE& from);
  CapabilityRatingsDESE(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapabilityRatingsDESE&& from) noexcept
      : CapabilityRatingsDESE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapabilityRatingsDEAOFieldNumber = 2,
    kCapabilityRatingsDEDOFieldNumber = 3,
    kSourceCapabilityRatingsFieldNumber = 1,
    kChaPwrRtgFieldNumber = 4,
    kChaPwrTgtFieldNumber = 5,
    kChaPwrLimFieldNumber = 6,
    kConnTypDCFieldNumber = 7,
    kConnTypPhs1FieldNumber = 8,
    kConnTypPhs2FieldNumber = 9,
    kConnTypPhs3FieldNumber = 10,
  };
  // repeated .evsemodule.CapabilityRatingsDEAO capabilityRatingsDEAO = 2 [(.uml.option_multiplicity_min) = 0];
  int capabilityratingsdeao_size() const;
  private:
  int _internal_capabilityratingsdeao_size() const;

  public:
  void clear_capabilityratingsdeao() ;
  ::evsemodule::CapabilityRatingsDEAO* PROTOBUF_NONNULL mutable_capabilityratingsdeao(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>* PROTOBUF_NONNULL mutable_capabilityratingsdeao();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>& _internal_capabilityratingsdeao() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>* PROTOBUF_NONNULL _internal_mutable_capabilityratingsdeao();
  public:
  const ::evsemodule::CapabilityRatingsDEAO& capabilityratingsdeao(int index) const;
  ::evsemodule::CapabilityRatingsDEAO* PROTOBUF_NONNULL add_capabilityratingsdeao();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>& capabilityratingsdeao() const;
  // repeated .evsemodule.CapabilityRatingsDEDO capabilityRatingsDEDO = 3 [(.uml.option_multiplicity_min) = 0];
  int capabilityratingsdedo_size() const;
  private:
  int _internal_capabilityratingsdedo_size() const;

  public:
  void clear_capabilityratingsdedo() ;
  ::evsemodule::CapabilityRatingsDEDO* PROTOBUF_NONNULL mutable_capabilityratingsdedo(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>* PROTOBUF_NONNULL mutable_capabilityratingsdedo();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>& _internal_capabilityratingsdedo() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>* PROTOBUF_NONNULL _internal_mutable_capabilityratingsdedo();
  public:
  const ::evsemodule::CapabilityRatingsDEDO& capabilityratingsdedo(int index) const;
  ::evsemodule::CapabilityRatingsDEDO* PROTOBUF_NONNULL add_capabilityratingsdedo();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>& capabilityratingsdedo() const;
  // .commonmodule.SourceCapabilityRatings sourceCapabilityRatings = 1 [(.uml.option_parent_message) = true];
  bool has_sourcecapabilityratings() const;
  void clear_sourcecapabilityratings() ;
  const ::commonmodule::SourceCapabilityRatings& sourcecapabilityratings() const;
  [[nodiscard]] ::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE release_sourcecapabilityratings();
  ::commonmodule::SourceCapabilityRatings* PROTOBUF_NONNULL mutable_sourcecapabilityratings();
  void set_allocated_sourcecapabilityratings(::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sourcecapabilityratings(::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE value);
  ::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE unsafe_arena_release_sourcecapabilityratings();

  private:
  const ::commonmodule::SourceCapabilityRatings& _internal_sourcecapabilityratings() const;
  ::commonmodule::SourceCapabilityRatings* PROTOBUF_NONNULL _internal_mutable_sourcecapabilityratings();

  public:
  // .commonmodule.ASG ChaPwrRtg = 4;
  bool has_chapwrrtg() const;
  void clear_chapwrrtg() ;
  const ::commonmodule::ASG& chapwrrtg() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_chapwrrtg();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_chapwrrtg();
  void set_allocated_chapwrrtg(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chapwrrtg(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_chapwrrtg();

  private:
  const ::commonmodule::ASG& _internal_chapwrrtg() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_chapwrrtg();

  public:
  // .commonmodule.ASG ChaPwrTgt = 5;
  bool has_chapwrtgt() const;
  void clear_chapwrtgt() ;
  const ::commonmodule::ASG& chapwrtgt() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_chapwrtgt();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_chapwrtgt();
  void set_allocated_chapwrtgt(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chapwrtgt(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_chapwrtgt();

  private:
  const ::commonmodule::ASG& _internal_chapwrtgt() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_chapwrtgt();

  public:
  // .commonmodule.ASG ChaPwrLim = 6;
  bool has_chapwrlim() const;
  void clear_chapwrlim() ;
  const ::commonmodule::ASG& chapwrlim() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_chapwrlim();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_chapwrlim();
  void set_allocated_chapwrlim(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chapwrlim(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_chapwrlim();

  private:
  const ::commonmodule::ASG& _internal_chapwrlim() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_chapwrlim();

  public:
  // .commonmodule.SPG ConnTypDC = 7;
  bool has_conntypdc() const;
  void clear_conntypdc() ;
  const ::commonmodule::SPG& conntypdc() const;
  [[nodiscard]] ::commonmodule::SPG* PROTOBUF_NULLABLE release_conntypdc();
  ::commonmodule::SPG* PROTOBUF_NONNULL mutable_conntypdc();
  void set_allocated_conntypdc(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conntypdc(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  ::commonmodule::SPG* PROTOBUF_NULLABLE unsafe_arena_release_conntypdc();

  private:
  const ::commonmodule::SPG& _internal_conntypdc() const;
  ::commonmodule::SPG* PROTOBUF_NONNULL _internal_mutable_conntypdc();

  public:
  // .commonmodule.SPG ConnTypPhs1 = 8;
  bool has_conntypphs1() const;
  void clear_conntypphs1() ;
  const ::commonmodule::SPG& conntypphs1() const;
  [[nodiscard]] ::commonmodule::SPG* PROTOBUF_NULLABLE release_conntypphs1();
  ::commonmodule::SPG* PROTOBUF_NONNULL mutable_conntypphs1();
  void set_allocated_conntypphs1(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conntypphs1(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  ::commonmodule::SPG* PROTOBUF_NULLABLE unsafe_arena_release_conntypphs1();

  private:
  const ::commonmodule::SPG& _internal_conntypphs1() const;
  ::commonmodule::SPG* PROTOBUF_NONNULL _internal_mutable_conntypphs1();

  public:
  // .commonmodule.SPG ConnTypPhs2 = 9;
  bool has_conntypphs2() const;
  void clear_conntypphs2() ;
  const ::commonmodule::SPG& conntypphs2() const;
  [[nodiscard]] ::commonmodule::SPG* PROTOBUF_NULLABLE release_conntypphs2();
  ::commonmodule::SPG* PROTOBUF_NONNULL mutable_conntypphs2();
  void set_allocated_conntypphs2(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conntypphs2(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  ::commonmodule::SPG* PROTOBUF_NULLABLE unsafe_arena_release_conntypphs2();

  private:
  const ::commonmodule::SPG& _internal_conntypphs2() const;
  ::commonmodule::SPG* PROTOBUF_NONNULL _internal_mutable_conntypphs2();

  public:
  // .commonmodule.SPG ConnTypPhs3 = 10;
  bool has_conntypphs3() const;
  void clear_conntypphs3() ;
  const ::commonmodule::SPG& conntypphs3() const;
  [[nodiscard]] ::commonmodule::SPG* PROTOBUF_NULLABLE release_conntypphs3();
  ::commonmodule::SPG* PROTOBUF_NONNULL mutable_conntypphs3();
  void set_allocated_conntypphs3(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conntypphs3(::commonmodule::SPG* PROTOBUF_NULLABLE value);
  ::commonmodule::SPG* PROTOBUF_NULLABLE unsafe_arena_release_conntypphs3();

  private:
  const ::commonmodule::SPG& _internal_conntypphs3() const;
  ::commonmodule::SPG* PROTOBUF_NONNULL _internal_mutable_conntypphs3();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.CapabilityRatingsDESE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10,
                                   10, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapabilityRatingsDESE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::CapabilityRatingsDEAO > capabilityratingsdeao_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::CapabilityRatingsDEDO > capabilityratingsdedo_;
    ::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE sourcecapabilityratings_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE chapwrrtg_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE chapwrtgt_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE chapwrlim_;
    ::commonmodule::SPG* PROTOBUF_NULLABLE conntypdc_;
    ::commonmodule::SPG* PROTOBUF_NULLABLE conntypphs1_;
    ::commonmodule::SPG* PROTOBUF_NULLABLE conntypphs2_;
    ::commonmodule::SPG* PROTOBUF_NULLABLE conntypphs3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CapabilityRatingsDESE_class_data_;
// -------------------------------------------------------------------

class CapabilityConfigurationDESE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.CapabilityConfigurationDESE) */ {
 public:
  inline CapabilityConfigurationDESE() : CapabilityConfigurationDESE(nullptr) {}
  ~CapabilityConfigurationDESE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapabilityConfigurationDESE* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapabilityConfigurationDESE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapabilityConfigurationDESE(::google::protobuf::internal::ConstantInitialized);

  inline CapabilityConfigurationDESE(const CapabilityConfigurationDESE& from) : CapabilityConfigurationDESE(nullptr, from) {}
  inline CapabilityConfigurationDESE(CapabilityConfigurationDESE&& from) noexcept
      : CapabilityConfigurationDESE(nullptr, ::std::move(from)) {}
  inline CapabilityConfigurationDESE& operator=(const CapabilityConfigurationDESE& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapabilityConfigurationDESE& operator=(CapabilityConfigurationDESE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapabilityConfigurationDESE& default_instance() {
    return *reinterpret_cast<const CapabilityConfigurationDESE*>(
        &_CapabilityConfigurationDESE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CapabilityConfigurationDESE& a, CapabilityConfigurationDESE& b) { a.Swap(&b); }
  inline void Swap(CapabilityConfigurationDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapabilityConfigurationDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapabilityConfigurationDESE* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapabilityConfigurationDESE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapabilityConfigurationDESE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapabilityConfigurationDESE& from) { CapabilityConfigurationDESE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapabilityConfigurationDESE* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.CapabilityConfigurationDESE"; }

 protected:
  explicit CapabilityConfigurationDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapabilityConfigurationDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapabilityConfigurationDESE& from);
  CapabilityConfigurationDESE(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapabilityConfigurationDESE&& from) noexcept
      : CapabilityConfigurationDESE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSourceCapabilityConfigurationFieldNumber = 1,
    kCapabilityConfigurationDEA0FieldNumber = 2,
    kCapabilityConfigurationDEDOFieldNumber = 3,
    kChaPwrRtgFieldNumber = 4,
    kChaPwrTgtFieldNumber = 5,
    kChaPwrLimFieldNumber = 6,
  };
  // .commonmodule.SourceCapabilityConfiguration sourceCapabilityConfiguration = 1 [(.uml.option_parent_message) = true];
  bool has_sourcecapabilityconfiguration() const;
  void clear_sourcecapabilityconfiguration() ;
  const ::commonmodule::SourceCapabilityConfiguration& sourcecapabilityconfiguration() const;
  [[nodiscard]] ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE release_sourcecapabilityconfiguration();
  ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NONNULL mutable_sourcecapabilityconfiguration();
  void set_allocated_sourcecapabilityconfiguration(::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sourcecapabilityconfiguration(::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE value);
  ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE unsafe_arena_release_sourcecapabilityconfiguration();

  private:
  const ::commonmodule::SourceCapabilityConfiguration& _internal_sourcecapabilityconfiguration() const;
  ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NONNULL _internal_mutable_sourcecapabilityconfiguration();

  public:
  // .evsemodule.CapabilityConfigurationDEAO capabilityConfigurationDEA0 = 2;
  bool has_capabilityconfigurationdea0() const;
  void clear_capabilityconfigurationdea0() ;
  const ::evsemodule::CapabilityConfigurationDEAO& capabilityconfigurationdea0() const;
  [[nodiscard]] ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE release_capabilityconfigurationdea0();
  ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NONNULL mutable_capabilityconfigurationdea0();
  void set_allocated_capabilityconfigurationdea0(::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_capabilityconfigurationdea0(::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE value);
  ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE unsafe_arena_release_capabilityconfigurationdea0();

  private:
  const ::evsemodule::CapabilityConfigurationDEAO& _internal_capabilityconfigurationdea0() const;
  ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NONNULL _internal_mutable_capabilityconfigurationdea0();

  public:
  // .evsemodule.CapabilityConfigurationDEDO capabilityConfigurationDEDO = 3;
  bool has_capabilityconfigurationdedo() const;
  void clear_capabilityconfigurationdedo() ;
  const ::evsemodule::CapabilityConfigurationDEDO& capabilityconfigurationdedo() const;
  [[nodiscard]] ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE release_capabilityconfigurationdedo();
  ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NONNULL mutable_capabilityconfigurationdedo();
  void set_allocated_capabilityconfigurationdedo(::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_capabilityconfigurationdedo(::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE value);
  ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE unsafe_arena_release_capabilityconfigurationdedo();

  private:
  const ::evsemodule::CapabilityConfigurationDEDO& _internal_capabilityconfigurationdedo() const;
  ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NONNULL _internal_mutable_capabilityconfigurationdedo();

  public:
  // .commonmodule.ASG ChaPwrRtg = 4;
  bool has_chapwrrtg() const;
  void clear_chapwrrtg() ;
  const ::commonmodule::ASG& chapwrrtg() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_chapwrrtg();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_chapwrrtg();
  void set_allocated_chapwrrtg(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chapwrrtg(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_chapwrrtg();

  private:
  const ::commonmodule::ASG& _internal_chapwrrtg() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_chapwrrtg();

  public:
  // .commonmodule.ASG ChaPwrTgt = 5;
  bool has_chapwrtgt() const;
  void clear_chapwrtgt() ;
  const ::commonmodule::ASG& chapwrtgt() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_chapwrtgt();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_chapwrtgt();
  void set_allocated_chapwrtgt(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chapwrtgt(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_chapwrtgt();

  private:
  const ::commonmodule::ASG& _internal_chapwrtgt() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_chapwrtgt();

  public:
  // .commonmodule.ASG ChaPwrLim = 6;
  bool has_chapwrlim() const;
  void clear_chapwrlim() ;
  const ::commonmodule::ASG& chapwrlim() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_chapwrlim();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_chapwrlim();
  void set_allocated_chapwrlim(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chapwrlim(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_chapwrlim();

  private:
  const ::commonmodule::ASG& _internal_chapwrlim() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_chapwrlim();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.CapabilityConfigurationDESE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapabilityConfigurationDESE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE sourcecapabilityconfiguration_;
    ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE capabilityconfigurationdea0_;
    ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE capabilityconfigurationdedo_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE chapwrrtg_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE chapwrtgt_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE chapwrlim_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CapabilityConfigurationDESE_class_data_;
// -------------------------------------------------------------------

class EventAndStatusDEDO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EventAndStatusDEDO) */ {
 public:
  inline EventAndStatusDEDO() : EventAndStatusDEDO(nullptr) {}
  ~EventAndStatusDEDO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventAndStatusDEDO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventAndStatusDEDO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventAndStatusDEDO(::google::protobuf::internal::ConstantInitialized);

  inline EventAndStatusDEDO(const EventAndStatusDEDO& from) : EventAndStatusDEDO(nullptr, from) {}
  inline EventAndStatusDEDO(EventAndStatusDEDO&& from) noexcept
      : EventAndStatusDEDO(nullptr, ::std::move(from)) {}
  inline EventAndStatusDEDO& operator=(const EventAndStatusDEDO& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAndStatusDEDO& operator=(EventAndStatusDEDO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAndStatusDEDO& default_instance() {
    return *reinterpret_cast<const EventAndStatusDEDO*>(
        &_EventAndStatusDEDO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(EventAndStatusDEDO& a, EventAndStatusDEDO& b) { a.Swap(&b); }
  inline void Swap(EventAndStatusDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAndStatusDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAndStatusDEDO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventAndStatusDEDO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventAndStatusDEDO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventAndStatusDEDO& from) { EventAndStatusDEDO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventAndStatusDEDO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EventAndStatusDEDO"; }

 protected:
  explicit EventAndStatusDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EventAndStatusDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EventAndStatusDEDO& from);
  EventAndStatusDEDO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EventAndStatusDEDO&& from) noexcept
      : EventAndStatusDEDO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kEventAndStatusDEEVFieldNumber = 2,
    kCabRtgDCFieldNumber = 3,
    kConnStAFieldNumber = 4,
    kConnStCFieldNumber = 5,
    kPlgStDCFieldNumber = 6,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforeventandstatus();

  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL _internal_mutable_logicalnodeforeventandstatus();

  public:
  // .evsemodule.EventAndStatusDEEV eventAndStatusDEEV = 2;
  bool has_eventandstatusdeev() const;
  void clear_eventandstatusdeev() ;
  const ::evsemodule::EventAndStatusDEEV& eventandstatusdeev() const;
  [[nodiscard]] ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE release_eventandstatusdeev();
  ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL mutable_eventandstatusdeev();
  void set_allocated_eventandstatusdeev(::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventandstatusdeev(::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value);
  ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE unsafe_arena_release_eventandstatusdeev();

  private:
  const ::evsemodule::EventAndStatusDEEV& _internal_eventandstatusdeev() const;
  ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL _internal_mutable_eventandstatusdeev();

  public:
  // .evsemodule.ENS_EVDCCableCapabilityKind CabRtgDC = 3;
  bool has_cabrtgdc() const;
  void clear_cabrtgdc() ;
  const ::evsemodule::ENS_EVDCCableCapabilityKind& cabrtgdc() const;
  [[nodiscard]] ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE release_cabrtgdc();
  ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL mutable_cabrtgdc();
  void set_allocated_cabrtgdc(::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_cabrtgdc(::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE unsafe_arena_release_cabrtgdc();

  private:
  const ::evsemodule::ENS_EVDCCableCapabilityKind& _internal_cabrtgdc() const;
  ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL _internal_mutable_cabrtgdc();

  public:
  // .evsemodule.ENS_EVDCConnectionStateAKind ConnStA = 4;
  bool has_connsta() const;
  void clear_connsta() ;
  const ::evsemodule::ENS_EVDCConnectionStateAKind& connsta() const;
  [[nodiscard]] ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE release_connsta();
  ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL mutable_connsta();
  void set_allocated_connsta(::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_connsta(::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE unsafe_arena_release_connsta();

  private:
  const ::evsemodule::ENS_EVDCConnectionStateAKind& _internal_connsta() const;
  ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL _internal_mutable_connsta();

  public:
  // .evsemodule.ENS_EVDCConnectionStateCKind ConnStC = 5;
  bool has_connstc() const;
  void clear_connstc() ;
  const ::evsemodule::ENS_EVDCConnectionStateCKind& connstc() const;
  [[nodiscard]] ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE release_connstc();
  ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL mutable_connstc();
  void set_allocated_connstc(::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_connstc(::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE unsafe_arena_release_connstc();

  private:
  const ::evsemodule::ENS_EVDCConnectionStateCKind& _internal_connstc() const;
  ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL _internal_mutable_connstc();

  public:
  // .evsemodule.ENS_EVDCPlugStateKind PlgStDC = 6;
  bool has_plgstdc() const;
  void clear_plgstdc() ;
  const ::evsemodule::ENS_EVDCPlugStateKind& plgstdc() const;
  [[nodiscard]] ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE release_plgstdc();
  ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NONNULL mutable_plgstdc();
  void set_allocated_plgstdc(::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_plgstdc(::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE unsafe_arena_release_plgstdc();

  private:
  const ::evsemodule::ENS_EVDCPlugStateKind& _internal_plgstdc() const;
  ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NONNULL _internal_mutable_plgstdc();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EventAndStatusDEDO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EventAndStatusDEDO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE logicalnodeforeventandstatus_;
    ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE eventandstatusdeev_;
    ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE cabrtgdc_;
    ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE connsta_;
    ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE connstc_;
    ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE plgstdc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDEDO_class_data_;
// -------------------------------------------------------------------

class EventAndStatusDEAO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EventAndStatusDEAO) */ {
 public:
  inline EventAndStatusDEAO() : EventAndStatusDEAO(nullptr) {}
  ~EventAndStatusDEAO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventAndStatusDEAO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventAndStatusDEAO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventAndStatusDEAO(::google::protobuf::internal::ConstantInitialized);

  inline EventAndStatusDEAO(const EventAndStatusDEAO& from) : EventAndStatusDEAO(nullptr, from) {}
  inline EventAndStatusDEAO(EventAndStatusDEAO&& from) noexcept
      : EventAndStatusDEAO(nullptr, ::std::move(from)) {}
  inline EventAndStatusDEAO& operator=(const EventAndStatusDEAO& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAndStatusDEAO& operator=(EventAndStatusDEAO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAndStatusDEAO& default_instance() {
    return *reinterpret_cast<const EventAndStatusDEAO*>(
        &_EventAndStatusDEAO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(EventAndStatusDEAO& a, EventAndStatusDEAO& b) { a.Swap(&b); }
  inline void Swap(EventAndStatusDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAndStatusDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAndStatusDEAO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventAndStatusDEAO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventAndStatusDEAO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventAndStatusDEAO& from) { EventAndStatusDEAO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventAndStatusDEAO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EventAndStatusDEAO"; }

 protected:
  explicit EventAndStatusDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EventAndStatusDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EventAndStatusDEAO& from);
  EventAndStatusDEAO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EventAndStatusDEAO&& from) noexcept
      : EventAndStatusDEAO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kEventAndStatusDEEVFieldNumber = 2,
    kDigCommFieldNumber = 3,
    kConnStFieldNumber = 4,
    kPlgStACFieldNumber = 5,
    kCabRtgACFieldNumber = 6,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforeventandstatus();

  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL _internal_mutable_logicalnodeforeventandstatus();

  public:
  // .evsemodule.EventAndStatusDEEV eventAndStatusDEEV = 2;
  bool has_eventandstatusdeev() const;
  void clear_eventandstatusdeev() ;
  const ::evsemodule::EventAndStatusDEEV& eventandstatusdeev() const;
  [[nodiscard]] ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE release_eventandstatusdeev();
  ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL mutable_eventandstatusdeev();
  void set_allocated_eventandstatusdeev(::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventandstatusdeev(::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value);
  ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE unsafe_arena_release_eventandstatusdeev();

  private:
  const ::evsemodule::EventAndStatusDEEV& _internal_eventandstatusdeev() const;
  ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL _internal_mutable_eventandstatusdeev();

  public:
  // .commonmodule.StatusSPS DigComm = 3;
  bool has_digcomm() const;
  void clear_digcomm() ;
  const ::commonmodule::StatusSPS& digcomm() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_digcomm();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_digcomm();
  void set_allocated_digcomm(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_digcomm(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_digcomm();

  private:
  const ::commonmodule::StatusSPS& _internal_digcomm() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_digcomm();

  public:
  // .evsemodule.ENS_EVACConnectionStateKind ConnSt = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_connst() const;
  void clear_connst() ;
  const ::evsemodule::ENS_EVACConnectionStateKind& connst() const;
  [[nodiscard]] ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE release_connst();
  ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NONNULL mutable_connst();
  void set_allocated_connst(::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_connst(::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE unsafe_arena_release_connst();

  private:
  const ::evsemodule::ENS_EVACConnectionStateKind& _internal_connst() const;
  ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NONNULL _internal_mutable_connst();

  public:
  // .evsemodule.ENS_EVACPlugStateKind PlgStAC = 5;
  bool has_plgstac() const;
  void clear_plgstac() ;
  const ::evsemodule::ENS_EVACPlugStateKind& plgstac() const;
  [[nodiscard]] ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE release_plgstac();
  ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NONNULL mutable_plgstac();
  void set_allocated_plgstac(::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_plgstac(::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE unsafe_arena_release_plgstac();

  private:
  const ::evsemodule::ENS_EVACPlugStateKind& _internal_plgstac() const;
  ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NONNULL _internal_mutable_plgstac();

  public:
  // .evsemodule.ENS_EVACCableCapabilityKind CabRtgAC = 6;
  bool has_cabrtgac() const;
  void clear_cabrtgac() ;
  const ::evsemodule::ENS_EVACCableCapabilityKind& cabrtgac() const;
  [[nodiscard]] ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE release_cabrtgac();
  ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL mutable_cabrtgac();
  void set_allocated_cabrtgac(::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_cabrtgac(::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE value);
  ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE unsafe_arena_release_cabrtgac();

  private:
  const ::evsemodule::ENS_EVACCableCapabilityKind& _internal_cabrtgac() const;
  ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL _internal_mutable_cabrtgac();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EventAndStatusDEAO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EventAndStatusDEAO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE logicalnodeforeventandstatus_;
    ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE eventandstatusdeev_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE digcomm_;
    ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE connst_;
    ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE plgstac_;
    ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE cabrtgac_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDEAO_class_data_;
// -------------------------------------------------------------------

class EVSEReadingDESE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEReadingDESE) */ {
 public:
  inline EVSEReadingDESE() : EVSEReadingDESE(nullptr) {}
  ~EVSEReadingDESE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEReadingDESE* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEReadingDESE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEReadingDESE(::google::protobuf::internal::ConstantInitialized);

  inline EVSEReadingDESE(const EVSEReadingDESE& from) : EVSEReadingDESE(nullptr, from) {}
  inline EVSEReadingDESE(EVSEReadingDESE&& from) noexcept
      : EVSEReadingDESE(nullptr, ::std::move(from)) {}
  inline EVSEReadingDESE& operator=(const EVSEReadingDESE& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEReadingDESE& operator=(EVSEReadingDESE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEReadingDESE& default_instance() {
    return *reinterpret_cast<const EVSEReadingDESE*>(
        &_EVSEReadingDESE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(EVSEReadingDESE& a, EVSEReadingDESE& b) { a.Swap(&b); }
  inline void Swap(EVSEReadingDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEReadingDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEReadingDESE* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEReadingDESE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEReadingDESE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEReadingDESE& from) { EVSEReadingDESE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEReadingDESE* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEReadingDESE"; }

 protected:
  explicit EVSEReadingDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEReadingDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEReadingDESE& from);
  EVSEReadingDESE(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEReadingDESE&& from) noexcept
      : EVSEReadingDESE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeFieldNumber = 1,
    kReadingDEAOFieldNumber = 2,
    kReadingDEDOFieldNumber = 3,
    kChaVFieldNumber = 4,
    kChaAFieldNumber = 5,
    kChaWFieldNumber = 6,
    kChaWhFieldNumber = 7,
  };
  // .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnode() const;
  void clear_logicalnode() ;
  const ::commonmodule::LogicalNode& logicalnode() const;
  [[nodiscard]] ::commonmodule::LogicalNode* PROTOBUF_NULLABLE release_logicalnode();
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL mutable_logicalnode();
  void set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNode* PROTOBUF_NULLABLE unsafe_arena_release_logicalnode();

  private:
  const ::commonmodule::LogicalNode& _internal_logicalnode() const;
  ::commonmodule::LogicalNode* PROTOBUF_NONNULL _internal_mutable_logicalnode();

  public:
  // .evsemodule.ReadingDEAO readingDEAO = 2;
  bool has_readingdeao() const;
  void clear_readingdeao() ;
  const ::evsemodule::ReadingDEAO& readingdeao() const;
  [[nodiscard]] ::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE release_readingdeao();
  ::evsemodule::ReadingDEAO* PROTOBUF_NONNULL mutable_readingdeao();
  void set_allocated_readingdeao(::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingdeao(::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE value);
  ::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE unsafe_arena_release_readingdeao();

  private:
  const ::evsemodule::ReadingDEAO& _internal_readingdeao() const;
  ::evsemodule::ReadingDEAO* PROTOBUF_NONNULL _internal_mutable_readingdeao();

  public:
  // .evsemodule.ReadingDEDO readingDEDO = 3;
  bool has_readingdedo() const;
  void clear_readingdedo() ;
  const ::evsemodule::ReadingDEDO& readingdedo() const;
  [[nodiscard]] ::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE release_readingdedo();
  ::evsemodule::ReadingDEDO* PROTOBUF_NONNULL mutable_readingdedo();
  void set_allocated_readingdedo(::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingdedo(::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE value);
  ::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE unsafe_arena_release_readingdedo();

  private:
  const ::evsemodule::ReadingDEDO& _internal_readingdedo() const;
  ::evsemodule::ReadingDEDO* PROTOBUF_NONNULL _internal_mutable_readingdedo();

  public:
  // .commonmodule.MV ChaV = 4;
  bool has_chav() const;
  void clear_chav() ;
  const ::commonmodule::MV& chav() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_chav();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_chav();
  void set_allocated_chav(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chav(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_chav();

  private:
  const ::commonmodule::MV& _internal_chav() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_chav();

  public:
  // .commonmodule.MV ChaA = 5;
  bool has_chaa() const;
  void clear_chaa() ;
  const ::commonmodule::MV& chaa() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_chaa();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_chaa();
  void set_allocated_chaa(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chaa(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_chaa();

  private:
  const ::commonmodule::MV& _internal_chaa() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_chaa();

  public:
  // .commonmodule.MV ChaW = 6;
  bool has_chaw() const;
  void clear_chaw() ;
  const ::commonmodule::MV& chaw() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_chaw();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_chaw();
  void set_allocated_chaw(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chaw(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_chaw();

  private:
  const ::commonmodule::MV& _internal_chaw() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_chaw();

  public:
  // .commonmodule.MV ChaWh = 7;
  bool has_chawh() const;
  void clear_chawh() ;
  const ::commonmodule::MV& chawh() const;
  [[nodiscard]] ::commonmodule::MV* PROTOBUF_NULLABLE release_chawh();
  ::commonmodule::MV* PROTOBUF_NONNULL mutable_chawh();
  void set_allocated_chawh(::commonmodule::MV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chawh(::commonmodule::MV* PROTOBUF_NULLABLE value);
  ::commonmodule::MV* PROTOBUF_NULLABLE unsafe_arena_release_chawh();

  private:
  const ::commonmodule::MV& _internal_chawh() const;
  ::commonmodule::MV* PROTOBUF_NONNULL _internal_mutable_chawh();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEReadingDESE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEReadingDESE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE logicalnode_;
    ::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE readingdeao_;
    ::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE readingdedo_;
    ::commonmodule::MV* PROTOBUF_NULLABLE chav_;
    ::commonmodule::MV* PROTOBUF_NULLABLE chaa_;
    ::commonmodule::MV* PROTOBUF_NULLABLE chaw_;
    ::commonmodule::MV* PROTOBUF_NULLABLE chawh_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEReadingDESE_class_data_;
// -------------------------------------------------------------------

class EVSEPointStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEPointStatus) */ {
 public:
  inline EVSEPointStatus() : EVSEPointStatus(nullptr) {}
  ~EVSEPointStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEPointStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEPointStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEPointStatus(::google::protobuf::internal::ConstantInitialized);

  inline EVSEPointStatus(const EVSEPointStatus& from) : EVSEPointStatus(nullptr, from) {}
  inline EVSEPointStatus(EVSEPointStatus&& from) noexcept
      : EVSEPointStatus(nullptr, ::std::move(from)) {}
  inline EVSEPointStatus& operator=(const EVSEPointStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEPointStatus& operator=(EVSEPointStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEPointStatus& default_instance() {
    return *reinterpret_cast<const EVSEPointStatus*>(
        &_EVSEPointStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(EVSEPointStatus& a, EVSEPointStatus& b) { a.Swap(&b); }
  inline void Swap(EVSEPointStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEPointStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEPointStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEPointStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEPointStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEPointStatus& from) { EVSEPointStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEPointStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEPointStatus"; }

 protected:
  explicit EVSEPointStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEPointStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEPointStatus& from);
  EVSEPointStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEPointStatus&& from) noexcept
      : EVSEPointStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFunctionFieldNumber = 3,
    kModeFieldNumber = 4,
    kRampRatesFieldNumber = 7,
    kResetFieldNumber = 10,
    kStateFieldNumber = 11,
    kEnterServiceOperationFieldNumber = 16,
    kHzWOperationFieldNumber = 17,
    kLimitWOperationFieldNumber = 18,
    kPFOperationFieldNumber = 19,
    kTmHzTripOperationFieldNumber = 20,
    kTmVoltTripOperationFieldNumber = 21,
    kVArOperationFieldNumber = 22,
    kVoltVarOperationFieldNumber = 23,
    kVoltWOperationFieldNumber = 24,
    kWVarOperationFieldNumber = 25,
    kWOperationFieldNumber = 26,
    kNoRestricEnableFieldNumber = 27,
    kChargeControlEnableFieldNumber = 28,
  };
  // .evsemodule.EVSEFunction function = 3;
  bool has_function() const;
  void clear_function() ;
  const ::evsemodule::EVSEFunction& function() const;
  [[nodiscard]] ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE release_function();
  ::evsemodule::EVSEFunction* PROTOBUF_NONNULL mutable_function();
  void set_allocated_function(::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_function(::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE unsafe_arena_release_function();

  private:
  const ::evsemodule::EVSEFunction& _internal_function() const;
  ::evsemodule::EVSEFunction* PROTOBUF_NONNULL _internal_mutable_function();

  public:
  // .commonmodule.ENG_GridConnectModeKind mode = 4;
  bool has_mode() const;
  void clear_mode() ;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  [[nodiscard]] ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE release_mode();
  ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value);
  ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE unsafe_arena_release_mode();

  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_mode() const;
  ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL _internal_mutable_mode();

  public:
  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  [[nodiscard]] ::commonmodule::RampRate* PROTOBUF_NULLABLE release_ramprates();
  ::commonmodule::RampRate* PROTOBUF_NONNULL mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  ::commonmodule::RampRate* PROTOBUF_NULLABLE unsafe_arena_release_ramprates();

  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* PROTOBUF_NONNULL _internal_mutable_ramprates();

  public:
  // .commonmodule.ControlSPC reset = 10;
  bool has_reset() const;
  void clear_reset() ;
  const ::commonmodule::ControlSPC& reset() const;
  [[nodiscard]] ::commonmodule::ControlSPC* PROTOBUF_NULLABLE release_reset();
  ::commonmodule::ControlSPC* PROTOBUF_NONNULL mutable_reset();
  void set_allocated_reset(::commonmodule::ControlSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reset(::commonmodule::ControlSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlSPC* PROTOBUF_NULLABLE unsafe_arena_release_reset();

  private:
  const ::commonmodule::ControlSPC& _internal_reset() const;
  ::commonmodule::ControlSPC* PROTOBUF_NONNULL _internal_mutable_reset();

  public:
  // .evsemodule.Optional_ChargingStateKind state = 11;
  bool has_state() const;
  void clear_state() ;
  const ::evsemodule::Optional_ChargingStateKind& state() const;
  [[nodiscard]] ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE release_state();
  ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL mutable_state();
  void set_allocated_state(::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_state(::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value);
  ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE unsafe_arena_release_state();

  private:
  const ::evsemodule::Optional_ChargingStateKind& _internal_state() const;
  ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // .commonmodule.EnterServiceAPC enterServiceOperation = 16;
  bool has_enterserviceoperation() const;
  void clear_enterserviceoperation() ;
  const ::commonmodule::EnterServiceAPC& enterserviceoperation() const;
  [[nodiscard]] ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE release_enterserviceoperation();
  ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL mutable_enterserviceoperation();
  void set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE unsafe_arena_release_enterserviceoperation();

  private:
  const ::commonmodule::EnterServiceAPC& _internal_enterserviceoperation() const;
  ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL _internal_mutable_enterserviceoperation();

  public:
  // .commonmodule.HzWAPC hzWOperation = 17;
  bool has_hzwoperation() const;
  void clear_hzwoperation() ;
  const ::commonmodule::HzWAPC& hzwoperation() const;
  [[nodiscard]] ::commonmodule::HzWAPC* PROTOBUF_NULLABLE release_hzwoperation();
  ::commonmodule::HzWAPC* PROTOBUF_NONNULL mutable_hzwoperation();
  void set_allocated_hzwoperation(::commonmodule::HzWAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hzwoperation(::commonmodule::HzWAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::HzWAPC* PROTOBUF_NULLABLE unsafe_arena_release_hzwoperation();

  private:
  const ::commonmodule::HzWAPC& _internal_hzwoperation() const;
  ::commonmodule::HzWAPC* PROTOBUF_NONNULL _internal_mutable_hzwoperation();

  public:
  // .commonmodule.LimitWAPC limitWOperation = 18;
  bool has_limitwoperation() const;
  void clear_limitwoperation() ;
  const ::commonmodule::LimitWAPC& limitwoperation() const;
  [[nodiscard]] ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE release_limitwoperation();
  ::commonmodule::LimitWAPC* PROTOBUF_NONNULL mutable_limitwoperation();
  void set_allocated_limitwoperation(::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_limitwoperation(::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE unsafe_arena_release_limitwoperation();

  private:
  const ::commonmodule::LimitWAPC& _internal_limitwoperation() const;
  ::commonmodule::LimitWAPC* PROTOBUF_NONNULL _internal_mutable_limitwoperation();

  public:
  // .commonmodule.PFSPC pFOperation = 19;
  bool has_pfoperation() const;
  void clear_pfoperation() ;
  const ::commonmodule::PFSPC& pfoperation() const;
  [[nodiscard]] ::commonmodule::PFSPC* PROTOBUF_NULLABLE release_pfoperation();
  ::commonmodule::PFSPC* PROTOBUF_NONNULL mutable_pfoperation();
  void set_allocated_pfoperation(::commonmodule::PFSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pfoperation(::commonmodule::PFSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PFSPC* PROTOBUF_NULLABLE unsafe_arena_release_pfoperation();

  private:
  const ::commonmodule::PFSPC& _internal_pfoperation() const;
  ::commonmodule::PFSPC* PROTOBUF_NONNULL _internal_mutable_pfoperation();

  public:
  // .commonmodule.TmHzCSG tmHzTripOperation = 20;
  bool has_tmhztripoperation() const;
  void clear_tmhztripoperation() ;
  const ::commonmodule::TmHzCSG& tmhztripoperation() const;
  [[nodiscard]] ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE release_tmhztripoperation();
  ::commonmodule::TmHzCSG* PROTOBUF_NONNULL mutable_tmhztripoperation();
  void set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE unsafe_arena_release_tmhztripoperation();

  private:
  const ::commonmodule::TmHzCSG& _internal_tmhztripoperation() const;
  ::commonmodule::TmHzCSG* PROTOBUF_NONNULL _internal_mutable_tmhztripoperation();

  public:
  // .commonmodule.TmVoltCSG tmVoltTripOperation = 21;
  bool has_tmvolttripoperation() const;
  void clear_tmvolttripoperation() ;
  const ::commonmodule::TmVoltCSG& tmvolttripoperation() const;
  [[nodiscard]] ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE release_tmvolttripoperation();
  ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL mutable_tmvolttripoperation();
  void set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE unsafe_arena_release_tmvolttripoperation();

  private:
  const ::commonmodule::TmVoltCSG& _internal_tmvolttripoperation() const;
  ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL _internal_mutable_tmvolttripoperation();

  public:
  // .commonmodule.VarSPC vArOperation = 22;
  bool has_varoperation() const;
  void clear_varoperation() ;
  const ::commonmodule::VarSPC& varoperation() const;
  [[nodiscard]] ::commonmodule::VarSPC* PROTOBUF_NULLABLE release_varoperation();
  ::commonmodule::VarSPC* PROTOBUF_NONNULL mutable_varoperation();
  void set_allocated_varoperation(::commonmodule::VarSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_varoperation(::commonmodule::VarSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::VarSPC* PROTOBUF_NULLABLE unsafe_arena_release_varoperation();

  private:
  const ::commonmodule::VarSPC& _internal_varoperation() const;
  ::commonmodule::VarSPC* PROTOBUF_NONNULL _internal_mutable_varoperation();

  public:
  // .commonmodule.VoltVarCSG voltVarOperation = 23;
  bool has_voltvaroperation() const;
  void clear_voltvaroperation() ;
  const ::commonmodule::VoltVarCSG& voltvaroperation() const;
  [[nodiscard]] ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE release_voltvaroperation();
  ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL mutable_voltvaroperation();
  void set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE unsafe_arena_release_voltvaroperation();

  private:
  const ::commonmodule::VoltVarCSG& _internal_voltvaroperation() const;
  ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL _internal_mutable_voltvaroperation();

  public:
  // .commonmodule.VoltWCSG voltWOperation = 24;
  bool has_voltwoperation() const;
  void clear_voltwoperation() ;
  const ::commonmodule::VoltWCSG& voltwoperation() const;
  [[nodiscard]] ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE release_voltwoperation();
  ::commonmodule::VoltWCSG* PROTOBUF_NONNULL mutable_voltwoperation();
  void set_allocated_voltwoperation(::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltwoperation(::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE unsafe_arena_release_voltwoperation();

  private:
  const ::commonmodule::VoltWCSG& _internal_voltwoperation() const;
  ::commonmodule::VoltWCSG* PROTOBUF_NONNULL _internal_mutable_voltwoperation();

  public:
  // .commonmodule.WVarCSG wVarOperation = 25;
  bool has_wvaroperation() const;
  void clear_wvaroperation() ;
  const ::commonmodule::WVarCSG& wvaroperation() const;
  [[nodiscard]] ::commonmodule::WVarCSG* PROTOBUF_NULLABLE release_wvaroperation();
  ::commonmodule::WVarCSG* PROTOBUF_NONNULL mutable_wvaroperation();
  void set_allocated_wvaroperation(::commonmodule::WVarCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_wvaroperation(::commonmodule::WVarCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::WVarCSG* PROTOBUF_NULLABLE unsafe_arena_release_wvaroperation();

  private:
  const ::commonmodule::WVarCSG& _internal_wvaroperation() const;
  ::commonmodule::WVarCSG* PROTOBUF_NONNULL _internal_mutable_wvaroperation();

  public:
  // .commonmodule.WSPC wOperation = 26;
  bool has_woperation() const;
  void clear_woperation() ;
  const ::commonmodule::WSPC& woperation() const;
  [[nodiscard]] ::commonmodule::WSPC* PROTOBUF_NULLABLE release_woperation();
  ::commonmodule::WSPC* PROTOBUF_NONNULL mutable_woperation();
  void set_allocated_woperation(::commonmodule::WSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_woperation(::commonmodule::WSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::WSPC* PROTOBUF_NULLABLE unsafe_arena_release_woperation();

  private:
  const ::commonmodule::WSPC& _internal_woperation() const;
  ::commonmodule::WSPC* PROTOBUF_NONNULL _internal_mutable_woperation();

  public:
  // .commonmodule.StatusSPS noRestricEnable = 27;
  bool has_norestricenable() const;
  void clear_norestricenable() ;
  const ::commonmodule::StatusSPS& norestricenable() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_norestricenable();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_norestricenable();
  void set_allocated_norestricenable(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_norestricenable(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_norestricenable();

  private:
  const ::commonmodule::StatusSPS& _internal_norestricenable() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_norestricenable();

  public:
  // .commonmodule.StatusSPS chargeControlEnable = 28;
  bool has_chargecontrolenable() const;
  void clear_chargecontrolenable() ;
  const ::commonmodule::StatusSPS& chargecontrolenable() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_chargecontrolenable();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_chargecontrolenable();
  void set_allocated_chargecontrolenable(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chargecontrolenable(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_chargecontrolenable();

  private:
  const ::commonmodule::StatusSPS& _internal_chargecontrolenable() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_chargecontrolenable();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEPointStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 18,
                                   18, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEPointStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE function_;
    ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE mode_;
    ::commonmodule::RampRate* PROTOBUF_NULLABLE ramprates_;
    ::commonmodule::ControlSPC* PROTOBUF_NULLABLE reset_;
    ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE state_;
    ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE enterserviceoperation_;
    ::commonmodule::HzWAPC* PROTOBUF_NULLABLE hzwoperation_;
    ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE limitwoperation_;
    ::commonmodule::PFSPC* PROTOBUF_NULLABLE pfoperation_;
    ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE tmhztripoperation_;
    ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE tmvolttripoperation_;
    ::commonmodule::VarSPC* PROTOBUF_NULLABLE varoperation_;
    ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE voltvaroperation_;
    ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE voltwoperation_;
    ::commonmodule::WVarCSG* PROTOBUF_NULLABLE wvaroperation_;
    ::commonmodule::WSPC* PROTOBUF_NULLABLE woperation_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE norestricenable_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE chargecontrolenable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEPointStatus_class_data_;
// -------------------------------------------------------------------

class EVSEPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEPoint) */ {
 public:
  inline EVSEPoint() : EVSEPoint(nullptr) {}
  ~EVSEPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEPoint* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEPoint(::google::protobuf::internal::ConstantInitialized);

  inline EVSEPoint(const EVSEPoint& from) : EVSEPoint(nullptr, from) {}
  inline EVSEPoint(EVSEPoint&& from) noexcept
      : EVSEPoint(nullptr, ::std::move(from)) {}
  inline EVSEPoint& operator=(const EVSEPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEPoint& operator=(EVSEPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEPoint& default_instance() {
    return *reinterpret_cast<const EVSEPoint*>(
        &_EVSEPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(EVSEPoint& a, EVSEPoint& b) { a.Swap(&b); }
  inline void Swap(EVSEPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEPoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEPoint& from) { EVSEPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEPoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEPoint"; }

 protected:
  explicit EVSEPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEPoint& from);
  EVSEPoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEPoint&& from) noexcept
      : EVSEPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFunctionFieldNumber = 3,
    kModeFieldNumber = 4,
    kRampRatesFieldNumber = 7,
    kResetFieldNumber = 10,
    kStateFieldNumber = 11,
    kEnterServiceOperationFieldNumber = 16,
    kHzWOperationFieldNumber = 17,
    kLimitWOperationFieldNumber = 18,
    kPFOperationFieldNumber = 19,
    kTmHzTripOperationFieldNumber = 20,
    kTmVoltTripOperationFieldNumber = 21,
    kVArOperationFieldNumber = 22,
    kVoltVarOperationFieldNumber = 23,
    kVoltWOperationFieldNumber = 24,
    kWVarOperationFieldNumber = 25,
    kWOperationFieldNumber = 26,
  };
  // .evsemodule.EVSEFunction function = 3;
  bool has_function() const;
  void clear_function() ;
  const ::evsemodule::EVSEFunction& function() const;
  [[nodiscard]] ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE release_function();
  ::evsemodule::EVSEFunction* PROTOBUF_NONNULL mutable_function();
  void set_allocated_function(::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_function(::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE unsafe_arena_release_function();

  private:
  const ::evsemodule::EVSEFunction& _internal_function() const;
  ::evsemodule::EVSEFunction* PROTOBUF_NONNULL _internal_mutable_function();

  public:
  // .commonmodule.ENG_GridConnectModeKind mode = 4;
  bool has_mode() const;
  void clear_mode() ;
  const ::commonmodule::ENG_GridConnectModeKind& mode() const;
  [[nodiscard]] ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE release_mode();
  ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL mutable_mode();
  void set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value);
  ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE unsafe_arena_release_mode();

  private:
  const ::commonmodule::ENG_GridConnectModeKind& _internal_mode() const;
  ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL _internal_mutable_mode();

  public:
  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  [[nodiscard]] ::commonmodule::RampRate* PROTOBUF_NULLABLE release_ramprates();
  ::commonmodule::RampRate* PROTOBUF_NONNULL mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  ::commonmodule::RampRate* PROTOBUF_NULLABLE unsafe_arena_release_ramprates();

  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* PROTOBUF_NONNULL _internal_mutable_ramprates();

  public:
  // .commonmodule.ControlSPC reset = 10;
  bool has_reset() const;
  void clear_reset() ;
  const ::commonmodule::ControlSPC& reset() const;
  [[nodiscard]] ::commonmodule::ControlSPC* PROTOBUF_NULLABLE release_reset();
  ::commonmodule::ControlSPC* PROTOBUF_NONNULL mutable_reset();
  void set_allocated_reset(::commonmodule::ControlSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reset(::commonmodule::ControlSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlSPC* PROTOBUF_NULLABLE unsafe_arena_release_reset();

  private:
  const ::commonmodule::ControlSPC& _internal_reset() const;
  ::commonmodule::ControlSPC* PROTOBUF_NONNULL _internal_mutable_reset();

  public:
  // .evsemodule.Optional_ChargingStateKind state = 11;
  bool has_state() const;
  void clear_state() ;
  const ::evsemodule::Optional_ChargingStateKind& state() const;
  [[nodiscard]] ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE release_state();
  ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL mutable_state();
  void set_allocated_state(::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_state(::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value);
  ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE unsafe_arena_release_state();

  private:
  const ::evsemodule::Optional_ChargingStateKind& _internal_state() const;
  ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // .commonmodule.EnterServiceAPC enterServiceOperation = 16;
  bool has_enterserviceoperation() const;
  void clear_enterserviceoperation() ;
  const ::commonmodule::EnterServiceAPC& enterserviceoperation() const;
  [[nodiscard]] ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE release_enterserviceoperation();
  ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL mutable_enterserviceoperation();
  void set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE unsafe_arena_release_enterserviceoperation();

  private:
  const ::commonmodule::EnterServiceAPC& _internal_enterserviceoperation() const;
  ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL _internal_mutable_enterserviceoperation();

  public:
  // .commonmodule.HzWAPC hzWOperation = 17;
  bool has_hzwoperation() const;
  void clear_hzwoperation() ;
  const ::commonmodule::HzWAPC& hzwoperation() const;
  [[nodiscard]] ::commonmodule::HzWAPC* PROTOBUF_NULLABLE release_hzwoperation();
  ::commonmodule::HzWAPC* PROTOBUF_NONNULL mutable_hzwoperation();
  void set_allocated_hzwoperation(::commonmodule::HzWAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hzwoperation(::commonmodule::HzWAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::HzWAPC* PROTOBUF_NULLABLE unsafe_arena_release_hzwoperation();

  private:
  const ::commonmodule::HzWAPC& _internal_hzwoperation() const;
  ::commonmodule::HzWAPC* PROTOBUF_NONNULL _internal_mutable_hzwoperation();

  public:
  // .commonmodule.LimitWAPC limitWOperation = 18;
  bool has_limitwoperation() const;
  void clear_limitwoperation() ;
  const ::commonmodule::LimitWAPC& limitwoperation() const;
  [[nodiscard]] ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE release_limitwoperation();
  ::commonmodule::LimitWAPC* PROTOBUF_NONNULL mutable_limitwoperation();
  void set_allocated_limitwoperation(::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_limitwoperation(::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE unsafe_arena_release_limitwoperation();

  private:
  const ::commonmodule::LimitWAPC& _internal_limitwoperation() const;
  ::commonmodule::LimitWAPC* PROTOBUF_NONNULL _internal_mutable_limitwoperation();

  public:
  // .commonmodule.PFSPC pFOperation = 19;
  bool has_pfoperation() const;
  void clear_pfoperation() ;
  const ::commonmodule::PFSPC& pfoperation() const;
  [[nodiscard]] ::commonmodule::PFSPC* PROTOBUF_NULLABLE release_pfoperation();
  ::commonmodule::PFSPC* PROTOBUF_NONNULL mutable_pfoperation();
  void set_allocated_pfoperation(::commonmodule::PFSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pfoperation(::commonmodule::PFSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PFSPC* PROTOBUF_NULLABLE unsafe_arena_release_pfoperation();

  private:
  const ::commonmodule::PFSPC& _internal_pfoperation() const;
  ::commonmodule::PFSPC* PROTOBUF_NONNULL _internal_mutable_pfoperation();

  public:
  // .commonmodule.TmHzCSG tmHzTripOperation = 20;
  bool has_tmhztripoperation() const;
  void clear_tmhztripoperation() ;
  const ::commonmodule::TmHzCSG& tmhztripoperation() const;
  [[nodiscard]] ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE release_tmhztripoperation();
  ::commonmodule::TmHzCSG* PROTOBUF_NONNULL mutable_tmhztripoperation();
  void set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE unsafe_arena_release_tmhztripoperation();

  private:
  const ::commonmodule::TmHzCSG& _internal_tmhztripoperation() const;
  ::commonmodule::TmHzCSG* PROTOBUF_NONNULL _internal_mutable_tmhztripoperation();

  public:
  // .commonmodule.TmVoltCSG tmVoltTripOperation = 21;
  bool has_tmvolttripoperation() const;
  void clear_tmvolttripoperation() ;
  const ::commonmodule::TmVoltCSG& tmvolttripoperation() const;
  [[nodiscard]] ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE release_tmvolttripoperation();
  ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL mutable_tmvolttripoperation();
  void set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE unsafe_arena_release_tmvolttripoperation();

  private:
  const ::commonmodule::TmVoltCSG& _internal_tmvolttripoperation() const;
  ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL _internal_mutable_tmvolttripoperation();

  public:
  // .commonmodule.VarSPC vArOperation = 22;
  bool has_varoperation() const;
  void clear_varoperation() ;
  const ::commonmodule::VarSPC& varoperation() const;
  [[nodiscard]] ::commonmodule::VarSPC* PROTOBUF_NULLABLE release_varoperation();
  ::commonmodule::VarSPC* PROTOBUF_NONNULL mutable_varoperation();
  void set_allocated_varoperation(::commonmodule::VarSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_varoperation(::commonmodule::VarSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::VarSPC* PROTOBUF_NULLABLE unsafe_arena_release_varoperation();

  private:
  const ::commonmodule::VarSPC& _internal_varoperation() const;
  ::commonmodule::VarSPC* PROTOBUF_NONNULL _internal_mutable_varoperation();

  public:
  // .commonmodule.VoltVarCSG voltVarOperation = 23;
  bool has_voltvaroperation() const;
  void clear_voltvaroperation() ;
  const ::commonmodule::VoltVarCSG& voltvaroperation() const;
  [[nodiscard]] ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE release_voltvaroperation();
  ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL mutable_voltvaroperation();
  void set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE unsafe_arena_release_voltvaroperation();

  private:
  const ::commonmodule::VoltVarCSG& _internal_voltvaroperation() const;
  ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL _internal_mutable_voltvaroperation();

  public:
  // .commonmodule.VoltWCSG voltWOperation = 24;
  bool has_voltwoperation() const;
  void clear_voltwoperation() ;
  const ::commonmodule::VoltWCSG& voltwoperation() const;
  [[nodiscard]] ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE release_voltwoperation();
  ::commonmodule::VoltWCSG* PROTOBUF_NONNULL mutable_voltwoperation();
  void set_allocated_voltwoperation(::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltwoperation(::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE unsafe_arena_release_voltwoperation();

  private:
  const ::commonmodule::VoltWCSG& _internal_voltwoperation() const;
  ::commonmodule::VoltWCSG* PROTOBUF_NONNULL _internal_mutable_voltwoperation();

  public:
  // .commonmodule.WVarCSG wVarOperation = 25;
  bool has_wvaroperation() const;
  void clear_wvaroperation() ;
  const ::commonmodule::WVarCSG& wvaroperation() const;
  [[nodiscard]] ::commonmodule::WVarCSG* PROTOBUF_NULLABLE release_wvaroperation();
  ::commonmodule::WVarCSG* PROTOBUF_NONNULL mutable_wvaroperation();
  void set_allocated_wvaroperation(::commonmodule::WVarCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_wvaroperation(::commonmodule::WVarCSG* PROTOBUF_NULLABLE value);
  ::commonmodule::WVarCSG* PROTOBUF_NULLABLE unsafe_arena_release_wvaroperation();

  private:
  const ::commonmodule::WVarCSG& _internal_wvaroperation() const;
  ::commonmodule::WVarCSG* PROTOBUF_NONNULL _internal_mutable_wvaroperation();

  public:
  // .commonmodule.WSPC wOperation = 26;
  bool has_woperation() const;
  void clear_woperation() ;
  const ::commonmodule::WSPC& woperation() const;
  [[nodiscard]] ::commonmodule::WSPC* PROTOBUF_NULLABLE release_woperation();
  ::commonmodule::WSPC* PROTOBUF_NONNULL mutable_woperation();
  void set_allocated_woperation(::commonmodule::WSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_woperation(::commonmodule::WSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::WSPC* PROTOBUF_NULLABLE unsafe_arena_release_woperation();

  private:
  const ::commonmodule::WSPC& _internal_woperation() const;
  ::commonmodule::WSPC* PROTOBUF_NONNULL _internal_mutable_woperation();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 16,
                                   16, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE function_;
    ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE mode_;
    ::commonmodule::RampRate* PROTOBUF_NULLABLE ramprates_;
    ::commonmodule::ControlSPC* PROTOBUF_NULLABLE reset_;
    ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE state_;
    ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE enterserviceoperation_;
    ::commonmodule::HzWAPC* PROTOBUF_NULLABLE hzwoperation_;
    ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE limitwoperation_;
    ::commonmodule::PFSPC* PROTOBUF_NULLABLE pfoperation_;
    ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE tmhztripoperation_;
    ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE tmvolttripoperation_;
    ::commonmodule::VarSPC* PROTOBUF_NULLABLE varoperation_;
    ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE voltvaroperation_;
    ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE voltwoperation_;
    ::commonmodule::WVarCSG* PROTOBUF_NULLABLE wvaroperation_;
    ::commonmodule::WSPC* PROTOBUF_NULLABLE woperation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEPoint_class_data_;
// -------------------------------------------------------------------

class EVSECapabilityOverride final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSECapabilityOverride) */ {
 public:
  inline EVSECapabilityOverride() : EVSECapabilityOverride(nullptr) {}
  ~EVSECapabilityOverride() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSECapabilityOverride* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSECapabilityOverride));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSECapabilityOverride(::google::protobuf::internal::ConstantInitialized);

  inline EVSECapabilityOverride(const EVSECapabilityOverride& from) : EVSECapabilityOverride(nullptr, from) {}
  inline EVSECapabilityOverride(EVSECapabilityOverride&& from) noexcept
      : EVSECapabilityOverride(nullptr, ::std::move(from)) {}
  inline EVSECapabilityOverride& operator=(const EVSECapabilityOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSECapabilityOverride& operator=(EVSECapabilityOverride&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSECapabilityOverride& default_instance() {
    return *reinterpret_cast<const EVSECapabilityOverride*>(
        &_EVSECapabilityOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(EVSECapabilityOverride& a, EVSECapabilityOverride& b) { a.Swap(&b); }
  inline void Swap(EVSECapabilityOverride* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSECapabilityOverride* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSECapabilityOverride* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSECapabilityOverride>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSECapabilityOverride& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSECapabilityOverride& from) { EVSECapabilityOverride::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSECapabilityOverride* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSECapabilityOverride"; }

 protected:
  explicit EVSECapabilityOverride(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSECapabilityOverride(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSECapabilityOverride& from);
  EVSECapabilityOverride(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSECapabilityOverride&& from) noexcept
      : EVSECapabilityOverride(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapabilityConfigurationDESEFieldNumber = 2,
    kNameplateValueFieldNumber = 1,
  };
  // repeated .evsemodule.CapabilityConfigurationDESE capabilityConfigurationDESE = 2 [(.uml.option_multiplicity_min) = 0];
  int capabilityconfigurationdese_size() const;
  private:
  int _internal_capabilityconfigurationdese_size() const;

  public:
  void clear_capabilityconfigurationdese() ;
  ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL mutable_capabilityconfigurationdese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL mutable_capabilityconfigurationdese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>& _internal_capabilityconfigurationdese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL _internal_mutable_capabilityconfigurationdese();
  public:
  const ::evsemodule::CapabilityConfigurationDESE& capabilityconfigurationdese(int index) const;
  ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL add_capabilityconfigurationdese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>& capabilityconfigurationdese() const;
  // .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
  bool has_nameplatevalue() const;
  void clear_nameplatevalue() ;
  const ::commonmodule::NameplateValue& nameplatevalue() const;
  [[nodiscard]] ::commonmodule::NameplateValue* PROTOBUF_NULLABLE release_nameplatevalue();
  ::commonmodule::NameplateValue* PROTOBUF_NONNULL mutable_nameplatevalue();
  void set_allocated_nameplatevalue(::commonmodule::NameplateValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nameplatevalue(::commonmodule::NameplateValue* PROTOBUF_NULLABLE value);
  ::commonmodule::NameplateValue* PROTOBUF_NULLABLE unsafe_arena_release_nameplatevalue();

  private:
  const ::commonmodule::NameplateValue& _internal_nameplatevalue() const;
  ::commonmodule::NameplateValue* PROTOBUF_NONNULL _internal_mutable_nameplatevalue();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSECapabilityOverride)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSECapabilityOverride& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::CapabilityConfigurationDESE > capabilityconfigurationdese_;
    ::commonmodule::NameplateValue* PROTOBUF_NULLABLE nameplatevalue_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSECapabilityOverride_class_data_;
// -------------------------------------------------------------------

class EVSECapability final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSECapability) */ {
 public:
  inline EVSECapability() : EVSECapability(nullptr) {}
  ~EVSECapability() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSECapability* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSECapability));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSECapability(::google::protobuf::internal::ConstantInitialized);

  inline EVSECapability(const EVSECapability& from) : EVSECapability(nullptr, from) {}
  inline EVSECapability(EVSECapability&& from) noexcept
      : EVSECapability(nullptr, ::std::move(from)) {}
  inline EVSECapability& operator=(const EVSECapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSECapability& operator=(EVSECapability&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSECapability& default_instance() {
    return *reinterpret_cast<const EVSECapability*>(
        &_EVSECapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(EVSECapability& a, EVSECapability& b) { a.Swap(&b); }
  inline void Swap(EVSECapability* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSECapability* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSECapability* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSECapability>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSECapability& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSECapability& from) { EVSECapability::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSECapability* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSECapability"; }

 protected:
  explicit EVSECapability(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSECapability(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSECapability& from);
  EVSECapability(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSECapability&& from) noexcept
      : EVSECapability(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapabilityRatingsDESEFieldNumber = 2,
    kCapabilityConfigurationDESEFieldNumber = 3,
    kNameplateValueFieldNumber = 1,
    kCapabilityRatingsZCABFieldNumber = 4,
  };
  // repeated .evsemodule.CapabilityRatingsDESE capabilityRatingsDESE = 2 [(.uml.option_multiplicity_min) = 0];
  int capabilityratingsdese_size() const;
  private:
  int _internal_capabilityratingsdese_size() const;

  public:
  void clear_capabilityratingsdese() ;
  ::evsemodule::CapabilityRatingsDESE* PROTOBUF_NONNULL mutable_capabilityratingsdese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>* PROTOBUF_NONNULL mutable_capabilityratingsdese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>& _internal_capabilityratingsdese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>* PROTOBUF_NONNULL _internal_mutable_capabilityratingsdese();
  public:
  const ::evsemodule::CapabilityRatingsDESE& capabilityratingsdese(int index) const;
  ::evsemodule::CapabilityRatingsDESE* PROTOBUF_NONNULL add_capabilityratingsdese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>& capabilityratingsdese() const;
  // repeated .evsemodule.CapabilityConfigurationDESE capabilityConfigurationDESE = 3 [(.uml.option_multiplicity_min) = 0];
  int capabilityconfigurationdese_size() const;
  private:
  int _internal_capabilityconfigurationdese_size() const;

  public:
  void clear_capabilityconfigurationdese() ;
  ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL mutable_capabilityconfigurationdese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL mutable_capabilityconfigurationdese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>& _internal_capabilityconfigurationdese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL _internal_mutable_capabilityconfigurationdese();
  public:
  const ::evsemodule::CapabilityConfigurationDESE& capabilityconfigurationdese(int index) const;
  ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL add_capabilityconfigurationdese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>& capabilityconfigurationdese() const;
  // .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
  bool has_nameplatevalue() const;
  void clear_nameplatevalue() ;
  const ::commonmodule::NameplateValue& nameplatevalue() const;
  [[nodiscard]] ::commonmodule::NameplateValue* PROTOBUF_NULLABLE release_nameplatevalue();
  ::commonmodule::NameplateValue* PROTOBUF_NONNULL mutable_nameplatevalue();
  void set_allocated_nameplatevalue(::commonmodule::NameplateValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nameplatevalue(::commonmodule::NameplateValue* PROTOBUF_NULLABLE value);
  ::commonmodule::NameplateValue* PROTOBUF_NULLABLE unsafe_arena_release_nameplatevalue();

  private:
  const ::commonmodule::NameplateValue& _internal_nameplatevalue() const;
  ::commonmodule::NameplateValue* PROTOBUF_NONNULL _internal_mutable_nameplatevalue();

  public:
  // .evsemodule.CapabilityRatingsZCAB capabilityRatingsZCAB = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_capabilityratingszcab() const;
  void clear_capabilityratingszcab() ;
  const ::evsemodule::CapabilityRatingsZCAB& capabilityratingszcab() const;
  [[nodiscard]] ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE release_capabilityratingszcab();
  ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NONNULL mutable_capabilityratingszcab();
  void set_allocated_capabilityratingszcab(::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_capabilityratingszcab(::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE value);
  ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE unsafe_arena_release_capabilityratingszcab();

  private:
  const ::evsemodule::CapabilityRatingsZCAB& _internal_capabilityratingszcab() const;
  ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NONNULL _internal_mutable_capabilityratingszcab();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSECapability)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSECapability& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::CapabilityRatingsDESE > capabilityratingsdese_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::CapabilityConfigurationDESE > capabilityconfigurationdese_;
    ::commonmodule::NameplateValue* PROTOBUF_NULLABLE nameplatevalue_;
    ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE capabilityratingszcab_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSECapability_class_data_;
// -------------------------------------------------------------------

class ControlDEDO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ControlDEDO) */ {
 public:
  inline ControlDEDO() : ControlDEDO(nullptr) {}
  ~ControlDEDO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ControlDEDO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ControlDEDO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlDEDO(::google::protobuf::internal::ConstantInitialized);

  inline ControlDEDO(const ControlDEDO& from) : ControlDEDO(nullptr, from) {}
  inline ControlDEDO(ControlDEDO&& from) noexcept
      : ControlDEDO(nullptr, ::std::move(from)) {}
  inline ControlDEDO& operator=(const ControlDEDO& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlDEDO& operator=(ControlDEDO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlDEDO& default_instance() {
    return *reinterpret_cast<const ControlDEDO*>(
        &_ControlDEDO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(ControlDEDO& a, ControlDEDO& b) { a.Swap(&b); }
  inline void Swap(ControlDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlDEDO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlDEDO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ControlDEDO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlDEDO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlDEDO& from) { ControlDEDO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ControlDEDO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ControlDEDO"; }

 protected:
  explicit ControlDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ControlDEDO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ControlDEDO& from);
  ControlDEDO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ControlDEDO&& from) noexcept
      : ControlDEDO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kControlDEEVFieldNumber = 2,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforcontrol();

  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL _internal_mutable_logicalnodeforcontrol();

  public:
  // .evsemodule.ControlDEEV controlDEEV = 2;
  bool has_controldeev() const;
  void clear_controldeev() ;
  const ::evsemodule::ControlDEEV& controldeev() const;
  [[nodiscard]] ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE release_controldeev();
  ::evsemodule::ControlDEEV* PROTOBUF_NONNULL mutable_controldeev();
  void set_allocated_controldeev(::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controldeev(::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value);
  ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE unsafe_arena_release_controldeev();

  private:
  const ::evsemodule::ControlDEEV& _internal_controldeev() const;
  ::evsemodule::ControlDEEV* PROTOBUF_NONNULL _internal_mutable_controldeev();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ControlDEDO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ControlDEDO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE logicalnodeforcontrol_;
    ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE controldeev_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ControlDEDO_class_data_;
// -------------------------------------------------------------------

class ControlDEAO final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ControlDEAO) */ {
 public:
  inline ControlDEAO() : ControlDEAO(nullptr) {}
  ~ControlDEAO() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ControlDEAO* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ControlDEAO));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlDEAO(::google::protobuf::internal::ConstantInitialized);

  inline ControlDEAO(const ControlDEAO& from) : ControlDEAO(nullptr, from) {}
  inline ControlDEAO(ControlDEAO&& from) noexcept
      : ControlDEAO(nullptr, ::std::move(from)) {}
  inline ControlDEAO& operator=(const ControlDEAO& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlDEAO& operator=(ControlDEAO&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlDEAO& default_instance() {
    return *reinterpret_cast<const ControlDEAO*>(
        &_ControlDEAO_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ControlDEAO& a, ControlDEAO& b) { a.Swap(&b); }
  inline void Swap(ControlDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlDEAO* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlDEAO* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ControlDEAO>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlDEAO& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlDEAO& from) { ControlDEAO::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ControlDEAO* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ControlDEAO"; }

 protected:
  explicit ControlDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ControlDEAO(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ControlDEAO& from);
  ControlDEAO(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ControlDEAO&& from) noexcept
      : ControlDEAO(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kControlDEEVFieldNumber = 2,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforcontrol();

  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL _internal_mutable_logicalnodeforcontrol();

  public:
  // .evsemodule.ControlDEEV controlDEEV = 2;
  bool has_controldeev() const;
  void clear_controldeev() ;
  const ::evsemodule::ControlDEEV& controldeev() const;
  [[nodiscard]] ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE release_controldeev();
  ::evsemodule::ControlDEEV* PROTOBUF_NONNULL mutable_controldeev();
  void set_allocated_controldeev(::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controldeev(::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value);
  ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE unsafe_arena_release_controldeev();

  private:
  const ::evsemodule::ControlDEEV& _internal_controldeev() const;
  ::evsemodule::ControlDEEV* PROTOBUF_NONNULL _internal_mutable_controldeev();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ControlDEAO)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ControlDEAO& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE logicalnodeforcontrol_;
    ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE controldeev_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ControlDEAO_class_data_;
// -------------------------------------------------------------------

class EventAndStatusDESE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EventAndStatusDESE) */ {
 public:
  inline EventAndStatusDESE() : EventAndStatusDESE(nullptr) {}
  ~EventAndStatusDESE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventAndStatusDESE* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventAndStatusDESE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventAndStatusDESE(::google::protobuf::internal::ConstantInitialized);

  inline EventAndStatusDESE(const EventAndStatusDESE& from) : EventAndStatusDESE(nullptr, from) {}
  inline EventAndStatusDESE(EventAndStatusDESE&& from) noexcept
      : EventAndStatusDESE(nullptr, ::std::move(from)) {}
  inline EventAndStatusDESE& operator=(const EventAndStatusDESE& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAndStatusDESE& operator=(EventAndStatusDESE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAndStatusDESE& default_instance() {
    return *reinterpret_cast<const EventAndStatusDESE*>(
        &_EventAndStatusDESE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(EventAndStatusDESE& a, EventAndStatusDESE& b) { a.Swap(&b); }
  inline void Swap(EventAndStatusDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAndStatusDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAndStatusDESE* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventAndStatusDESE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventAndStatusDESE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventAndStatusDESE& from) { EventAndStatusDESE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventAndStatusDESE* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EventAndStatusDESE"; }

 protected:
  explicit EventAndStatusDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EventAndStatusDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EventAndStatusDESE& from);
  EventAndStatusDESE(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EventAndStatusDESE&& from) noexcept
      : EventAndStatusDESE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kEventAndStatusDEAOFieldNumber = 2,
    kEventAndStatusDEDOFieldNumber = 3,
    kIsoTestFltFieldNumber = 4,
    kScTestFltFieldNumber = 5,
    kDigCommLosFieldNumber = 6,
    kWldDetFieldNumber = 7,
    kPointStatusFieldNumber = 8,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforeventandstatus();

  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL _internal_mutable_logicalnodeforeventandstatus();

  public:
  // .evsemodule.EventAndStatusDEAO eventAndStatusDEAO = 2;
  bool has_eventandstatusdeao() const;
  void clear_eventandstatusdeao() ;
  const ::evsemodule::EventAndStatusDEAO& eventandstatusdeao() const;
  [[nodiscard]] ::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE release_eventandstatusdeao();
  ::evsemodule::EventAndStatusDEAO* PROTOBUF_NONNULL mutable_eventandstatusdeao();
  void set_allocated_eventandstatusdeao(::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventandstatusdeao(::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE value);
  ::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE unsafe_arena_release_eventandstatusdeao();

  private:
  const ::evsemodule::EventAndStatusDEAO& _internal_eventandstatusdeao() const;
  ::evsemodule::EventAndStatusDEAO* PROTOBUF_NONNULL _internal_mutable_eventandstatusdeao();

  public:
  // .evsemodule.EventAndStatusDEDO eventAndStatusDEDO = 3;
  bool has_eventandstatusdedo() const;
  void clear_eventandstatusdedo() ;
  const ::evsemodule::EventAndStatusDEDO& eventandstatusdedo() const;
  [[nodiscard]] ::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE release_eventandstatusdedo();
  ::evsemodule::EventAndStatusDEDO* PROTOBUF_NONNULL mutable_eventandstatusdedo();
  void set_allocated_eventandstatusdedo(::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventandstatusdedo(::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE value);
  ::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE unsafe_arena_release_eventandstatusdedo();

  private:
  const ::evsemodule::EventAndStatusDEDO& _internal_eventandstatusdedo() const;
  ::evsemodule::EventAndStatusDEDO* PROTOBUF_NONNULL _internal_mutable_eventandstatusdedo();

  public:
  // .commonmodule.StatusSPS IsoTestFlt = 4;
  bool has_isotestflt() const;
  void clear_isotestflt() ;
  const ::commonmodule::StatusSPS& isotestflt() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_isotestflt();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_isotestflt();
  void set_allocated_isotestflt(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_isotestflt(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_isotestflt();

  private:
  const ::commonmodule::StatusSPS& _internal_isotestflt() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_isotestflt();

  public:
  // .commonmodule.StatusSPS ScTestFlt = 5;
  bool has_sctestflt() const;
  void clear_sctestflt() ;
  const ::commonmodule::StatusSPS& sctestflt() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_sctestflt();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_sctestflt();
  void set_allocated_sctestflt(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sctestflt(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_sctestflt();

  private:
  const ::commonmodule::StatusSPS& _internal_sctestflt() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_sctestflt();

  public:
  // .commonmodule.StatusSPS DigCommLos = 6;
  bool has_digcommlos() const;
  void clear_digcommlos() ;
  const ::commonmodule::StatusSPS& digcommlos() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_digcommlos();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_digcommlos();
  void set_allocated_digcommlos(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_digcommlos(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_digcommlos();

  private:
  const ::commonmodule::StatusSPS& _internal_digcommlos() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_digcommlos();

  public:
  // .commonmodule.StatusSPS WldDet = 7;
  bool has_wlddet() const;
  void clear_wlddet() ;
  const ::commonmodule::StatusSPS& wlddet() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_wlddet();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_wlddet();
  void set_allocated_wlddet(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_wlddet(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_wlddet();

  private:
  const ::commonmodule::StatusSPS& _internal_wlddet() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_wlddet();

  public:
  // .evsemodule.EVSEPointStatus PointStatus = 8;
  bool has_pointstatus() const;
  void clear_pointstatus() ;
  const ::evsemodule::EVSEPointStatus& pointstatus() const;
  [[nodiscard]] ::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE release_pointstatus();
  ::evsemodule::EVSEPointStatus* PROTOBUF_NONNULL mutable_pointstatus();
  void set_allocated_pointstatus(::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pointstatus(::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE unsafe_arena_release_pointstatus();

  private:
  const ::evsemodule::EVSEPointStatus& _internal_pointstatus() const;
  ::evsemodule::EVSEPointStatus* PROTOBUF_NONNULL _internal_mutable_pointstatus();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EventAndStatusDESE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   8, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EventAndStatusDESE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE logicalnodeforeventandstatus_;
    ::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE eventandstatusdeao_;
    ::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE eventandstatusdedo_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE isotestflt_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE sctestflt_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE digcommlos_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE wlddet_;
    ::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE pointstatus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EventAndStatusDESE_class_data_;
// -------------------------------------------------------------------

class EVSEReading final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEReading) */ {
 public:
  inline EVSEReading() : EVSEReading(nullptr) {}
  ~EVSEReading() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEReading* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEReading));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEReading(::google::protobuf::internal::ConstantInitialized);

  inline EVSEReading(const EVSEReading& from) : EVSEReading(nullptr, from) {}
  inline EVSEReading(EVSEReading&& from) noexcept
      : EVSEReading(nullptr, ::std::move(from)) {}
  inline EVSEReading& operator=(const EVSEReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEReading& operator=(EVSEReading&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEReading& default_instance() {
    return *reinterpret_cast<const EVSEReading*>(
        &_EVSEReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(EVSEReading& a, EVSEReading& b) { a.Swap(&b); }
  inline void Swap(EVSEReading* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEReading* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEReading* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEReading>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEReading& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEReading& from) { EVSEReading::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEReading* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEReading"; }

 protected:
  explicit EVSEReading(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEReading(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEReading& from);
  EVSEReading(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEReading&& from) noexcept
      : EVSEReading(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEvseReadingDESEFieldNumber = 4,
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kReadingMMXUFieldNumber = 2,
    kReadingMMTRFieldNumber = 3,
    kPhaseMMTNFieldNumber = 5,
    kReadingMMDCFieldNumber = 6,
  };
  // repeated .evsemodule.EVSEReadingDESE evseReadingDESE = 4 [(.uml.option_multiplicity_min) = 0];
  int evsereadingdese_size() const;
  private:
  int _internal_evsereadingdese_size() const;

  public:
  void clear_evsereadingdese() ;
  ::evsemodule::EVSEReadingDESE* PROTOBUF_NONNULL mutable_evsereadingdese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>* PROTOBUF_NONNULL mutable_evsereadingdese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>& _internal_evsereadingdese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>* PROTOBUF_NONNULL _internal_mutable_evsereadingdese();
  public:
  const ::evsemodule::EVSEReadingDESE& evsereadingdese(int index) const;
  ::evsemodule::EVSEReadingDESE* PROTOBUF_NONNULL add_evsereadingdese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>& evsereadingdese() const;
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  [[nodiscard]] ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value);
  ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE unsafe_arena_release_conductingequipmentterminalreading();

  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL _internal_mutable_conductingequipmentterminalreading();

  public:
  // .commonmodule.ReadingMMXU readingMMXU = 2;
  bool has_readingmmxu() const;
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  [[nodiscard]] ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE release_readingmmxu();
  ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE unsafe_arena_release_readingmmxu();

  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL _internal_mutable_readingmmxu();

  public:
  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  [[nodiscard]] ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE release_readingmmtr();
  ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmmtr(::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE unsafe_arena_release_readingmmtr();

  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL _internal_mutable_readingmmtr();

  public:
  // .commonmodule.PhaseMMTN phaseMMTN = 5;
  bool has_phasemmtn() const;
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  [[nodiscard]] ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE release_phasemmtn();
  ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_phasemmtn(::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE unsafe_arena_release_phasemmtn();

  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL _internal_mutable_phasemmtn();

  public:
  // .commonmodule.ReadingMMDC readingMMDC = 6;
  bool has_readingmmdc() const;
  void clear_readingmmdc() ;
  const ::commonmodule::ReadingMMDC& readingmmdc() const;
  [[nodiscard]] ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE release_readingmmdc();
  ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL mutable_readingmmdc();
  void set_allocated_readingmmdc(::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmmdc(::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE unsafe_arena_release_readingmmdc();

  private:
  const ::commonmodule::ReadingMMDC& _internal_readingmmdc() const;
  ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL _internal_mutable_readingmmdc();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEReading)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEReading& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::EVSEReadingDESE > evsereadingdese_;
    ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE conductingequipmentterminalreading_;
    ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE readingmmxu_;
    ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE readingmmtr_;
    ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE phasemmtn_;
    ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE readingmmdc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEReading_class_data_;
// -------------------------------------------------------------------

class EVSECurvePoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSECurvePoint) */ {
 public:
  inline EVSECurvePoint() : EVSECurvePoint(nullptr) {}
  ~EVSECurvePoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSECurvePoint* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSECurvePoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSECurvePoint(::google::protobuf::internal::ConstantInitialized);

  inline EVSECurvePoint(const EVSECurvePoint& from) : EVSECurvePoint(nullptr, from) {}
  inline EVSECurvePoint(EVSECurvePoint&& from) noexcept
      : EVSECurvePoint(nullptr, ::std::move(from)) {}
  inline EVSECurvePoint& operator=(const EVSECurvePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSECurvePoint& operator=(EVSECurvePoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSECurvePoint& default_instance() {
    return *reinterpret_cast<const EVSECurvePoint*>(
        &_EVSECurvePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(EVSECurvePoint& a, EVSECurvePoint& b) { a.Swap(&b); }
  inline void Swap(EVSECurvePoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSECurvePoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSECurvePoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSECurvePoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSECurvePoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSECurvePoint& from) { EVSECurvePoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSECurvePoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSECurvePoint"; }

 protected:
  explicit EVSECurvePoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSECurvePoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSECurvePoint& from);
  EVSECurvePoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSECurvePoint&& from) noexcept
      : EVSECurvePoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kDurationFieldNumber = 3,
    kStackLevelFieldNumber = 4,
    kIdFieldNumber = 5,
  };
  // .evsemodule.EVSEPoint control = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_control() const;
  void clear_control() ;
  const ::evsemodule::EVSEPoint& control() const;
  [[nodiscard]] ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE release_control();
  ::evsemodule::EVSEPoint* PROTOBUF_NONNULL mutable_control();
  void set_allocated_control(::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_control(::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE unsafe_arena_release_control();

  private:
  const ::evsemodule::EVSEPoint& _internal_control() const;
  ::evsemodule::EVSEPoint* PROTOBUF_NONNULL _internal_mutable_control();

  public:
  // .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  void clear_starttime() ;
  const ::commonmodule::ControlTimestamp& starttime() const;
  [[nodiscard]] ::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE release_starttime();
  ::commonmodule::ControlTimestamp* PROTOBUF_NONNULL mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_starttime(::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE unsafe_arena_release_starttime();

  private:
  const ::commonmodule::ControlTimestamp& _internal_starttime() const;
  ::commonmodule::ControlTimestamp* PROTOBUF_NONNULL _internal_mutable_starttime();

  public:
  // uint64 duration = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_duration() ;
  ::uint64_t duration() const;
  void set_duration(::uint64_t value);

  private:
  ::uint64_t _internal_duration() const;
  void _internal_set_duration(::uint64_t value);

  public:
  // uint64 stackLevel = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_stacklevel() ;
  ::uint64_t stacklevel() const;
  void set_stacklevel(::uint64_t value);

  private:
  ::uint64_t _internal_stacklevel() const;
  void _internal_set_stacklevel(::uint64_t value);

  public:
  // uint64 id = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSECurvePoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSECurvePoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE control_;
    ::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE starttime_;
    ::uint64_t duration_;
    ::uint64_t stacklevel_;
    ::uint64_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSECurvePoint_class_data_;
// -------------------------------------------------------------------

class EVSECapabilityProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSECapabilityProfile) */ {
 public:
  inline EVSECapabilityProfile() : EVSECapabilityProfile(nullptr) {}
  ~EVSECapabilityProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSECapabilityProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSECapabilityProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSECapabilityProfile(::google::protobuf::internal::ConstantInitialized);

  inline EVSECapabilityProfile(const EVSECapabilityProfile& from) : EVSECapabilityProfile(nullptr, from) {}
  inline EVSECapabilityProfile(EVSECapabilityProfile&& from) noexcept
      : EVSECapabilityProfile(nullptr, ::std::move(from)) {}
  inline EVSECapabilityProfile& operator=(const EVSECapabilityProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSECapabilityProfile& operator=(EVSECapabilityProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSECapabilityProfile& default_instance() {
    return *reinterpret_cast<const EVSECapabilityProfile*>(
        &_EVSECapabilityProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(EVSECapabilityProfile& a, EVSECapabilityProfile& b) { a.Swap(&b); }
  inline void Swap(EVSECapabilityProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSECapabilityProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSECapabilityProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSECapabilityProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSECapabilityProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSECapabilityProfile& from) { EVSECapabilityProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSECapabilityProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSECapabilityProfile"; }

 protected:
  explicit EVSECapabilityProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSECapabilityProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSECapabilityProfile& from);
  EVSECapabilityProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSECapabilityProfile&& from) noexcept
      : EVSECapabilityProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapabilityMessageInfoFieldNumber = 1,
    kEvseFieldNumber = 2,
    kEvseCapabilityFieldNumber = 3,
  };
  // .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_capabilitymessageinfo() const;
  void clear_capabilitymessageinfo() ;
  const ::commonmodule::CapabilityMessageInfo& capabilitymessageinfo() const;
  [[nodiscard]] ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE release_capabilitymessageinfo();
  ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL mutable_capabilitymessageinfo();
  void set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_capabilitymessageinfo();

  private:
  const ::commonmodule::CapabilityMessageInfo& _internal_capabilitymessageinfo() const;
  ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL _internal_mutable_capabilitymessageinfo();

  public:
  // .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evse() const;
  void clear_evse() ;
  const ::evsemodule::EVSE& evse() const;
  [[nodiscard]] ::evsemodule::EVSE* PROTOBUF_NULLABLE release_evse();
  ::evsemodule::EVSE* PROTOBUF_NONNULL mutable_evse();
  void set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSE* PROTOBUF_NULLABLE unsafe_arena_release_evse();

  private:
  const ::evsemodule::EVSE& _internal_evse() const;
  ::evsemodule::EVSE* PROTOBUF_NONNULL _internal_mutable_evse();

  public:
  // .evsemodule.EVSECapability evseCapability = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evsecapability() const;
  void clear_evsecapability() ;
  const ::evsemodule::EVSECapability& evsecapability() const;
  [[nodiscard]] ::evsemodule::EVSECapability* PROTOBUF_NULLABLE release_evsecapability();
  ::evsemodule::EVSECapability* PROTOBUF_NONNULL mutable_evsecapability();
  void set_allocated_evsecapability(::evsemodule::EVSECapability* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evsecapability(::evsemodule::EVSECapability* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSECapability* PROTOBUF_NULLABLE unsafe_arena_release_evsecapability();

  private:
  const ::evsemodule::EVSECapability& _internal_evsecapability() const;
  ::evsemodule::EVSECapability* PROTOBUF_NONNULL _internal_mutable_evsecapability();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSECapabilityProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSECapabilityProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE capabilitymessageinfo_;
    ::evsemodule::EVSE* PROTOBUF_NULLABLE evse_;
    ::evsemodule::EVSECapability* PROTOBUF_NULLABLE evsecapability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSECapabilityProfile_class_data_;
// -------------------------------------------------------------------

class EVSECapabilityOverrideProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSECapabilityOverrideProfile) */ {
 public:
  inline EVSECapabilityOverrideProfile() : EVSECapabilityOverrideProfile(nullptr) {}
  ~EVSECapabilityOverrideProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSECapabilityOverrideProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSECapabilityOverrideProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSECapabilityOverrideProfile(::google::protobuf::internal::ConstantInitialized);

  inline EVSECapabilityOverrideProfile(const EVSECapabilityOverrideProfile& from) : EVSECapabilityOverrideProfile(nullptr, from) {}
  inline EVSECapabilityOverrideProfile(EVSECapabilityOverrideProfile&& from) noexcept
      : EVSECapabilityOverrideProfile(nullptr, ::std::move(from)) {}
  inline EVSECapabilityOverrideProfile& operator=(const EVSECapabilityOverrideProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSECapabilityOverrideProfile& operator=(EVSECapabilityOverrideProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSECapabilityOverrideProfile& default_instance() {
    return *reinterpret_cast<const EVSECapabilityOverrideProfile*>(
        &_EVSECapabilityOverrideProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(EVSECapabilityOverrideProfile& a, EVSECapabilityOverrideProfile& b) { a.Swap(&b); }
  inline void Swap(EVSECapabilityOverrideProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSECapabilityOverrideProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSECapabilityOverrideProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSECapabilityOverrideProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSECapabilityOverrideProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSECapabilityOverrideProfile& from) { EVSECapabilityOverrideProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSECapabilityOverrideProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSECapabilityOverrideProfile"; }

 protected:
  explicit EVSECapabilityOverrideProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSECapabilityOverrideProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSECapabilityOverrideProfile& from);
  EVSECapabilityOverrideProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSECapabilityOverrideProfile&& from) noexcept
      : EVSECapabilityOverrideProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapabilityMessageInfoFieldNumber = 1,
    kEvseFieldNumber = 2,
    kEvseCapabilityOverrideFieldNumber = 3,
  };
  // .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_capabilitymessageinfo() const;
  void clear_capabilitymessageinfo() ;
  const ::commonmodule::CapabilityMessageInfo& capabilitymessageinfo() const;
  [[nodiscard]] ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE release_capabilitymessageinfo();
  ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL mutable_capabilitymessageinfo();
  void set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_capabilitymessageinfo();

  private:
  const ::commonmodule::CapabilityMessageInfo& _internal_capabilitymessageinfo() const;
  ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL _internal_mutable_capabilitymessageinfo();

  public:
  // .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evse() const;
  void clear_evse() ;
  const ::evsemodule::EVSE& evse() const;
  [[nodiscard]] ::evsemodule::EVSE* PROTOBUF_NULLABLE release_evse();
  ::evsemodule::EVSE* PROTOBUF_NONNULL mutable_evse();
  void set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSE* PROTOBUF_NULLABLE unsafe_arena_release_evse();

  private:
  const ::evsemodule::EVSE& _internal_evse() const;
  ::evsemodule::EVSE* PROTOBUF_NONNULL _internal_mutable_evse();

  public:
  // .evsemodule.EVSECapabilityOverride evseCapabilityOverride = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evsecapabilityoverride() const;
  void clear_evsecapabilityoverride() ;
  const ::evsemodule::EVSECapabilityOverride& evsecapabilityoverride() const;
  [[nodiscard]] ::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE release_evsecapabilityoverride();
  ::evsemodule::EVSECapabilityOverride* PROTOBUF_NONNULL mutable_evsecapabilityoverride();
  void set_allocated_evsecapabilityoverride(::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evsecapabilityoverride(::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE unsafe_arena_release_evsecapabilityoverride();

  private:
  const ::evsemodule::EVSECapabilityOverride& _internal_evsecapabilityoverride() const;
  ::evsemodule::EVSECapabilityOverride* PROTOBUF_NONNULL _internal_mutable_evsecapabilityoverride();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSECapabilityOverrideProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSECapabilityOverrideProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE capabilitymessageinfo_;
    ::evsemodule::EVSE* PROTOBUF_NULLABLE evse_;
    ::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE evsecapabilityoverride_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSECapabilityOverrideProfile_class_data_;
// -------------------------------------------------------------------

class DiscreteControlDESE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.DiscreteControlDESE) */ {
 public:
  inline DiscreteControlDESE() : DiscreteControlDESE(nullptr) {}
  ~DiscreteControlDESE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscreteControlDESE* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscreteControlDESE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscreteControlDESE(::google::protobuf::internal::ConstantInitialized);

  inline DiscreteControlDESE(const DiscreteControlDESE& from) : DiscreteControlDESE(nullptr, from) {}
  inline DiscreteControlDESE(DiscreteControlDESE&& from) noexcept
      : DiscreteControlDESE(nullptr, ::std::move(from)) {}
  inline DiscreteControlDESE& operator=(const DiscreteControlDESE& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscreteControlDESE& operator=(DiscreteControlDESE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscreteControlDESE& default_instance() {
    return *reinterpret_cast<const DiscreteControlDESE*>(
        &_DiscreteControlDESE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(DiscreteControlDESE& a, DiscreteControlDESE& b) { a.Swap(&b); }
  inline void Swap(DiscreteControlDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscreteControlDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscreteControlDESE* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscreteControlDESE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscreteControlDESE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscreteControlDESE& from) { DiscreteControlDESE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscreteControlDESE* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.DiscreteControlDESE"; }

 protected:
  explicit DiscreteControlDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscreteControlDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscreteControlDESE& from);
  DiscreteControlDESE(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscreteControlDESE&& from) noexcept
      : DiscreteControlDESE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kControlFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforcontrol();

  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL _internal_mutable_logicalnodeforcontrol();

  public:
  // .evsemodule.EVSEPoint control = 3;
  bool has_control() const;
  void clear_control() ;
  const ::evsemodule::EVSEPoint& control() const;
  [[nodiscard]] ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE release_control();
  ::evsemodule::EVSEPoint* PROTOBUF_NONNULL mutable_control();
  void set_allocated_control(::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_control(::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE unsafe_arena_release_control();

  private:
  const ::evsemodule::EVSEPoint& _internal_control() const;
  ::evsemodule::EVSEPoint* PROTOBUF_NONNULL _internal_mutable_control();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.DiscreteControlDESE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscreteControlDESE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE logicalnodeforcontrol_;
    ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE control_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscreteControlDESE_class_data_;
// -------------------------------------------------------------------

class EVSEStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEStatus) */ {
 public:
  inline EVSEStatus() : EVSEStatus(nullptr) {}
  ~EVSEStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEStatus(::google::protobuf::internal::ConstantInitialized);

  inline EVSEStatus(const EVSEStatus& from) : EVSEStatus(nullptr, from) {}
  inline EVSEStatus(EVSEStatus&& from) noexcept
      : EVSEStatus(nullptr, ::std::move(from)) {}
  inline EVSEStatus& operator=(const EVSEStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEStatus& operator=(EVSEStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEStatus& default_instance() {
    return *reinterpret_cast<const EVSEStatus*>(
        &_EVSEStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(EVSEStatus& a, EVSEStatus& b) { a.Swap(&b); }
  inline void Swap(EVSEStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEStatus& from) { EVSEStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEStatus"; }

 protected:
  explicit EVSEStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEStatus& from);
  EVSEStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEStatus&& from) noexcept
      : EVSEStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventAndStatusDESEFieldNumber = 2,
    kStatusValueFieldNumber = 1,
  };
  // repeated .evsemodule.EventAndStatusDESE eventAndStatusDESE = 2 [(.uml.option_multiplicity_min) = 0];
  int eventandstatusdese_size() const;
  private:
  int _internal_eventandstatusdese_size() const;

  public:
  void clear_eventandstatusdese() ;
  ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL mutable_eventandstatusdese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL mutable_eventandstatusdese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>& _internal_eventandstatusdese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL _internal_mutable_eventandstatusdese();
  public:
  const ::evsemodule::EventAndStatusDESE& eventandstatusdese(int index) const;
  ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL add_eventandstatusdese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>& eventandstatusdese() const;
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  [[nodiscard]] ::commonmodule::StatusValue* PROTOBUF_NULLABLE release_statusvalue();
  ::commonmodule::StatusValue* PROTOBUF_NONNULL mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_statusvalue(::commonmodule::StatusValue* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusValue* PROTOBUF_NULLABLE unsafe_arena_release_statusvalue();

  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* PROTOBUF_NONNULL _internal_mutable_statusvalue();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::EventAndStatusDESE > eventandstatusdese_;
    ::commonmodule::StatusValue* PROTOBUF_NULLABLE statusvalue_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEStatus_class_data_;
// -------------------------------------------------------------------

class EVSEReadingProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEReadingProfile) */ {
 public:
  inline EVSEReadingProfile() : EVSEReadingProfile(nullptr) {}
  ~EVSEReadingProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEReadingProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEReadingProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEReadingProfile(::google::protobuf::internal::ConstantInitialized);

  inline EVSEReadingProfile(const EVSEReadingProfile& from) : EVSEReadingProfile(nullptr, from) {}
  inline EVSEReadingProfile(EVSEReadingProfile&& from) noexcept
      : EVSEReadingProfile(nullptr, ::std::move(from)) {}
  inline EVSEReadingProfile& operator=(const EVSEReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEReadingProfile& operator=(EVSEReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEReadingProfile& default_instance() {
    return *reinterpret_cast<const EVSEReadingProfile*>(
        &_EVSEReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(EVSEReadingProfile& a, EVSEReadingProfile& b) { a.Swap(&b); }
  inline void Swap(EVSEReadingProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEReadingProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEReadingProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEReadingProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEReadingProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEReadingProfile& from) { EVSEReadingProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEReadingProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEReadingProfile"; }

 protected:
  explicit EVSEReadingProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEReadingProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEReadingProfile& from);
  EVSEReadingProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEReadingProfile&& from) noexcept
      : EVSEReadingProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReadingMessageInfoFieldNumber = 1,
    kEvseFieldNumber = 2,
    kEvseReadingFieldNumber = 3,
  };
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  [[nodiscard]] ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_readingmessageinfo();

  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL _internal_mutable_readingmessageinfo();

  public:
  // .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evse() const;
  void clear_evse() ;
  const ::evsemodule::EVSE& evse() const;
  [[nodiscard]] ::evsemodule::EVSE* PROTOBUF_NULLABLE release_evse();
  ::evsemodule::EVSE* PROTOBUF_NONNULL mutable_evse();
  void set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSE* PROTOBUF_NULLABLE unsafe_arena_release_evse();

  private:
  const ::evsemodule::EVSE& _internal_evse() const;
  ::evsemodule::EVSE* PROTOBUF_NONNULL _internal_mutable_evse();

  public:
  // .evsemodule.EVSEReading evseReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evsereading() const;
  void clear_evsereading() ;
  const ::evsemodule::EVSEReading& evsereading() const;
  [[nodiscard]] ::evsemodule::EVSEReading* PROTOBUF_NULLABLE release_evsereading();
  ::evsemodule::EVSEReading* PROTOBUF_NONNULL mutable_evsereading();
  void set_allocated_evsereading(::evsemodule::EVSEReading* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evsereading(::evsemodule::EVSEReading* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEReading* PROTOBUF_NULLABLE unsafe_arena_release_evsereading();

  private:
  const ::evsemodule::EVSEReading& _internal_evsereading() const;
  ::evsemodule::EVSEReading* PROTOBUF_NONNULL _internal_mutable_evsereading();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEReadingProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEReadingProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE readingmessageinfo_;
    ::evsemodule::EVSE* PROTOBUF_NULLABLE evse_;
    ::evsemodule::EVSEReading* PROTOBUF_NULLABLE evsereading_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEReadingProfile_class_data_;
// -------------------------------------------------------------------

class EVSEEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEEvent) */ {
 public:
  inline EVSEEvent() : EVSEEvent(nullptr) {}
  ~EVSEEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEEvent* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEEvent(::google::protobuf::internal::ConstantInitialized);

  inline EVSEEvent(const EVSEEvent& from) : EVSEEvent(nullptr, from) {}
  inline EVSEEvent(EVSEEvent&& from) noexcept
      : EVSEEvent(nullptr, ::std::move(from)) {}
  inline EVSEEvent& operator=(const EVSEEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEEvent& operator=(EVSEEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEEvent& default_instance() {
    return *reinterpret_cast<const EVSEEvent*>(
        &_EVSEEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(EVSEEvent& a, EVSEEvent& b) { a.Swap(&b); }
  inline void Swap(EVSEEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEEvent& from) { EVSEEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEEvent"; }

 protected:
  explicit EVSEEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEEvent& from);
  EVSEEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEEvent&& from) noexcept
      : EVSEEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventAndStatusDESEFieldNumber = 2,
    kEventValueFieldNumber = 1,
  };
  // repeated .evsemodule.EventAndStatusDESE eventAndStatusDESE = 2 [(.uml.option_multiplicity_min) = 0];
  int eventandstatusdese_size() const;
  private:
  int _internal_eventandstatusdese_size() const;

  public:
  void clear_eventandstatusdese() ;
  ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL mutable_eventandstatusdese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL mutable_eventandstatusdese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>& _internal_eventandstatusdese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL _internal_mutable_eventandstatusdese();
  public:
  const ::evsemodule::EventAndStatusDESE& eventandstatusdese(int index) const;
  ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL add_eventandstatusdese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>& eventandstatusdese() const;
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  [[nodiscard]] ::commonmodule::EventValue* PROTOBUF_NULLABLE release_eventvalue();
  ::commonmodule::EventValue* PROTOBUF_NONNULL mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventvalue(::commonmodule::EventValue* PROTOBUF_NULLABLE value);
  ::commonmodule::EventValue* PROTOBUF_NULLABLE unsafe_arena_release_eventvalue();

  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* PROTOBUF_NONNULL _internal_mutable_eventvalue();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::EventAndStatusDESE > eventandstatusdese_;
    ::commonmodule::EventValue* PROTOBUF_NULLABLE eventvalue_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEEvent_class_data_;
// -------------------------------------------------------------------

class EVSEDiscreteControl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEDiscreteControl) */ {
 public:
  inline EVSEDiscreteControl() : EVSEDiscreteControl(nullptr) {}
  ~EVSEDiscreteControl() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEDiscreteControl* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEDiscreteControl));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEDiscreteControl(::google::protobuf::internal::ConstantInitialized);

  inline EVSEDiscreteControl(const EVSEDiscreteControl& from) : EVSEDiscreteControl(nullptr, from) {}
  inline EVSEDiscreteControl(EVSEDiscreteControl&& from) noexcept
      : EVSEDiscreteControl(nullptr, ::std::move(from)) {}
  inline EVSEDiscreteControl& operator=(const EVSEDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEDiscreteControl& operator=(EVSEDiscreteControl&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEDiscreteControl& default_instance() {
    return *reinterpret_cast<const EVSEDiscreteControl*>(
        &_EVSEDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(EVSEDiscreteControl& a, EVSEDiscreteControl& b) { a.Swap(&b); }
  inline void Swap(EVSEDiscreteControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEDiscreteControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEDiscreteControl* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEDiscreteControl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEDiscreteControl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEDiscreteControl& from) { EVSEDiscreteControl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEDiscreteControl* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEDiscreteControl"; }

 protected:
  explicit EVSEDiscreteControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEDiscreteControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEDiscreteControl& from);
  EVSEDiscreteControl(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEDiscreteControl&& from) noexcept
      : EVSEDiscreteControl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiscreteControlDESEFieldNumber = 2,
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 3,
  };
  // repeated .evsemodule.DiscreteControlDESE discreteControlDESE = 2 [(.uml.option_multiplicity_min) = 0];
  int discretecontroldese_size() const;
  private:
  int _internal_discretecontroldese_size() const;

  public:
  void clear_discretecontroldese() ;
  ::evsemodule::DiscreteControlDESE* PROTOBUF_NONNULL mutable_discretecontroldese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>* PROTOBUF_NONNULL mutable_discretecontroldese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>& _internal_discretecontroldese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>* PROTOBUF_NONNULL _internal_mutable_discretecontroldese();
  public:
  const ::evsemodule::DiscreteControlDESE& discretecontroldese(int index) const;
  ::evsemodule::DiscreteControlDESE* PROTOBUF_NONNULL add_discretecontroldese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>& discretecontroldese() const;
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  [[nodiscard]] ::commonmodule::ControlValue* PROTOBUF_NULLABLE release_controlvalue();
  ::commonmodule::ControlValue* PROTOBUF_NONNULL mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlValue* PROTOBUF_NULLABLE unsafe_arena_release_controlvalue();

  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* PROTOBUF_NONNULL _internal_mutable_controlvalue();

  public:
  // .commonmodule.CheckConditions check = 3;
  bool has_check() const;
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  [[nodiscard]] ::commonmodule::CheckConditions* PROTOBUF_NULLABLE release_check();
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  ::commonmodule::CheckConditions* PROTOBUF_NULLABLE unsafe_arena_release_check();

  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL _internal_mutable_check();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEDiscreteControl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEDiscreteControl& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::DiscreteControlDESE > discretecontroldese_;
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE controlvalue_;
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE check_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEDiscreteControl_class_data_;
// -------------------------------------------------------------------

class EVSECSG final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSECSG) */ {
 public:
  inline EVSECSG() : EVSECSG(nullptr) {}
  ~EVSECSG() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSECSG* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSECSG));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSECSG(::google::protobuf::internal::ConstantInitialized);

  inline EVSECSG(const EVSECSG& from) : EVSECSG(nullptr, from) {}
  inline EVSECSG(EVSECSG&& from) noexcept
      : EVSECSG(nullptr, ::std::move(from)) {}
  inline EVSECSG& operator=(const EVSECSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSECSG& operator=(EVSECSG&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSECSG& default_instance() {
    return *reinterpret_cast<const EVSECSG*>(
        &_EVSECSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EVSECSG& a, EVSECSG& b) { a.Swap(&b); }
  inline void Swap(EVSECSG* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSECSG* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSECSG* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSECSG>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSECSG& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSECSG& from) { EVSECSG::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSECSG* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSECSG"; }

 protected:
  explicit EVSECSG(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSECSG(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSECSG& from);
  EVSECSG(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSECSG&& from) noexcept
      : EVSECSG(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .evsemodule.EVSECurvePoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::evsemodule::EVSECurvePoint* PROTOBUF_NONNULL mutable_crvpts(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>* PROTOBUF_NONNULL mutable_crvpts();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>& _internal_crvpts() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>* PROTOBUF_NONNULL _internal_mutable_crvpts();
  public:
  const ::evsemodule::EVSECurvePoint& crvpts(int index) const;
  ::evsemodule::EVSECurvePoint* PROTOBUF_NONNULL add_crvpts();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>& crvpts() const;
  // @@protoc_insertion_point(class_scope:evsemodule.EVSECSG)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSECSG& from_msg);
    ::google::protobuf::RepeatedPtrField< ::evsemodule::EVSECurvePoint > crvpts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSECSG_class_data_;
// -------------------------------------------------------------------

class EVSEStatusProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEStatusProfile) */ {
 public:
  inline EVSEStatusProfile() : EVSEStatusProfile(nullptr) {}
  ~EVSEStatusProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEStatusProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEStatusProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEStatusProfile(::google::protobuf::internal::ConstantInitialized);

  inline EVSEStatusProfile(const EVSEStatusProfile& from) : EVSEStatusProfile(nullptr, from) {}
  inline EVSEStatusProfile(EVSEStatusProfile&& from) noexcept
      : EVSEStatusProfile(nullptr, ::std::move(from)) {}
  inline EVSEStatusProfile& operator=(const EVSEStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEStatusProfile& operator=(EVSEStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEStatusProfile& default_instance() {
    return *reinterpret_cast<const EVSEStatusProfile*>(
        &_EVSEStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(EVSEStatusProfile& a, EVSEStatusProfile& b) { a.Swap(&b); }
  inline void Swap(EVSEStatusProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEStatusProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEStatusProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEStatusProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEStatusProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEStatusProfile& from) { EVSEStatusProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEStatusProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEStatusProfile"; }

 protected:
  explicit EVSEStatusProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEStatusProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEStatusProfile& from);
  EVSEStatusProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEStatusProfile&& from) noexcept
      : EVSEStatusProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kEvseFieldNumber = 2,
    kEvseStatusFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  [[nodiscard]] ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_statusmessageinfo();

  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL _internal_mutable_statusmessageinfo();

  public:
  // .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evse() const;
  void clear_evse() ;
  const ::evsemodule::EVSE& evse() const;
  [[nodiscard]] ::evsemodule::EVSE* PROTOBUF_NULLABLE release_evse();
  ::evsemodule::EVSE* PROTOBUF_NONNULL mutable_evse();
  void set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSE* PROTOBUF_NULLABLE unsafe_arena_release_evse();

  private:
  const ::evsemodule::EVSE& _internal_evse() const;
  ::evsemodule::EVSE* PROTOBUF_NONNULL _internal_mutable_evse();

  public:
  // .evsemodule.EVSEStatus evseStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evsestatus() const;
  void clear_evsestatus() ;
  const ::evsemodule::EVSEStatus& evsestatus() const;
  [[nodiscard]] ::evsemodule::EVSEStatus* PROTOBUF_NULLABLE release_evsestatus();
  ::evsemodule::EVSEStatus* PROTOBUF_NONNULL mutable_evsestatus();
  void set_allocated_evsestatus(::evsemodule::EVSEStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evsestatus(::evsemodule::EVSEStatus* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEStatus* PROTOBUF_NULLABLE unsafe_arena_release_evsestatus();

  private:
  const ::evsemodule::EVSEStatus& _internal_evsestatus() const;
  ::evsemodule::EVSEStatus* PROTOBUF_NONNULL _internal_mutable_evsestatus();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEStatusProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEStatusProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE statusmessageinfo_;
    ::evsemodule::EVSE* PROTOBUF_NULLABLE evse_;
    ::evsemodule::EVSEStatus* PROTOBUF_NULLABLE evsestatus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEStatusProfile_class_data_;
// -------------------------------------------------------------------

class EVSEEventProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEEventProfile) */ {
 public:
  inline EVSEEventProfile() : EVSEEventProfile(nullptr) {}
  ~EVSEEventProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEEventProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEEventProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEEventProfile(::google::protobuf::internal::ConstantInitialized);

  inline EVSEEventProfile(const EVSEEventProfile& from) : EVSEEventProfile(nullptr, from) {}
  inline EVSEEventProfile(EVSEEventProfile&& from) noexcept
      : EVSEEventProfile(nullptr, ::std::move(from)) {}
  inline EVSEEventProfile& operator=(const EVSEEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEEventProfile& operator=(EVSEEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEEventProfile& default_instance() {
    return *reinterpret_cast<const EVSEEventProfile*>(
        &_EVSEEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(EVSEEventProfile& a, EVSEEventProfile& b) { a.Swap(&b); }
  inline void Swap(EVSEEventProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEEventProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEEventProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEEventProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEEventProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEEventProfile& from) { EVSEEventProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEEventProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEEventProfile"; }

 protected:
  explicit EVSEEventProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEEventProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEEventProfile& from);
  EVSEEventProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEEventProfile&& from) noexcept
      : EVSEEventProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kEvseFieldNumber = 2,
    kEvseEventFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  [[nodiscard]] ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_eventmessageinfo();

  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL _internal_mutable_eventmessageinfo();

  public:
  // .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evse() const;
  void clear_evse() ;
  const ::evsemodule::EVSE& evse() const;
  [[nodiscard]] ::evsemodule::EVSE* PROTOBUF_NULLABLE release_evse();
  ::evsemodule::EVSE* PROTOBUF_NONNULL mutable_evse();
  void set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSE* PROTOBUF_NULLABLE unsafe_arena_release_evse();

  private:
  const ::evsemodule::EVSE& _internal_evse() const;
  ::evsemodule::EVSE* PROTOBUF_NONNULL _internal_mutable_evse();

  public:
  // .evsemodule.EVSEEvent evseEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evseevent() const;
  void clear_evseevent() ;
  const ::evsemodule::EVSEEvent& evseevent() const;
  [[nodiscard]] ::evsemodule::EVSEEvent* PROTOBUF_NULLABLE release_evseevent();
  ::evsemodule::EVSEEvent* PROTOBUF_NONNULL mutable_evseevent();
  void set_allocated_evseevent(::evsemodule::EVSEEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evseevent(::evsemodule::EVSEEvent* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEEvent* PROTOBUF_NULLABLE unsafe_arena_release_evseevent();

  private:
  const ::evsemodule::EVSEEvent& _internal_evseevent() const;
  ::evsemodule::EVSEEvent* PROTOBUF_NONNULL _internal_mutable_evseevent();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEEventProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEEventProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE eventmessageinfo_;
    ::evsemodule::EVSE* PROTOBUF_NULLABLE evse_;
    ::evsemodule::EVSEEvent* PROTOBUF_NULLABLE evseevent_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEEventProfile_class_data_;
// -------------------------------------------------------------------

class EVSEDiscreteControlProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEDiscreteControlProfile) */ {
 public:
  inline EVSEDiscreteControlProfile() : EVSEDiscreteControlProfile(nullptr) {}
  ~EVSEDiscreteControlProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEDiscreteControlProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEDiscreteControlProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEDiscreteControlProfile(::google::protobuf::internal::ConstantInitialized);

  inline EVSEDiscreteControlProfile(const EVSEDiscreteControlProfile& from) : EVSEDiscreteControlProfile(nullptr, from) {}
  inline EVSEDiscreteControlProfile(EVSEDiscreteControlProfile&& from) noexcept
      : EVSEDiscreteControlProfile(nullptr, ::std::move(from)) {}
  inline EVSEDiscreteControlProfile& operator=(const EVSEDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEDiscreteControlProfile& operator=(EVSEDiscreteControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEDiscreteControlProfile& default_instance() {
    return *reinterpret_cast<const EVSEDiscreteControlProfile*>(
        &_EVSEDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(EVSEDiscreteControlProfile& a, EVSEDiscreteControlProfile& b) { a.Swap(&b); }
  inline void Swap(EVSEDiscreteControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEDiscreteControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEDiscreteControlProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEDiscreteControlProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEDiscreteControlProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEDiscreteControlProfile& from) { EVSEDiscreteControlProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEDiscreteControlProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEDiscreteControlProfile"; }

 protected:
  explicit EVSEDiscreteControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEDiscreteControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEDiscreteControlProfile& from);
  EVSEDiscreteControlProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEDiscreteControlProfile&& from) noexcept
      : EVSEDiscreteControlProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kEvseFieldNumber = 2,
    kEvseDiscreteControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  [[nodiscard]] ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_controlmessageinfo();

  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL _internal_mutable_controlmessageinfo();

  public:
  // .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evse() const;
  void clear_evse() ;
  const ::evsemodule::EVSE& evse() const;
  [[nodiscard]] ::evsemodule::EVSE* PROTOBUF_NULLABLE release_evse();
  ::evsemodule::EVSE* PROTOBUF_NONNULL mutable_evse();
  void set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSE* PROTOBUF_NULLABLE unsafe_arena_release_evse();

  private:
  const ::evsemodule::EVSE& _internal_evse() const;
  ::evsemodule::EVSE* PROTOBUF_NONNULL _internal_mutable_evse();

  public:
  // .evsemodule.EVSEDiscreteControl evseDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evsediscretecontrol() const;
  void clear_evsediscretecontrol() ;
  const ::evsemodule::EVSEDiscreteControl& evsediscretecontrol() const;
  [[nodiscard]] ::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE release_evsediscretecontrol();
  ::evsemodule::EVSEDiscreteControl* PROTOBUF_NONNULL mutable_evsediscretecontrol();
  void set_allocated_evsediscretecontrol(::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evsediscretecontrol(::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE unsafe_arena_release_evsediscretecontrol();

  private:
  const ::evsemodule::EVSEDiscreteControl& _internal_evsediscretecontrol() const;
  ::evsemodule::EVSEDiscreteControl* PROTOBUF_NONNULL _internal_mutable_evsediscretecontrol();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEDiscreteControlProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEDiscreteControlProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE controlmessageinfo_;
    ::evsemodule::EVSE* PROTOBUF_NULLABLE evse_;
    ::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE evsediscretecontrol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEDiscreteControlProfile_class_data_;
// -------------------------------------------------------------------

class DESEControlScheduleFSCH final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.DESEControlScheduleFSCH) */ {
 public:
  inline DESEControlScheduleFSCH() : DESEControlScheduleFSCH(nullptr) {}
  ~DESEControlScheduleFSCH() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DESEControlScheduleFSCH* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DESEControlScheduleFSCH));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DESEControlScheduleFSCH(::google::protobuf::internal::ConstantInitialized);

  inline DESEControlScheduleFSCH(const DESEControlScheduleFSCH& from) : DESEControlScheduleFSCH(nullptr, from) {}
  inline DESEControlScheduleFSCH(DESEControlScheduleFSCH&& from) noexcept
      : DESEControlScheduleFSCH(nullptr, ::std::move(from)) {}
  inline DESEControlScheduleFSCH& operator=(const DESEControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline DESEControlScheduleFSCH& operator=(DESEControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DESEControlScheduleFSCH& default_instance() {
    return *reinterpret_cast<const DESEControlScheduleFSCH*>(
        &_DESEControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(DESEControlScheduleFSCH& a, DESEControlScheduleFSCH& b) { a.Swap(&b); }
  inline void Swap(DESEControlScheduleFSCH* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DESEControlScheduleFSCH* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DESEControlScheduleFSCH* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DESEControlScheduleFSCH>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DESEControlScheduleFSCH& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DESEControlScheduleFSCH& from) { DESEControlScheduleFSCH::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DESEControlScheduleFSCH* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.DESEControlScheduleFSCH"; }

 protected:
  explicit DESEControlScheduleFSCH(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DESEControlScheduleFSCH(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DESEControlScheduleFSCH& from);
  DESEControlScheduleFSCH(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DESEControlScheduleFSCH&& from) noexcept
      : DESEControlScheduleFSCH(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValDCSGFieldNumber = 1,
  };
  // .evsemodule.EVSECSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  void clear_valdcsg() ;
  const ::evsemodule::EVSECSG& valdcsg() const;
  [[nodiscard]] ::evsemodule::EVSECSG* PROTOBUF_NULLABLE release_valdcsg();
  ::evsemodule::EVSECSG* PROTOBUF_NONNULL mutable_valdcsg();
  void set_allocated_valdcsg(::evsemodule::EVSECSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_valdcsg(::evsemodule::EVSECSG* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSECSG* PROTOBUF_NULLABLE unsafe_arena_release_valdcsg();

  private:
  const ::evsemodule::EVSECSG& _internal_valdcsg() const;
  ::evsemodule::EVSECSG* PROTOBUF_NONNULL _internal_mutable_valdcsg();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.DESEControlScheduleFSCH)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DESEControlScheduleFSCH& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::evsemodule::EVSECSG* PROTOBUF_NULLABLE valdcsg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DESEControlScheduleFSCH_class_data_;
// -------------------------------------------------------------------

class ControlDESE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.ControlDESE) */ {
 public:
  inline ControlDESE() : ControlDESE(nullptr) {}
  ~ControlDESE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ControlDESE* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ControlDESE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlDESE(::google::protobuf::internal::ConstantInitialized);

  inline ControlDESE(const ControlDESE& from) : ControlDESE(nullptr, from) {}
  inline ControlDESE(ControlDESE&& from) noexcept
      : ControlDESE(nullptr, ::std::move(from)) {}
  inline ControlDESE& operator=(const ControlDESE& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlDESE& operator=(ControlDESE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlDESE& default_instance() {
    return *reinterpret_cast<const ControlDESE*>(
        &_ControlDESE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(ControlDESE& a, ControlDESE& b) { a.Swap(&b); }
  inline void Swap(ControlDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlDESE* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlDESE* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ControlDESE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlDESE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlDESE& from) { ControlDESE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ControlDESE* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.ControlDESE"; }

 protected:
  explicit ControlDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ControlDESE(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ControlDESE& from);
  ControlDESE(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ControlDESE&& from) noexcept
      : ControlDESE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlFSCCFieldNumber = 1,
    kDeseControlScheduleFSCHFieldNumber = 2,
    kControlDEAOFieldNumber = 3,
    kControlDEEOFieldNumber = 4,
    kChaAMaxFieldNumber = 5,
  };
  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  void clear_controlfscc() ;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  [[nodiscard]] ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE release_controlfscc();
  ::commonmodule::ControlFSCC* PROTOBUF_NONNULL mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlfscc(::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE unsafe_arena_release_controlfscc();

  private:
  const ::commonmodule::ControlFSCC& _internal_controlfscc() const;
  ::commonmodule::ControlFSCC* PROTOBUF_NONNULL _internal_mutable_controlfscc();

  public:
  // .evsemodule.DESEControlScheduleFSCH deseControlScheduleFSCH = 2;
  bool has_desecontrolschedulefsch() const;
  void clear_desecontrolschedulefsch() ;
  const ::evsemodule::DESEControlScheduleFSCH& desecontrolschedulefsch() const;
  [[nodiscard]] ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE release_desecontrolschedulefsch();
  ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NONNULL mutable_desecontrolschedulefsch();
  void set_allocated_desecontrolschedulefsch(::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_desecontrolschedulefsch(::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE value);
  ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE unsafe_arena_release_desecontrolschedulefsch();

  private:
  const ::evsemodule::DESEControlScheduleFSCH& _internal_desecontrolschedulefsch() const;
  ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NONNULL _internal_mutable_desecontrolschedulefsch();

  public:
  // .evsemodule.ControlDEAO controlDEAO = 3;
  bool has_controldeao() const;
  void clear_controldeao() ;
  const ::evsemodule::ControlDEAO& controldeao() const;
  [[nodiscard]] ::evsemodule::ControlDEAO* PROTOBUF_NULLABLE release_controldeao();
  ::evsemodule::ControlDEAO* PROTOBUF_NONNULL mutable_controldeao();
  void set_allocated_controldeao(::evsemodule::ControlDEAO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controldeao(::evsemodule::ControlDEAO* PROTOBUF_NULLABLE value);
  ::evsemodule::ControlDEAO* PROTOBUF_NULLABLE unsafe_arena_release_controldeao();

  private:
  const ::evsemodule::ControlDEAO& _internal_controldeao() const;
  ::evsemodule::ControlDEAO* PROTOBUF_NONNULL _internal_mutable_controldeao();

  public:
  // .evsemodule.ControlDEDO controlDEEO = 4;
  bool has_controldeeo() const;
  void clear_controldeeo() ;
  const ::evsemodule::ControlDEDO& controldeeo() const;
  [[nodiscard]] ::evsemodule::ControlDEDO* PROTOBUF_NULLABLE release_controldeeo();
  ::evsemodule::ControlDEDO* PROTOBUF_NONNULL mutable_controldeeo();
  void set_allocated_controldeeo(::evsemodule::ControlDEDO* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controldeeo(::evsemodule::ControlDEDO* PROTOBUF_NULLABLE value);
  ::evsemodule::ControlDEDO* PROTOBUF_NULLABLE unsafe_arena_release_controldeeo();

  private:
  const ::evsemodule::ControlDEDO& _internal_controldeeo() const;
  ::evsemodule::ControlDEDO* PROTOBUF_NONNULL _internal_mutable_controldeeo();

  public:
  // .google.protobuf.FloatValue ChaAMax = 5;
  bool has_chaamax() const;
  void clear_chaamax() ;
  const ::google::protobuf::FloatValue& chaamax() const;
  [[nodiscard]] ::google::protobuf::FloatValue* PROTOBUF_NULLABLE release_chaamax();
  ::google::protobuf::FloatValue* PROTOBUF_NONNULL mutable_chaamax();
  void set_allocated_chaamax(::google::protobuf::FloatValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_chaamax(::google::protobuf::FloatValue* PROTOBUF_NULLABLE value);
  ::google::protobuf::FloatValue* PROTOBUF_NULLABLE unsafe_arena_release_chaamax();

  private:
  const ::google::protobuf::FloatValue& _internal_chaamax() const;
  ::google::protobuf::FloatValue* PROTOBUF_NONNULL _internal_mutable_chaamax();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.ControlDESE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ControlDESE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE controlfscc_;
    ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE desecontrolschedulefsch_;
    ::evsemodule::ControlDEAO* PROTOBUF_NULLABLE controldeao_;
    ::evsemodule::ControlDEDO* PROTOBUF_NULLABLE controldeeo_;
    ::google::protobuf::FloatValue* PROTOBUF_NULLABLE chaamax_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ControlDESE_class_data_;
// -------------------------------------------------------------------

class EVSEControl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEControl) */ {
 public:
  inline EVSEControl() : EVSEControl(nullptr) {}
  ~EVSEControl() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEControl* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEControl));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEControl(::google::protobuf::internal::ConstantInitialized);

  inline EVSEControl(const EVSEControl& from) : EVSEControl(nullptr, from) {}
  inline EVSEControl(EVSEControl&& from) noexcept
      : EVSEControl(nullptr, ::std::move(from)) {}
  inline EVSEControl& operator=(const EVSEControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEControl& operator=(EVSEControl&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEControl& default_instance() {
    return *reinterpret_cast<const EVSEControl*>(
        &_EVSEControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(EVSEControl& a, EVSEControl& b) { a.Swap(&b); }
  inline void Swap(EVSEControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEControl* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEControl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEControl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEControl& from) { EVSEControl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEControl* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEControl"; }

 protected:
  explicit EVSEControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEControl& from);
  EVSEControl(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEControl&& from) noexcept
      : EVSEControl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlDESEFieldNumber = 2,
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 3,
  };
  // repeated .evsemodule.ControlDESE controlDESE = 2 [(.uml.option_multiplicity_min) = 0];
  int controldese_size() const;
  private:
  int _internal_controldese_size() const;

  public:
  void clear_controldese() ;
  ::evsemodule::ControlDESE* PROTOBUF_NONNULL mutable_controldese(int index);
  ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>* PROTOBUF_NONNULL mutable_controldese();

  private:
  const ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>& _internal_controldese() const;
  ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>* PROTOBUF_NONNULL _internal_mutable_controldese();
  public:
  const ::evsemodule::ControlDESE& controldese(int index) const;
  ::evsemodule::ControlDESE* PROTOBUF_NONNULL add_controldese();
  const ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>& controldese() const;
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  [[nodiscard]] ::commonmodule::ControlValue* PROTOBUF_NULLABLE release_controlvalue();
  ::commonmodule::ControlValue* PROTOBUF_NONNULL mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlValue* PROTOBUF_NULLABLE unsafe_arena_release_controlvalue();

  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* PROTOBUF_NONNULL _internal_mutable_controlvalue();

  public:
  // .commonmodule.CheckConditions check = 3;
  bool has_check() const;
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  [[nodiscard]] ::commonmodule::CheckConditions* PROTOBUF_NULLABLE release_check();
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  ::commonmodule::CheckConditions* PROTOBUF_NULLABLE unsafe_arena_release_check();

  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL _internal_mutable_check();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEControl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEControl& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::evsemodule::ControlDESE > controldese_;
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE controlvalue_;
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE check_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEControl_class_data_;
// -------------------------------------------------------------------

class EVSEControlProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:evsemodule.EVSEControlProfile) */ {
 public:
  inline EVSEControlProfile() : EVSEControlProfile(nullptr) {}
  ~EVSEControlProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EVSEControlProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EVSEControlProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EVSEControlProfile(::google::protobuf::internal::ConstantInitialized);

  inline EVSEControlProfile(const EVSEControlProfile& from) : EVSEControlProfile(nullptr, from) {}
  inline EVSEControlProfile(EVSEControlProfile&& from) noexcept
      : EVSEControlProfile(nullptr, ::std::move(from)) {}
  inline EVSEControlProfile& operator=(const EVSEControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline EVSEControlProfile& operator=(EVSEControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EVSEControlProfile& default_instance() {
    return *reinterpret_cast<const EVSEControlProfile*>(
        &_EVSEControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(EVSEControlProfile& a, EVSEControlProfile& b) { a.Swap(&b); }
  inline void Swap(EVSEControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EVSEControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EVSEControlProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EVSEControlProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EVSEControlProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EVSEControlProfile& from) { EVSEControlProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EVSEControlProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "evsemodule.EVSEControlProfile"; }

 protected:
  explicit EVSEControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EVSEControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EVSEControlProfile& from);
  EVSEControlProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EVSEControlProfile&& from) noexcept
      : EVSEControlProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kEvseFieldNumber = 2,
    kEvseControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  [[nodiscard]] ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_controlmessageinfo();

  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL _internal_mutable_controlmessageinfo();

  public:
  // .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evse() const;
  void clear_evse() ;
  const ::evsemodule::EVSE& evse() const;
  [[nodiscard]] ::evsemodule::EVSE* PROTOBUF_NULLABLE release_evse();
  ::evsemodule::EVSE* PROTOBUF_NONNULL mutable_evse();
  void set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSE* PROTOBUF_NULLABLE unsafe_arena_release_evse();

  private:
  const ::evsemodule::EVSE& _internal_evse() const;
  ::evsemodule::EVSE* PROTOBUF_NONNULL _internal_mutable_evse();

  public:
  // .evsemodule.EVSEControl evseControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_evsecontrol() const;
  void clear_evsecontrol() ;
  const ::evsemodule::EVSEControl& evsecontrol() const;
  [[nodiscard]] ::evsemodule::EVSEControl* PROTOBUF_NULLABLE release_evsecontrol();
  ::evsemodule::EVSEControl* PROTOBUF_NONNULL mutable_evsecontrol();
  void set_allocated_evsecontrol(::evsemodule::EVSEControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_evsecontrol(::evsemodule::EVSEControl* PROTOBUF_NULLABLE value);
  ::evsemodule::EVSEControl* PROTOBUF_NULLABLE unsafe_arena_release_evsecontrol();

  private:
  const ::evsemodule::EVSEControl& _internal_evsecontrol() const;
  ::evsemodule::EVSEControl* PROTOBUF_NONNULL _internal_mutable_evsecontrol();

  public:
  // @@protoc_insertion_point(class_scope:evsemodule.EVSEControlProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EVSEControlProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE controlmessageinfo_;
    ::evsemodule::EVSE* PROTOBUF_NULLABLE evse_;
    ::evsemodule::EVSEControl* PROTOBUF_NULLABLE evsecontrol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_evsemodule_2fevsemodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EVSEControlProfile_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CapabilityConfigurationDEAO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityConfigurationDEAO::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& CapabilityConfigurationDEAO::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CapabilityConfigurationDEAO::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDEAO.logicalNode)
  return _internal_logicalnode();
}
inline void CapabilityConfigurationDEAO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDEAO.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityConfigurationDEAO::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityConfigurationDEAO::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDEAO.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityConfigurationDEAO::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityConfigurationDEAO::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDEAO.logicalNode)
  return _msg;
}
inline void CapabilityConfigurationDEAO::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDEAO.logicalNode)
}

// .commonmodule.ControlING ChaARtg = 3;
inline bool CapabilityConfigurationDEAO::has_chaartg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chaartg_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlING& CapabilityConfigurationDEAO::_internal_chaartg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlING* p = _impl_.chaartg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& CapabilityConfigurationDEAO::chaartg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDEAO.ChaARtg)
  return _internal_chaartg();
}
inline void CapabilityConfigurationDEAO::unsafe_arena_set_allocated_chaartg(
    ::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaartg_);
  }
  _impl_.chaartg_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDEAO.ChaARtg)
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityConfigurationDEAO::release_chaartg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ControlING* released = _impl_.chaartg_;
  _impl_.chaartg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityConfigurationDEAO::unsafe_arena_release_chaartg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDEAO.ChaARtg)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ControlING* temp = _impl_.chaartg_;
  _impl_.chaartg_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityConfigurationDEAO::_internal_mutable_chaartg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chaartg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlING>(GetArena());
    _impl_.chaartg_ = reinterpret_cast<::commonmodule::ControlING*>(p);
  }
  return _impl_.chaartg_;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityConfigurationDEAO::mutable_chaartg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ControlING* _msg = _internal_mutable_chaartg();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDEAO.ChaARtg)
  return _msg;
}
inline void CapabilityConfigurationDEAO::set_allocated_chaartg(::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaartg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.chaartg_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDEAO.ChaARtg)
}

// .commonmodule.ControlING ChaAMax = 4;
inline bool CapabilityConfigurationDEAO::has_chaamax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chaamax_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlING& CapabilityConfigurationDEAO::_internal_chaamax() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlING* p = _impl_.chaamax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& CapabilityConfigurationDEAO::chaamax() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDEAO.ChaAMax)
  return _internal_chaamax();
}
inline void CapabilityConfigurationDEAO::unsafe_arena_set_allocated_chaamax(
    ::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaamax_);
  }
  _impl_.chaamax_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDEAO.ChaAMax)
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityConfigurationDEAO::release_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ControlING* released = _impl_.chaamax_;
  _impl_.chaamax_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityConfigurationDEAO::unsafe_arena_release_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDEAO.ChaAMax)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ControlING* temp = _impl_.chaamax_;
  _impl_.chaamax_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityConfigurationDEAO::_internal_mutable_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chaamax_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlING>(GetArena());
    _impl_.chaamax_ = reinterpret_cast<::commonmodule::ControlING*>(p);
  }
  return _impl_.chaamax_;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityConfigurationDEAO::mutable_chaamax()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::ControlING* _msg = _internal_mutable_chaamax();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDEAO.ChaAMax)
  return _msg;
}
inline void CapabilityConfigurationDEAO::set_allocated_chaamax(::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaamax_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.chaamax_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDEAO.ChaAMax)
}

// -------------------------------------------------------------------

// CapabilityConfigurationDEDO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityConfigurationDEDO::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& CapabilityConfigurationDEDO::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CapabilityConfigurationDEDO::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDEDO.logicalNode)
  return _internal_logicalnode();
}
inline void CapabilityConfigurationDEDO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDEDO.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityConfigurationDEDO::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityConfigurationDEDO::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDEDO.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityConfigurationDEDO::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityConfigurationDEDO::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDEDO.logicalNode)
  return _msg;
}
inline void CapabilityConfigurationDEDO::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDEDO.logicalNode)
}

// -------------------------------------------------------------------

// CapabilityConfigurationDESE

// .commonmodule.SourceCapabilityConfiguration sourceCapabilityConfiguration = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityConfigurationDESE::has_sourcecapabilityconfiguration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sourcecapabilityconfiguration_ != nullptr);
  return value;
}
inline const ::commonmodule::SourceCapabilityConfiguration& CapabilityConfigurationDESE::_internal_sourcecapabilityconfiguration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SourceCapabilityConfiguration* p = _impl_.sourcecapabilityconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SourceCapabilityConfiguration&>(::commonmodule::_SourceCapabilityConfiguration_default_instance_);
}
inline const ::commonmodule::SourceCapabilityConfiguration& CapabilityConfigurationDESE::sourcecapabilityconfiguration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDESE.sourceCapabilityConfiguration)
  return _internal_sourcecapabilityconfiguration();
}
inline void CapabilityConfigurationDESE::unsafe_arena_set_allocated_sourcecapabilityconfiguration(
    ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcecapabilityconfiguration_);
  }
  _impl_.sourcecapabilityconfiguration_ = reinterpret_cast<::commonmodule::SourceCapabilityConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDESE.sourceCapabilityConfiguration)
}
inline ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE CapabilityConfigurationDESE::release_sourcecapabilityconfiguration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::SourceCapabilityConfiguration* released = _impl_.sourcecapabilityconfiguration_;
  _impl_.sourcecapabilityconfiguration_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE CapabilityConfigurationDESE::unsafe_arena_release_sourcecapabilityconfiguration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDESE.sourceCapabilityConfiguration)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::SourceCapabilityConfiguration* temp = _impl_.sourcecapabilityconfiguration_;
  _impl_.sourcecapabilityconfiguration_ = nullptr;
  return temp;
}
inline ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NONNULL CapabilityConfigurationDESE::_internal_mutable_sourcecapabilityconfiguration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sourcecapabilityconfiguration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SourceCapabilityConfiguration>(GetArena());
    _impl_.sourcecapabilityconfiguration_ = reinterpret_cast<::commonmodule::SourceCapabilityConfiguration*>(p);
  }
  return _impl_.sourcecapabilityconfiguration_;
}
inline ::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NONNULL CapabilityConfigurationDESE::mutable_sourcecapabilityconfiguration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::SourceCapabilityConfiguration* _msg = _internal_mutable_sourcecapabilityconfiguration();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDESE.sourceCapabilityConfiguration)
  return _msg;
}
inline void CapabilityConfigurationDESE::set_allocated_sourcecapabilityconfiguration(::commonmodule::SourceCapabilityConfiguration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcecapabilityconfiguration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sourcecapabilityconfiguration_ = reinterpret_cast<::commonmodule::SourceCapabilityConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDESE.sourceCapabilityConfiguration)
}

// .evsemodule.CapabilityConfigurationDEAO capabilityConfigurationDEA0 = 2;
inline bool CapabilityConfigurationDESE::has_capabilityconfigurationdea0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capabilityconfigurationdea0_ != nullptr);
  return value;
}
inline void CapabilityConfigurationDESE::clear_capabilityconfigurationdea0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilityconfigurationdea0_ != nullptr) _impl_.capabilityconfigurationdea0_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::CapabilityConfigurationDEAO& CapabilityConfigurationDESE::_internal_capabilityconfigurationdea0() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::CapabilityConfigurationDEAO* p = _impl_.capabilityconfigurationdea0_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::CapabilityConfigurationDEAO&>(::evsemodule::_CapabilityConfigurationDEAO_default_instance_);
}
inline const ::evsemodule::CapabilityConfigurationDEAO& CapabilityConfigurationDESE::capabilityconfigurationdea0() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEA0)
  return _internal_capabilityconfigurationdea0();
}
inline void CapabilityConfigurationDESE::unsafe_arena_set_allocated_capabilityconfigurationdea0(
    ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilityconfigurationdea0_);
  }
  _impl_.capabilityconfigurationdea0_ = reinterpret_cast<::evsemodule::CapabilityConfigurationDEAO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEA0)
}
inline ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE CapabilityConfigurationDESE::release_capabilityconfigurationdea0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::CapabilityConfigurationDEAO* released = _impl_.capabilityconfigurationdea0_;
  _impl_.capabilityconfigurationdea0_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE CapabilityConfigurationDESE::unsafe_arena_release_capabilityconfigurationdea0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEA0)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::CapabilityConfigurationDEAO* temp = _impl_.capabilityconfigurationdea0_;
  _impl_.capabilityconfigurationdea0_ = nullptr;
  return temp;
}
inline ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NONNULL CapabilityConfigurationDESE::_internal_mutable_capabilityconfigurationdea0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilityconfigurationdea0_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::CapabilityConfigurationDEAO>(GetArena());
    _impl_.capabilityconfigurationdea0_ = reinterpret_cast<::evsemodule::CapabilityConfigurationDEAO*>(p);
  }
  return _impl_.capabilityconfigurationdea0_;
}
inline ::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NONNULL CapabilityConfigurationDESE::mutable_capabilityconfigurationdea0()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::CapabilityConfigurationDEAO* _msg = _internal_mutable_capabilityconfigurationdea0();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEA0)
  return _msg;
}
inline void CapabilityConfigurationDESE::set_allocated_capabilityconfigurationdea0(::evsemodule::CapabilityConfigurationDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilityconfigurationdea0_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.capabilityconfigurationdea0_ = reinterpret_cast<::evsemodule::CapabilityConfigurationDEAO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEA0)
}

// .evsemodule.CapabilityConfigurationDEDO capabilityConfigurationDEDO = 3;
inline bool CapabilityConfigurationDESE::has_capabilityconfigurationdedo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capabilityconfigurationdedo_ != nullptr);
  return value;
}
inline void CapabilityConfigurationDESE::clear_capabilityconfigurationdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilityconfigurationdedo_ != nullptr) _impl_.capabilityconfigurationdedo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::CapabilityConfigurationDEDO& CapabilityConfigurationDESE::_internal_capabilityconfigurationdedo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::CapabilityConfigurationDEDO* p = _impl_.capabilityconfigurationdedo_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::CapabilityConfigurationDEDO&>(::evsemodule::_CapabilityConfigurationDEDO_default_instance_);
}
inline const ::evsemodule::CapabilityConfigurationDEDO& CapabilityConfigurationDESE::capabilityconfigurationdedo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEDO)
  return _internal_capabilityconfigurationdedo();
}
inline void CapabilityConfigurationDESE::unsafe_arena_set_allocated_capabilityconfigurationdedo(
    ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilityconfigurationdedo_);
  }
  _impl_.capabilityconfigurationdedo_ = reinterpret_cast<::evsemodule::CapabilityConfigurationDEDO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEDO)
}
inline ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE CapabilityConfigurationDESE::release_capabilityconfigurationdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::CapabilityConfigurationDEDO* released = _impl_.capabilityconfigurationdedo_;
  _impl_.capabilityconfigurationdedo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE CapabilityConfigurationDESE::unsafe_arena_release_capabilityconfigurationdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEDO)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::CapabilityConfigurationDEDO* temp = _impl_.capabilityconfigurationdedo_;
  _impl_.capabilityconfigurationdedo_ = nullptr;
  return temp;
}
inline ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NONNULL CapabilityConfigurationDESE::_internal_mutable_capabilityconfigurationdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilityconfigurationdedo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::CapabilityConfigurationDEDO>(GetArena());
    _impl_.capabilityconfigurationdedo_ = reinterpret_cast<::evsemodule::CapabilityConfigurationDEDO*>(p);
  }
  return _impl_.capabilityconfigurationdedo_;
}
inline ::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NONNULL CapabilityConfigurationDESE::mutable_capabilityconfigurationdedo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::CapabilityConfigurationDEDO* _msg = _internal_mutable_capabilityconfigurationdedo();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEDO)
  return _msg;
}
inline void CapabilityConfigurationDESE::set_allocated_capabilityconfigurationdedo(::evsemodule::CapabilityConfigurationDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilityconfigurationdedo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.capabilityconfigurationdedo_ = reinterpret_cast<::evsemodule::CapabilityConfigurationDEDO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDESE.capabilityConfigurationDEDO)
}

// .commonmodule.ASG ChaPwrRtg = 4;
inline bool CapabilityConfigurationDESE::has_chapwrrtg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chapwrrtg_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityConfigurationDESE::_internal_chapwrrtg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.chapwrrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityConfigurationDESE::chapwrrtg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDESE.ChaPwrRtg)
  return _internal_chapwrrtg();
}
inline void CapabilityConfigurationDESE::unsafe_arena_set_allocated_chapwrrtg(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrrtg_);
  }
  _impl_.chapwrrtg_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDESE.ChaPwrRtg)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityConfigurationDESE::release_chapwrrtg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ASG* released = _impl_.chapwrrtg_;
  _impl_.chapwrrtg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityConfigurationDESE::unsafe_arena_release_chapwrrtg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDESE.ChaPwrRtg)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ASG* temp = _impl_.chapwrrtg_;
  _impl_.chapwrrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityConfigurationDESE::_internal_mutable_chapwrrtg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chapwrrtg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.chapwrrtg_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.chapwrrtg_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityConfigurationDESE::mutable_chapwrrtg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::ASG* _msg = _internal_mutable_chapwrrtg();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDESE.ChaPwrRtg)
  return _msg;
}
inline void CapabilityConfigurationDESE::set_allocated_chapwrrtg(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrrtg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.chapwrrtg_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDESE.ChaPwrRtg)
}

// .commonmodule.ASG ChaPwrTgt = 5;
inline bool CapabilityConfigurationDESE::has_chapwrtgt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chapwrtgt_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityConfigurationDESE::_internal_chapwrtgt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.chapwrtgt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityConfigurationDESE::chapwrtgt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDESE.ChaPwrTgt)
  return _internal_chapwrtgt();
}
inline void CapabilityConfigurationDESE::unsafe_arena_set_allocated_chapwrtgt(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrtgt_);
  }
  _impl_.chapwrtgt_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDESE.ChaPwrTgt)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityConfigurationDESE::release_chapwrtgt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ASG* released = _impl_.chapwrtgt_;
  _impl_.chapwrtgt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityConfigurationDESE::unsafe_arena_release_chapwrtgt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDESE.ChaPwrTgt)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ASG* temp = _impl_.chapwrtgt_;
  _impl_.chapwrtgt_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityConfigurationDESE::_internal_mutable_chapwrtgt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chapwrtgt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.chapwrtgt_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.chapwrtgt_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityConfigurationDESE::mutable_chapwrtgt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::ASG* _msg = _internal_mutable_chapwrtgt();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDESE.ChaPwrTgt)
  return _msg;
}
inline void CapabilityConfigurationDESE::set_allocated_chapwrtgt(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrtgt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.chapwrtgt_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDESE.ChaPwrTgt)
}

// .commonmodule.ASG ChaPwrLim = 6;
inline bool CapabilityConfigurationDESE::has_chapwrlim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chapwrlim_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityConfigurationDESE::_internal_chapwrlim() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.chapwrlim_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityConfigurationDESE::chapwrlim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityConfigurationDESE.ChaPwrLim)
  return _internal_chapwrlim();
}
inline void CapabilityConfigurationDESE::unsafe_arena_set_allocated_chapwrlim(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrlim_);
  }
  _impl_.chapwrlim_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityConfigurationDESE.ChaPwrLim)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityConfigurationDESE::release_chapwrlim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::ASG* released = _impl_.chapwrlim_;
  _impl_.chapwrlim_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityConfigurationDESE::unsafe_arena_release_chapwrlim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityConfigurationDESE.ChaPwrLim)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::ASG* temp = _impl_.chapwrlim_;
  _impl_.chapwrlim_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityConfigurationDESE::_internal_mutable_chapwrlim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chapwrlim_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.chapwrlim_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.chapwrlim_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityConfigurationDESE::mutable_chapwrlim()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::ASG* _msg = _internal_mutable_chapwrlim();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityConfigurationDESE.ChaPwrLim)
  return _msg;
}
inline void CapabilityConfigurationDESE::set_allocated_chapwrlim(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrlim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.chapwrlim_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityConfigurationDESE.ChaPwrLim)
}

// -------------------------------------------------------------------

// EVSECapabilityOverride

// .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
inline bool EVSECapabilityOverride::has_nameplatevalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nameplatevalue_ != nullptr);
  return value;
}
inline const ::commonmodule::NameplateValue& EVSECapabilityOverride::_internal_nameplatevalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::NameplateValue* p = _impl_.nameplatevalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::NameplateValue&>(::commonmodule::_NameplateValue_default_instance_);
}
inline const ::commonmodule::NameplateValue& EVSECapabilityOverride::nameplatevalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityOverride.nameplateValue)
  return _internal_nameplatevalue();
}
inline void EVSECapabilityOverride::unsafe_arena_set_allocated_nameplatevalue(
    ::commonmodule::NameplateValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nameplatevalue_);
  }
  _impl_.nameplatevalue_ = reinterpret_cast<::commonmodule::NameplateValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapabilityOverride.nameplateValue)
}
inline ::commonmodule::NameplateValue* PROTOBUF_NULLABLE EVSECapabilityOverride::release_nameplatevalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::NameplateValue* released = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::NameplateValue* PROTOBUF_NULLABLE EVSECapabilityOverride::unsafe_arena_release_nameplatevalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapabilityOverride.nameplateValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
  return temp;
}
inline ::commonmodule::NameplateValue* PROTOBUF_NONNULL EVSECapabilityOverride::_internal_mutable_nameplatevalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nameplatevalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::NameplateValue>(GetArena());
    _impl_.nameplatevalue_ = reinterpret_cast<::commonmodule::NameplateValue*>(p);
  }
  return _impl_.nameplatevalue_;
}
inline ::commonmodule::NameplateValue* PROTOBUF_NONNULL EVSECapabilityOverride::mutable_nameplatevalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::NameplateValue* _msg = _internal_mutable_nameplatevalue();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityOverride.nameplateValue)
  return _msg;
}
inline void EVSECapabilityOverride::set_allocated_nameplatevalue(::commonmodule::NameplateValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nameplatevalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.nameplatevalue_ = reinterpret_cast<::commonmodule::NameplateValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapabilityOverride.nameplateValue)
}

// repeated .evsemodule.CapabilityConfigurationDESE capabilityConfigurationDESE = 2 [(.uml.option_multiplicity_min) = 0];
inline int EVSECapabilityOverride::_internal_capabilityconfigurationdese_size() const {
  return _internal_capabilityconfigurationdese().size();
}
inline int EVSECapabilityOverride::capabilityconfigurationdese_size() const {
  return _internal_capabilityconfigurationdese_size();
}
inline void EVSECapabilityOverride::clear_capabilityconfigurationdese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capabilityconfigurationdese_.Clear();
}
inline ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL EVSECapabilityOverride::mutable_capabilityconfigurationdese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityOverride.capabilityConfigurationDESE)
  return _internal_mutable_capabilityconfigurationdese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL EVSECapabilityOverride::mutable_capabilityconfigurationdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSECapabilityOverride.capabilityConfigurationDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_capabilityconfigurationdese();
}
inline const ::evsemodule::CapabilityConfigurationDESE& EVSECapabilityOverride::capabilityconfigurationdese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityOverride.capabilityConfigurationDESE)
  return _internal_capabilityconfigurationdese().Get(index);
}
inline ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL EVSECapabilityOverride::add_capabilityconfigurationdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::CapabilityConfigurationDESE* _add = _internal_mutable_capabilityconfigurationdese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSECapabilityOverride.capabilityConfigurationDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>& EVSECapabilityOverride::capabilityconfigurationdese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSECapabilityOverride.capabilityConfigurationDESE)
  return _internal_capabilityconfigurationdese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>&
EVSECapabilityOverride::_internal_capabilityconfigurationdese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capabilityconfigurationdese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL
EVSECapabilityOverride::_internal_mutable_capabilityconfigurationdese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.capabilityconfigurationdese_;
}

// -------------------------------------------------------------------

// EVSE

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool EVSE::has_conductingequipment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conductingequipment_ != nullptr);
  return value;
}
inline const ::commonmodule::ConductingEquipment& EVSE::_internal_conductingequipment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& EVSE::conductingequipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSE.conductingEquipment)
  return _internal_conductingequipment();
}
inline void EVSE::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = reinterpret_cast<::commonmodule::ConductingEquipment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSE.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE EVSE::release_conductingequipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipment* released = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE EVSE::unsafe_arena_release_conductingequipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSE.conductingEquipment)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL EVSE::_internal_mutable_conductingequipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ConductingEquipment>(GetArena());
    _impl_.conductingequipment_ = reinterpret_cast<::commonmodule::ConductingEquipment*>(p);
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL EVSE::mutable_conductingequipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSE.conductingEquipment)
  return _msg;
}
inline void EVSE::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipment_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.conductingequipment_ = reinterpret_cast<::commonmodule::ConductingEquipment*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSE.conductingEquipment)
}

// -------------------------------------------------------------------

// EVSECapabilityOverrideProfile

// .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EVSECapabilityOverrideProfile::has_capabilitymessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capabilitymessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::CapabilityMessageInfo& EVSECapabilityOverrideProfile::_internal_capabilitymessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::CapabilityMessageInfo* p = _impl_.capabilitymessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CapabilityMessageInfo&>(::commonmodule::_CapabilityMessageInfo_default_instance_);
}
inline const ::commonmodule::CapabilityMessageInfo& EVSECapabilityOverrideProfile::capabilitymessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityOverrideProfile.capabilityMessageInfo)
  return _internal_capabilitymessageinfo();
}
inline void EVSECapabilityOverrideProfile::unsafe_arena_set_allocated_capabilitymessageinfo(
    ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  _impl_.capabilitymessageinfo_ = reinterpret_cast<::commonmodule::CapabilityMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapabilityOverrideProfile.capabilityMessageInfo)
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE EVSECapabilityOverrideProfile::release_capabilitymessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::CapabilityMessageInfo* released = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE EVSECapabilityOverrideProfile::unsafe_arena_release_capabilitymessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapabilityOverrideProfile.capabilityMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL EVSECapabilityOverrideProfile::_internal_mutable_capabilitymessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilitymessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::CapabilityMessageInfo>(GetArena());
    _impl_.capabilitymessageinfo_ = reinterpret_cast<::commonmodule::CapabilityMessageInfo*>(p);
  }
  return _impl_.capabilitymessageinfo_;
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL EVSECapabilityOverrideProfile::mutable_capabilitymessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::CapabilityMessageInfo* _msg = _internal_mutable_capabilitymessageinfo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityOverrideProfile.capabilityMessageInfo)
  return _msg;
}
inline void EVSECapabilityOverrideProfile::set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilitymessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.capabilitymessageinfo_ = reinterpret_cast<::commonmodule::CapabilityMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapabilityOverrideProfile.capabilityMessageInfo)
}

// .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSECapabilityOverrideProfile::has_evse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evse_ != nullptr);
  return value;
}
inline void EVSECapabilityOverrideProfile::clear_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ != nullptr) _impl_.evse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSE& EVSECapabilityOverrideProfile::_internal_evse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSE* p = _impl_.evse_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSE&>(::evsemodule::_EVSE_default_instance_);
}
inline const ::evsemodule::EVSE& EVSECapabilityOverrideProfile::evse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityOverrideProfile.evse)
  return _internal_evse();
}
inline void EVSECapabilityOverrideProfile::unsafe_arena_set_allocated_evse(
    ::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }
  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapabilityOverrideProfile.evse)
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSECapabilityOverrideProfile::release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* released = _impl_.evse_;
  _impl_.evse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSECapabilityOverrideProfile::unsafe_arena_release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapabilityOverrideProfile.evse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* temp = _impl_.evse_;
  _impl_.evse_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSECapabilityOverrideProfile::_internal_mutable_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSE>(GetArena());
    _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(p);
  }
  return _impl_.evse_;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSECapabilityOverrideProfile::mutable_evse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSE* _msg = _internal_mutable_evse();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityOverrideProfile.evse)
  return _msg;
}
inline void EVSECapabilityOverrideProfile::set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapabilityOverrideProfile.evse)
}

// .evsemodule.EVSECapabilityOverride evseCapabilityOverride = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSECapabilityOverrideProfile::has_evsecapabilityoverride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evsecapabilityoverride_ != nullptr);
  return value;
}
inline void EVSECapabilityOverrideProfile::clear_evsecapabilityoverride() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsecapabilityoverride_ != nullptr) _impl_.evsecapabilityoverride_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EVSECapabilityOverride& EVSECapabilityOverrideProfile::_internal_evsecapabilityoverride() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSECapabilityOverride* p = _impl_.evsecapabilityoverride_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSECapabilityOverride&>(::evsemodule::_EVSECapabilityOverride_default_instance_);
}
inline const ::evsemodule::EVSECapabilityOverride& EVSECapabilityOverrideProfile::evsecapabilityoverride() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityOverrideProfile.evseCapabilityOverride)
  return _internal_evsecapabilityoverride();
}
inline void EVSECapabilityOverrideProfile::unsafe_arena_set_allocated_evsecapabilityoverride(
    ::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsecapabilityoverride_);
  }
  _impl_.evsecapabilityoverride_ = reinterpret_cast<::evsemodule::EVSECapabilityOverride*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapabilityOverrideProfile.evseCapabilityOverride)
}
inline ::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE EVSECapabilityOverrideProfile::release_evsecapabilityoverride() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSECapabilityOverride* released = _impl_.evsecapabilityoverride_;
  _impl_.evsecapabilityoverride_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE EVSECapabilityOverrideProfile::unsafe_arena_release_evsecapabilityoverride() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapabilityOverrideProfile.evseCapabilityOverride)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSECapabilityOverride* temp = _impl_.evsecapabilityoverride_;
  _impl_.evsecapabilityoverride_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSECapabilityOverride* PROTOBUF_NONNULL EVSECapabilityOverrideProfile::_internal_mutable_evsecapabilityoverride() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsecapabilityoverride_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSECapabilityOverride>(GetArena());
    _impl_.evsecapabilityoverride_ = reinterpret_cast<::evsemodule::EVSECapabilityOverride*>(p);
  }
  return _impl_.evsecapabilityoverride_;
}
inline ::evsemodule::EVSECapabilityOverride* PROTOBUF_NONNULL EVSECapabilityOverrideProfile::mutable_evsecapabilityoverride()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EVSECapabilityOverride* _msg = _internal_mutable_evsecapabilityoverride();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityOverrideProfile.evseCapabilityOverride)
  return _msg;
}
inline void EVSECapabilityOverrideProfile::set_allocated_evsecapabilityoverride(::evsemodule::EVSECapabilityOverride* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsecapabilityoverride_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.evsecapabilityoverride_ = reinterpret_cast<::evsemodule::EVSECapabilityOverride*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapabilityOverrideProfile.evseCapabilityOverride)
}

// -------------------------------------------------------------------

// CapabilityRatingsZCAB

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityRatingsZCAB::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& CapabilityRatingsZCAB::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CapabilityRatingsZCAB::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsZCAB.logicalNode)
  return _internal_logicalnode();
}
inline void CapabilityRatingsZCAB::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsZCAB.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityRatingsZCAB::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityRatingsZCAB::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsZCAB.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityRatingsZCAB::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityRatingsZCAB::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsZCAB.logicalNode)
  return _msg;
}
inline void CapabilityRatingsZCAB::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsZCAB.logicalNode)
}

// .commonmodule.ASG ARtg = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool CapabilityRatingsZCAB::has_artg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.artg_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityRatingsZCAB::_internal_artg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.artg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityRatingsZCAB::artg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsZCAB.ARtg)
  return _internal_artg();
}
inline void CapabilityRatingsZCAB::unsafe_arena_set_allocated_artg(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.artg_);
  }
  _impl_.artg_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsZCAB.ARtg)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsZCAB::release_artg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ASG* released = _impl_.artg_;
  _impl_.artg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsZCAB::unsafe_arena_release_artg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsZCAB.ARtg)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ASG* temp = _impl_.artg_;
  _impl_.artg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsZCAB::_internal_mutable_artg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.artg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.artg_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.artg_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsZCAB::mutable_artg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ASG* _msg = _internal_mutable_artg();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsZCAB.ARtg)
  return _msg;
}
inline void CapabilityRatingsZCAB::set_allocated_artg(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.artg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.artg_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsZCAB.ARtg)
}

// .commonmodule.ASG OvlMaxPct = 3;
inline bool CapabilityRatingsZCAB::has_ovlmaxpct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ovlmaxpct_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityRatingsZCAB::_internal_ovlmaxpct() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.ovlmaxpct_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityRatingsZCAB::ovlmaxpct() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsZCAB.OvlMaxPct)
  return _internal_ovlmaxpct();
}
inline void CapabilityRatingsZCAB::unsafe_arena_set_allocated_ovlmaxpct(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ovlmaxpct_);
  }
  _impl_.ovlmaxpct_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsZCAB.OvlMaxPct)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsZCAB::release_ovlmaxpct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ASG* released = _impl_.ovlmaxpct_;
  _impl_.ovlmaxpct_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsZCAB::unsafe_arena_release_ovlmaxpct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsZCAB.OvlMaxPct)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ASG* temp = _impl_.ovlmaxpct_;
  _impl_.ovlmaxpct_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsZCAB::_internal_mutable_ovlmaxpct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ovlmaxpct_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.ovlmaxpct_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.ovlmaxpct_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsZCAB::mutable_ovlmaxpct()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::ASG* _msg = _internal_mutable_ovlmaxpct();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsZCAB.OvlMaxPct)
  return _msg;
}
inline void CapabilityRatingsZCAB::set_allocated_ovlmaxpct(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ovlmaxpct_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ovlmaxpct_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsZCAB.OvlMaxPct)
}

// .commonmodule.ControlING OvlMaxTm = 4;
inline bool CapabilityRatingsZCAB::has_ovlmaxtm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ovlmaxtm_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlING& CapabilityRatingsZCAB::_internal_ovlmaxtm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlING* p = _impl_.ovlmaxtm_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& CapabilityRatingsZCAB::ovlmaxtm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsZCAB.OvlMaxTm)
  return _internal_ovlmaxtm();
}
inline void CapabilityRatingsZCAB::unsafe_arena_set_allocated_ovlmaxtm(
    ::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ovlmaxtm_);
  }
  _impl_.ovlmaxtm_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsZCAB.OvlMaxTm)
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityRatingsZCAB::release_ovlmaxtm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ControlING* released = _impl_.ovlmaxtm_;
  _impl_.ovlmaxtm_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityRatingsZCAB::unsafe_arena_release_ovlmaxtm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsZCAB.OvlMaxTm)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ControlING* temp = _impl_.ovlmaxtm_;
  _impl_.ovlmaxtm_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityRatingsZCAB::_internal_mutable_ovlmaxtm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ovlmaxtm_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlING>(GetArena());
    _impl_.ovlmaxtm_ = reinterpret_cast<::commonmodule::ControlING*>(p);
  }
  return _impl_.ovlmaxtm_;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityRatingsZCAB::mutable_ovlmaxtm()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::ControlING* _msg = _internal_mutable_ovlmaxtm();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsZCAB.OvlMaxTm)
  return _msg;
}
inline void CapabilityRatingsZCAB::set_allocated_ovlmaxtm(::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ovlmaxtm_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.ovlmaxtm_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsZCAB.OvlMaxTm)
}

// -------------------------------------------------------------------

// CapabilityRatingsDEAO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityRatingsDEAO::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& CapabilityRatingsDEAO::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CapabilityRatingsDEAO::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDEAO.logicalNode)
  return _internal_logicalnode();
}
inline void CapabilityRatingsDEAO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDEAO.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityRatingsDEAO::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityRatingsDEAO::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDEAO.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityRatingsDEAO::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityRatingsDEAO::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDEAO.logicalNode)
  return _msg;
}
inline void CapabilityRatingsDEAO::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDEAO.logicalNode)
}

// .commonmodule.ControlING ChaARtg = 3;
inline bool CapabilityRatingsDEAO::has_chaartg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chaartg_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlING& CapabilityRatingsDEAO::_internal_chaartg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlING* p = _impl_.chaartg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& CapabilityRatingsDEAO::chaartg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDEAO.ChaARtg)
  return _internal_chaartg();
}
inline void CapabilityRatingsDEAO::unsafe_arena_set_allocated_chaartg(
    ::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaartg_);
  }
  _impl_.chaartg_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDEAO.ChaARtg)
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityRatingsDEAO::release_chaartg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ControlING* released = _impl_.chaartg_;
  _impl_.chaartg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityRatingsDEAO::unsafe_arena_release_chaartg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDEAO.ChaARtg)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ControlING* temp = _impl_.chaartg_;
  _impl_.chaartg_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityRatingsDEAO::_internal_mutable_chaartg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chaartg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlING>(GetArena());
    _impl_.chaartg_ = reinterpret_cast<::commonmodule::ControlING*>(p);
  }
  return _impl_.chaartg_;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityRatingsDEAO::mutable_chaartg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ControlING* _msg = _internal_mutable_chaartg();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDEAO.ChaARtg)
  return _msg;
}
inline void CapabilityRatingsDEAO::set_allocated_chaartg(::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaartg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.chaartg_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDEAO.ChaARtg)
}

// .commonmodule.ControlING ChaAMax = 4;
inline bool CapabilityRatingsDEAO::has_chaamax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chaamax_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlING& CapabilityRatingsDEAO::_internal_chaamax() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlING* p = _impl_.chaamax_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlING&>(::commonmodule::_ControlING_default_instance_);
}
inline const ::commonmodule::ControlING& CapabilityRatingsDEAO::chaamax() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDEAO.ChaAMax)
  return _internal_chaamax();
}
inline void CapabilityRatingsDEAO::unsafe_arena_set_allocated_chaamax(
    ::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaamax_);
  }
  _impl_.chaamax_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDEAO.ChaAMax)
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityRatingsDEAO::release_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ControlING* released = _impl_.chaamax_;
  _impl_.chaamax_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlING* PROTOBUF_NULLABLE CapabilityRatingsDEAO::unsafe_arena_release_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDEAO.ChaAMax)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ControlING* temp = _impl_.chaamax_;
  _impl_.chaamax_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityRatingsDEAO::_internal_mutable_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chaamax_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlING>(GetArena());
    _impl_.chaamax_ = reinterpret_cast<::commonmodule::ControlING*>(p);
  }
  return _impl_.chaamax_;
}
inline ::commonmodule::ControlING* PROTOBUF_NONNULL CapabilityRatingsDEAO::mutable_chaamax()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::ControlING* _msg = _internal_mutable_chaamax();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDEAO.ChaAMax)
  return _msg;
}
inline void CapabilityRatingsDEAO::set_allocated_chaamax(::commonmodule::ControlING* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaamax_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.chaamax_ = reinterpret_cast<::commonmodule::ControlING*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDEAO.ChaAMax)
}

// -------------------------------------------------------------------

// CapabilityRatingsDEDO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityRatingsDEDO::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& CapabilityRatingsDEDO::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& CapabilityRatingsDEDO::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDEDO.logicalNode)
  return _internal_logicalnode();
}
inline void CapabilityRatingsDEDO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDEDO.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityRatingsDEDO::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE CapabilityRatingsDEDO::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDEDO.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityRatingsDEDO::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL CapabilityRatingsDEDO::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDEDO.logicalNode)
  return _msg;
}
inline void CapabilityRatingsDEDO::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDEDO.logicalNode)
}

// -------------------------------------------------------------------

// CapabilityRatingsDESE

// .commonmodule.SourceCapabilityRatings sourceCapabilityRatings = 1 [(.uml.option_parent_message) = true];
inline bool CapabilityRatingsDESE::has_sourcecapabilityratings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sourcecapabilityratings_ != nullptr);
  return value;
}
inline const ::commonmodule::SourceCapabilityRatings& CapabilityRatingsDESE::_internal_sourcecapabilityratings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SourceCapabilityRatings* p = _impl_.sourcecapabilityratings_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SourceCapabilityRatings&>(::commonmodule::_SourceCapabilityRatings_default_instance_);
}
inline const ::commonmodule::SourceCapabilityRatings& CapabilityRatingsDESE::sourcecapabilityratings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.sourceCapabilityRatings)
  return _internal_sourcecapabilityratings();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_sourcecapabilityratings(
    ::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcecapabilityratings_);
  }
  _impl_.sourcecapabilityratings_ = reinterpret_cast<::commonmodule::SourceCapabilityRatings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.sourceCapabilityRatings)
}
inline ::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_sourcecapabilityratings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::SourceCapabilityRatings* released = _impl_.sourcecapabilityratings_;
  _impl_.sourcecapabilityratings_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_sourcecapabilityratings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.sourceCapabilityRatings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::SourceCapabilityRatings* temp = _impl_.sourcecapabilityratings_;
  _impl_.sourcecapabilityratings_ = nullptr;
  return temp;
}
inline ::commonmodule::SourceCapabilityRatings* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_sourcecapabilityratings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sourcecapabilityratings_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SourceCapabilityRatings>(GetArena());
    _impl_.sourcecapabilityratings_ = reinterpret_cast<::commonmodule::SourceCapabilityRatings*>(p);
  }
  return _impl_.sourcecapabilityratings_;
}
inline ::commonmodule::SourceCapabilityRatings* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_sourcecapabilityratings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::SourceCapabilityRatings* _msg = _internal_mutable_sourcecapabilityratings();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.sourceCapabilityRatings)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_sourcecapabilityratings(::commonmodule::SourceCapabilityRatings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sourcecapabilityratings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sourcecapabilityratings_ = reinterpret_cast<::commonmodule::SourceCapabilityRatings*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.sourceCapabilityRatings)
}

// repeated .evsemodule.CapabilityRatingsDEAO capabilityRatingsDEAO = 2 [(.uml.option_multiplicity_min) = 0];
inline int CapabilityRatingsDESE::_internal_capabilityratingsdeao_size() const {
  return _internal_capabilityratingsdeao().size();
}
inline int CapabilityRatingsDESE::capabilityratingsdeao_size() const {
  return _internal_capabilityratingsdeao_size();
}
inline void CapabilityRatingsDESE::clear_capabilityratingsdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capabilityratingsdeao_.Clear();
}
inline ::evsemodule::CapabilityRatingsDEAO* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_capabilityratingsdeao(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEAO)
  return _internal_mutable_capabilityratingsdeao()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_capabilityratingsdeao()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEAO)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_capabilityratingsdeao();
}
inline const ::evsemodule::CapabilityRatingsDEAO& CapabilityRatingsDESE::capabilityratingsdeao(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEAO)
  return _internal_capabilityratingsdeao().Get(index);
}
inline ::evsemodule::CapabilityRatingsDEAO* PROTOBUF_NONNULL CapabilityRatingsDESE::add_capabilityratingsdeao()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::CapabilityRatingsDEAO* _add = _internal_mutable_capabilityratingsdeao()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEAO)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>& CapabilityRatingsDESE::capabilityratingsdeao() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEAO)
  return _internal_capabilityratingsdeao();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>&
CapabilityRatingsDESE::_internal_capabilityratingsdeao() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capabilityratingsdeao_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEAO>* PROTOBUF_NONNULL
CapabilityRatingsDESE::_internal_mutable_capabilityratingsdeao() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.capabilityratingsdeao_;
}

// repeated .evsemodule.CapabilityRatingsDEDO capabilityRatingsDEDO = 3 [(.uml.option_multiplicity_min) = 0];
inline int CapabilityRatingsDESE::_internal_capabilityratingsdedo_size() const {
  return _internal_capabilityratingsdedo().size();
}
inline int CapabilityRatingsDESE::capabilityratingsdedo_size() const {
  return _internal_capabilityratingsdedo_size();
}
inline void CapabilityRatingsDESE::clear_capabilityratingsdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capabilityratingsdedo_.Clear();
}
inline ::evsemodule::CapabilityRatingsDEDO* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_capabilityratingsdedo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEDO)
  return _internal_mutable_capabilityratingsdedo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_capabilityratingsdedo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEDO)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_capabilityratingsdedo();
}
inline const ::evsemodule::CapabilityRatingsDEDO& CapabilityRatingsDESE::capabilityratingsdedo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEDO)
  return _internal_capabilityratingsdedo().Get(index);
}
inline ::evsemodule::CapabilityRatingsDEDO* PROTOBUF_NONNULL CapabilityRatingsDESE::add_capabilityratingsdedo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::CapabilityRatingsDEDO* _add = _internal_mutable_capabilityratingsdedo()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEDO)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>& CapabilityRatingsDESE::capabilityratingsdedo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.CapabilityRatingsDESE.capabilityRatingsDEDO)
  return _internal_capabilityratingsdedo();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>&
CapabilityRatingsDESE::_internal_capabilityratingsdedo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capabilityratingsdedo_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDEDO>* PROTOBUF_NONNULL
CapabilityRatingsDESE::_internal_mutable_capabilityratingsdedo() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.capabilityratingsdedo_;
}

// .commonmodule.ASG ChaPwrRtg = 4;
inline bool CapabilityRatingsDESE::has_chapwrrtg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chapwrrtg_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityRatingsDESE::_internal_chapwrrtg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.chapwrrtg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityRatingsDESE::chapwrrtg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.ChaPwrRtg)
  return _internal_chapwrrtg();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_chapwrrtg(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrrtg_);
  }
  _impl_.chapwrrtg_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.ChaPwrRtg)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_chapwrrtg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ASG* released = _impl_.chapwrrtg_;
  _impl_.chapwrrtg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_chapwrrtg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.ChaPwrRtg)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ASG* temp = _impl_.chapwrrtg_;
  _impl_.chapwrrtg_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_chapwrrtg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chapwrrtg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.chapwrrtg_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.chapwrrtg_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_chapwrrtg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ASG* _msg = _internal_mutable_chapwrrtg();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.ChaPwrRtg)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_chapwrrtg(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrrtg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.chapwrrtg_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.ChaPwrRtg)
}

// .commonmodule.ASG ChaPwrTgt = 5;
inline bool CapabilityRatingsDESE::has_chapwrtgt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chapwrtgt_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityRatingsDESE::_internal_chapwrtgt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.chapwrtgt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityRatingsDESE::chapwrtgt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.ChaPwrTgt)
  return _internal_chapwrtgt();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_chapwrtgt(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrtgt_);
  }
  _impl_.chapwrtgt_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.ChaPwrTgt)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_chapwrtgt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ASG* released = _impl_.chapwrtgt_;
  _impl_.chapwrtgt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_chapwrtgt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.ChaPwrTgt)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ASG* temp = _impl_.chapwrtgt_;
  _impl_.chapwrtgt_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_chapwrtgt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chapwrtgt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.chapwrtgt_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.chapwrtgt_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_chapwrtgt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::ASG* _msg = _internal_mutable_chapwrtgt();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.ChaPwrTgt)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_chapwrtgt(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrtgt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.chapwrtgt_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.ChaPwrTgt)
}

// .commonmodule.ASG ChaPwrLim = 6;
inline bool CapabilityRatingsDESE::has_chapwrlim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chapwrlim_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& CapabilityRatingsDESE::_internal_chapwrlim() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.chapwrlim_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& CapabilityRatingsDESE::chapwrlim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.ChaPwrLim)
  return _internal_chapwrlim();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_chapwrlim(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrlim_);
  }
  _impl_.chapwrlim_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.ChaPwrLim)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_chapwrlim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ASG* released = _impl_.chapwrlim_;
  _impl_.chapwrlim_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_chapwrlim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.ChaPwrLim)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ASG* temp = _impl_.chapwrlim_;
  _impl_.chapwrlim_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_chapwrlim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chapwrlim_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.chapwrlim_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.chapwrlim_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_chapwrlim()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::ASG* _msg = _internal_mutable_chapwrlim();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.ChaPwrLim)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_chapwrlim(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chapwrlim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.chapwrlim_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.ChaPwrLim)
}

// .commonmodule.SPG ConnTypDC = 7;
inline bool CapabilityRatingsDESE::has_conntypdc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conntypdc_ != nullptr);
  return value;
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::_internal_conntypdc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SPG* p = _impl_.conntypdc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SPG&>(::commonmodule::_SPG_default_instance_);
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::conntypdc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.ConnTypDC)
  return _internal_conntypdc();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_conntypdc(
    ::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypdc_);
  }
  _impl_.conntypdc_ = reinterpret_cast<::commonmodule::SPG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypDC)
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_conntypdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::SPG* released = _impl_.conntypdc_;
  _impl_.conntypdc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_conntypdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.ConnTypDC)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::SPG* temp = _impl_.conntypdc_;
  _impl_.conntypdc_ = nullptr;
  return temp;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_conntypdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conntypdc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SPG>(GetArena());
    _impl_.conntypdc_ = reinterpret_cast<::commonmodule::SPG*>(p);
  }
  return _impl_.conntypdc_;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_conntypdc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::SPG* _msg = _internal_mutable_conntypdc();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.ConnTypDC)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_conntypdc(::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypdc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.conntypdc_ = reinterpret_cast<::commonmodule::SPG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypDC)
}

// .commonmodule.SPG ConnTypPhs1 = 8;
inline bool CapabilityRatingsDESE::has_conntypphs1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conntypphs1_ != nullptr);
  return value;
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::_internal_conntypphs1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SPG* p = _impl_.conntypphs1_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SPG&>(::commonmodule::_SPG_default_instance_);
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::conntypphs1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.ConnTypPhs1)
  return _internal_conntypphs1();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_conntypphs1(
    ::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypphs1_);
  }
  _impl_.conntypphs1_ = reinterpret_cast<::commonmodule::SPG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypPhs1)
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_conntypphs1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::SPG* released = _impl_.conntypphs1_;
  _impl_.conntypphs1_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_conntypphs1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.ConnTypPhs1)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::SPG* temp = _impl_.conntypphs1_;
  _impl_.conntypphs1_ = nullptr;
  return temp;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_conntypphs1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conntypphs1_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SPG>(GetArena());
    _impl_.conntypphs1_ = reinterpret_cast<::commonmodule::SPG*>(p);
  }
  return _impl_.conntypphs1_;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_conntypphs1()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::SPG* _msg = _internal_mutable_conntypphs1();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.ConnTypPhs1)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_conntypphs1(::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypphs1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.conntypphs1_ = reinterpret_cast<::commonmodule::SPG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypPhs1)
}

// .commonmodule.SPG ConnTypPhs2 = 9;
inline bool CapabilityRatingsDESE::has_conntypphs2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conntypphs2_ != nullptr);
  return value;
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::_internal_conntypphs2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SPG* p = _impl_.conntypphs2_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SPG&>(::commonmodule::_SPG_default_instance_);
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::conntypphs2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.ConnTypPhs2)
  return _internal_conntypphs2();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_conntypphs2(
    ::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypphs2_);
  }
  _impl_.conntypphs2_ = reinterpret_cast<::commonmodule::SPG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypPhs2)
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_conntypphs2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::SPG* released = _impl_.conntypphs2_;
  _impl_.conntypphs2_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_conntypphs2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.ConnTypPhs2)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::SPG* temp = _impl_.conntypphs2_;
  _impl_.conntypphs2_ = nullptr;
  return temp;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_conntypphs2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conntypphs2_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SPG>(GetArena());
    _impl_.conntypphs2_ = reinterpret_cast<::commonmodule::SPG*>(p);
  }
  return _impl_.conntypphs2_;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_conntypphs2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::SPG* _msg = _internal_mutable_conntypphs2();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.ConnTypPhs2)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_conntypphs2(::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypphs2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.conntypphs2_ = reinterpret_cast<::commonmodule::SPG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypPhs2)
}

// .commonmodule.SPG ConnTypPhs3 = 10;
inline bool CapabilityRatingsDESE::has_conntypphs3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conntypphs3_ != nullptr);
  return value;
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::_internal_conntypphs3() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SPG* p = _impl_.conntypphs3_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SPG&>(::commonmodule::_SPG_default_instance_);
}
inline const ::commonmodule::SPG& CapabilityRatingsDESE::conntypphs3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.CapabilityRatingsDESE.ConnTypPhs3)
  return _internal_conntypphs3();
}
inline void CapabilityRatingsDESE::unsafe_arena_set_allocated_conntypphs3(
    ::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypphs3_);
  }
  _impl_.conntypphs3_ = reinterpret_cast<::commonmodule::SPG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypPhs3)
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::release_conntypphs3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::SPG* released = _impl_.conntypphs3_;
  _impl_.conntypphs3_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SPG* PROTOBUF_NULLABLE CapabilityRatingsDESE::unsafe_arena_release_conntypphs3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.CapabilityRatingsDESE.ConnTypPhs3)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::SPG* temp = _impl_.conntypphs3_;
  _impl_.conntypphs3_ = nullptr;
  return temp;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::_internal_mutable_conntypphs3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conntypphs3_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SPG>(GetArena());
    _impl_.conntypphs3_ = reinterpret_cast<::commonmodule::SPG*>(p);
  }
  return _impl_.conntypphs3_;
}
inline ::commonmodule::SPG* PROTOBUF_NONNULL CapabilityRatingsDESE::mutable_conntypphs3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::commonmodule::SPG* _msg = _internal_mutable_conntypphs3();
  // @@protoc_insertion_point(field_mutable:evsemodule.CapabilityRatingsDESE.ConnTypPhs3)
  return _msg;
}
inline void CapabilityRatingsDESE::set_allocated_conntypphs3(::commonmodule::SPG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypphs3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.conntypphs3_ = reinterpret_cast<::commonmodule::SPG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.CapabilityRatingsDESE.ConnTypPhs3)
}

// -------------------------------------------------------------------

// EVSECapability

// .commonmodule.NameplateValue nameplateValue = 1 [(.uml.option_parent_message) = true];
inline bool EVSECapability::has_nameplatevalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nameplatevalue_ != nullptr);
  return value;
}
inline const ::commonmodule::NameplateValue& EVSECapability::_internal_nameplatevalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::NameplateValue* p = _impl_.nameplatevalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::NameplateValue&>(::commonmodule::_NameplateValue_default_instance_);
}
inline const ::commonmodule::NameplateValue& EVSECapability::nameplatevalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapability.nameplateValue)
  return _internal_nameplatevalue();
}
inline void EVSECapability::unsafe_arena_set_allocated_nameplatevalue(
    ::commonmodule::NameplateValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nameplatevalue_);
  }
  _impl_.nameplatevalue_ = reinterpret_cast<::commonmodule::NameplateValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapability.nameplateValue)
}
inline ::commonmodule::NameplateValue* PROTOBUF_NULLABLE EVSECapability::release_nameplatevalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::NameplateValue* released = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::NameplateValue* PROTOBUF_NULLABLE EVSECapability::unsafe_arena_release_nameplatevalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapability.nameplateValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::NameplateValue* temp = _impl_.nameplatevalue_;
  _impl_.nameplatevalue_ = nullptr;
  return temp;
}
inline ::commonmodule::NameplateValue* PROTOBUF_NONNULL EVSECapability::_internal_mutable_nameplatevalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nameplatevalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::NameplateValue>(GetArena());
    _impl_.nameplatevalue_ = reinterpret_cast<::commonmodule::NameplateValue*>(p);
  }
  return _impl_.nameplatevalue_;
}
inline ::commonmodule::NameplateValue* PROTOBUF_NONNULL EVSECapability::mutable_nameplatevalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::NameplateValue* _msg = _internal_mutable_nameplatevalue();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapability.nameplateValue)
  return _msg;
}
inline void EVSECapability::set_allocated_nameplatevalue(::commonmodule::NameplateValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nameplatevalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.nameplatevalue_ = reinterpret_cast<::commonmodule::NameplateValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapability.nameplateValue)
}

// repeated .evsemodule.CapabilityRatingsDESE capabilityRatingsDESE = 2 [(.uml.option_multiplicity_min) = 0];
inline int EVSECapability::_internal_capabilityratingsdese_size() const {
  return _internal_capabilityratingsdese().size();
}
inline int EVSECapability::capabilityratingsdese_size() const {
  return _internal_capabilityratingsdese_size();
}
inline void EVSECapability::clear_capabilityratingsdese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capabilityratingsdese_.Clear();
}
inline ::evsemodule::CapabilityRatingsDESE* PROTOBUF_NONNULL EVSECapability::mutable_capabilityratingsdese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapability.capabilityRatingsDESE)
  return _internal_mutable_capabilityratingsdese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>* PROTOBUF_NONNULL EVSECapability::mutable_capabilityratingsdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSECapability.capabilityRatingsDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_capabilityratingsdese();
}
inline const ::evsemodule::CapabilityRatingsDESE& EVSECapability::capabilityratingsdese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapability.capabilityRatingsDESE)
  return _internal_capabilityratingsdese().Get(index);
}
inline ::evsemodule::CapabilityRatingsDESE* PROTOBUF_NONNULL EVSECapability::add_capabilityratingsdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::CapabilityRatingsDESE* _add = _internal_mutable_capabilityratingsdese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSECapability.capabilityRatingsDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>& EVSECapability::capabilityratingsdese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSECapability.capabilityRatingsDESE)
  return _internal_capabilityratingsdese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>&
EVSECapability::_internal_capabilityratingsdese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capabilityratingsdese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityRatingsDESE>* PROTOBUF_NONNULL
EVSECapability::_internal_mutable_capabilityratingsdese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.capabilityratingsdese_;
}

// repeated .evsemodule.CapabilityConfigurationDESE capabilityConfigurationDESE = 3 [(.uml.option_multiplicity_min) = 0];
inline int EVSECapability::_internal_capabilityconfigurationdese_size() const {
  return _internal_capabilityconfigurationdese().size();
}
inline int EVSECapability::capabilityconfigurationdese_size() const {
  return _internal_capabilityconfigurationdese_size();
}
inline void EVSECapability::clear_capabilityconfigurationdese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capabilityconfigurationdese_.Clear();
}
inline ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL EVSECapability::mutable_capabilityconfigurationdese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapability.capabilityConfigurationDESE)
  return _internal_mutable_capabilityconfigurationdese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL EVSECapability::mutable_capabilityconfigurationdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSECapability.capabilityConfigurationDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_capabilityconfigurationdese();
}
inline const ::evsemodule::CapabilityConfigurationDESE& EVSECapability::capabilityconfigurationdese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapability.capabilityConfigurationDESE)
  return _internal_capabilityconfigurationdese().Get(index);
}
inline ::evsemodule::CapabilityConfigurationDESE* PROTOBUF_NONNULL EVSECapability::add_capabilityconfigurationdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::CapabilityConfigurationDESE* _add = _internal_mutable_capabilityconfigurationdese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSECapability.capabilityConfigurationDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>& EVSECapability::capabilityconfigurationdese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSECapability.capabilityConfigurationDESE)
  return _internal_capabilityconfigurationdese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>&
EVSECapability::_internal_capabilityconfigurationdese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capabilityconfigurationdese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::CapabilityConfigurationDESE>* PROTOBUF_NONNULL
EVSECapability::_internal_mutable_capabilityconfigurationdese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.capabilityconfigurationdese_;
}

// .evsemodule.CapabilityRatingsZCAB capabilityRatingsZCAB = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSECapability::has_capabilityratingszcab() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capabilityratingszcab_ != nullptr);
  return value;
}
inline void EVSECapability::clear_capabilityratingszcab() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilityratingszcab_ != nullptr) _impl_.capabilityratingszcab_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::CapabilityRatingsZCAB& EVSECapability::_internal_capabilityratingszcab() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::CapabilityRatingsZCAB* p = _impl_.capabilityratingszcab_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::CapabilityRatingsZCAB&>(::evsemodule::_CapabilityRatingsZCAB_default_instance_);
}
inline const ::evsemodule::CapabilityRatingsZCAB& EVSECapability::capabilityratingszcab() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapability.capabilityRatingsZCAB)
  return _internal_capabilityratingszcab();
}
inline void EVSECapability::unsafe_arena_set_allocated_capabilityratingszcab(
    ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilityratingszcab_);
  }
  _impl_.capabilityratingszcab_ = reinterpret_cast<::evsemodule::CapabilityRatingsZCAB*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapability.capabilityRatingsZCAB)
}
inline ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE EVSECapability::release_capabilityratingszcab() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::CapabilityRatingsZCAB* released = _impl_.capabilityratingszcab_;
  _impl_.capabilityratingszcab_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE EVSECapability::unsafe_arena_release_capabilityratingszcab() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapability.capabilityRatingsZCAB)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::CapabilityRatingsZCAB* temp = _impl_.capabilityratingszcab_;
  _impl_.capabilityratingszcab_ = nullptr;
  return temp;
}
inline ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NONNULL EVSECapability::_internal_mutable_capabilityratingszcab() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilityratingszcab_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::CapabilityRatingsZCAB>(GetArena());
    _impl_.capabilityratingszcab_ = reinterpret_cast<::evsemodule::CapabilityRatingsZCAB*>(p);
  }
  return _impl_.capabilityratingszcab_;
}
inline ::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NONNULL EVSECapability::mutable_capabilityratingszcab()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::CapabilityRatingsZCAB* _msg = _internal_mutable_capabilityratingszcab();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapability.capabilityRatingsZCAB)
  return _msg;
}
inline void EVSECapability::set_allocated_capabilityratingszcab(::evsemodule::CapabilityRatingsZCAB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilityratingszcab_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.capabilityratingszcab_ = reinterpret_cast<::evsemodule::CapabilityRatingsZCAB*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapability.capabilityRatingsZCAB)
}

// -------------------------------------------------------------------

// EVSECapabilityProfile

// .commonmodule.CapabilityMessageInfo capabilityMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EVSECapabilityProfile::has_capabilitymessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capabilitymessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::CapabilityMessageInfo& EVSECapabilityProfile::_internal_capabilitymessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::CapabilityMessageInfo* p = _impl_.capabilitymessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CapabilityMessageInfo&>(::commonmodule::_CapabilityMessageInfo_default_instance_);
}
inline const ::commonmodule::CapabilityMessageInfo& EVSECapabilityProfile::capabilitymessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityProfile.capabilityMessageInfo)
  return _internal_capabilitymessageinfo();
}
inline void EVSECapabilityProfile::unsafe_arena_set_allocated_capabilitymessageinfo(
    ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilitymessageinfo_);
  }
  _impl_.capabilitymessageinfo_ = reinterpret_cast<::commonmodule::CapabilityMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapabilityProfile.capabilityMessageInfo)
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE EVSECapabilityProfile::release_capabilitymessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::CapabilityMessageInfo* released = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE EVSECapabilityProfile::unsafe_arena_release_capabilitymessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapabilityProfile.capabilityMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::CapabilityMessageInfo* temp = _impl_.capabilitymessageinfo_;
  _impl_.capabilitymessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL EVSECapabilityProfile::_internal_mutable_capabilitymessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capabilitymessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::CapabilityMessageInfo>(GetArena());
    _impl_.capabilitymessageinfo_ = reinterpret_cast<::commonmodule::CapabilityMessageInfo*>(p);
  }
  return _impl_.capabilitymessageinfo_;
}
inline ::commonmodule::CapabilityMessageInfo* PROTOBUF_NONNULL EVSECapabilityProfile::mutable_capabilitymessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::CapabilityMessageInfo* _msg = _internal_mutable_capabilitymessageinfo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityProfile.capabilityMessageInfo)
  return _msg;
}
inline void EVSECapabilityProfile::set_allocated_capabilitymessageinfo(::commonmodule::CapabilityMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capabilitymessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.capabilitymessageinfo_ = reinterpret_cast<::commonmodule::CapabilityMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapabilityProfile.capabilityMessageInfo)
}

// .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSECapabilityProfile::has_evse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evse_ != nullptr);
  return value;
}
inline void EVSECapabilityProfile::clear_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ != nullptr) _impl_.evse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSE& EVSECapabilityProfile::_internal_evse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSE* p = _impl_.evse_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSE&>(::evsemodule::_EVSE_default_instance_);
}
inline const ::evsemodule::EVSE& EVSECapabilityProfile::evse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityProfile.evse)
  return _internal_evse();
}
inline void EVSECapabilityProfile::unsafe_arena_set_allocated_evse(
    ::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }
  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapabilityProfile.evse)
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSECapabilityProfile::release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* released = _impl_.evse_;
  _impl_.evse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSECapabilityProfile::unsafe_arena_release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapabilityProfile.evse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* temp = _impl_.evse_;
  _impl_.evse_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSECapabilityProfile::_internal_mutable_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSE>(GetArena());
    _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(p);
  }
  return _impl_.evse_;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSECapabilityProfile::mutable_evse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSE* _msg = _internal_mutable_evse();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityProfile.evse)
  return _msg;
}
inline void EVSECapabilityProfile::set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapabilityProfile.evse)
}

// .evsemodule.EVSECapability evseCapability = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSECapabilityProfile::has_evsecapability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evsecapability_ != nullptr);
  return value;
}
inline void EVSECapabilityProfile::clear_evsecapability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsecapability_ != nullptr) _impl_.evsecapability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EVSECapability& EVSECapabilityProfile::_internal_evsecapability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSECapability* p = _impl_.evsecapability_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSECapability&>(::evsemodule::_EVSECapability_default_instance_);
}
inline const ::evsemodule::EVSECapability& EVSECapabilityProfile::evsecapability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECapabilityProfile.evseCapability)
  return _internal_evsecapability();
}
inline void EVSECapabilityProfile::unsafe_arena_set_allocated_evsecapability(
    ::evsemodule::EVSECapability* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsecapability_);
  }
  _impl_.evsecapability_ = reinterpret_cast<::evsemodule::EVSECapability*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECapabilityProfile.evseCapability)
}
inline ::evsemodule::EVSECapability* PROTOBUF_NULLABLE EVSECapabilityProfile::release_evsecapability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSECapability* released = _impl_.evsecapability_;
  _impl_.evsecapability_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSECapability* PROTOBUF_NULLABLE EVSECapabilityProfile::unsafe_arena_release_evsecapability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECapabilityProfile.evseCapability)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSECapability* temp = _impl_.evsecapability_;
  _impl_.evsecapability_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSECapability* PROTOBUF_NONNULL EVSECapabilityProfile::_internal_mutable_evsecapability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsecapability_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSECapability>(GetArena());
    _impl_.evsecapability_ = reinterpret_cast<::evsemodule::EVSECapability*>(p);
  }
  return _impl_.evsecapability_;
}
inline ::evsemodule::EVSECapability* PROTOBUF_NONNULL EVSECapabilityProfile::mutable_evsecapability()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EVSECapability* _msg = _internal_mutable_evsecapability();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECapabilityProfile.evseCapability)
  return _msg;
}
inline void EVSECapabilityProfile::set_allocated_evsecapability(::evsemodule::EVSECapability* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsecapability_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.evsecapability_ = reinterpret_cast<::evsemodule::EVSECapability*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECapabilityProfile.evseCapability)
}

// -------------------------------------------------------------------

// EVSEFunction

// .commonmodule.CapacityFirming capacityFirming = 1;
inline bool EVSEFunction::has_capacityfirming() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capacityfirming_ != nullptr);
  return value;
}
inline const ::commonmodule::CapacityFirming& EVSEFunction::_internal_capacityfirming() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::CapacityFirming* p = _impl_.capacityfirming_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CapacityFirming&>(::commonmodule::_CapacityFirming_default_instance_);
}
inline const ::commonmodule::CapacityFirming& EVSEFunction::capacityfirming() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEFunction.capacityFirming)
  return _internal_capacityfirming();
}
inline void EVSEFunction::unsafe_arena_set_allocated_capacityfirming(
    ::commonmodule::CapacityFirming* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacityfirming_);
  }
  _impl_.capacityfirming_ = reinterpret_cast<::commonmodule::CapacityFirming*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEFunction.capacityFirming)
}
inline ::commonmodule::CapacityFirming* PROTOBUF_NULLABLE EVSEFunction::release_capacityfirming() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::CapacityFirming* released = _impl_.capacityfirming_;
  _impl_.capacityfirming_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::CapacityFirming* PROTOBUF_NULLABLE EVSEFunction::unsafe_arena_release_capacityfirming() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEFunction.capacityFirming)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::CapacityFirming* temp = _impl_.capacityfirming_;
  _impl_.capacityfirming_ = nullptr;
  return temp;
}
inline ::commonmodule::CapacityFirming* PROTOBUF_NONNULL EVSEFunction::_internal_mutable_capacityfirming() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capacityfirming_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::CapacityFirming>(GetArena());
    _impl_.capacityfirming_ = reinterpret_cast<::commonmodule::CapacityFirming*>(p);
  }
  return _impl_.capacityfirming_;
}
inline ::commonmodule::CapacityFirming* PROTOBUF_NONNULL EVSEFunction::mutable_capacityfirming()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::CapacityFirming* _msg = _internal_mutable_capacityfirming();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEFunction.capacityFirming)
  return _msg;
}
inline void EVSEFunction::set_allocated_capacityfirming(::commonmodule::CapacityFirming* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacityfirming_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.capacityfirming_ = reinterpret_cast<::commonmodule::CapacityFirming*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEFunction.capacityFirming)
}

// .commonmodule.FrequencyRegulation frequencyRegulation = 2;
inline bool EVSEFunction::has_frequencyregulation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frequencyregulation_ != nullptr);
  return value;
}
inline const ::commonmodule::FrequencyRegulation& EVSEFunction::_internal_frequencyregulation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::FrequencyRegulation* p = _impl_.frequencyregulation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::FrequencyRegulation&>(::commonmodule::_FrequencyRegulation_default_instance_);
}
inline const ::commonmodule::FrequencyRegulation& EVSEFunction::frequencyregulation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEFunction.frequencyRegulation)
  return _internal_frequencyregulation();
}
inline void EVSEFunction::unsafe_arena_set_allocated_frequencyregulation(
    ::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.frequencyregulation_);
  }
  _impl_.frequencyregulation_ = reinterpret_cast<::commonmodule::FrequencyRegulation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEFunction.frequencyRegulation)
}
inline ::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE EVSEFunction::release_frequencyregulation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::FrequencyRegulation* released = _impl_.frequencyregulation_;
  _impl_.frequencyregulation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE EVSEFunction::unsafe_arena_release_frequencyregulation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEFunction.frequencyRegulation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::FrequencyRegulation* temp = _impl_.frequencyregulation_;
  _impl_.frequencyregulation_ = nullptr;
  return temp;
}
inline ::commonmodule::FrequencyRegulation* PROTOBUF_NONNULL EVSEFunction::_internal_mutable_frequencyregulation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.frequencyregulation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::FrequencyRegulation>(GetArena());
    _impl_.frequencyregulation_ = reinterpret_cast<::commonmodule::FrequencyRegulation*>(p);
  }
  return _impl_.frequencyregulation_;
}
inline ::commonmodule::FrequencyRegulation* PROTOBUF_NONNULL EVSEFunction::mutable_frequencyregulation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::FrequencyRegulation* _msg = _internal_mutable_frequencyregulation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEFunction.frequencyRegulation)
  return _msg;
}
inline void EVSEFunction::set_allocated_frequencyregulation(::commonmodule::FrequencyRegulation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.frequencyregulation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.frequencyregulation_ = reinterpret_cast<::commonmodule::FrequencyRegulation*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEFunction.frequencyRegulation)
}

// .commonmodule.PeakShaving peakShaving = 3;
inline bool EVSEFunction::has_peakshaving() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.peakshaving_ != nullptr);
  return value;
}
inline const ::commonmodule::PeakShaving& EVSEFunction::_internal_peakshaving() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PeakShaving* p = _impl_.peakshaving_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PeakShaving&>(::commonmodule::_PeakShaving_default_instance_);
}
inline const ::commonmodule::PeakShaving& EVSEFunction::peakshaving() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEFunction.peakShaving)
  return _internal_peakshaving();
}
inline void EVSEFunction::unsafe_arena_set_allocated_peakshaving(
    ::commonmodule::PeakShaving* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.peakshaving_);
  }
  _impl_.peakshaving_ = reinterpret_cast<::commonmodule::PeakShaving*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEFunction.peakShaving)
}
inline ::commonmodule::PeakShaving* PROTOBUF_NULLABLE EVSEFunction::release_peakshaving() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::PeakShaving* released = _impl_.peakshaving_;
  _impl_.peakshaving_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PeakShaving* PROTOBUF_NULLABLE EVSEFunction::unsafe_arena_release_peakshaving() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEFunction.peakShaving)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::PeakShaving* temp = _impl_.peakshaving_;
  _impl_.peakshaving_ = nullptr;
  return temp;
}
inline ::commonmodule::PeakShaving* PROTOBUF_NONNULL EVSEFunction::_internal_mutable_peakshaving() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.peakshaving_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PeakShaving>(GetArena());
    _impl_.peakshaving_ = reinterpret_cast<::commonmodule::PeakShaving*>(p);
  }
  return _impl_.peakshaving_;
}
inline ::commonmodule::PeakShaving* PROTOBUF_NONNULL EVSEFunction::mutable_peakshaving()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::PeakShaving* _msg = _internal_mutable_peakshaving();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEFunction.peakShaving)
  return _msg;
}
inline void EVSEFunction::set_allocated_peakshaving(::commonmodule::PeakShaving* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.peakshaving_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.peakshaving_ = reinterpret_cast<::commonmodule::PeakShaving*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEFunction.peakShaving)
}

// .commonmodule.SocLimit socLimit = 4;
inline bool EVSEFunction::has_soclimit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.soclimit_ != nullptr);
  return value;
}
inline const ::commonmodule::SocLimit& EVSEFunction::_internal_soclimit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SocLimit* p = _impl_.soclimit_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SocLimit&>(::commonmodule::_SocLimit_default_instance_);
}
inline const ::commonmodule::SocLimit& EVSEFunction::soclimit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEFunction.socLimit)
  return _internal_soclimit();
}
inline void EVSEFunction::unsafe_arena_set_allocated_soclimit(
    ::commonmodule::SocLimit* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.soclimit_);
  }
  _impl_.soclimit_ = reinterpret_cast<::commonmodule::SocLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEFunction.socLimit)
}
inline ::commonmodule::SocLimit* PROTOBUF_NULLABLE EVSEFunction::release_soclimit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::SocLimit* released = _impl_.soclimit_;
  _impl_.soclimit_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SocLimit* PROTOBUF_NULLABLE EVSEFunction::unsafe_arena_release_soclimit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEFunction.socLimit)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::SocLimit* temp = _impl_.soclimit_;
  _impl_.soclimit_ = nullptr;
  return temp;
}
inline ::commonmodule::SocLimit* PROTOBUF_NONNULL EVSEFunction::_internal_mutable_soclimit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.soclimit_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SocLimit>(GetArena());
    _impl_.soclimit_ = reinterpret_cast<::commonmodule::SocLimit*>(p);
  }
  return _impl_.soclimit_;
}
inline ::commonmodule::SocLimit* PROTOBUF_NONNULL EVSEFunction::mutable_soclimit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::SocLimit* _msg = _internal_mutable_soclimit();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEFunction.socLimit)
  return _msg;
}
inline void EVSEFunction::set_allocated_soclimit(::commonmodule::SocLimit* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.soclimit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.soclimit_ = reinterpret_cast<::commonmodule::SocLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEFunction.socLimit)
}

// .commonmodule.SOCManagement socManagement = 5;
inline bool EVSEFunction::has_socmanagement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.socmanagement_ != nullptr);
  return value;
}
inline const ::commonmodule::SOCManagement& EVSEFunction::_internal_socmanagement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::SOCManagement* p = _impl_.socmanagement_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::SOCManagement&>(::commonmodule::_SOCManagement_default_instance_);
}
inline const ::commonmodule::SOCManagement& EVSEFunction::socmanagement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEFunction.socManagement)
  return _internal_socmanagement();
}
inline void EVSEFunction::unsafe_arena_set_allocated_socmanagement(
    ::commonmodule::SOCManagement* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.socmanagement_);
  }
  _impl_.socmanagement_ = reinterpret_cast<::commonmodule::SOCManagement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEFunction.socManagement)
}
inline ::commonmodule::SOCManagement* PROTOBUF_NULLABLE EVSEFunction::release_socmanagement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::SOCManagement* released = _impl_.socmanagement_;
  _impl_.socmanagement_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::SOCManagement* PROTOBUF_NULLABLE EVSEFunction::unsafe_arena_release_socmanagement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEFunction.socManagement)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::SOCManagement* temp = _impl_.socmanagement_;
  _impl_.socmanagement_ = nullptr;
  return temp;
}
inline ::commonmodule::SOCManagement* PROTOBUF_NONNULL EVSEFunction::_internal_mutable_socmanagement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.socmanagement_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::SOCManagement>(GetArena());
    _impl_.socmanagement_ = reinterpret_cast<::commonmodule::SOCManagement*>(p);
  }
  return _impl_.socmanagement_;
}
inline ::commonmodule::SOCManagement* PROTOBUF_NONNULL EVSEFunction::mutable_socmanagement()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::SOCManagement* _msg = _internal_mutable_socmanagement();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEFunction.socManagement)
  return _msg;
}
inline void EVSEFunction::set_allocated_socmanagement(::commonmodule::SOCManagement* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.socmanagement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.socmanagement_ = reinterpret_cast<::commonmodule::SOCManagement*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEFunction.socManagement)
}

// .commonmodule.VoltageDroop voltageDroop = 6;
inline bool EVSEFunction::has_voltagedroop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltagedroop_ != nullptr);
  return value;
}
inline const ::commonmodule::VoltageDroop& EVSEFunction::_internal_voltagedroop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VoltageDroop* p = _impl_.voltagedroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltageDroop&>(::commonmodule::_VoltageDroop_default_instance_);
}
inline const ::commonmodule::VoltageDroop& EVSEFunction::voltagedroop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEFunction.voltageDroop)
  return _internal_voltagedroop();
}
inline void EVSEFunction::unsafe_arena_set_allocated_voltagedroop(
    ::commonmodule::VoltageDroop* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagedroop_);
  }
  _impl_.voltagedroop_ = reinterpret_cast<::commonmodule::VoltageDroop*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEFunction.voltageDroop)
}
inline ::commonmodule::VoltageDroop* PROTOBUF_NULLABLE EVSEFunction::release_voltagedroop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::VoltageDroop* released = _impl_.voltagedroop_;
  _impl_.voltagedroop_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VoltageDroop* PROTOBUF_NULLABLE EVSEFunction::unsafe_arena_release_voltagedroop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEFunction.voltageDroop)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::VoltageDroop* temp = _impl_.voltagedroop_;
  _impl_.voltagedroop_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltageDroop* PROTOBUF_NONNULL EVSEFunction::_internal_mutable_voltagedroop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltagedroop_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VoltageDroop>(GetArena());
    _impl_.voltagedroop_ = reinterpret_cast<::commonmodule::VoltageDroop*>(p);
  }
  return _impl_.voltagedroop_;
}
inline ::commonmodule::VoltageDroop* PROTOBUF_NONNULL EVSEFunction::mutable_voltagedroop()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::VoltageDroop* _msg = _internal_mutable_voltagedroop();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEFunction.voltageDroop)
  return _msg;
}
inline void EVSEFunction::set_allocated_voltagedroop(::commonmodule::VoltageDroop* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagedroop_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.voltagedroop_ = reinterpret_cast<::commonmodule::VoltageDroop*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEFunction.voltageDroop)
}

// .commonmodule.VoltagePI voltagePI = 7;
inline bool EVSEFunction::has_voltagepi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltagepi_ != nullptr);
  return value;
}
inline const ::commonmodule::VoltagePI& EVSEFunction::_internal_voltagepi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VoltagePI* p = _impl_.voltagepi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltagePI&>(::commonmodule::_VoltagePI_default_instance_);
}
inline const ::commonmodule::VoltagePI& EVSEFunction::voltagepi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEFunction.voltagePI)
  return _internal_voltagepi();
}
inline void EVSEFunction::unsafe_arena_set_allocated_voltagepi(
    ::commonmodule::VoltagePI* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagepi_);
  }
  _impl_.voltagepi_ = reinterpret_cast<::commonmodule::VoltagePI*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEFunction.voltagePI)
}
inline ::commonmodule::VoltagePI* PROTOBUF_NULLABLE EVSEFunction::release_voltagepi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::VoltagePI* released = _impl_.voltagepi_;
  _impl_.voltagepi_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VoltagePI* PROTOBUF_NULLABLE EVSEFunction::unsafe_arena_release_voltagepi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEFunction.voltagePI)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::VoltagePI* temp = _impl_.voltagepi_;
  _impl_.voltagepi_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltagePI* PROTOBUF_NONNULL EVSEFunction::_internal_mutable_voltagepi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltagepi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VoltagePI>(GetArena());
    _impl_.voltagepi_ = reinterpret_cast<::commonmodule::VoltagePI*>(p);
  }
  return _impl_.voltagepi_;
}
inline ::commonmodule::VoltagePI* PROTOBUF_NONNULL EVSEFunction::mutable_voltagepi()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::VoltagePI* _msg = _internal_mutable_voltagepi();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEFunction.voltagePI)
  return _msg;
}
inline void EVSEFunction::set_allocated_voltagepi(::commonmodule::VoltagePI* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagepi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.voltagepi_ = reinterpret_cast<::commonmodule::VoltagePI*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEFunction.voltagePI)
}

// -------------------------------------------------------------------

// Optional_ChargingStateKind

// .evsemodule.ChargingStateKind value = 1;
inline void Optional_ChargingStateKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::ChargingStateKind Optional_ChargingStateKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_ChargingStateKind.value)
  return _internal_value();
}
inline void Optional_ChargingStateKind::set_value(::evsemodule::ChargingStateKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_ChargingStateKind.value)
}
inline ::evsemodule::ChargingStateKind Optional_ChargingStateKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::ChargingStateKind>(_impl_.value_);
}
inline void Optional_ChargingStateKind::_internal_set_value(::evsemodule::ChargingStateKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// EVSEPoint

// .evsemodule.EVSEFunction function = 3;
inline bool EVSEPoint::has_function() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.function_ != nullptr);
  return value;
}
inline void EVSEPoint::clear_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_ != nullptr) _impl_.function_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::evsemodule::EVSEFunction& EVSEPoint::_internal_function() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEFunction* p = _impl_.function_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEFunction&>(::evsemodule::_EVSEFunction_default_instance_);
}
inline const ::evsemodule::EVSEFunction& EVSEPoint::function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.function)
  return _internal_function();
}
inline void EVSEPoint::unsafe_arena_set_allocated_function(
    ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.function_);
  }
  _impl_.function_ = reinterpret_cast<::evsemodule::EVSEFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.function)
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE EVSEPoint::release_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSEFunction* released = _impl_.function_;
  _impl_.function_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.function)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSEFunction* temp = _impl_.function_;
  _impl_.function_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEFunction>(GetArena());
    _impl_.function_ = reinterpret_cast<::evsemodule::EVSEFunction*>(p);
  }
  return _impl_.function_;
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NONNULL EVSEPoint::mutable_function()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::evsemodule::EVSEFunction* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.function)
  return _msg;
}
inline void EVSEPoint::set_allocated_function(::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.function_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.function_ = reinterpret_cast<::evsemodule::EVSEFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.function)
}

// .commonmodule.ENG_GridConnectModeKind mode = 4;
inline bool EVSEPoint::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mode_ != nullptr);
  return value;
}
inline const ::commonmodule::ENG_GridConnectModeKind& EVSEPoint::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& EVSEPoint::mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.mode)
  return _internal_mode();
}
inline void EVSEPoint::unsafe_arena_set_allocated_mode(
    ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mode_);
  }
  _impl_.mode_ = reinterpret_cast<::commonmodule::ENG_GridConnectModeKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.mode)
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE EVSEPoint::release_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ENG_GridConnectModeKind* released = _impl_.mode_;
  _impl_.mode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.mode)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ENG_GridConnectModeKind>(GetArena());
    _impl_.mode_ = reinterpret_cast<::commonmodule::ENG_GridConnectModeKind*>(p);
  }
  return _impl_.mode_;
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL EVSEPoint::mutable_mode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.mode)
  return _msg;
}
inline void EVSEPoint::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mode_ = reinterpret_cast<::commonmodule::ENG_GridConnectModeKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.mode)
}

// .commonmodule.RampRate rampRates = 7;
inline bool EVSEPoint::has_ramprates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ramprates_ != nullptr);
  return value;
}
inline const ::commonmodule::RampRate& EVSEPoint::_internal_ramprates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& EVSEPoint::ramprates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.rampRates)
  return _internal_ramprates();
}
inline void EVSEPoint::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.rampRates)
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE EVSEPoint::release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::RampRate* released = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.rampRates)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ramprates_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::RampRate>(GetArena());
    _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(p);
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL EVSEPoint::mutable_ramprates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.rampRates)
  return _msg;
}
inline void EVSEPoint::set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.rampRates)
}

// .commonmodule.ControlSPC reset = 10;
inline bool EVSEPoint::has_reset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reset_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlSPC& EVSEPoint::_internal_reset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlSPC* p = _impl_.reset_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& EVSEPoint::reset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.reset)
  return _internal_reset();
}
inline void EVSEPoint::unsafe_arena_set_allocated_reset(
    ::commonmodule::ControlSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reset_);
  }
  _impl_.reset_ = reinterpret_cast<::commonmodule::ControlSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.reset)
}
inline ::commonmodule::ControlSPC* PROTOBUF_NULLABLE EVSEPoint::release_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ControlSPC* released = _impl_.reset_;
  _impl_.reset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlSPC* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.reset)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.reset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlSPC>(GetArena());
    _impl_.reset_ = reinterpret_cast<::commonmodule::ControlSPC*>(p);
  }
  return _impl_.reset_;
}
inline ::commonmodule::ControlSPC* PROTOBUF_NONNULL EVSEPoint::mutable_reset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::ControlSPC* _msg = _internal_mutable_reset();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.reset)
  return _msg;
}
inline void EVSEPoint::set_allocated_reset(::commonmodule::ControlSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.reset_ = reinterpret_cast<::commonmodule::ControlSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.reset)
}

// .evsemodule.Optional_ChargingStateKind state = 11;
inline bool EVSEPoint::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void EVSEPoint::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::evsemodule::Optional_ChargingStateKind& EVSEPoint::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::Optional_ChargingStateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::Optional_ChargingStateKind&>(::evsemodule::_Optional_ChargingStateKind_default_instance_);
}
inline const ::evsemodule::Optional_ChargingStateKind& EVSEPoint::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.state)
  return _internal_state();
}
inline void EVSEPoint::unsafe_arena_set_allocated_state(
    ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::evsemodule::Optional_ChargingStateKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.state)
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE EVSEPoint::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::Optional_ChargingStateKind* released = _impl_.state_;
  _impl_.state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.state)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::Optional_ChargingStateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::Optional_ChargingStateKind>(GetArena());
    _impl_.state_ = reinterpret_cast<::evsemodule::Optional_ChargingStateKind*>(p);
  }
  return _impl_.state_;
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL EVSEPoint::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::evsemodule::Optional_ChargingStateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.state)
  return _msg;
}
inline void EVSEPoint::set_allocated_state(::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.state_ = reinterpret_cast<::evsemodule::Optional_ChargingStateKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.state)
}

// .commonmodule.EnterServiceAPC enterServiceOperation = 16;
inline bool EVSEPoint::has_enterserviceoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.enterserviceoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::EnterServiceAPC& EVSEPoint::_internal_enterserviceoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::EnterServiceAPC* p = _impl_.enterserviceoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnterServiceAPC&>(::commonmodule::_EnterServiceAPC_default_instance_);
}
inline const ::commonmodule::EnterServiceAPC& EVSEPoint::enterserviceoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.enterServiceOperation)
  return _internal_enterserviceoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_enterserviceoperation(
    ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.enterserviceoperation_);
  }
  _impl_.enterserviceoperation_ = reinterpret_cast<::commonmodule::EnterServiceAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.enterServiceOperation)
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE EVSEPoint::release_enterserviceoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::EnterServiceAPC* released = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_enterserviceoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.enterServiceOperation)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_enterserviceoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.enterserviceoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::EnterServiceAPC>(GetArena());
    _impl_.enterserviceoperation_ = reinterpret_cast<::commonmodule::EnterServiceAPC*>(p);
  }
  return _impl_.enterserviceoperation_;
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL EVSEPoint::mutable_enterserviceoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::EnterServiceAPC* _msg = _internal_mutable_enterserviceoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.enterServiceOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.enterserviceoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.enterserviceoperation_ = reinterpret_cast<::commonmodule::EnterServiceAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.enterServiceOperation)
}

// .commonmodule.HzWAPC hzWOperation = 17;
inline bool EVSEPoint::has_hzwoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hzwoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::HzWAPC& EVSEPoint::_internal_hzwoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::HzWAPC* p = _impl_.hzwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWAPC&>(::commonmodule::_HzWAPC_default_instance_);
}
inline const ::commonmodule::HzWAPC& EVSEPoint::hzwoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.hzWOperation)
  return _internal_hzwoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_hzwoperation(
    ::commonmodule::HzWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hzwoperation_);
  }
  _impl_.hzwoperation_ = reinterpret_cast<::commonmodule::HzWAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.hzWOperation)
}
inline ::commonmodule::HzWAPC* PROTOBUF_NULLABLE EVSEPoint::release_hzwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::HzWAPC* released = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::HzWAPC* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_hzwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.hzWOperation)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWAPC* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_hzwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hzwoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::HzWAPC>(GetArena());
    _impl_.hzwoperation_ = reinterpret_cast<::commonmodule::HzWAPC*>(p);
  }
  return _impl_.hzwoperation_;
}
inline ::commonmodule::HzWAPC* PROTOBUF_NONNULL EVSEPoint::mutable_hzwoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::HzWAPC* _msg = _internal_mutable_hzwoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.hzWOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_hzwoperation(::commonmodule::HzWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hzwoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.hzwoperation_ = reinterpret_cast<::commonmodule::HzWAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.hzWOperation)
}

// .commonmodule.LimitWAPC limitWOperation = 18;
inline bool EVSEPoint::has_limitwoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limitwoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::LimitWAPC& EVSEPoint::_internal_limitwoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LimitWAPC* p = _impl_.limitwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LimitWAPC&>(::commonmodule::_LimitWAPC_default_instance_);
}
inline const ::commonmodule::LimitWAPC& EVSEPoint::limitwoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.limitWOperation)
  return _internal_limitwoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_limitwoperation(
    ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limitwoperation_);
  }
  _impl_.limitwoperation_ = reinterpret_cast<::commonmodule::LimitWAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.limitWOperation)
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE EVSEPoint::release_limitwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::LimitWAPC* released = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_limitwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.limitWOperation)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_limitwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.limitwoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LimitWAPC>(GetArena());
    _impl_.limitwoperation_ = reinterpret_cast<::commonmodule::LimitWAPC*>(p);
  }
  return _impl_.limitwoperation_;
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NONNULL EVSEPoint::mutable_limitwoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::commonmodule::LimitWAPC* _msg = _internal_mutable_limitwoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.limitWOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_limitwoperation(::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limitwoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.limitwoperation_ = reinterpret_cast<::commonmodule::LimitWAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.limitWOperation)
}

// .commonmodule.PFSPC pFOperation = 19;
inline bool EVSEPoint::has_pfoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pfoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::PFSPC& EVSEPoint::_internal_pfoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PFSPC* p = _impl_.pfoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PFSPC&>(::commonmodule::_PFSPC_default_instance_);
}
inline const ::commonmodule::PFSPC& EVSEPoint::pfoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.pFOperation)
  return _internal_pfoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_pfoperation(
    ::commonmodule::PFSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pfoperation_);
  }
  _impl_.pfoperation_ = reinterpret_cast<::commonmodule::PFSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.pFOperation)
}
inline ::commonmodule::PFSPC* PROTOBUF_NULLABLE EVSEPoint::release_pfoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::PFSPC* released = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PFSPC* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_pfoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.pFOperation)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::PFSPC* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_pfoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pfoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PFSPC>(GetArena());
    _impl_.pfoperation_ = reinterpret_cast<::commonmodule::PFSPC*>(p);
  }
  return _impl_.pfoperation_;
}
inline ::commonmodule::PFSPC* PROTOBUF_NONNULL EVSEPoint::mutable_pfoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::commonmodule::PFSPC* _msg = _internal_mutable_pfoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.pFOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_pfoperation(::commonmodule::PFSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pfoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.pfoperation_ = reinterpret_cast<::commonmodule::PFSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.pFOperation)
}

// .commonmodule.TmHzCSG tmHzTripOperation = 20;
inline bool EVSEPoint::has_tmhztripoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tmhztripoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::TmHzCSG& EVSEPoint::_internal_tmhztripoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::TmHzCSG* p = _impl_.tmhztripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmHzCSG&>(::commonmodule::_TmHzCSG_default_instance_);
}
inline const ::commonmodule::TmHzCSG& EVSEPoint::tmhztripoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.tmHzTripOperation)
  return _internal_tmhztripoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_tmhztripoperation(
    ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmhztripoperation_);
  }
  _impl_.tmhztripoperation_ = reinterpret_cast<::commonmodule::TmHzCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.tmHzTripOperation)
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE EVSEPoint::release_tmhztripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::TmHzCSG* released = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_tmhztripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.tmHzTripOperation)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_tmhztripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tmhztripoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::TmHzCSG>(GetArena());
    _impl_.tmhztripoperation_ = reinterpret_cast<::commonmodule::TmHzCSG*>(p);
  }
  return _impl_.tmhztripoperation_;
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NONNULL EVSEPoint::mutable_tmhztripoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::commonmodule::TmHzCSG* _msg = _internal_mutable_tmhztripoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.tmHzTripOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmhztripoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.tmhztripoperation_ = reinterpret_cast<::commonmodule::TmHzCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.tmHzTripOperation)
}

// .commonmodule.TmVoltCSG tmVoltTripOperation = 21;
inline bool EVSEPoint::has_tmvolttripoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tmvolttripoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::TmVoltCSG& EVSEPoint::_internal_tmvolttripoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::TmVoltCSG* p = _impl_.tmvolttripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmVoltCSG&>(::commonmodule::_TmVoltCSG_default_instance_);
}
inline const ::commonmodule::TmVoltCSG& EVSEPoint::tmvolttripoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.tmVoltTripOperation)
  return _internal_tmvolttripoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_tmvolttripoperation(
    ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  _impl_.tmvolttripoperation_ = reinterpret_cast<::commonmodule::TmVoltCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.tmVoltTripOperation)
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE EVSEPoint::release_tmvolttripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::TmVoltCSG* released = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_tmvolttripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.tmVoltTripOperation)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_tmvolttripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tmvolttripoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::TmVoltCSG>(GetArena());
    _impl_.tmvolttripoperation_ = reinterpret_cast<::commonmodule::TmVoltCSG*>(p);
  }
  return _impl_.tmvolttripoperation_;
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL EVSEPoint::mutable_tmvolttripoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::commonmodule::TmVoltCSG* _msg = _internal_mutable_tmvolttripoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.tmVoltTripOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmvolttripoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.tmvolttripoperation_ = reinterpret_cast<::commonmodule::TmVoltCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.tmVoltTripOperation)
}

// .commonmodule.VarSPC vArOperation = 22;
inline bool EVSEPoint::has_varoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.varoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::VarSPC& EVSEPoint::_internal_varoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VarSPC* p = _impl_.varoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VarSPC&>(::commonmodule::_VarSPC_default_instance_);
}
inline const ::commonmodule::VarSPC& EVSEPoint::varoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.vArOperation)
  return _internal_varoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_varoperation(
    ::commonmodule::VarSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.varoperation_);
  }
  _impl_.varoperation_ = reinterpret_cast<::commonmodule::VarSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.vArOperation)
}
inline ::commonmodule::VarSPC* PROTOBUF_NULLABLE EVSEPoint::release_varoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::VarSPC* released = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VarSPC* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_varoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.vArOperation)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VarSPC* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_varoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.varoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VarSPC>(GetArena());
    _impl_.varoperation_ = reinterpret_cast<::commonmodule::VarSPC*>(p);
  }
  return _impl_.varoperation_;
}
inline ::commonmodule::VarSPC* PROTOBUF_NONNULL EVSEPoint::mutable_varoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::commonmodule::VarSPC* _msg = _internal_mutable_varoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.vArOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_varoperation(::commonmodule::VarSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.varoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.varoperation_ = reinterpret_cast<::commonmodule::VarSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.vArOperation)
}

// .commonmodule.VoltVarCSG voltVarOperation = 23;
inline bool EVSEPoint::has_voltvaroperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltvaroperation_ != nullptr);
  return value;
}
inline const ::commonmodule::VoltVarCSG& EVSEPoint::_internal_voltvaroperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VoltVarCSG* p = _impl_.voltvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltVarCSG&>(::commonmodule::_VoltVarCSG_default_instance_);
}
inline const ::commonmodule::VoltVarCSG& EVSEPoint::voltvaroperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.voltVarOperation)
  return _internal_voltvaroperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_voltvaroperation(
    ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltvaroperation_);
  }
  _impl_.voltvaroperation_ = reinterpret_cast<::commonmodule::VoltVarCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.voltVarOperation)
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE EVSEPoint::release_voltvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::VoltVarCSG* released = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_voltvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.voltVarOperation)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_voltvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltvaroperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VoltVarCSG>(GetArena());
    _impl_.voltvaroperation_ = reinterpret_cast<::commonmodule::VoltVarCSG*>(p);
  }
  return _impl_.voltvaroperation_;
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL EVSEPoint::mutable_voltvaroperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00001000u;
  ::commonmodule::VoltVarCSG* _msg = _internal_mutable_voltvaroperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.voltVarOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltvaroperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.voltvaroperation_ = reinterpret_cast<::commonmodule::VoltVarCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.voltVarOperation)
}

// .commonmodule.VoltWCSG voltWOperation = 24;
inline bool EVSEPoint::has_voltwoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltwoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::VoltWCSG& EVSEPoint::_internal_voltwoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VoltWCSG* p = _impl_.voltwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltWCSG&>(::commonmodule::_VoltWCSG_default_instance_);
}
inline const ::commonmodule::VoltWCSG& EVSEPoint::voltwoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.voltWOperation)
  return _internal_voltwoperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_voltwoperation(
    ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltwoperation_);
  }
  _impl_.voltwoperation_ = reinterpret_cast<::commonmodule::VoltWCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.voltWOperation)
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE EVSEPoint::release_voltwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::commonmodule::VoltWCSG* released = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_voltwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.voltWOperation)

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_voltwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltwoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VoltWCSG>(GetArena());
    _impl_.voltwoperation_ = reinterpret_cast<::commonmodule::VoltWCSG*>(p);
  }
  return _impl_.voltwoperation_;
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NONNULL EVSEPoint::mutable_voltwoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00002000u;
  ::commonmodule::VoltWCSG* _msg = _internal_mutable_voltwoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.voltWOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_voltwoperation(::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltwoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }

  _impl_.voltwoperation_ = reinterpret_cast<::commonmodule::VoltWCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.voltWOperation)
}

// .commonmodule.WVarCSG wVarOperation = 25;
inline bool EVSEPoint::has_wvaroperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wvaroperation_ != nullptr);
  return value;
}
inline const ::commonmodule::WVarCSG& EVSEPoint::_internal_wvaroperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::WVarCSG* p = _impl_.wvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WVarCSG&>(::commonmodule::_WVarCSG_default_instance_);
}
inline const ::commonmodule::WVarCSG& EVSEPoint::wvaroperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.wVarOperation)
  return _internal_wvaroperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_wvaroperation(
    ::commonmodule::WVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wvaroperation_);
  }
  _impl_.wvaroperation_ = reinterpret_cast<::commonmodule::WVarCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.wVarOperation)
}
inline ::commonmodule::WVarCSG* PROTOBUF_NULLABLE EVSEPoint::release_wvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::commonmodule::WVarCSG* released = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::WVarCSG* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_wvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.wVarOperation)

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WVarCSG* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_wvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.wvaroperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::WVarCSG>(GetArena());
    _impl_.wvaroperation_ = reinterpret_cast<::commonmodule::WVarCSG*>(p);
  }
  return _impl_.wvaroperation_;
}
inline ::commonmodule::WVarCSG* PROTOBUF_NONNULL EVSEPoint::mutable_wvaroperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00004000u;
  ::commonmodule::WVarCSG* _msg = _internal_mutable_wvaroperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.wVarOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_wvaroperation(::commonmodule::WVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wvaroperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }

  _impl_.wvaroperation_ = reinterpret_cast<::commonmodule::WVarCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.wVarOperation)
}

// .commonmodule.WSPC wOperation = 26;
inline bool EVSEPoint::has_woperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.woperation_ != nullptr);
  return value;
}
inline const ::commonmodule::WSPC& EVSEPoint::_internal_woperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::WSPC* p = _impl_.woperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WSPC&>(::commonmodule::_WSPC_default_instance_);
}
inline const ::commonmodule::WSPC& EVSEPoint::woperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPoint.wOperation)
  return _internal_woperation();
}
inline void EVSEPoint::unsafe_arena_set_allocated_woperation(
    ::commonmodule::WSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.woperation_);
  }
  _impl_.woperation_ = reinterpret_cast<::commonmodule::WSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPoint.wOperation)
}
inline ::commonmodule::WSPC* PROTOBUF_NULLABLE EVSEPoint::release_woperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::commonmodule::WSPC* released = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::WSPC* PROTOBUF_NULLABLE EVSEPoint::unsafe_arena_release_woperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPoint.wOperation)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::commonmodule::WSPC* temp = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WSPC* PROTOBUF_NONNULL EVSEPoint::_internal_mutable_woperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.woperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::WSPC>(GetArena());
    _impl_.woperation_ = reinterpret_cast<::commonmodule::WSPC*>(p);
  }
  return _impl_.woperation_;
}
inline ::commonmodule::WSPC* PROTOBUF_NONNULL EVSEPoint::mutable_woperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00008000u;
  ::commonmodule::WSPC* _msg = _internal_mutable_woperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPoint.wOperation)
  return _msg;
}
inline void EVSEPoint::set_allocated_woperation(::commonmodule::WSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.woperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.woperation_ = reinterpret_cast<::commonmodule::WSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPoint.wOperation)
}

// -------------------------------------------------------------------

// EVSECurvePoint

// .evsemodule.EVSEPoint control = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSECurvePoint::has_control() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_ != nullptr);
  return value;
}
inline void EVSECurvePoint::clear_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.control_ != nullptr) _impl_.control_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::evsemodule::EVSEPoint& EVSECurvePoint::_internal_control() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEPoint* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEPoint&>(::evsemodule::_EVSEPoint_default_instance_);
}
inline const ::evsemodule::EVSEPoint& EVSECurvePoint::control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECurvePoint.control)
  return _internal_control();
}
inline void EVSECurvePoint::unsafe_arena_set_allocated_control(
    ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = reinterpret_cast<::evsemodule::EVSEPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECurvePoint.control)
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE EVSECurvePoint::release_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSEPoint* released = _impl_.control_;
  _impl_.control_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE EVSECurvePoint::unsafe_arena_release_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECurvePoint.control)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSEPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NONNULL EVSECurvePoint::_internal_mutable_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.control_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEPoint>(GetArena());
    _impl_.control_ = reinterpret_cast<::evsemodule::EVSEPoint*>(p);
  }
  return _impl_.control_;
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NONNULL EVSECurvePoint::mutable_control()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::evsemodule::EVSEPoint* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECurvePoint.control)
  return _msg;
}
inline void EVSECurvePoint::set_allocated_control(::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.control_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.control_ = reinterpret_cast<::evsemodule::EVSEPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECurvePoint.control)
}

// .commonmodule.ControlTimestamp startTime = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSECurvePoint::has_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starttime_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlTimestamp& EVSECurvePoint::_internal_starttime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlTimestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlTimestamp&>(::commonmodule::_ControlTimestamp_default_instance_);
}
inline const ::commonmodule::ControlTimestamp& EVSECurvePoint::starttime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECurvePoint.startTime)
  return _internal_starttime();
}
inline void EVSECurvePoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = reinterpret_cast<::commonmodule::ControlTimestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSECurvePoint.startTime)
}
inline ::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE EVSECurvePoint::release_starttime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ControlTimestamp* released = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE EVSECurvePoint::unsafe_arena_release_starttime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSECurvePoint.startTime)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* PROTOBUF_NONNULL EVSECurvePoint::_internal_mutable_starttime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.starttime_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlTimestamp>(GetArena());
    _impl_.starttime_ = reinterpret_cast<::commonmodule::ControlTimestamp*>(p);
  }
  return _impl_.starttime_;
}
inline ::commonmodule::ControlTimestamp* PROTOBUF_NONNULL EVSECurvePoint::mutable_starttime()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ControlTimestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECurvePoint.startTime)
  return _msg;
}
inline void EVSECurvePoint::set_allocated_starttime(::commonmodule::ControlTimestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starttime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.starttime_ = reinterpret_cast<::commonmodule::ControlTimestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSECurvePoint.startTime)
}

// uint64 duration = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EVSECurvePoint::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t EVSECurvePoint::duration() const {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECurvePoint.duration)
  return _internal_duration();
}
inline void EVSECurvePoint::set_duration(::uint64_t value) {
  _internal_set_duration(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.EVSECurvePoint.duration)
}
inline ::uint64_t EVSECurvePoint::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_;
}
inline void EVSECurvePoint::_internal_set_duration(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = value;
}

// uint64 stackLevel = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EVSECurvePoint::clear_stacklevel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stacklevel_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t EVSECurvePoint::stacklevel() const {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECurvePoint.stackLevel)
  return _internal_stacklevel();
}
inline void EVSECurvePoint::set_stacklevel(::uint64_t value) {
  _internal_set_stacklevel(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:evsemodule.EVSECurvePoint.stackLevel)
}
inline ::uint64_t EVSECurvePoint::_internal_stacklevel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stacklevel_;
}
inline void EVSECurvePoint::_internal_set_stacklevel(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stacklevel_ = value;
}

// uint64 id = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void EVSECurvePoint::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t EVSECurvePoint::id() const {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECurvePoint.id)
  return _internal_id();
}
inline void EVSECurvePoint::set_id(::uint64_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:evsemodule.EVSECurvePoint.id)
}
inline ::uint64_t EVSECurvePoint::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void EVSECurvePoint::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// EVSECSG

// repeated .evsemodule.EVSECurvePoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int EVSECSG::_internal_crvpts_size() const {
  return _internal_crvpts().size();
}
inline int EVSECSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void EVSECSG::clear_crvpts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.crvpts_.Clear();
}
inline ::evsemodule::EVSECurvePoint* PROTOBUF_NONNULL EVSECSG::mutable_crvpts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSECSG.crvPts)
  return _internal_mutable_crvpts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>* PROTOBUF_NONNULL EVSECSG::mutable_crvpts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSECSG.crvPts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_crvpts();
}
inline const ::evsemodule::EVSECurvePoint& EVSECSG::crvpts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSECSG.crvPts)
  return _internal_crvpts().Get(index);
}
inline ::evsemodule::EVSECurvePoint* PROTOBUF_NONNULL EVSECSG::add_crvpts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::EVSECurvePoint* _add = _internal_mutable_crvpts()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSECSG.crvPts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>& EVSECSG::crvpts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSECSG.crvPts)
  return _internal_crvpts();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>&
EVSECSG::_internal_crvpts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.crvpts_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EVSECurvePoint>* PROTOBUF_NONNULL
EVSECSG::_internal_mutable_crvpts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.crvpts_;
}

// -------------------------------------------------------------------

// DESEControlScheduleFSCH

// .evsemodule.EVSECSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool DESEControlScheduleFSCH::has_valdcsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.valdcsg_ != nullptr);
  return value;
}
inline void DESEControlScheduleFSCH::clear_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.valdcsg_ != nullptr) _impl_.valdcsg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::evsemodule::EVSECSG& DESEControlScheduleFSCH::_internal_valdcsg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSECSG* p = _impl_.valdcsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSECSG&>(::evsemodule::_EVSECSG_default_instance_);
}
inline const ::evsemodule::EVSECSG& DESEControlScheduleFSCH::valdcsg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.DESEControlScheduleFSCH.ValDCSG)
  return _internal_valdcsg();
}
inline void DESEControlScheduleFSCH::unsafe_arena_set_allocated_valdcsg(
    ::evsemodule::EVSECSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.valdcsg_);
  }
  _impl_.valdcsg_ = reinterpret_cast<::evsemodule::EVSECSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.DESEControlScheduleFSCH.ValDCSG)
}
inline ::evsemodule::EVSECSG* PROTOBUF_NULLABLE DESEControlScheduleFSCH::release_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSECSG* released = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSECSG* PROTOBUF_NULLABLE DESEControlScheduleFSCH::unsafe_arena_release_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.DESEControlScheduleFSCH.ValDCSG)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSECSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSECSG* PROTOBUF_NONNULL DESEControlScheduleFSCH::_internal_mutable_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.valdcsg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSECSG>(GetArena());
    _impl_.valdcsg_ = reinterpret_cast<::evsemodule::EVSECSG*>(p);
  }
  return _impl_.valdcsg_;
}
inline ::evsemodule::EVSECSG* PROTOBUF_NONNULL DESEControlScheduleFSCH::mutable_valdcsg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::evsemodule::EVSECSG* _msg = _internal_mutable_valdcsg();
  // @@protoc_insertion_point(field_mutable:evsemodule.DESEControlScheduleFSCH.ValDCSG)
  return _msg;
}
inline void DESEControlScheduleFSCH::set_allocated_valdcsg(::evsemodule::EVSECSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.valdcsg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.valdcsg_ = reinterpret_cast<::evsemodule::EVSECSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.DESEControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// DEEVControlScheduleFSCH

// .commonmodule.ScheduleCSG ValACSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool DEEVControlScheduleFSCH::has_valacsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.valacsg_ != nullptr);
  return value;
}
inline const ::commonmodule::ScheduleCSG& DEEVControlScheduleFSCH::_internal_valacsg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ScheduleCSG* p = _impl_.valacsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ScheduleCSG&>(::commonmodule::_ScheduleCSG_default_instance_);
}
inline const ::commonmodule::ScheduleCSG& DEEVControlScheduleFSCH::valacsg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.DEEVControlScheduleFSCH.ValACSG)
  return _internal_valacsg();
}
inline void DEEVControlScheduleFSCH::unsafe_arena_set_allocated_valacsg(
    ::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.valacsg_);
  }
  _impl_.valacsg_ = reinterpret_cast<::commonmodule::ScheduleCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.DEEVControlScheduleFSCH.ValACSG)
}
inline ::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE DEEVControlScheduleFSCH::release_valacsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ScheduleCSG* released = _impl_.valacsg_;
  _impl_.valacsg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE DEEVControlScheduleFSCH::unsafe_arena_release_valacsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.DEEVControlScheduleFSCH.ValACSG)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ScheduleCSG* temp = _impl_.valacsg_;
  _impl_.valacsg_ = nullptr;
  return temp;
}
inline ::commonmodule::ScheduleCSG* PROTOBUF_NONNULL DEEVControlScheduleFSCH::_internal_mutable_valacsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.valacsg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ScheduleCSG>(GetArena());
    _impl_.valacsg_ = reinterpret_cast<::commonmodule::ScheduleCSG*>(p);
  }
  return _impl_.valacsg_;
}
inline ::commonmodule::ScheduleCSG* PROTOBUF_NONNULL DEEVControlScheduleFSCH::mutable_valacsg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ScheduleCSG* _msg = _internal_mutable_valacsg();
  // @@protoc_insertion_point(field_mutable:evsemodule.DEEVControlScheduleFSCH.ValACSG)
  return _msg;
}
inline void DEEVControlScheduleFSCH::set_allocated_valacsg(::commonmodule::ScheduleCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.valacsg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.valacsg_ = reinterpret_cast<::commonmodule::ScheduleCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.DEEVControlScheduleFSCH.ValACSG)
}

// -------------------------------------------------------------------

// ControlDEEV

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool ControlDEEV::has_logicalnodeforcontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforcontrol_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForControl& ControlDEEV::_internal_logicalnodeforcontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& ControlDEEV::logicalnodeforcontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDEEV.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void ControlDEEV::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDEEV.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE ControlDEEV::release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* released = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE ControlDEEV::unsafe_arena_release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDEEV.logicalNodeForControl)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL ControlDEEV::_internal_mutable_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForControl>(GetArena());
    _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(p);
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL ControlDEEV::mutable_logicalnodeforcontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDEEV.logicalNodeForControl)
  return _msg;
}
inline void ControlDEEV::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDEEV.logicalNodeForControl)
}

// .evsemodule.DEEVControlScheduleFSCH deevControlScheduleFSCH = 2;
inline bool ControlDEEV::has_deevcontrolschedulefsch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deevcontrolschedulefsch_ != nullptr);
  return value;
}
inline void ControlDEEV::clear_deevcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.deevcontrolschedulefsch_ != nullptr) _impl_.deevcontrolschedulefsch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::DEEVControlScheduleFSCH& ControlDEEV::_internal_deevcontrolschedulefsch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::DEEVControlScheduleFSCH* p = _impl_.deevcontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::DEEVControlScheduleFSCH&>(::evsemodule::_DEEVControlScheduleFSCH_default_instance_);
}
inline const ::evsemodule::DEEVControlScheduleFSCH& ControlDEEV::deevcontrolschedulefsch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDEEV.deevControlScheduleFSCH)
  return _internal_deevcontrolschedulefsch();
}
inline void ControlDEEV::unsafe_arena_set_allocated_deevcontrolschedulefsch(
    ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deevcontrolschedulefsch_);
  }
  _impl_.deevcontrolschedulefsch_ = reinterpret_cast<::evsemodule::DEEVControlScheduleFSCH*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDEEV.deevControlScheduleFSCH)
}
inline ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE ControlDEEV::release_deevcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::DEEVControlScheduleFSCH* released = _impl_.deevcontrolschedulefsch_;
  _impl_.deevcontrolschedulefsch_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE ControlDEEV::unsafe_arena_release_deevcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDEEV.deevControlScheduleFSCH)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::DEEVControlScheduleFSCH* temp = _impl_.deevcontrolschedulefsch_;
  _impl_.deevcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NONNULL ControlDEEV::_internal_mutable_deevcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.deevcontrolschedulefsch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::DEEVControlScheduleFSCH>(GetArena());
    _impl_.deevcontrolschedulefsch_ = reinterpret_cast<::evsemodule::DEEVControlScheduleFSCH*>(p);
  }
  return _impl_.deevcontrolschedulefsch_;
}
inline ::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NONNULL ControlDEEV::mutable_deevcontrolschedulefsch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::DEEVControlScheduleFSCH* _msg = _internal_mutable_deevcontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDEEV.deevControlScheduleFSCH)
  return _msg;
}
inline void ControlDEEV::set_allocated_deevcontrolschedulefsch(::evsemodule::DEEVControlScheduleFSCH* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deevcontrolschedulefsch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.deevcontrolschedulefsch_ = reinterpret_cast<::evsemodule::DEEVControlScheduleFSCH*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDEEV.deevControlScheduleFSCH)
}

// -------------------------------------------------------------------

// ControlDEAO

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool ControlDEAO::has_logicalnodeforcontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforcontrol_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForControl& ControlDEAO::_internal_logicalnodeforcontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& ControlDEAO::logicalnodeforcontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDEAO.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void ControlDEAO::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDEAO.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE ControlDEAO::release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* released = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE ControlDEAO::unsafe_arena_release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDEAO.logicalNodeForControl)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL ControlDEAO::_internal_mutable_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForControl>(GetArena());
    _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(p);
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL ControlDEAO::mutable_logicalnodeforcontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDEAO.logicalNodeForControl)
  return _msg;
}
inline void ControlDEAO::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDEAO.logicalNodeForControl)
}

// .evsemodule.ControlDEEV controlDEEV = 2;
inline bool ControlDEAO::has_controldeev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controldeev_ != nullptr);
  return value;
}
inline void ControlDEAO::clear_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeev_ != nullptr) _impl_.controldeev_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::ControlDEEV& ControlDEAO::_internal_controldeev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ControlDEEV* p = _impl_.controldeev_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ControlDEEV&>(::evsemodule::_ControlDEEV_default_instance_);
}
inline const ::evsemodule::ControlDEEV& ControlDEAO::controldeev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDEAO.controlDEEV)
  return _internal_controldeev();
}
inline void ControlDEAO::unsafe_arena_set_allocated_controldeev(
    ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeev_);
  }
  _impl_.controldeev_ = reinterpret_cast<::evsemodule::ControlDEEV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDEAO.controlDEEV)
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE ControlDEAO::release_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ControlDEEV* released = _impl_.controldeev_;
  _impl_.controldeev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE ControlDEAO::unsafe_arena_release_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDEAO.controlDEEV)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ControlDEEV* temp = _impl_.controldeev_;
  _impl_.controldeev_ = nullptr;
  return temp;
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NONNULL ControlDEAO::_internal_mutable_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ControlDEEV>(GetArena());
    _impl_.controldeev_ = reinterpret_cast<::evsemodule::ControlDEEV*>(p);
  }
  return _impl_.controldeev_;
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NONNULL ControlDEAO::mutable_controldeev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::ControlDEEV* _msg = _internal_mutable_controldeev();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDEAO.controlDEEV)
  return _msg;
}
inline void ControlDEAO::set_allocated_controldeev(::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.controldeev_ = reinterpret_cast<::evsemodule::ControlDEEV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDEAO.controlDEEV)
}

// -------------------------------------------------------------------

// ControlDEDO

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool ControlDEDO::has_logicalnodeforcontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforcontrol_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForControl& ControlDEDO::_internal_logicalnodeforcontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& ControlDEDO::logicalnodeforcontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDEDO.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void ControlDEDO::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDEDO.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE ControlDEDO::release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* released = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE ControlDEDO::unsafe_arena_release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDEDO.logicalNodeForControl)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL ControlDEDO::_internal_mutable_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForControl>(GetArena());
    _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(p);
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL ControlDEDO::mutable_logicalnodeforcontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDEDO.logicalNodeForControl)
  return _msg;
}
inline void ControlDEDO::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDEDO.logicalNodeForControl)
}

// .evsemodule.ControlDEEV controlDEEV = 2;
inline bool ControlDEDO::has_controldeev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controldeev_ != nullptr);
  return value;
}
inline void ControlDEDO::clear_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeev_ != nullptr) _impl_.controldeev_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::ControlDEEV& ControlDEDO::_internal_controldeev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ControlDEEV* p = _impl_.controldeev_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ControlDEEV&>(::evsemodule::_ControlDEEV_default_instance_);
}
inline const ::evsemodule::ControlDEEV& ControlDEDO::controldeev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDEDO.controlDEEV)
  return _internal_controldeev();
}
inline void ControlDEDO::unsafe_arena_set_allocated_controldeev(
    ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeev_);
  }
  _impl_.controldeev_ = reinterpret_cast<::evsemodule::ControlDEEV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDEDO.controlDEEV)
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE ControlDEDO::release_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ControlDEEV* released = _impl_.controldeev_;
  _impl_.controldeev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NULLABLE ControlDEDO::unsafe_arena_release_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDEDO.controlDEEV)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ControlDEEV* temp = _impl_.controldeev_;
  _impl_.controldeev_ = nullptr;
  return temp;
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NONNULL ControlDEDO::_internal_mutable_controldeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ControlDEEV>(GetArena());
    _impl_.controldeev_ = reinterpret_cast<::evsemodule::ControlDEEV*>(p);
  }
  return _impl_.controldeev_;
}
inline ::evsemodule::ControlDEEV* PROTOBUF_NONNULL ControlDEDO::mutable_controldeev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::ControlDEEV* _msg = _internal_mutable_controldeev();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDEDO.controlDEEV)
  return _msg;
}
inline void ControlDEDO::set_allocated_controldeev(::evsemodule::ControlDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.controldeev_ = reinterpret_cast<::evsemodule::ControlDEEV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDEDO.controlDEEV)
}

// -------------------------------------------------------------------

// ControlDESE

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool ControlDESE::has_controlfscc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlfscc_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlFSCC& ControlDESE::_internal_controlfscc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlFSCC* p = _impl_.controlfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlFSCC&>(::commonmodule::_ControlFSCC_default_instance_);
}
inline const ::commonmodule::ControlFSCC& ControlDESE::controlfscc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDESE.controlFSCC)
  return _internal_controlfscc();
}
inline void ControlDESE::unsafe_arena_set_allocated_controlfscc(
    ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlfscc_);
  }
  _impl_.controlfscc_ = reinterpret_cast<::commonmodule::ControlFSCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDESE.controlFSCC)
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE ControlDESE::release_controlfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlFSCC* released = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE ControlDESE::unsafe_arena_release_controlfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDESE.controlFSCC)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NONNULL ControlDESE::_internal_mutable_controlfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlfscc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlFSCC>(GetArena());
    _impl_.controlfscc_ = reinterpret_cast<::commonmodule::ControlFSCC*>(p);
  }
  return _impl_.controlfscc_;
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NONNULL ControlDESE::mutable_controlfscc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlFSCC* _msg = _internal_mutable_controlfscc();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDESE.controlFSCC)
  return _msg;
}
inline void ControlDESE::set_allocated_controlfscc(::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlfscc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlfscc_ = reinterpret_cast<::commonmodule::ControlFSCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDESE.controlFSCC)
}

// .evsemodule.DESEControlScheduleFSCH deseControlScheduleFSCH = 2;
inline bool ControlDESE::has_desecontrolschedulefsch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.desecontrolschedulefsch_ != nullptr);
  return value;
}
inline void ControlDESE::clear_desecontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.desecontrolschedulefsch_ != nullptr) _impl_.desecontrolschedulefsch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::DESEControlScheduleFSCH& ControlDESE::_internal_desecontrolschedulefsch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::DESEControlScheduleFSCH* p = _impl_.desecontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::DESEControlScheduleFSCH&>(::evsemodule::_DESEControlScheduleFSCH_default_instance_);
}
inline const ::evsemodule::DESEControlScheduleFSCH& ControlDESE::desecontrolschedulefsch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDESE.deseControlScheduleFSCH)
  return _internal_desecontrolschedulefsch();
}
inline void ControlDESE::unsafe_arena_set_allocated_desecontrolschedulefsch(
    ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.desecontrolschedulefsch_);
  }
  _impl_.desecontrolschedulefsch_ = reinterpret_cast<::evsemodule::DESEControlScheduleFSCH*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDESE.deseControlScheduleFSCH)
}
inline ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE ControlDESE::release_desecontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::DESEControlScheduleFSCH* released = _impl_.desecontrolschedulefsch_;
  _impl_.desecontrolschedulefsch_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE ControlDESE::unsafe_arena_release_desecontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDESE.deseControlScheduleFSCH)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::DESEControlScheduleFSCH* temp = _impl_.desecontrolschedulefsch_;
  _impl_.desecontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NONNULL ControlDESE::_internal_mutable_desecontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.desecontrolschedulefsch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::DESEControlScheduleFSCH>(GetArena());
    _impl_.desecontrolschedulefsch_ = reinterpret_cast<::evsemodule::DESEControlScheduleFSCH*>(p);
  }
  return _impl_.desecontrolschedulefsch_;
}
inline ::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NONNULL ControlDESE::mutable_desecontrolschedulefsch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::DESEControlScheduleFSCH* _msg = _internal_mutable_desecontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDESE.deseControlScheduleFSCH)
  return _msg;
}
inline void ControlDESE::set_allocated_desecontrolschedulefsch(::evsemodule::DESEControlScheduleFSCH* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.desecontrolschedulefsch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.desecontrolschedulefsch_ = reinterpret_cast<::evsemodule::DESEControlScheduleFSCH*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDESE.deseControlScheduleFSCH)
}

// .evsemodule.ControlDEAO controlDEAO = 3;
inline bool ControlDESE::has_controldeao() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controldeao_ != nullptr);
  return value;
}
inline void ControlDESE::clear_controldeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeao_ != nullptr) _impl_.controldeao_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::ControlDEAO& ControlDESE::_internal_controldeao() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ControlDEAO* p = _impl_.controldeao_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ControlDEAO&>(::evsemodule::_ControlDEAO_default_instance_);
}
inline const ::evsemodule::ControlDEAO& ControlDESE::controldeao() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDESE.controlDEAO)
  return _internal_controldeao();
}
inline void ControlDESE::unsafe_arena_set_allocated_controldeao(
    ::evsemodule::ControlDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeao_);
  }
  _impl_.controldeao_ = reinterpret_cast<::evsemodule::ControlDEAO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDESE.controlDEAO)
}
inline ::evsemodule::ControlDEAO* PROTOBUF_NULLABLE ControlDESE::release_controldeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::ControlDEAO* released = _impl_.controldeao_;
  _impl_.controldeao_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ControlDEAO* PROTOBUF_NULLABLE ControlDESE::unsafe_arena_release_controldeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDESE.controlDEAO)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::ControlDEAO* temp = _impl_.controldeao_;
  _impl_.controldeao_ = nullptr;
  return temp;
}
inline ::evsemodule::ControlDEAO* PROTOBUF_NONNULL ControlDESE::_internal_mutable_controldeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeao_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ControlDEAO>(GetArena());
    _impl_.controldeao_ = reinterpret_cast<::evsemodule::ControlDEAO*>(p);
  }
  return _impl_.controldeao_;
}
inline ::evsemodule::ControlDEAO* PROTOBUF_NONNULL ControlDESE::mutable_controldeao()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::ControlDEAO* _msg = _internal_mutable_controldeao();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDESE.controlDEAO)
  return _msg;
}
inline void ControlDESE::set_allocated_controldeao(::evsemodule::ControlDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeao_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.controldeao_ = reinterpret_cast<::evsemodule::ControlDEAO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDESE.controlDEAO)
}

// .evsemodule.ControlDEDO controlDEEO = 4;
inline bool ControlDESE::has_controldeeo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controldeeo_ != nullptr);
  return value;
}
inline void ControlDESE::clear_controldeeo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeeo_ != nullptr) _impl_.controldeeo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::evsemodule::ControlDEDO& ControlDESE::_internal_controldeeo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ControlDEDO* p = _impl_.controldeeo_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ControlDEDO&>(::evsemodule::_ControlDEDO_default_instance_);
}
inline const ::evsemodule::ControlDEDO& ControlDESE::controldeeo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDESE.controlDEEO)
  return _internal_controldeeo();
}
inline void ControlDESE::unsafe_arena_set_allocated_controldeeo(
    ::evsemodule::ControlDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeeo_);
  }
  _impl_.controldeeo_ = reinterpret_cast<::evsemodule::ControlDEDO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDESE.controlDEEO)
}
inline ::evsemodule::ControlDEDO* PROTOBUF_NULLABLE ControlDESE::release_controldeeo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ControlDEDO* released = _impl_.controldeeo_;
  _impl_.controldeeo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ControlDEDO* PROTOBUF_NULLABLE ControlDESE::unsafe_arena_release_controldeeo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDESE.controlDEEO)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ControlDEDO* temp = _impl_.controldeeo_;
  _impl_.controldeeo_ = nullptr;
  return temp;
}
inline ::evsemodule::ControlDEDO* PROTOBUF_NONNULL ControlDESE::_internal_mutable_controldeeo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controldeeo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ControlDEDO>(GetArena());
    _impl_.controldeeo_ = reinterpret_cast<::evsemodule::ControlDEDO*>(p);
  }
  return _impl_.controldeeo_;
}
inline ::evsemodule::ControlDEDO* PROTOBUF_NONNULL ControlDESE::mutable_controldeeo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::evsemodule::ControlDEDO* _msg = _internal_mutable_controldeeo();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDESE.controlDEEO)
  return _msg;
}
inline void ControlDESE::set_allocated_controldeeo(::evsemodule::ControlDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controldeeo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.controldeeo_ = reinterpret_cast<::evsemodule::ControlDEDO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDESE.controlDEEO)
}

// .google.protobuf.FloatValue ChaAMax = 5;
inline bool ControlDESE::has_chaamax() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chaamax_ != nullptr);
  return value;
}
inline const ::google::protobuf::FloatValue& ControlDESE::_internal_chaamax() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FloatValue* p = _impl_.chaamax_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FloatValue&>(::google::protobuf::_FloatValue_default_instance_);
}
inline const ::google::protobuf::FloatValue& ControlDESE::chaamax() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ControlDESE.ChaAMax)
  return _internal_chaamax();
}
inline void ControlDESE::unsafe_arena_set_allocated_chaamax(
    ::google::protobuf::FloatValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaamax_);
  }
  _impl_.chaamax_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ControlDESE.ChaAMax)
}
inline ::google::protobuf::FloatValue* PROTOBUF_NULLABLE ControlDESE::release_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::FloatValue* released = _impl_.chaamax_;
  _impl_.chaamax_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::FloatValue* PROTOBUF_NULLABLE ControlDESE::unsafe_arena_release_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ControlDESE.ChaAMax)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::FloatValue* temp = _impl_.chaamax_;
  _impl_.chaamax_ = nullptr;
  return temp;
}
inline ::google::protobuf::FloatValue* PROTOBUF_NONNULL ControlDESE::_internal_mutable_chaamax() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chaamax_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FloatValue>(GetArena());
    _impl_.chaamax_ = reinterpret_cast<::google::protobuf::FloatValue*>(p);
  }
  return _impl_.chaamax_;
}
inline ::google::protobuf::FloatValue* PROTOBUF_NONNULL ControlDESE::mutable_chaamax()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::FloatValue* _msg = _internal_mutable_chaamax();
  // @@protoc_insertion_point(field_mutable:evsemodule.ControlDESE.ChaAMax)
  return _msg;
}
inline void ControlDESE::set_allocated_chaamax(::google::protobuf::FloatValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaamax_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.chaamax_ = reinterpret_cast<::google::protobuf::FloatValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ControlDESE.ChaAMax)
}

// -------------------------------------------------------------------

// EVSEControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool EVSEControl::has_controlvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlValue& EVSEControl::_internal_controlvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& EVSEControl::controlvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEControl.controlValue)
  return _internal_controlvalue();
}
inline void EVSEControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEControl.controlValue)
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE EVSEControl::release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* released = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE EVSEControl::unsafe_arena_release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEControl.controlValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL EVSEControl::_internal_mutable_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlValue>(GetArena());
    _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(p);
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL EVSEControl::mutable_controlvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEControl.controlValue)
  return _msg;
}
inline void EVSEControl::set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEControl.controlValue)
}

// repeated .evsemodule.ControlDESE controlDESE = 2 [(.uml.option_multiplicity_min) = 0];
inline int EVSEControl::_internal_controldese_size() const {
  return _internal_controldese().size();
}
inline int EVSEControl::controldese_size() const {
  return _internal_controldese_size();
}
inline void EVSEControl::clear_controldese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controldese_.Clear();
}
inline ::evsemodule::ControlDESE* PROTOBUF_NONNULL EVSEControl::mutable_controldese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEControl.controlDESE)
  return _internal_mutable_controldese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>* PROTOBUF_NONNULL EVSEControl::mutable_controldese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSEControl.controlDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_controldese();
}
inline const ::evsemodule::ControlDESE& EVSEControl::controldese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEControl.controlDESE)
  return _internal_controldese().Get(index);
}
inline ::evsemodule::ControlDESE* PROTOBUF_NONNULL EVSEControl::add_controldese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::ControlDESE* _add = _internal_mutable_controldese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSEControl.controlDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>& EVSEControl::controldese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSEControl.controlDESE)
  return _internal_controldese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>&
EVSEControl::_internal_controldese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.controldese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::ControlDESE>* PROTOBUF_NONNULL
EVSEControl::_internal_mutable_controldese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.controldese_;
}

// .commonmodule.CheckConditions check = 3;
inline bool EVSEControl::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_ != nullptr);
  return value;
}
inline const ::commonmodule::CheckConditions& EVSEControl::_internal_check() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& EVSEControl::check() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEControl.check)
  return _internal_check();
}
inline void EVSEControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEControl.check)
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE EVSEControl::release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* released = _impl_.check_;
  _impl_.check_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE EVSEControl::unsafe_arena_release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEControl.check)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL EVSEControl::_internal_mutable_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.check_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::CheckConditions>(GetArena());
    _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(p);
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL EVSEControl::mutable_check()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEControl.check)
  return _msg;
}
inline void EVSEControl::set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEControl.check)
}

// -------------------------------------------------------------------

// EVSEControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EVSEControlProfile::has_controlmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlMessageInfo& EVSEControlProfile::_internal_controlmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& EVSEControlProfile::controlmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void EVSEControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE EVSEControlProfile::release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* released = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE EVSEControlProfile::unsafe_arena_release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEControlProfile.controlMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL EVSEControlProfile::_internal_mutable_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlMessageInfo>(GetArena());
    _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(p);
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL EVSEControlProfile::mutable_controlmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEControlProfile.controlMessageInfo)
  return _msg;
}
inline void EVSEControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEControlProfile.controlMessageInfo)
}

// .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEControlProfile::has_evse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evse_ != nullptr);
  return value;
}
inline void EVSEControlProfile::clear_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ != nullptr) _impl_.evse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSE& EVSEControlProfile::_internal_evse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSE* p = _impl_.evse_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSE&>(::evsemodule::_EVSE_default_instance_);
}
inline const ::evsemodule::EVSE& EVSEControlProfile::evse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEControlProfile.evse)
  return _internal_evse();
}
inline void EVSEControlProfile::unsafe_arena_set_allocated_evse(
    ::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }
  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEControlProfile.evse)
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEControlProfile::release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* released = _impl_.evse_;
  _impl_.evse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEControlProfile::unsafe_arena_release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEControlProfile.evse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* temp = _impl_.evse_;
  _impl_.evse_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEControlProfile::_internal_mutable_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSE>(GetArena());
    _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(p);
  }
  return _impl_.evse_;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEControlProfile::mutable_evse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSE* _msg = _internal_mutable_evse();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEControlProfile.evse)
  return _msg;
}
inline void EVSEControlProfile::set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEControlProfile.evse)
}

// .evsemodule.EVSEControl evseControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEControlProfile::has_evsecontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evsecontrol_ != nullptr);
  return value;
}
inline void EVSEControlProfile::clear_evsecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsecontrol_ != nullptr) _impl_.evsecontrol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EVSEControl& EVSEControlProfile::_internal_evsecontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEControl* p = _impl_.evsecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEControl&>(::evsemodule::_EVSEControl_default_instance_);
}
inline const ::evsemodule::EVSEControl& EVSEControlProfile::evsecontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEControlProfile.evseControl)
  return _internal_evsecontrol();
}
inline void EVSEControlProfile::unsafe_arena_set_allocated_evsecontrol(
    ::evsemodule::EVSEControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsecontrol_);
  }
  _impl_.evsecontrol_ = reinterpret_cast<::evsemodule::EVSEControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEControlProfile.evseControl)
}
inline ::evsemodule::EVSEControl* PROTOBUF_NULLABLE EVSEControlProfile::release_evsecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEControl* released = _impl_.evsecontrol_;
  _impl_.evsecontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEControl* PROTOBUF_NULLABLE EVSEControlProfile::unsafe_arena_release_evsecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEControlProfile.evseControl)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEControl* temp = _impl_.evsecontrol_;
  _impl_.evsecontrol_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEControl* PROTOBUF_NONNULL EVSEControlProfile::_internal_mutable_evsecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsecontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEControl>(GetArena());
    _impl_.evsecontrol_ = reinterpret_cast<::evsemodule::EVSEControl*>(p);
  }
  return _impl_.evsecontrol_;
}
inline ::evsemodule::EVSEControl* PROTOBUF_NONNULL EVSEControlProfile::mutable_evsecontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EVSEControl* _msg = _internal_mutable_evsecontrol();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEControlProfile.evseControl)
  return _msg;
}
inline void EVSEControlProfile::set_allocated_evsecontrol(::evsemodule::EVSEControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsecontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.evsecontrol_ = reinterpret_cast<::evsemodule::EVSEControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEControlProfile.evseControl)
}

// -------------------------------------------------------------------

// DiscreteControlDESE

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool DiscreteControlDESE::has_logicalnodeforcontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforcontrol_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForControl& DiscreteControlDESE::_internal_logicalnodeforcontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& DiscreteControlDESE::logicalnodeforcontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.DiscreteControlDESE.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void DiscreteControlDESE::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.DiscreteControlDESE.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE DiscreteControlDESE::release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* released = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE DiscreteControlDESE::unsafe_arena_release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.DiscreteControlDESE.logicalNodeForControl)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL DiscreteControlDESE::_internal_mutable_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForControl>(GetArena());
    _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(p);
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL DiscreteControlDESE::mutable_logicalnodeforcontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:evsemodule.DiscreteControlDESE.logicalNodeForControl)
  return _msg;
}
inline void DiscreteControlDESE::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.DiscreteControlDESE.logicalNodeForControl)
}

// .evsemodule.EVSEPoint control = 3;
inline bool DiscreteControlDESE::has_control() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_ != nullptr);
  return value;
}
inline void DiscreteControlDESE::clear_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.control_ != nullptr) _impl_.control_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSEPoint& DiscreteControlDESE::_internal_control() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEPoint* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEPoint&>(::evsemodule::_EVSEPoint_default_instance_);
}
inline const ::evsemodule::EVSEPoint& DiscreteControlDESE::control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.DiscreteControlDESE.control)
  return _internal_control();
}
inline void DiscreteControlDESE::unsafe_arena_set_allocated_control(
    ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = reinterpret_cast<::evsemodule::EVSEPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.DiscreteControlDESE.control)
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE DiscreteControlDESE::release_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSEPoint* released = _impl_.control_;
  _impl_.control_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NULLABLE DiscreteControlDESE::unsafe_arena_release_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.DiscreteControlDESE.control)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSEPoint* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NONNULL DiscreteControlDESE::_internal_mutable_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.control_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEPoint>(GetArena());
    _impl_.control_ = reinterpret_cast<::evsemodule::EVSEPoint*>(p);
  }
  return _impl_.control_;
}
inline ::evsemodule::EVSEPoint* PROTOBUF_NONNULL DiscreteControlDESE::mutable_control()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSEPoint* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:evsemodule.DiscreteControlDESE.control)
  return _msg;
}
inline void DiscreteControlDESE::set_allocated_control(::evsemodule::EVSEPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.control_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.control_ = reinterpret_cast<::evsemodule::EVSEPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.DiscreteControlDESE.control)
}

// -------------------------------------------------------------------

// EVSEDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool EVSEDiscreteControl::has_controlvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlValue& EVSEDiscreteControl::_internal_controlvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& EVSEDiscreteControl::controlvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEDiscreteControl.controlValue)
  return _internal_controlvalue();
}
inline void EVSEDiscreteControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEDiscreteControl.controlValue)
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE EVSEDiscreteControl::release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* released = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE EVSEDiscreteControl::unsafe_arena_release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEDiscreteControl.controlValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL EVSEDiscreteControl::_internal_mutable_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlValue>(GetArena());
    _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(p);
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL EVSEDiscreteControl::mutable_controlvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEDiscreteControl.controlValue)
  return _msg;
}
inline void EVSEDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEDiscreteControl.controlValue)
}

// repeated .evsemodule.DiscreteControlDESE discreteControlDESE = 2 [(.uml.option_multiplicity_min) = 0];
inline int EVSEDiscreteControl::_internal_discretecontroldese_size() const {
  return _internal_discretecontroldese().size();
}
inline int EVSEDiscreteControl::discretecontroldese_size() const {
  return _internal_discretecontroldese_size();
}
inline void EVSEDiscreteControl::clear_discretecontroldese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.discretecontroldese_.Clear();
}
inline ::evsemodule::DiscreteControlDESE* PROTOBUF_NONNULL EVSEDiscreteControl::mutable_discretecontroldese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEDiscreteControl.discreteControlDESE)
  return _internal_mutable_discretecontroldese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>* PROTOBUF_NONNULL EVSEDiscreteControl::mutable_discretecontroldese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSEDiscreteControl.discreteControlDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_discretecontroldese();
}
inline const ::evsemodule::DiscreteControlDESE& EVSEDiscreteControl::discretecontroldese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEDiscreteControl.discreteControlDESE)
  return _internal_discretecontroldese().Get(index);
}
inline ::evsemodule::DiscreteControlDESE* PROTOBUF_NONNULL EVSEDiscreteControl::add_discretecontroldese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::DiscreteControlDESE* _add = _internal_mutable_discretecontroldese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSEDiscreteControl.discreteControlDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>& EVSEDiscreteControl::discretecontroldese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSEDiscreteControl.discreteControlDESE)
  return _internal_discretecontroldese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>&
EVSEDiscreteControl::_internal_discretecontroldese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.discretecontroldese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::DiscreteControlDESE>* PROTOBUF_NONNULL
EVSEDiscreteControl::_internal_mutable_discretecontroldese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.discretecontroldese_;
}

// .commonmodule.CheckConditions check = 3;
inline bool EVSEDiscreteControl::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_ != nullptr);
  return value;
}
inline const ::commonmodule::CheckConditions& EVSEDiscreteControl::_internal_check() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& EVSEDiscreteControl::check() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEDiscreteControl.check)
  return _internal_check();
}
inline void EVSEDiscreteControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEDiscreteControl.check)
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE EVSEDiscreteControl::release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* released = _impl_.check_;
  _impl_.check_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE EVSEDiscreteControl::unsafe_arena_release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEDiscreteControl.check)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL EVSEDiscreteControl::_internal_mutable_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.check_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::CheckConditions>(GetArena());
    _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(p);
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL EVSEDiscreteControl::mutable_check()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEDiscreteControl.check)
  return _msg;
}
inline void EVSEDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEDiscreteControl.check)
}

// -------------------------------------------------------------------

// EVSEDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EVSEDiscreteControlProfile::has_controlmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlMessageInfo& EVSEDiscreteControlProfile::_internal_controlmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& EVSEDiscreteControlProfile::controlmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEDiscreteControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void EVSEDiscreteControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEDiscreteControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE EVSEDiscreteControlProfile::release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* released = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE EVSEDiscreteControlProfile::unsafe_arena_release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEDiscreteControlProfile.controlMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL EVSEDiscreteControlProfile::_internal_mutable_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlMessageInfo>(GetArena());
    _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(p);
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL EVSEDiscreteControlProfile::mutable_controlmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEDiscreteControlProfile.controlMessageInfo)
  return _msg;
}
inline void EVSEDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEDiscreteControlProfile.controlMessageInfo)
}

// .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEDiscreteControlProfile::has_evse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evse_ != nullptr);
  return value;
}
inline void EVSEDiscreteControlProfile::clear_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ != nullptr) _impl_.evse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSE& EVSEDiscreteControlProfile::_internal_evse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSE* p = _impl_.evse_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSE&>(::evsemodule::_EVSE_default_instance_);
}
inline const ::evsemodule::EVSE& EVSEDiscreteControlProfile::evse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEDiscreteControlProfile.evse)
  return _internal_evse();
}
inline void EVSEDiscreteControlProfile::unsafe_arena_set_allocated_evse(
    ::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }
  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEDiscreteControlProfile.evse)
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEDiscreteControlProfile::release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* released = _impl_.evse_;
  _impl_.evse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEDiscreteControlProfile::unsafe_arena_release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEDiscreteControlProfile.evse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* temp = _impl_.evse_;
  _impl_.evse_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEDiscreteControlProfile::_internal_mutable_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSE>(GetArena());
    _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(p);
  }
  return _impl_.evse_;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEDiscreteControlProfile::mutable_evse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSE* _msg = _internal_mutable_evse();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEDiscreteControlProfile.evse)
  return _msg;
}
inline void EVSEDiscreteControlProfile::set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEDiscreteControlProfile.evse)
}

// .evsemodule.EVSEDiscreteControl evseDiscreteControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEDiscreteControlProfile::has_evsediscretecontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evsediscretecontrol_ != nullptr);
  return value;
}
inline void EVSEDiscreteControlProfile::clear_evsediscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsediscretecontrol_ != nullptr) _impl_.evsediscretecontrol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EVSEDiscreteControl& EVSEDiscreteControlProfile::_internal_evsediscretecontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEDiscreteControl* p = _impl_.evsediscretecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEDiscreteControl&>(::evsemodule::_EVSEDiscreteControl_default_instance_);
}
inline const ::evsemodule::EVSEDiscreteControl& EVSEDiscreteControlProfile::evsediscretecontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEDiscreteControlProfile.evseDiscreteControl)
  return _internal_evsediscretecontrol();
}
inline void EVSEDiscreteControlProfile::unsafe_arena_set_allocated_evsediscretecontrol(
    ::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsediscretecontrol_);
  }
  _impl_.evsediscretecontrol_ = reinterpret_cast<::evsemodule::EVSEDiscreteControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEDiscreteControlProfile.evseDiscreteControl)
}
inline ::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE EVSEDiscreteControlProfile::release_evsediscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEDiscreteControl* released = _impl_.evsediscretecontrol_;
  _impl_.evsediscretecontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE EVSEDiscreteControlProfile::unsafe_arena_release_evsediscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEDiscreteControlProfile.evseDiscreteControl)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEDiscreteControl* temp = _impl_.evsediscretecontrol_;
  _impl_.evsediscretecontrol_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEDiscreteControl* PROTOBUF_NONNULL EVSEDiscreteControlProfile::_internal_mutable_evsediscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsediscretecontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEDiscreteControl>(GetArena());
    _impl_.evsediscretecontrol_ = reinterpret_cast<::evsemodule::EVSEDiscreteControl*>(p);
  }
  return _impl_.evsediscretecontrol_;
}
inline ::evsemodule::EVSEDiscreteControl* PROTOBUF_NONNULL EVSEDiscreteControlProfile::mutable_evsediscretecontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EVSEDiscreteControl* _msg = _internal_mutable_evsediscretecontrol();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEDiscreteControlProfile.evseDiscreteControl)
  return _msg;
}
inline void EVSEDiscreteControlProfile::set_allocated_evsediscretecontrol(::evsemodule::EVSEDiscreteControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsediscretecontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.evsediscretecontrol_ = reinterpret_cast<::evsemodule::EVSEDiscreteControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEDiscreteControlProfile.evseDiscreteControl)
}

// -------------------------------------------------------------------

// EVSEPointStatus

// .evsemodule.EVSEFunction function = 3;
inline bool EVSEPointStatus::has_function() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.function_ != nullptr);
  return value;
}
inline void EVSEPointStatus::clear_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_ != nullptr) _impl_.function_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::evsemodule::EVSEFunction& EVSEPointStatus::_internal_function() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEFunction* p = _impl_.function_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEFunction&>(::evsemodule::_EVSEFunction_default_instance_);
}
inline const ::evsemodule::EVSEFunction& EVSEPointStatus::function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.function)
  return _internal_function();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_function(
    ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.function_);
  }
  _impl_.function_ = reinterpret_cast<::evsemodule::EVSEFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.function)
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE EVSEPointStatus::release_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSEFunction* released = _impl_.function_;
  _impl_.function_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.function)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::evsemodule::EVSEFunction* temp = _impl_.function_;
  _impl_.function_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.function_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEFunction>(GetArena());
    _impl_.function_ = reinterpret_cast<::evsemodule::EVSEFunction*>(p);
  }
  return _impl_.function_;
}
inline ::evsemodule::EVSEFunction* PROTOBUF_NONNULL EVSEPointStatus::mutable_function()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::evsemodule::EVSEFunction* _msg = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.function)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_function(::evsemodule::EVSEFunction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.function_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.function_ = reinterpret_cast<::evsemodule::EVSEFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.function)
}

// .commonmodule.ENG_GridConnectModeKind mode = 4;
inline bool EVSEPointStatus::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mode_ != nullptr);
  return value;
}
inline const ::commonmodule::ENG_GridConnectModeKind& EVSEPointStatus::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ENG_GridConnectModeKind* p = _impl_.mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENG_GridConnectModeKind&>(::commonmodule::_ENG_GridConnectModeKind_default_instance_);
}
inline const ::commonmodule::ENG_GridConnectModeKind& EVSEPointStatus::mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.mode)
  return _internal_mode();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_mode(
    ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mode_);
  }
  _impl_.mode_ = reinterpret_cast<::commonmodule::ENG_GridConnectModeKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.mode)
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE EVSEPointStatus::release_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ENG_GridConnectModeKind* released = _impl_.mode_;
  _impl_.mode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.mode)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ENG_GridConnectModeKind* temp = _impl_.mode_;
  _impl_.mode_ = nullptr;
  return temp;
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ENG_GridConnectModeKind>(GetArena());
    _impl_.mode_ = reinterpret_cast<::commonmodule::ENG_GridConnectModeKind*>(p);
  }
  return _impl_.mode_;
}
inline ::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NONNULL EVSEPointStatus::mutable_mode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ENG_GridConnectModeKind* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.mode)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_mode(::commonmodule::ENG_GridConnectModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mode_ = reinterpret_cast<::commonmodule::ENG_GridConnectModeKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.mode)
}

// .commonmodule.RampRate rampRates = 7;
inline bool EVSEPointStatus::has_ramprates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ramprates_ != nullptr);
  return value;
}
inline const ::commonmodule::RampRate& EVSEPointStatus::_internal_ramprates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& EVSEPointStatus::ramprates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.rampRates)
  return _internal_ramprates();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.rampRates)
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE EVSEPointStatus::release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::RampRate* released = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.rampRates)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ramprates_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::RampRate>(GetArena());
    _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(p);
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL EVSEPointStatus::mutable_ramprates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.rampRates)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.rampRates)
}

// .commonmodule.ControlSPC reset = 10;
inline bool EVSEPointStatus::has_reset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reset_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlSPC& EVSEPointStatus::_internal_reset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlSPC* p = _impl_.reset_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& EVSEPointStatus::reset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.reset)
  return _internal_reset();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_reset(
    ::commonmodule::ControlSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reset_);
  }
  _impl_.reset_ = reinterpret_cast<::commonmodule::ControlSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.reset)
}
inline ::commonmodule::ControlSPC* PROTOBUF_NULLABLE EVSEPointStatus::release_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ControlSPC* released = _impl_.reset_;
  _impl_.reset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlSPC* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.reset)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.reset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlSPC>(GetArena());
    _impl_.reset_ = reinterpret_cast<::commonmodule::ControlSPC*>(p);
  }
  return _impl_.reset_;
}
inline ::commonmodule::ControlSPC* PROTOBUF_NONNULL EVSEPointStatus::mutable_reset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::ControlSPC* _msg = _internal_mutable_reset();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.reset)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_reset(::commonmodule::ControlSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.reset_ = reinterpret_cast<::commonmodule::ControlSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.reset)
}

// .evsemodule.Optional_ChargingStateKind state = 11;
inline bool EVSEPointStatus::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void EVSEPointStatus::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::evsemodule::Optional_ChargingStateKind& EVSEPointStatus::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::Optional_ChargingStateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::Optional_ChargingStateKind&>(::evsemodule::_Optional_ChargingStateKind_default_instance_);
}
inline const ::evsemodule::Optional_ChargingStateKind& EVSEPointStatus::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.state)
  return _internal_state();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_state(
    ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::evsemodule::Optional_ChargingStateKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.state)
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE EVSEPointStatus::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::Optional_ChargingStateKind* released = _impl_.state_;
  _impl_.state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.state)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::Optional_ChargingStateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::Optional_ChargingStateKind>(GetArena());
    _impl_.state_ = reinterpret_cast<::evsemodule::Optional_ChargingStateKind*>(p);
  }
  return _impl_.state_;
}
inline ::evsemodule::Optional_ChargingStateKind* PROTOBUF_NONNULL EVSEPointStatus::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::evsemodule::Optional_ChargingStateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.state)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_state(::evsemodule::Optional_ChargingStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.state_ = reinterpret_cast<::evsemodule::Optional_ChargingStateKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.state)
}

// .commonmodule.EnterServiceAPC enterServiceOperation = 16;
inline bool EVSEPointStatus::has_enterserviceoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.enterserviceoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::EnterServiceAPC& EVSEPointStatus::_internal_enterserviceoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::EnterServiceAPC* p = _impl_.enterserviceoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnterServiceAPC&>(::commonmodule::_EnterServiceAPC_default_instance_);
}
inline const ::commonmodule::EnterServiceAPC& EVSEPointStatus::enterserviceoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.enterServiceOperation)
  return _internal_enterserviceoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_enterserviceoperation(
    ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.enterserviceoperation_);
  }
  _impl_.enterserviceoperation_ = reinterpret_cast<::commonmodule::EnterServiceAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.enterServiceOperation)
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE EVSEPointStatus::release_enterserviceoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::EnterServiceAPC* released = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_enterserviceoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.enterServiceOperation)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::EnterServiceAPC* temp = _impl_.enterserviceoperation_;
  _impl_.enterserviceoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_enterserviceoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.enterserviceoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::EnterServiceAPC>(GetArena());
    _impl_.enterserviceoperation_ = reinterpret_cast<::commonmodule::EnterServiceAPC*>(p);
  }
  return _impl_.enterserviceoperation_;
}
inline ::commonmodule::EnterServiceAPC* PROTOBUF_NONNULL EVSEPointStatus::mutable_enterserviceoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::EnterServiceAPC* _msg = _internal_mutable_enterserviceoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.enterServiceOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_enterserviceoperation(::commonmodule::EnterServiceAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.enterserviceoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.enterserviceoperation_ = reinterpret_cast<::commonmodule::EnterServiceAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.enterServiceOperation)
}

// .commonmodule.HzWAPC hzWOperation = 17;
inline bool EVSEPointStatus::has_hzwoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hzwoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::HzWAPC& EVSEPointStatus::_internal_hzwoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::HzWAPC* p = _impl_.hzwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::HzWAPC&>(::commonmodule::_HzWAPC_default_instance_);
}
inline const ::commonmodule::HzWAPC& EVSEPointStatus::hzwoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.hzWOperation)
  return _internal_hzwoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_hzwoperation(
    ::commonmodule::HzWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hzwoperation_);
  }
  _impl_.hzwoperation_ = reinterpret_cast<::commonmodule::HzWAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.hzWOperation)
}
inline ::commonmodule::HzWAPC* PROTOBUF_NULLABLE EVSEPointStatus::release_hzwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::HzWAPC* released = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::HzWAPC* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_hzwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.hzWOperation)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::HzWAPC* temp = _impl_.hzwoperation_;
  _impl_.hzwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::HzWAPC* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_hzwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hzwoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::HzWAPC>(GetArena());
    _impl_.hzwoperation_ = reinterpret_cast<::commonmodule::HzWAPC*>(p);
  }
  return _impl_.hzwoperation_;
}
inline ::commonmodule::HzWAPC* PROTOBUF_NONNULL EVSEPointStatus::mutable_hzwoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::HzWAPC* _msg = _internal_mutable_hzwoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.hzWOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_hzwoperation(::commonmodule::HzWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hzwoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.hzwoperation_ = reinterpret_cast<::commonmodule::HzWAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.hzWOperation)
}

// .commonmodule.LimitWAPC limitWOperation = 18;
inline bool EVSEPointStatus::has_limitwoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limitwoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::LimitWAPC& EVSEPointStatus::_internal_limitwoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LimitWAPC* p = _impl_.limitwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LimitWAPC&>(::commonmodule::_LimitWAPC_default_instance_);
}
inline const ::commonmodule::LimitWAPC& EVSEPointStatus::limitwoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.limitWOperation)
  return _internal_limitwoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_limitwoperation(
    ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limitwoperation_);
  }
  _impl_.limitwoperation_ = reinterpret_cast<::commonmodule::LimitWAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.limitWOperation)
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE EVSEPointStatus::release_limitwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::LimitWAPC* released = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_limitwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.limitWOperation)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::LimitWAPC* temp = _impl_.limitwoperation_;
  _impl_.limitwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_limitwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.limitwoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LimitWAPC>(GetArena());
    _impl_.limitwoperation_ = reinterpret_cast<::commonmodule::LimitWAPC*>(p);
  }
  return _impl_.limitwoperation_;
}
inline ::commonmodule::LimitWAPC* PROTOBUF_NONNULL EVSEPointStatus::mutable_limitwoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::commonmodule::LimitWAPC* _msg = _internal_mutable_limitwoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.limitWOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_limitwoperation(::commonmodule::LimitWAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limitwoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.limitwoperation_ = reinterpret_cast<::commonmodule::LimitWAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.limitWOperation)
}

// .commonmodule.PFSPC pFOperation = 19;
inline bool EVSEPointStatus::has_pfoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pfoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::PFSPC& EVSEPointStatus::_internal_pfoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PFSPC* p = _impl_.pfoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PFSPC&>(::commonmodule::_PFSPC_default_instance_);
}
inline const ::commonmodule::PFSPC& EVSEPointStatus::pfoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.pFOperation)
  return _internal_pfoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_pfoperation(
    ::commonmodule::PFSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pfoperation_);
  }
  _impl_.pfoperation_ = reinterpret_cast<::commonmodule::PFSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.pFOperation)
}
inline ::commonmodule::PFSPC* PROTOBUF_NULLABLE EVSEPointStatus::release_pfoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::PFSPC* released = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PFSPC* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_pfoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.pFOperation)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::PFSPC* temp = _impl_.pfoperation_;
  _impl_.pfoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::PFSPC* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_pfoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pfoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PFSPC>(GetArena());
    _impl_.pfoperation_ = reinterpret_cast<::commonmodule::PFSPC*>(p);
  }
  return _impl_.pfoperation_;
}
inline ::commonmodule::PFSPC* PROTOBUF_NONNULL EVSEPointStatus::mutable_pfoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::commonmodule::PFSPC* _msg = _internal_mutable_pfoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.pFOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_pfoperation(::commonmodule::PFSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pfoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.pfoperation_ = reinterpret_cast<::commonmodule::PFSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.pFOperation)
}

// .commonmodule.TmHzCSG tmHzTripOperation = 20;
inline bool EVSEPointStatus::has_tmhztripoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tmhztripoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::TmHzCSG& EVSEPointStatus::_internal_tmhztripoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::TmHzCSG* p = _impl_.tmhztripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmHzCSG&>(::commonmodule::_TmHzCSG_default_instance_);
}
inline const ::commonmodule::TmHzCSG& EVSEPointStatus::tmhztripoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.tmHzTripOperation)
  return _internal_tmhztripoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_tmhztripoperation(
    ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmhztripoperation_);
  }
  _impl_.tmhztripoperation_ = reinterpret_cast<::commonmodule::TmHzCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.tmHzTripOperation)
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE EVSEPointStatus::release_tmhztripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::TmHzCSG* released = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_tmhztripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.tmHzTripOperation)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::TmHzCSG* temp = _impl_.tmhztripoperation_;
  _impl_.tmhztripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_tmhztripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tmhztripoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::TmHzCSG>(GetArena());
    _impl_.tmhztripoperation_ = reinterpret_cast<::commonmodule::TmHzCSG*>(p);
  }
  return _impl_.tmhztripoperation_;
}
inline ::commonmodule::TmHzCSG* PROTOBUF_NONNULL EVSEPointStatus::mutable_tmhztripoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::commonmodule::TmHzCSG* _msg = _internal_mutable_tmhztripoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.tmHzTripOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_tmhztripoperation(::commonmodule::TmHzCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmhztripoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.tmhztripoperation_ = reinterpret_cast<::commonmodule::TmHzCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.tmHzTripOperation)
}

// .commonmodule.TmVoltCSG tmVoltTripOperation = 21;
inline bool EVSEPointStatus::has_tmvolttripoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tmvolttripoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::TmVoltCSG& EVSEPointStatus::_internal_tmvolttripoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::TmVoltCSG* p = _impl_.tmvolttripoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::TmVoltCSG&>(::commonmodule::_TmVoltCSG_default_instance_);
}
inline const ::commonmodule::TmVoltCSG& EVSEPointStatus::tmvolttripoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.tmVoltTripOperation)
  return _internal_tmvolttripoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_tmvolttripoperation(
    ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmvolttripoperation_);
  }
  _impl_.tmvolttripoperation_ = reinterpret_cast<::commonmodule::TmVoltCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.tmVoltTripOperation)
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE EVSEPointStatus::release_tmvolttripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::TmVoltCSG* released = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_tmvolttripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.tmVoltTripOperation)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::TmVoltCSG* temp = _impl_.tmvolttripoperation_;
  _impl_.tmvolttripoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_tmvolttripoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tmvolttripoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::TmVoltCSG>(GetArena());
    _impl_.tmvolttripoperation_ = reinterpret_cast<::commonmodule::TmVoltCSG*>(p);
  }
  return _impl_.tmvolttripoperation_;
}
inline ::commonmodule::TmVoltCSG* PROTOBUF_NONNULL EVSEPointStatus::mutable_tmvolttripoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::commonmodule::TmVoltCSG* _msg = _internal_mutable_tmvolttripoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.tmVoltTripOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_tmvolttripoperation(::commonmodule::TmVoltCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tmvolttripoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.tmvolttripoperation_ = reinterpret_cast<::commonmodule::TmVoltCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.tmVoltTripOperation)
}

// .commonmodule.VarSPC vArOperation = 22;
inline bool EVSEPointStatus::has_varoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.varoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::VarSPC& EVSEPointStatus::_internal_varoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VarSPC* p = _impl_.varoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VarSPC&>(::commonmodule::_VarSPC_default_instance_);
}
inline const ::commonmodule::VarSPC& EVSEPointStatus::varoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.vArOperation)
  return _internal_varoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_varoperation(
    ::commonmodule::VarSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.varoperation_);
  }
  _impl_.varoperation_ = reinterpret_cast<::commonmodule::VarSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.vArOperation)
}
inline ::commonmodule::VarSPC* PROTOBUF_NULLABLE EVSEPointStatus::release_varoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::VarSPC* released = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VarSPC* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_varoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.vArOperation)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::VarSPC* temp = _impl_.varoperation_;
  _impl_.varoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VarSPC* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_varoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.varoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VarSPC>(GetArena());
    _impl_.varoperation_ = reinterpret_cast<::commonmodule::VarSPC*>(p);
  }
  return _impl_.varoperation_;
}
inline ::commonmodule::VarSPC* PROTOBUF_NONNULL EVSEPointStatus::mutable_varoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::commonmodule::VarSPC* _msg = _internal_mutable_varoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.vArOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_varoperation(::commonmodule::VarSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.varoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.varoperation_ = reinterpret_cast<::commonmodule::VarSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.vArOperation)
}

// .commonmodule.VoltVarCSG voltVarOperation = 23;
inline bool EVSEPointStatus::has_voltvaroperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltvaroperation_ != nullptr);
  return value;
}
inline const ::commonmodule::VoltVarCSG& EVSEPointStatus::_internal_voltvaroperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VoltVarCSG* p = _impl_.voltvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltVarCSG&>(::commonmodule::_VoltVarCSG_default_instance_);
}
inline const ::commonmodule::VoltVarCSG& EVSEPointStatus::voltvaroperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.voltVarOperation)
  return _internal_voltvaroperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_voltvaroperation(
    ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltvaroperation_);
  }
  _impl_.voltvaroperation_ = reinterpret_cast<::commonmodule::VoltVarCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.voltVarOperation)
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE EVSEPointStatus::release_voltvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::VoltVarCSG* released = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_voltvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.voltVarOperation)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::VoltVarCSG* temp = _impl_.voltvaroperation_;
  _impl_.voltvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_voltvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltvaroperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VoltVarCSG>(GetArena());
    _impl_.voltvaroperation_ = reinterpret_cast<::commonmodule::VoltVarCSG*>(p);
  }
  return _impl_.voltvaroperation_;
}
inline ::commonmodule::VoltVarCSG* PROTOBUF_NONNULL EVSEPointStatus::mutable_voltvaroperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00001000u;
  ::commonmodule::VoltVarCSG* _msg = _internal_mutable_voltvaroperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.voltVarOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_voltvaroperation(::commonmodule::VoltVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltvaroperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.voltvaroperation_ = reinterpret_cast<::commonmodule::VoltVarCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.voltVarOperation)
}

// .commonmodule.VoltWCSG voltWOperation = 24;
inline bool EVSEPointStatus::has_voltwoperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltwoperation_ != nullptr);
  return value;
}
inline const ::commonmodule::VoltWCSG& EVSEPointStatus::_internal_voltwoperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::VoltWCSG* p = _impl_.voltwoperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::VoltWCSG&>(::commonmodule::_VoltWCSG_default_instance_);
}
inline const ::commonmodule::VoltWCSG& EVSEPointStatus::voltwoperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.voltWOperation)
  return _internal_voltwoperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_voltwoperation(
    ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltwoperation_);
  }
  _impl_.voltwoperation_ = reinterpret_cast<::commonmodule::VoltWCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.voltWOperation)
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE EVSEPointStatus::release_voltwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::commonmodule::VoltWCSG* released = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_voltwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.voltWOperation)

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::commonmodule::VoltWCSG* temp = _impl_.voltwoperation_;
  _impl_.voltwoperation_ = nullptr;
  return temp;
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_voltwoperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltwoperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::VoltWCSG>(GetArena());
    _impl_.voltwoperation_ = reinterpret_cast<::commonmodule::VoltWCSG*>(p);
  }
  return _impl_.voltwoperation_;
}
inline ::commonmodule::VoltWCSG* PROTOBUF_NONNULL EVSEPointStatus::mutable_voltwoperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00002000u;
  ::commonmodule::VoltWCSG* _msg = _internal_mutable_voltwoperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.voltWOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_voltwoperation(::commonmodule::VoltWCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltwoperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }

  _impl_.voltwoperation_ = reinterpret_cast<::commonmodule::VoltWCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.voltWOperation)
}

// .commonmodule.WVarCSG wVarOperation = 25;
inline bool EVSEPointStatus::has_wvaroperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wvaroperation_ != nullptr);
  return value;
}
inline const ::commonmodule::WVarCSG& EVSEPointStatus::_internal_wvaroperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::WVarCSG* p = _impl_.wvaroperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WVarCSG&>(::commonmodule::_WVarCSG_default_instance_);
}
inline const ::commonmodule::WVarCSG& EVSEPointStatus::wvaroperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.wVarOperation)
  return _internal_wvaroperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_wvaroperation(
    ::commonmodule::WVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wvaroperation_);
  }
  _impl_.wvaroperation_ = reinterpret_cast<::commonmodule::WVarCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.wVarOperation)
}
inline ::commonmodule::WVarCSG* PROTOBUF_NULLABLE EVSEPointStatus::release_wvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::commonmodule::WVarCSG* released = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::WVarCSG* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_wvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.wVarOperation)

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::commonmodule::WVarCSG* temp = _impl_.wvaroperation_;
  _impl_.wvaroperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WVarCSG* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_wvaroperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.wvaroperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::WVarCSG>(GetArena());
    _impl_.wvaroperation_ = reinterpret_cast<::commonmodule::WVarCSG*>(p);
  }
  return _impl_.wvaroperation_;
}
inline ::commonmodule::WVarCSG* PROTOBUF_NONNULL EVSEPointStatus::mutable_wvaroperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00004000u;
  ::commonmodule::WVarCSG* _msg = _internal_mutable_wvaroperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.wVarOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_wvaroperation(::commonmodule::WVarCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wvaroperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }

  _impl_.wvaroperation_ = reinterpret_cast<::commonmodule::WVarCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.wVarOperation)
}

// .commonmodule.WSPC wOperation = 26;
inline bool EVSEPointStatus::has_woperation() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.woperation_ != nullptr);
  return value;
}
inline const ::commonmodule::WSPC& EVSEPointStatus::_internal_woperation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::WSPC* p = _impl_.woperation_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::WSPC&>(::commonmodule::_WSPC_default_instance_);
}
inline const ::commonmodule::WSPC& EVSEPointStatus::woperation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.wOperation)
  return _internal_woperation();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_woperation(
    ::commonmodule::WSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.woperation_);
  }
  _impl_.woperation_ = reinterpret_cast<::commonmodule::WSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.wOperation)
}
inline ::commonmodule::WSPC* PROTOBUF_NULLABLE EVSEPointStatus::release_woperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::commonmodule::WSPC* released = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::WSPC* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_woperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.wOperation)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::commonmodule::WSPC* temp = _impl_.woperation_;
  _impl_.woperation_ = nullptr;
  return temp;
}
inline ::commonmodule::WSPC* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_woperation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.woperation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::WSPC>(GetArena());
    _impl_.woperation_ = reinterpret_cast<::commonmodule::WSPC*>(p);
  }
  return _impl_.woperation_;
}
inline ::commonmodule::WSPC* PROTOBUF_NONNULL EVSEPointStatus::mutable_woperation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00008000u;
  ::commonmodule::WSPC* _msg = _internal_mutable_woperation();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.wOperation)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_woperation(::commonmodule::WSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.woperation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.woperation_ = reinterpret_cast<::commonmodule::WSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.wOperation)
}

// .commonmodule.StatusSPS noRestricEnable = 27;
inline bool EVSEPointStatus::has_norestricenable() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.norestricenable_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& EVSEPointStatus::_internal_norestricenable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.norestricenable_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EVSEPointStatus::norestricenable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.noRestricEnable)
  return _internal_norestricenable();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_norestricenable(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.norestricenable_);
  }
  _impl_.norestricenable_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.noRestricEnable)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EVSEPointStatus::release_norestricenable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::commonmodule::StatusSPS* released = _impl_.norestricenable_;
  _impl_.norestricenable_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_norestricenable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.noRestricEnable)

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::commonmodule::StatusSPS* temp = _impl_.norestricenable_;
  _impl_.norestricenable_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_norestricenable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.norestricenable_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.norestricenable_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.norestricenable_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EVSEPointStatus::mutable_norestricenable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00010000u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_norestricenable();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.noRestricEnable)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_norestricenable(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.norestricenable_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }

  _impl_.norestricenable_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.noRestricEnable)
}

// .commonmodule.StatusSPS chargeControlEnable = 28;
inline bool EVSEPointStatus::has_chargecontrolenable() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chargecontrolenable_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& EVSEPointStatus::_internal_chargecontrolenable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.chargecontrolenable_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EVSEPointStatus::chargecontrolenable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEPointStatus.chargeControlEnable)
  return _internal_chargecontrolenable();
}
inline void EVSEPointStatus::unsafe_arena_set_allocated_chargecontrolenable(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chargecontrolenable_);
  }
  _impl_.chargecontrolenable_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEPointStatus.chargeControlEnable)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EVSEPointStatus::release_chargecontrolenable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::commonmodule::StatusSPS* released = _impl_.chargecontrolenable_;
  _impl_.chargecontrolenable_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EVSEPointStatus::unsafe_arena_release_chargecontrolenable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEPointStatus.chargeControlEnable)

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::commonmodule::StatusSPS* temp = _impl_.chargecontrolenable_;
  _impl_.chargecontrolenable_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EVSEPointStatus::_internal_mutable_chargecontrolenable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chargecontrolenable_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.chargecontrolenable_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.chargecontrolenable_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EVSEPointStatus::mutable_chargecontrolenable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00020000u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_chargecontrolenable();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEPointStatus.chargeControlEnable)
  return _msg;
}
inline void EVSEPointStatus::set_allocated_chargecontrolenable(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chargecontrolenable_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }

  _impl_.chargecontrolenable_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEPointStatus.chargeControlEnable)
}

// -------------------------------------------------------------------

// Optional_EVACConnectionStateKind

// .evsemodule.EVACConnectionStateKind value = 1;
inline void Optional_EVACConnectionStateKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVACConnectionStateKind Optional_EVACConnectionStateKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVACConnectionStateKind.value)
  return _internal_value();
}
inline void Optional_EVACConnectionStateKind::set_value(::evsemodule::EVACConnectionStateKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVACConnectionStateKind.value)
}
inline ::evsemodule::EVACConnectionStateKind Optional_EVACConnectionStateKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVACConnectionStateKind>(_impl_.value_);
}
inline void Optional_EVACConnectionStateKind::_internal_set_value(::evsemodule::EVACConnectionStateKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVACConnectionStateKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVACConnectionStateKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVACConnectionStateKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVACConnectionStateKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACConnectionStateKind.q)
  return _internal_q();
}
inline void ENS_EVACConnectionStateKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVACConnectionStateKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVACConnectionStateKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVACConnectionStateKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVACConnectionStateKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVACConnectionStateKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVACConnectionStateKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVACConnectionStateKind.q)
  return _msg;
}
inline void ENS_EVACConnectionStateKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVACConnectionStateKind.q)
}

// .evsemodule.EVACConnectionStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVACConnectionStateKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVACConnectionStateKind ENS_EVACConnectionStateKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACConnectionStateKind.stVal)
  return _internal_stval();
}
inline void ENS_EVACConnectionStateKind::set_stval(::evsemodule::EVACConnectionStateKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVACConnectionStateKind.stVal)
}
inline ::evsemodule::EVACConnectionStateKind ENS_EVACConnectionStateKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVACConnectionStateKind>(_impl_.stval_);
}
inline void ENS_EVACConnectionStateKind::_internal_set_stval(::evsemodule::EVACConnectionStateKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVACConnectionStateKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVACConnectionStateKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVACConnectionStateKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACConnectionStateKind.t)
  return _internal_t();
}
inline void ENS_EVACConnectionStateKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVACConnectionStateKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVACConnectionStateKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVACConnectionStateKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVACConnectionStateKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVACConnectionStateKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVACConnectionStateKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVACConnectionStateKind.t)
  return _msg;
}
inline void ENS_EVACConnectionStateKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVACConnectionStateKind.t)
}

// -------------------------------------------------------------------

// Optional_EVACPlugStateKind

// .evsemodule.EVACPlugStateKind value = 1;
inline void Optional_EVACPlugStateKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVACPlugStateKind Optional_EVACPlugStateKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVACPlugStateKind.value)
  return _internal_value();
}
inline void Optional_EVACPlugStateKind::set_value(::evsemodule::EVACPlugStateKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVACPlugStateKind.value)
}
inline ::evsemodule::EVACPlugStateKind Optional_EVACPlugStateKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVACPlugStateKind>(_impl_.value_);
}
inline void Optional_EVACPlugStateKind::_internal_set_value(::evsemodule::EVACPlugStateKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVACPlugStateKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVACPlugStateKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVACPlugStateKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVACPlugStateKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACPlugStateKind.q)
  return _internal_q();
}
inline void ENS_EVACPlugStateKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVACPlugStateKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVACPlugStateKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVACPlugStateKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVACPlugStateKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVACPlugStateKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVACPlugStateKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVACPlugStateKind.q)
  return _msg;
}
inline void ENS_EVACPlugStateKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVACPlugStateKind.q)
}

// .evsemodule.EVACPlugStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVACPlugStateKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVACPlugStateKind ENS_EVACPlugStateKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACPlugStateKind.stVal)
  return _internal_stval();
}
inline void ENS_EVACPlugStateKind::set_stval(::evsemodule::EVACPlugStateKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVACPlugStateKind.stVal)
}
inline ::evsemodule::EVACPlugStateKind ENS_EVACPlugStateKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVACPlugStateKind>(_impl_.stval_);
}
inline void ENS_EVACPlugStateKind::_internal_set_stval(::evsemodule::EVACPlugStateKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVACPlugStateKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVACPlugStateKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVACPlugStateKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACPlugStateKind.t)
  return _internal_t();
}
inline void ENS_EVACPlugStateKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVACPlugStateKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVACPlugStateKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVACPlugStateKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVACPlugStateKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVACPlugStateKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVACPlugStateKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVACPlugStateKind.t)
  return _msg;
}
inline void ENS_EVACPlugStateKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVACPlugStateKind.t)
}

// -------------------------------------------------------------------

// Optional_EVACCableCapabilityKind

// .evsemodule.EVACCableCapabilityKind value = 1;
inline void Optional_EVACCableCapabilityKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVACCableCapabilityKind Optional_EVACCableCapabilityKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVACCableCapabilityKind.value)
  return _internal_value();
}
inline void Optional_EVACCableCapabilityKind::set_value(::evsemodule::EVACCableCapabilityKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVACCableCapabilityKind.value)
}
inline ::evsemodule::EVACCableCapabilityKind Optional_EVACCableCapabilityKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVACCableCapabilityKind>(_impl_.value_);
}
inline void Optional_EVACCableCapabilityKind::_internal_set_value(::evsemodule::EVACCableCapabilityKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVACCableCapabilityKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVACCableCapabilityKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVACCableCapabilityKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVACCableCapabilityKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACCableCapabilityKind.q)
  return _internal_q();
}
inline void ENS_EVACCableCapabilityKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVACCableCapabilityKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVACCableCapabilityKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVACCableCapabilityKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVACCableCapabilityKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVACCableCapabilityKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVACCableCapabilityKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVACCableCapabilityKind.q)
  return _msg;
}
inline void ENS_EVACCableCapabilityKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVACCableCapabilityKind.q)
}

// .evsemodule.EVACCableCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVACCableCapabilityKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVACCableCapabilityKind ENS_EVACCableCapabilityKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACCableCapabilityKind.stVal)
  return _internal_stval();
}
inline void ENS_EVACCableCapabilityKind::set_stval(::evsemodule::EVACCableCapabilityKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVACCableCapabilityKind.stVal)
}
inline ::evsemodule::EVACCableCapabilityKind ENS_EVACCableCapabilityKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVACCableCapabilityKind>(_impl_.stval_);
}
inline void ENS_EVACCableCapabilityKind::_internal_set_stval(::evsemodule::EVACCableCapabilityKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVACCableCapabilityKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVACCableCapabilityKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVACCableCapabilityKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVACCableCapabilityKind.t)
  return _internal_t();
}
inline void ENS_EVACCableCapabilityKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVACCableCapabilityKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVACCableCapabilityKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVACCableCapabilityKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVACCableCapabilityKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVACCableCapabilityKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVACCableCapabilityKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVACCableCapabilityKind.t)
  return _msg;
}
inline void ENS_EVACCableCapabilityKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVACCableCapabilityKind.t)
}

// -------------------------------------------------------------------

// Optional_EVConnectionChargingKind

// .evsemodule.EVConnectionChargingKind value = 1;
inline void Optional_EVConnectionChargingKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVConnectionChargingKind Optional_EVConnectionChargingKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVConnectionChargingKind.value)
  return _internal_value();
}
inline void Optional_EVConnectionChargingKind::set_value(::evsemodule::EVConnectionChargingKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVConnectionChargingKind.value)
}
inline ::evsemodule::EVConnectionChargingKind Optional_EVConnectionChargingKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVConnectionChargingKind>(_impl_.value_);
}
inline void Optional_EVConnectionChargingKind::_internal_set_value(::evsemodule::EVConnectionChargingKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVConnectionChargingKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVConnectionChargingKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVConnectionChargingKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVConnectionChargingKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVConnectionChargingKind.q)
  return _internal_q();
}
inline void ENS_EVConnectionChargingKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVConnectionChargingKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVConnectionChargingKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVConnectionChargingKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVConnectionChargingKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVConnectionChargingKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVConnectionChargingKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVConnectionChargingKind.q)
  return _msg;
}
inline void ENS_EVConnectionChargingKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVConnectionChargingKind.q)
}

// .evsemodule.EVConnectionChargingKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVConnectionChargingKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVConnectionChargingKind ENS_EVConnectionChargingKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVConnectionChargingKind.stVal)
  return _internal_stval();
}
inline void ENS_EVConnectionChargingKind::set_stval(::evsemodule::EVConnectionChargingKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVConnectionChargingKind.stVal)
}
inline ::evsemodule::EVConnectionChargingKind ENS_EVConnectionChargingKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVConnectionChargingKind>(_impl_.stval_);
}
inline void ENS_EVConnectionChargingKind::_internal_set_stval(::evsemodule::EVConnectionChargingKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVConnectionChargingKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVConnectionChargingKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVConnectionChargingKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVConnectionChargingKind.t)
  return _internal_t();
}
inline void ENS_EVConnectionChargingKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVConnectionChargingKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVConnectionChargingKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVConnectionChargingKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVConnectionChargingKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVConnectionChargingKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVConnectionChargingKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVConnectionChargingKind.t)
  return _msg;
}
inline void ENS_EVConnectionChargingKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVConnectionChargingKind.t)
}

// -------------------------------------------------------------------

// EventAndStatusDEEV

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EventAndStatusDEEV::has_logicalnodeforeventandstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforeventandstatus_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDEEV::_internal_logicalnodeforeventandstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDEEV::logicalnodeforeventandstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDEEV::release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* released = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.logicalNodeForEventAndStatus)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForEventAndStatus>(GetArena());
    _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(p);
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_logicalnodeforeventandstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.logicalNodeForEventAndStatus)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.logicalNodeForEventAndStatus)
}

// .google.protobuf.StringValue EVId = 2 [(.uml.option_uuid) = true];
inline bool EventAndStatusDEEV::has_evid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evid_ != nullptr);
  return value;
}
inline const ::google::protobuf::StringValue& EventAndStatusDEEV::_internal_evid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::StringValue* p = _impl_.evid_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::StringValue&>(::google::protobuf::_StringValue_default_instance_);
}
inline const ::google::protobuf::StringValue& EventAndStatusDEEV::evid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.EVId)
  return _internal_evid();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_evid(
    ::google::protobuf::StringValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evid_);
  }
  _impl_.evid_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.EVId)
}
inline ::google::protobuf::StringValue* PROTOBUF_NULLABLE EventAndStatusDEEV::release_evid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::StringValue* released = _impl_.evid_;
  _impl_.evid_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::StringValue* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_evid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.EVId)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::StringValue* temp = _impl_.evid_;
  _impl_.evid_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_evid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evid_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::StringValue>(GetArena());
    _impl_.evid_ = reinterpret_cast<::google::protobuf::StringValue*>(p);
  }
  return _impl_.evid_;
}
inline ::google::protobuf::StringValue* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_evid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::StringValue* _msg = _internal_mutable_evid();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.EVId)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_evid(::google::protobuf::StringValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evid_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.EVId)
}

// .google.protobuf.StringValue EMAId = 3 [(.uml.option_uuid) = true];
inline bool EventAndStatusDEEV::has_emaid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.emaid_ != nullptr);
  return value;
}
inline const ::google::protobuf::StringValue& EventAndStatusDEEV::_internal_emaid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::StringValue* p = _impl_.emaid_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::StringValue&>(::google::protobuf::_StringValue_default_instance_);
}
inline const ::google::protobuf::StringValue& EventAndStatusDEEV::emaid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.EMAId)
  return _internal_emaid();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_emaid(
    ::google::protobuf::StringValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emaid_);
  }
  _impl_.emaid_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.EMAId)
}
inline ::google::protobuf::StringValue* PROTOBUF_NULLABLE EventAndStatusDEEV::release_emaid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::StringValue* released = _impl_.emaid_;
  _impl_.emaid_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::StringValue* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_emaid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.EMAId)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::StringValue* temp = _impl_.emaid_;
  _impl_.emaid_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_emaid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.emaid_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::StringValue>(GetArena());
    _impl_.emaid_ = reinterpret_cast<::google::protobuf::StringValue*>(p);
  }
  return _impl_.emaid_;
}
inline ::google::protobuf::StringValue* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_emaid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::StringValue* _msg = _internal_mutable_emaid();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.EMAId)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_emaid(::google::protobuf::StringValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.emaid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.emaid_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.EMAId)
}

// .evsemodule.ENS_EVConnectionChargingKind ConnTypSel = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EventAndStatusDEEV::has_conntypsel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conntypsel_ != nullptr);
  return value;
}
inline void EventAndStatusDEEV::clear_conntypsel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conntypsel_ != nullptr) _impl_.conntypsel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::evsemodule::ENS_EVConnectionChargingKind& EventAndStatusDEEV::_internal_conntypsel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVConnectionChargingKind* p = _impl_.conntypsel_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVConnectionChargingKind&>(::evsemodule::_ENS_EVConnectionChargingKind_default_instance_);
}
inline const ::evsemodule::ENS_EVConnectionChargingKind& EventAndStatusDEEV::conntypsel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.ConnTypSel)
  return _internal_conntypsel();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_conntypsel(
    ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypsel_);
  }
  _impl_.conntypsel_ = reinterpret_cast<::evsemodule::ENS_EVConnectionChargingKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.ConnTypSel)
}
inline ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE EventAndStatusDEEV::release_conntypsel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ENS_EVConnectionChargingKind* released = _impl_.conntypsel_;
  _impl_.conntypsel_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_conntypsel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.ConnTypSel)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ENS_EVConnectionChargingKind* temp = _impl_.conntypsel_;
  _impl_.conntypsel_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_conntypsel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conntypsel_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVConnectionChargingKind>(GetArena());
    _impl_.conntypsel_ = reinterpret_cast<::evsemodule::ENS_EVConnectionChargingKind*>(p);
  }
  return _impl_.conntypsel_;
}
inline ::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_conntypsel()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::evsemodule::ENS_EVConnectionChargingKind* _msg = _internal_mutable_conntypsel();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.ConnTypSel)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_conntypsel(::evsemodule::ENS_EVConnectionChargingKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conntypsel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.conntypsel_ = reinterpret_cast<::evsemodule::ENS_EVConnectionChargingKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.ConnTypSel)
}

// .commonmodule.ClearingTime DptTm = 5;
inline bool EventAndStatusDEEV::has_dpttm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dpttm_ != nullptr);
  return value;
}
inline const ::commonmodule::ClearingTime& EventAndStatusDEEV::_internal_dpttm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ClearingTime* p = _impl_.dpttm_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ClearingTime&>(::commonmodule::_ClearingTime_default_instance_);
}
inline const ::commonmodule::ClearingTime& EventAndStatusDEEV::dpttm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.DptTm)
  return _internal_dpttm();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_dpttm(
    ::commonmodule::ClearingTime* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dpttm_);
  }
  _impl_.dpttm_ = reinterpret_cast<::commonmodule::ClearingTime*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.DptTm)
}
inline ::commonmodule::ClearingTime* PROTOBUF_NULLABLE EventAndStatusDEEV::release_dpttm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ClearingTime* released = _impl_.dpttm_;
  _impl_.dpttm_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ClearingTime* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_dpttm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.DptTm)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ClearingTime* temp = _impl_.dpttm_;
  _impl_.dpttm_ = nullptr;
  return temp;
}
inline ::commonmodule::ClearingTime* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_dpttm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dpttm_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ClearingTime>(GetArena());
    _impl_.dpttm_ = reinterpret_cast<::commonmodule::ClearingTime*>(p);
  }
  return _impl_.dpttm_;
}
inline ::commonmodule::ClearingTime* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_dpttm()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::ClearingTime* _msg = _internal_mutable_dpttm();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.DptTm)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_dpttm(::commonmodule::ClearingTime* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dpttm_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.dpttm_ = reinterpret_cast<::commonmodule::ClearingTime*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.DptTm)
}

// .commonmodule.MV WHReq = 6;
inline bool EventAndStatusDEEV::has_whreq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.whreq_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& EventAndStatusDEEV::_internal_whreq() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.whreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EventAndStatusDEEV::whreq() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.WHReq)
  return _internal_whreq();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_whreq(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.whreq_);
  }
  _impl_.whreq_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.WHReq)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EventAndStatusDEEV::release_whreq() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::MV* released = _impl_.whreq_;
  _impl_.whreq_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_whreq() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.WHReq)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::MV* temp = _impl_.whreq_;
  _impl_.whreq_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_whreq() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.whreq_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.whreq_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.whreq_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_whreq()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::MV* _msg = _internal_mutable_whreq();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.WHReq)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_whreq(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.whreq_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.whreq_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.WHReq)
}

// .commonmodule.MV WHAvail = 7;
inline bool EventAndStatusDEEV::has_whavail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.whavail_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& EventAndStatusDEEV::_internal_whavail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.whavail_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EventAndStatusDEEV::whavail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.WHAvail)
  return _internal_whavail();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_whavail(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.whavail_);
  }
  _impl_.whavail_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.WHAvail)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EventAndStatusDEEV::release_whavail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::MV* released = _impl_.whavail_;
  _impl_.whavail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_whavail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.WHAvail)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::MV* temp = _impl_.whavail_;
  _impl_.whavail_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_whavail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.whavail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.whavail_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.whavail_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_whavail()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::MV* _msg = _internal_mutable_whavail();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.WHAvail)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_whavail(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.whavail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.whavail_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.WHAvail)
}

// .commonmodule.MV Soc = 8;
inline bool EventAndStatusDEEV::has_soc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.soc_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& EventAndStatusDEEV::_internal_soc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.soc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EventAndStatusDEEV::soc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEEV.Soc)
  return _internal_soc();
}
inline void EventAndStatusDEEV::unsafe_arena_set_allocated_soc(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.soc_);
  }
  _impl_.soc_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEEV.Soc)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EventAndStatusDEEV::release_soc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::MV* released = _impl_.soc_;
  _impl_.soc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EventAndStatusDEEV::unsafe_arena_release_soc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEEV.Soc)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::MV* temp = _impl_.soc_;
  _impl_.soc_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EventAndStatusDEEV::_internal_mutable_soc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.soc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.soc_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.soc_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EventAndStatusDEEV::mutable_soc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::commonmodule::MV* _msg = _internal_mutable_soc();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEEV.Soc)
  return _msg;
}
inline void EventAndStatusDEEV::set_allocated_soc(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.soc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.soc_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEEV.Soc)
}

// -------------------------------------------------------------------

// EventAndStatusDEAO

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EventAndStatusDEAO::has_logicalnodeforeventandstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforeventandstatus_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDEAO::_internal_logicalnodeforeventandstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDEAO::logicalnodeforeventandstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEAO.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void EventAndStatusDEAO::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEAO.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDEAO::release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* released = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDEAO::unsafe_arena_release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEAO.logicalNodeForEventAndStatus)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDEAO::_internal_mutable_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForEventAndStatus>(GetArena());
    _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(p);
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDEAO::mutable_logicalnodeforeventandstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEAO.logicalNodeForEventAndStatus)
  return _msg;
}
inline void EventAndStatusDEAO::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEAO.logicalNodeForEventAndStatus)
}

// .evsemodule.EventAndStatusDEEV eventAndStatusDEEV = 2;
inline bool EventAndStatusDEAO::has_eventandstatusdeev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventandstatusdeev_ != nullptr);
  return value;
}
inline void EventAndStatusDEAO::clear_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdeev_ != nullptr) _impl_.eventandstatusdeev_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EventAndStatusDEEV& EventAndStatusDEAO::_internal_eventandstatusdeev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EventAndStatusDEEV* p = _impl_.eventandstatusdeev_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EventAndStatusDEEV&>(::evsemodule::_EventAndStatusDEEV_default_instance_);
}
inline const ::evsemodule::EventAndStatusDEEV& EventAndStatusDEAO::eventandstatusdeev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEAO.eventAndStatusDEEV)
  return _internal_eventandstatusdeev();
}
inline void EventAndStatusDEAO::unsafe_arena_set_allocated_eventandstatusdeev(
    ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdeev_);
  }
  _impl_.eventandstatusdeev_ = reinterpret_cast<::evsemodule::EventAndStatusDEEV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEAO.eventAndStatusDEEV)
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE EventAndStatusDEAO::release_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EventAndStatusDEEV* released = _impl_.eventandstatusdeev_;
  _impl_.eventandstatusdeev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE EventAndStatusDEAO::unsafe_arena_release_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEAO.eventAndStatusDEEV)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EventAndStatusDEEV* temp = _impl_.eventandstatusdeev_;
  _impl_.eventandstatusdeev_ = nullptr;
  return temp;
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL EventAndStatusDEAO::_internal_mutable_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdeev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EventAndStatusDEEV>(GetArena());
    _impl_.eventandstatusdeev_ = reinterpret_cast<::evsemodule::EventAndStatusDEEV*>(p);
  }
  return _impl_.eventandstatusdeev_;
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL EventAndStatusDEAO::mutable_eventandstatusdeev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EventAndStatusDEEV* _msg = _internal_mutable_eventandstatusdeev();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEAO.eventAndStatusDEEV)
  return _msg;
}
inline void EventAndStatusDEAO::set_allocated_eventandstatusdeev(::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdeev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.eventandstatusdeev_ = reinterpret_cast<::evsemodule::EventAndStatusDEEV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEAO.eventAndStatusDEEV)
}

// .commonmodule.StatusSPS DigComm = 3;
inline bool EventAndStatusDEAO::has_digcomm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.digcomm_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& EventAndStatusDEAO::_internal_digcomm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.digcomm_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EventAndStatusDEAO::digcomm() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEAO.DigComm)
  return _internal_digcomm();
}
inline void EventAndStatusDEAO::unsafe_arena_set_allocated_digcomm(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.digcomm_);
  }
  _impl_.digcomm_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEAO.DigComm)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDEAO::release_digcomm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::StatusSPS* released = _impl_.digcomm_;
  _impl_.digcomm_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDEAO::unsafe_arena_release_digcomm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEAO.DigComm)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::StatusSPS* temp = _impl_.digcomm_;
  _impl_.digcomm_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDEAO::_internal_mutable_digcomm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.digcomm_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.digcomm_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.digcomm_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDEAO::mutable_digcomm()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_digcomm();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEAO.DigComm)
  return _msg;
}
inline void EventAndStatusDEAO::set_allocated_digcomm(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.digcomm_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.digcomm_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEAO.DigComm)
}

// .evsemodule.ENS_EVACConnectionStateKind ConnSt = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EventAndStatusDEAO::has_connst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connst_ != nullptr);
  return value;
}
inline void EventAndStatusDEAO::clear_connst() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.connst_ != nullptr) _impl_.connst_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::evsemodule::ENS_EVACConnectionStateKind& EventAndStatusDEAO::_internal_connst() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVACConnectionStateKind* p = _impl_.connst_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVACConnectionStateKind&>(::evsemodule::_ENS_EVACConnectionStateKind_default_instance_);
}
inline const ::evsemodule::ENS_EVACConnectionStateKind& EventAndStatusDEAO::connst() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEAO.ConnSt)
  return _internal_connst();
}
inline void EventAndStatusDEAO::unsafe_arena_set_allocated_connst(
    ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connst_);
  }
  _impl_.connst_ = reinterpret_cast<::evsemodule::ENS_EVACConnectionStateKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEAO.ConnSt)
}
inline ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE EventAndStatusDEAO::release_connst() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ENS_EVACConnectionStateKind* released = _impl_.connst_;
  _impl_.connst_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE EventAndStatusDEAO::unsafe_arena_release_connst() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEAO.ConnSt)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ENS_EVACConnectionStateKind* temp = _impl_.connst_;
  _impl_.connst_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NONNULL EventAndStatusDEAO::_internal_mutable_connst() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.connst_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVACConnectionStateKind>(GetArena());
    _impl_.connst_ = reinterpret_cast<::evsemodule::ENS_EVACConnectionStateKind*>(p);
  }
  return _impl_.connst_;
}
inline ::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NONNULL EventAndStatusDEAO::mutable_connst()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::evsemodule::ENS_EVACConnectionStateKind* _msg = _internal_mutable_connst();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEAO.ConnSt)
  return _msg;
}
inline void EventAndStatusDEAO::set_allocated_connst(::evsemodule::ENS_EVACConnectionStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connst_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.connst_ = reinterpret_cast<::evsemodule::ENS_EVACConnectionStateKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEAO.ConnSt)
}

// .evsemodule.ENS_EVACPlugStateKind PlgStAC = 5;
inline bool EventAndStatusDEAO::has_plgstac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plgstac_ != nullptr);
  return value;
}
inline void EventAndStatusDEAO::clear_plgstac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plgstac_ != nullptr) _impl_.plgstac_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::evsemodule::ENS_EVACPlugStateKind& EventAndStatusDEAO::_internal_plgstac() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVACPlugStateKind* p = _impl_.plgstac_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVACPlugStateKind&>(::evsemodule::_ENS_EVACPlugStateKind_default_instance_);
}
inline const ::evsemodule::ENS_EVACPlugStateKind& EventAndStatusDEAO::plgstac() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEAO.PlgStAC)
  return _internal_plgstac();
}
inline void EventAndStatusDEAO::unsafe_arena_set_allocated_plgstac(
    ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.plgstac_);
  }
  _impl_.plgstac_ = reinterpret_cast<::evsemodule::ENS_EVACPlugStateKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEAO.PlgStAC)
}
inline ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE EventAndStatusDEAO::release_plgstac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::ENS_EVACPlugStateKind* released = _impl_.plgstac_;
  _impl_.plgstac_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE EventAndStatusDEAO::unsafe_arena_release_plgstac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEAO.PlgStAC)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::ENS_EVACPlugStateKind* temp = _impl_.plgstac_;
  _impl_.plgstac_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NONNULL EventAndStatusDEAO::_internal_mutable_plgstac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plgstac_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVACPlugStateKind>(GetArena());
    _impl_.plgstac_ = reinterpret_cast<::evsemodule::ENS_EVACPlugStateKind*>(p);
  }
  return _impl_.plgstac_;
}
inline ::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NONNULL EventAndStatusDEAO::mutable_plgstac()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::evsemodule::ENS_EVACPlugStateKind* _msg = _internal_mutable_plgstac();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEAO.PlgStAC)
  return _msg;
}
inline void EventAndStatusDEAO::set_allocated_plgstac(::evsemodule::ENS_EVACPlugStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.plgstac_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.plgstac_ = reinterpret_cast<::evsemodule::ENS_EVACPlugStateKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEAO.PlgStAC)
}

// .evsemodule.ENS_EVACCableCapabilityKind CabRtgAC = 6;
inline bool EventAndStatusDEAO::has_cabrtgac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cabrtgac_ != nullptr);
  return value;
}
inline void EventAndStatusDEAO::clear_cabrtgac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cabrtgac_ != nullptr) _impl_.cabrtgac_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::evsemodule::ENS_EVACCableCapabilityKind& EventAndStatusDEAO::_internal_cabrtgac() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVACCableCapabilityKind* p = _impl_.cabrtgac_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVACCableCapabilityKind&>(::evsemodule::_ENS_EVACCableCapabilityKind_default_instance_);
}
inline const ::evsemodule::ENS_EVACCableCapabilityKind& EventAndStatusDEAO::cabrtgac() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEAO.CabRtgAC)
  return _internal_cabrtgac();
}
inline void EventAndStatusDEAO::unsafe_arena_set_allocated_cabrtgac(
    ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cabrtgac_);
  }
  _impl_.cabrtgac_ = reinterpret_cast<::evsemodule::ENS_EVACCableCapabilityKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEAO.CabRtgAC)
}
inline ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE EventAndStatusDEAO::release_cabrtgac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::evsemodule::ENS_EVACCableCapabilityKind* released = _impl_.cabrtgac_;
  _impl_.cabrtgac_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE EventAndStatusDEAO::unsafe_arena_release_cabrtgac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEAO.CabRtgAC)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::evsemodule::ENS_EVACCableCapabilityKind* temp = _impl_.cabrtgac_;
  _impl_.cabrtgac_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL EventAndStatusDEAO::_internal_mutable_cabrtgac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cabrtgac_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVACCableCapabilityKind>(GetArena());
    _impl_.cabrtgac_ = reinterpret_cast<::evsemodule::ENS_EVACCableCapabilityKind*>(p);
  }
  return _impl_.cabrtgac_;
}
inline ::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NONNULL EventAndStatusDEAO::mutable_cabrtgac()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::evsemodule::ENS_EVACCableCapabilityKind* _msg = _internal_mutable_cabrtgac();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEAO.CabRtgAC)
  return _msg;
}
inline void EventAndStatusDEAO::set_allocated_cabrtgac(::evsemodule::ENS_EVACCableCapabilityKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cabrtgac_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.cabrtgac_ = reinterpret_cast<::evsemodule::ENS_EVACCableCapabilityKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEAO.CabRtgAC)
}

// -------------------------------------------------------------------

// Optional_EVDCCableCapabilityKind

// .evsemodule.EVDCCableCapabilityKind value = 1;
inline void Optional_EVDCCableCapabilityKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVDCCableCapabilityKind Optional_EVDCCableCapabilityKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVDCCableCapabilityKind.value)
  return _internal_value();
}
inline void Optional_EVDCCableCapabilityKind::set_value(::evsemodule::EVDCCableCapabilityKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVDCCableCapabilityKind.value)
}
inline ::evsemodule::EVDCCableCapabilityKind Optional_EVDCCableCapabilityKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCCableCapabilityKind>(_impl_.value_);
}
inline void Optional_EVDCCableCapabilityKind::_internal_set_value(::evsemodule::EVDCCableCapabilityKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVDCCableCapabilityKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVDCCableCapabilityKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVDCCableCapabilityKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVDCCableCapabilityKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCCableCapabilityKind.q)
  return _internal_q();
}
inline void ENS_EVDCCableCapabilityKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCCableCapabilityKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCCableCapabilityKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCCableCapabilityKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCCableCapabilityKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCCableCapabilityKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCCableCapabilityKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCCableCapabilityKind.q)
  return _msg;
}
inline void ENS_EVDCCableCapabilityKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCCableCapabilityKind.q)
}

// .evsemodule.EVDCCableCapabilityKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVDCCableCapabilityKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVDCCableCapabilityKind ENS_EVDCCableCapabilityKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCCableCapabilityKind.stVal)
  return _internal_stval();
}
inline void ENS_EVDCCableCapabilityKind::set_stval(::evsemodule::EVDCCableCapabilityKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVDCCableCapabilityKind.stVal)
}
inline ::evsemodule::EVDCCableCapabilityKind ENS_EVDCCableCapabilityKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCCableCapabilityKind>(_impl_.stval_);
}
inline void ENS_EVDCCableCapabilityKind::_internal_set_stval(::evsemodule::EVDCCableCapabilityKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVDCCableCapabilityKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVDCCableCapabilityKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVDCCableCapabilityKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCCableCapabilityKind.t)
  return _internal_t();
}
inline void ENS_EVDCCableCapabilityKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCCableCapabilityKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCCableCapabilityKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCCableCapabilityKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCCableCapabilityKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCCableCapabilityKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCCableCapabilityKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCCableCapabilityKind.t)
  return _msg;
}
inline void ENS_EVDCCableCapabilityKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCCableCapabilityKind.t)
}

// -------------------------------------------------------------------

// Optional_EVDCConnectionStateAKind

// .evsemodule.EVDCConnectionStateAKind value = 1;
inline void Optional_EVDCConnectionStateAKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVDCConnectionStateAKind Optional_EVDCConnectionStateAKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVDCConnectionStateAKind.value)
  return _internal_value();
}
inline void Optional_EVDCConnectionStateAKind::set_value(::evsemodule::EVDCConnectionStateAKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVDCConnectionStateAKind.value)
}
inline ::evsemodule::EVDCConnectionStateAKind Optional_EVDCConnectionStateAKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCConnectionStateAKind>(_impl_.value_);
}
inline void Optional_EVDCConnectionStateAKind::_internal_set_value(::evsemodule::EVDCConnectionStateAKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVDCConnectionStateAKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVDCConnectionStateAKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVDCConnectionStateAKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVDCConnectionStateAKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCConnectionStateAKind.q)
  return _internal_q();
}
inline void ENS_EVDCConnectionStateAKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCConnectionStateAKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCConnectionStateAKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCConnectionStateAKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCConnectionStateAKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCConnectionStateAKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCConnectionStateAKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCConnectionStateAKind.q)
  return _msg;
}
inline void ENS_EVDCConnectionStateAKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCConnectionStateAKind.q)
}

// .evsemodule.EVDCConnectionStateAKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVDCConnectionStateAKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVDCConnectionStateAKind ENS_EVDCConnectionStateAKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCConnectionStateAKind.stVal)
  return _internal_stval();
}
inline void ENS_EVDCConnectionStateAKind::set_stval(::evsemodule::EVDCConnectionStateAKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVDCConnectionStateAKind.stVal)
}
inline ::evsemodule::EVDCConnectionStateAKind ENS_EVDCConnectionStateAKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCConnectionStateAKind>(_impl_.stval_);
}
inline void ENS_EVDCConnectionStateAKind::_internal_set_stval(::evsemodule::EVDCConnectionStateAKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVDCConnectionStateAKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVDCConnectionStateAKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVDCConnectionStateAKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCConnectionStateAKind.t)
  return _internal_t();
}
inline void ENS_EVDCConnectionStateAKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCConnectionStateAKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCConnectionStateAKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCConnectionStateAKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCConnectionStateAKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCConnectionStateAKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCConnectionStateAKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCConnectionStateAKind.t)
  return _msg;
}
inline void ENS_EVDCConnectionStateAKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCConnectionStateAKind.t)
}

// -------------------------------------------------------------------

// Optional_EVDCConnectionStateCKind

// .evsemodule.EVDCConnectionStateCKind value = 1;
inline void Optional_EVDCConnectionStateCKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVDCConnectionStateCKind Optional_EVDCConnectionStateCKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVDCConnectionStateCKind.value)
  return _internal_value();
}
inline void Optional_EVDCConnectionStateCKind::set_value(::evsemodule::EVDCConnectionStateCKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVDCConnectionStateCKind.value)
}
inline ::evsemodule::EVDCConnectionStateCKind Optional_EVDCConnectionStateCKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCConnectionStateCKind>(_impl_.value_);
}
inline void Optional_EVDCConnectionStateCKind::_internal_set_value(::evsemodule::EVDCConnectionStateCKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVDCConnectionStateCKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVDCConnectionStateCKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVDCConnectionStateCKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVDCConnectionStateCKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCConnectionStateCKind.q)
  return _internal_q();
}
inline void ENS_EVDCConnectionStateCKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCConnectionStateCKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCConnectionStateCKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCConnectionStateCKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCConnectionStateCKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCConnectionStateCKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCConnectionStateCKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCConnectionStateCKind.q)
  return _msg;
}
inline void ENS_EVDCConnectionStateCKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCConnectionStateCKind.q)
}

// .evsemodule.EVDCConnectionStateCKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVDCConnectionStateCKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVDCConnectionStateCKind ENS_EVDCConnectionStateCKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCConnectionStateCKind.stVal)
  return _internal_stval();
}
inline void ENS_EVDCConnectionStateCKind::set_stval(::evsemodule::EVDCConnectionStateCKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVDCConnectionStateCKind.stVal)
}
inline ::evsemodule::EVDCConnectionStateCKind ENS_EVDCConnectionStateCKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCConnectionStateCKind>(_impl_.stval_);
}
inline void ENS_EVDCConnectionStateCKind::_internal_set_stval(::evsemodule::EVDCConnectionStateCKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVDCConnectionStateCKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVDCConnectionStateCKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVDCConnectionStateCKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCConnectionStateCKind.t)
  return _internal_t();
}
inline void ENS_EVDCConnectionStateCKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCConnectionStateCKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCConnectionStateCKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCConnectionStateCKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCConnectionStateCKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCConnectionStateCKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCConnectionStateCKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCConnectionStateCKind.t)
  return _msg;
}
inline void ENS_EVDCConnectionStateCKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCConnectionStateCKind.t)
}

// -------------------------------------------------------------------

// Optional_EVDCPlugStateKind

// .evsemodule.EVDCPlugStateKind value = 1;
inline void Optional_EVDCPlugStateKind::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::evsemodule::EVDCPlugStateKind Optional_EVDCPlugStateKind::value() const {
  // @@protoc_insertion_point(field_get:evsemodule.Optional_EVDCPlugStateKind.value)
  return _internal_value();
}
inline void Optional_EVDCPlugStateKind::set_value(::evsemodule::EVDCPlugStateKind value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:evsemodule.Optional_EVDCPlugStateKind.value)
}
inline ::evsemodule::EVDCPlugStateKind Optional_EVDCPlugStateKind::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCPlugStateKind>(_impl_.value_);
}
inline void Optional_EVDCPlugStateKind::_internal_set_value(::evsemodule::EVDCPlugStateKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ENS_EVDCPlugStateKind

// .commonmodule.Quality q = 1;
inline bool ENS_EVDCPlugStateKind::has_q() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.q_ != nullptr);
  return value;
}
inline const ::commonmodule::Quality& ENS_EVDCPlugStateKind::_internal_q() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Quality* p = _impl_.q_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Quality&>(::commonmodule::_Quality_default_instance_);
}
inline const ::commonmodule::Quality& ENS_EVDCPlugStateKind::q() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCPlugStateKind.q)
  return _internal_q();
}
inline void ENS_EVDCPlugStateKind::unsafe_arena_set_allocated_q(
    ::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }
  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCPlugStateKind.q)
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCPlugStateKind::release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* released = _impl_.q_;
  _impl_.q_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Quality* PROTOBUF_NULLABLE ENS_EVDCPlugStateKind::unsafe_arena_release_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCPlugStateKind.q)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::Quality* temp = _impl_.q_;
  _impl_.q_ = nullptr;
  return temp;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCPlugStateKind::_internal_mutable_q() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.q_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Quality>(GetArena());
    _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(p);
  }
  return _impl_.q_;
}
inline ::commonmodule::Quality* PROTOBUF_NONNULL ENS_EVDCPlugStateKind::mutable_q()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::Quality* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCPlugStateKind.q)
  return _msg;
}
inline void ENS_EVDCPlugStateKind::set_allocated_q(::commonmodule::Quality* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.q_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.q_ = reinterpret_cast<::commonmodule::Quality*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCPlugStateKind.q)
}

// .evsemodule.EVDCPlugStateKind stVal = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline void ENS_EVDCPlugStateKind::clear_stval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::evsemodule::EVDCPlugStateKind ENS_EVDCPlugStateKind::stval() const {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCPlugStateKind.stVal)
  return _internal_stval();
}
inline void ENS_EVDCPlugStateKind::set_stval(::evsemodule::EVDCPlugStateKind value) {
  _internal_set_stval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:evsemodule.ENS_EVDCPlugStateKind.stVal)
}
inline ::evsemodule::EVDCPlugStateKind ENS_EVDCPlugStateKind::_internal_stval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::evsemodule::EVDCPlugStateKind>(_impl_.stval_);
}
inline void ENS_EVDCPlugStateKind::_internal_set_stval(::evsemodule::EVDCPlugStateKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stval_ = value;
}

// .commonmodule.Timestamp t = 3;
inline bool ENS_EVDCPlugStateKind::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& ENS_EVDCPlugStateKind::_internal_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& ENS_EVDCPlugStateKind::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ENS_EVDCPlugStateKind.t)
  return _internal_t();
}
inline void ENS_EVDCPlugStateKind::unsafe_arena_set_allocated_t(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ENS_EVDCPlugStateKind.t)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCPlugStateKind::release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.t_;
  _impl_.t_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE ENS_EVDCPlugStateKind::unsafe_arena_release_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ENS_EVDCPlugStateKind.t)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCPlugStateKind::_internal_mutable_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.t_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.t_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL ENS_EVDCPlugStateKind::mutable_t()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:evsemodule.ENS_EVDCPlugStateKind.t)
  return _msg;
}
inline void ENS_EVDCPlugStateKind::set_allocated_t(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.t_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ENS_EVDCPlugStateKind.t)
}

// -------------------------------------------------------------------

// EventAndStatusDEDO

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EventAndStatusDEDO::has_logicalnodeforeventandstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforeventandstatus_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDEDO::_internal_logicalnodeforeventandstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDEDO::logicalnodeforeventandstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEDO.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void EventAndStatusDEDO::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEDO.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDEDO::release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* released = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDEDO::unsafe_arena_release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEDO.logicalNodeForEventAndStatus)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDEDO::_internal_mutable_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForEventAndStatus>(GetArena());
    _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(p);
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDEDO::mutable_logicalnodeforeventandstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEDO.logicalNodeForEventAndStatus)
  return _msg;
}
inline void EventAndStatusDEDO::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEDO.logicalNodeForEventAndStatus)
}

// .evsemodule.EventAndStatusDEEV eventAndStatusDEEV = 2;
inline bool EventAndStatusDEDO::has_eventandstatusdeev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventandstatusdeev_ != nullptr);
  return value;
}
inline void EventAndStatusDEDO::clear_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdeev_ != nullptr) _impl_.eventandstatusdeev_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EventAndStatusDEEV& EventAndStatusDEDO::_internal_eventandstatusdeev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EventAndStatusDEEV* p = _impl_.eventandstatusdeev_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EventAndStatusDEEV&>(::evsemodule::_EventAndStatusDEEV_default_instance_);
}
inline const ::evsemodule::EventAndStatusDEEV& EventAndStatusDEDO::eventandstatusdeev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEDO.eventAndStatusDEEV)
  return _internal_eventandstatusdeev();
}
inline void EventAndStatusDEDO::unsafe_arena_set_allocated_eventandstatusdeev(
    ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdeev_);
  }
  _impl_.eventandstatusdeev_ = reinterpret_cast<::evsemodule::EventAndStatusDEEV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEDO.eventAndStatusDEEV)
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE EventAndStatusDEDO::release_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EventAndStatusDEEV* released = _impl_.eventandstatusdeev_;
  _impl_.eventandstatusdeev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE EventAndStatusDEDO::unsafe_arena_release_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEDO.eventAndStatusDEEV)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EventAndStatusDEEV* temp = _impl_.eventandstatusdeev_;
  _impl_.eventandstatusdeev_ = nullptr;
  return temp;
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL EventAndStatusDEDO::_internal_mutable_eventandstatusdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdeev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EventAndStatusDEEV>(GetArena());
    _impl_.eventandstatusdeev_ = reinterpret_cast<::evsemodule::EventAndStatusDEEV*>(p);
  }
  return _impl_.eventandstatusdeev_;
}
inline ::evsemodule::EventAndStatusDEEV* PROTOBUF_NONNULL EventAndStatusDEDO::mutable_eventandstatusdeev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EventAndStatusDEEV* _msg = _internal_mutable_eventandstatusdeev();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEDO.eventAndStatusDEEV)
  return _msg;
}
inline void EventAndStatusDEDO::set_allocated_eventandstatusdeev(::evsemodule::EventAndStatusDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdeev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.eventandstatusdeev_ = reinterpret_cast<::evsemodule::EventAndStatusDEEV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEDO.eventAndStatusDEEV)
}

// .evsemodule.ENS_EVDCCableCapabilityKind CabRtgDC = 3;
inline bool EventAndStatusDEDO::has_cabrtgdc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cabrtgdc_ != nullptr);
  return value;
}
inline void EventAndStatusDEDO::clear_cabrtgdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cabrtgdc_ != nullptr) _impl_.cabrtgdc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::ENS_EVDCCableCapabilityKind& EventAndStatusDEDO::_internal_cabrtgdc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVDCCableCapabilityKind* p = _impl_.cabrtgdc_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVDCCableCapabilityKind&>(::evsemodule::_ENS_EVDCCableCapabilityKind_default_instance_);
}
inline const ::evsemodule::ENS_EVDCCableCapabilityKind& EventAndStatusDEDO::cabrtgdc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEDO.CabRtgDC)
  return _internal_cabrtgdc();
}
inline void EventAndStatusDEDO::unsafe_arena_set_allocated_cabrtgdc(
    ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cabrtgdc_);
  }
  _impl_.cabrtgdc_ = reinterpret_cast<::evsemodule::ENS_EVDCCableCapabilityKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEDO.CabRtgDC)
}
inline ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE EventAndStatusDEDO::release_cabrtgdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::ENS_EVDCCableCapabilityKind* released = _impl_.cabrtgdc_;
  _impl_.cabrtgdc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE EventAndStatusDEDO::unsafe_arena_release_cabrtgdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEDO.CabRtgDC)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::ENS_EVDCCableCapabilityKind* temp = _impl_.cabrtgdc_;
  _impl_.cabrtgdc_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL EventAndStatusDEDO::_internal_mutable_cabrtgdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cabrtgdc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVDCCableCapabilityKind>(GetArena());
    _impl_.cabrtgdc_ = reinterpret_cast<::evsemodule::ENS_EVDCCableCapabilityKind*>(p);
  }
  return _impl_.cabrtgdc_;
}
inline ::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NONNULL EventAndStatusDEDO::mutable_cabrtgdc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::ENS_EVDCCableCapabilityKind* _msg = _internal_mutable_cabrtgdc();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEDO.CabRtgDC)
  return _msg;
}
inline void EventAndStatusDEDO::set_allocated_cabrtgdc(::evsemodule::ENS_EVDCCableCapabilityKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cabrtgdc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.cabrtgdc_ = reinterpret_cast<::evsemodule::ENS_EVDCCableCapabilityKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEDO.CabRtgDC)
}

// .evsemodule.ENS_EVDCConnectionStateAKind ConnStA = 4;
inline bool EventAndStatusDEDO::has_connsta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connsta_ != nullptr);
  return value;
}
inline void EventAndStatusDEDO::clear_connsta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.connsta_ != nullptr) _impl_.connsta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::evsemodule::ENS_EVDCConnectionStateAKind& EventAndStatusDEDO::_internal_connsta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVDCConnectionStateAKind* p = _impl_.connsta_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVDCConnectionStateAKind&>(::evsemodule::_ENS_EVDCConnectionStateAKind_default_instance_);
}
inline const ::evsemodule::ENS_EVDCConnectionStateAKind& EventAndStatusDEDO::connsta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEDO.ConnStA)
  return _internal_connsta();
}
inline void EventAndStatusDEDO::unsafe_arena_set_allocated_connsta(
    ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connsta_);
  }
  _impl_.connsta_ = reinterpret_cast<::evsemodule::ENS_EVDCConnectionStateAKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEDO.ConnStA)
}
inline ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE EventAndStatusDEDO::release_connsta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ENS_EVDCConnectionStateAKind* released = _impl_.connsta_;
  _impl_.connsta_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE EventAndStatusDEDO::unsafe_arena_release_connsta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEDO.ConnStA)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::evsemodule::ENS_EVDCConnectionStateAKind* temp = _impl_.connsta_;
  _impl_.connsta_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL EventAndStatusDEDO::_internal_mutable_connsta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.connsta_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVDCConnectionStateAKind>(GetArena());
    _impl_.connsta_ = reinterpret_cast<::evsemodule::ENS_EVDCConnectionStateAKind*>(p);
  }
  return _impl_.connsta_;
}
inline ::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NONNULL EventAndStatusDEDO::mutable_connsta()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::evsemodule::ENS_EVDCConnectionStateAKind* _msg = _internal_mutable_connsta();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEDO.ConnStA)
  return _msg;
}
inline void EventAndStatusDEDO::set_allocated_connsta(::evsemodule::ENS_EVDCConnectionStateAKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connsta_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.connsta_ = reinterpret_cast<::evsemodule::ENS_EVDCConnectionStateAKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEDO.ConnStA)
}

// .evsemodule.ENS_EVDCConnectionStateCKind ConnStC = 5;
inline bool EventAndStatusDEDO::has_connstc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connstc_ != nullptr);
  return value;
}
inline void EventAndStatusDEDO::clear_connstc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.connstc_ != nullptr) _impl_.connstc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::evsemodule::ENS_EVDCConnectionStateCKind& EventAndStatusDEDO::_internal_connstc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVDCConnectionStateCKind* p = _impl_.connstc_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVDCConnectionStateCKind&>(::evsemodule::_ENS_EVDCConnectionStateCKind_default_instance_);
}
inline const ::evsemodule::ENS_EVDCConnectionStateCKind& EventAndStatusDEDO::connstc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEDO.ConnStC)
  return _internal_connstc();
}
inline void EventAndStatusDEDO::unsafe_arena_set_allocated_connstc(
    ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connstc_);
  }
  _impl_.connstc_ = reinterpret_cast<::evsemodule::ENS_EVDCConnectionStateCKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEDO.ConnStC)
}
inline ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE EventAndStatusDEDO::release_connstc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::ENS_EVDCConnectionStateCKind* released = _impl_.connstc_;
  _impl_.connstc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE EventAndStatusDEDO::unsafe_arena_release_connstc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEDO.ConnStC)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::evsemodule::ENS_EVDCConnectionStateCKind* temp = _impl_.connstc_;
  _impl_.connstc_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL EventAndStatusDEDO::_internal_mutable_connstc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.connstc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVDCConnectionStateCKind>(GetArena());
    _impl_.connstc_ = reinterpret_cast<::evsemodule::ENS_EVDCConnectionStateCKind*>(p);
  }
  return _impl_.connstc_;
}
inline ::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NONNULL EventAndStatusDEDO::mutable_connstc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::evsemodule::ENS_EVDCConnectionStateCKind* _msg = _internal_mutable_connstc();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEDO.ConnStC)
  return _msg;
}
inline void EventAndStatusDEDO::set_allocated_connstc(::evsemodule::ENS_EVDCConnectionStateCKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connstc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.connstc_ = reinterpret_cast<::evsemodule::ENS_EVDCConnectionStateCKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEDO.ConnStC)
}

// .evsemodule.ENS_EVDCPlugStateKind PlgStDC = 6;
inline bool EventAndStatusDEDO::has_plgstdc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plgstdc_ != nullptr);
  return value;
}
inline void EventAndStatusDEDO::clear_plgstdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plgstdc_ != nullptr) _impl_.plgstdc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::evsemodule::ENS_EVDCPlugStateKind& EventAndStatusDEDO::_internal_plgstdc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ENS_EVDCPlugStateKind* p = _impl_.plgstdc_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ENS_EVDCPlugStateKind&>(::evsemodule::_ENS_EVDCPlugStateKind_default_instance_);
}
inline const ::evsemodule::ENS_EVDCPlugStateKind& EventAndStatusDEDO::plgstdc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDEDO.PlgStDC)
  return _internal_plgstdc();
}
inline void EventAndStatusDEDO::unsafe_arena_set_allocated_plgstdc(
    ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.plgstdc_);
  }
  _impl_.plgstdc_ = reinterpret_cast<::evsemodule::ENS_EVDCPlugStateKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDEDO.PlgStDC)
}
inline ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE EventAndStatusDEDO::release_plgstdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::evsemodule::ENS_EVDCPlugStateKind* released = _impl_.plgstdc_;
  _impl_.plgstdc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE EventAndStatusDEDO::unsafe_arena_release_plgstdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDEDO.PlgStDC)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::evsemodule::ENS_EVDCPlugStateKind* temp = _impl_.plgstdc_;
  _impl_.plgstdc_ = nullptr;
  return temp;
}
inline ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NONNULL EventAndStatusDEDO::_internal_mutable_plgstdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plgstdc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ENS_EVDCPlugStateKind>(GetArena());
    _impl_.plgstdc_ = reinterpret_cast<::evsemodule::ENS_EVDCPlugStateKind*>(p);
  }
  return _impl_.plgstdc_;
}
inline ::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NONNULL EventAndStatusDEDO::mutable_plgstdc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::evsemodule::ENS_EVDCPlugStateKind* _msg = _internal_mutable_plgstdc();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDEDO.PlgStDC)
  return _msg;
}
inline void EventAndStatusDEDO::set_allocated_plgstdc(::evsemodule::ENS_EVDCPlugStateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.plgstdc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.plgstdc_ = reinterpret_cast<::evsemodule::ENS_EVDCPlugStateKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDEDO.PlgStDC)
}

// -------------------------------------------------------------------

// EventAndStatusDESE

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool EventAndStatusDESE::has_logicalnodeforeventandstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforeventandstatus_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDESE::_internal_logicalnodeforeventandstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& EventAndStatusDESE::logicalnodeforeventandstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDESE::release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* released = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.logicalNodeForEventAndStatus)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForEventAndStatus>(GetArena());
    _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(p);
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL EventAndStatusDESE::mutable_logicalnodeforeventandstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.logicalNodeForEventAndStatus)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.logicalNodeForEventAndStatus)
}

// .evsemodule.EventAndStatusDEAO eventAndStatusDEAO = 2;
inline bool EventAndStatusDESE::has_eventandstatusdeao() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventandstatusdeao_ != nullptr);
  return value;
}
inline void EventAndStatusDESE::clear_eventandstatusdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdeao_ != nullptr) _impl_.eventandstatusdeao_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EventAndStatusDEAO& EventAndStatusDESE::_internal_eventandstatusdeao() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EventAndStatusDEAO* p = _impl_.eventandstatusdeao_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EventAndStatusDEAO&>(::evsemodule::_EventAndStatusDEAO_default_instance_);
}
inline const ::evsemodule::EventAndStatusDEAO& EventAndStatusDESE::eventandstatusdeao() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.eventAndStatusDEAO)
  return _internal_eventandstatusdeao();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_eventandstatusdeao(
    ::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdeao_);
  }
  _impl_.eventandstatusdeao_ = reinterpret_cast<::evsemodule::EventAndStatusDEAO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.eventAndStatusDEAO)
}
inline ::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE EventAndStatusDESE::release_eventandstatusdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EventAndStatusDEAO* released = _impl_.eventandstatusdeao_;
  _impl_.eventandstatusdeao_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_eventandstatusdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.eventAndStatusDEAO)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EventAndStatusDEAO* temp = _impl_.eventandstatusdeao_;
  _impl_.eventandstatusdeao_ = nullptr;
  return temp;
}
inline ::evsemodule::EventAndStatusDEAO* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_eventandstatusdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdeao_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EventAndStatusDEAO>(GetArena());
    _impl_.eventandstatusdeao_ = reinterpret_cast<::evsemodule::EventAndStatusDEAO*>(p);
  }
  return _impl_.eventandstatusdeao_;
}
inline ::evsemodule::EventAndStatusDEAO* PROTOBUF_NONNULL EventAndStatusDESE::mutable_eventandstatusdeao()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EventAndStatusDEAO* _msg = _internal_mutable_eventandstatusdeao();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.eventAndStatusDEAO)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_eventandstatusdeao(::evsemodule::EventAndStatusDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdeao_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.eventandstatusdeao_ = reinterpret_cast<::evsemodule::EventAndStatusDEAO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.eventAndStatusDEAO)
}

// .evsemodule.EventAndStatusDEDO eventAndStatusDEDO = 3;
inline bool EventAndStatusDESE::has_eventandstatusdedo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventandstatusdedo_ != nullptr);
  return value;
}
inline void EventAndStatusDESE::clear_eventandstatusdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdedo_ != nullptr) _impl_.eventandstatusdedo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EventAndStatusDEDO& EventAndStatusDESE::_internal_eventandstatusdedo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EventAndStatusDEDO* p = _impl_.eventandstatusdedo_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EventAndStatusDEDO&>(::evsemodule::_EventAndStatusDEDO_default_instance_);
}
inline const ::evsemodule::EventAndStatusDEDO& EventAndStatusDESE::eventandstatusdedo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.eventAndStatusDEDO)
  return _internal_eventandstatusdedo();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_eventandstatusdedo(
    ::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdedo_);
  }
  _impl_.eventandstatusdedo_ = reinterpret_cast<::evsemodule::EventAndStatusDEDO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.eventAndStatusDEDO)
}
inline ::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE EventAndStatusDESE::release_eventandstatusdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EventAndStatusDEDO* released = _impl_.eventandstatusdedo_;
  _impl_.eventandstatusdedo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_eventandstatusdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.eventAndStatusDEDO)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EventAndStatusDEDO* temp = _impl_.eventandstatusdedo_;
  _impl_.eventandstatusdedo_ = nullptr;
  return temp;
}
inline ::evsemodule::EventAndStatusDEDO* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_eventandstatusdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventandstatusdedo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EventAndStatusDEDO>(GetArena());
    _impl_.eventandstatusdedo_ = reinterpret_cast<::evsemodule::EventAndStatusDEDO*>(p);
  }
  return _impl_.eventandstatusdedo_;
}
inline ::evsemodule::EventAndStatusDEDO* PROTOBUF_NONNULL EventAndStatusDESE::mutable_eventandstatusdedo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EventAndStatusDEDO* _msg = _internal_mutable_eventandstatusdedo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.eventAndStatusDEDO)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_eventandstatusdedo(::evsemodule::EventAndStatusDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventandstatusdedo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.eventandstatusdedo_ = reinterpret_cast<::evsemodule::EventAndStatusDEDO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.eventAndStatusDEDO)
}

// .commonmodule.StatusSPS IsoTestFlt = 4;
inline bool EventAndStatusDESE::has_isotestflt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.isotestflt_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::_internal_isotestflt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.isotestflt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::isotestflt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.IsoTestFlt)
  return _internal_isotestflt();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_isotestflt(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.isotestflt_);
  }
  _impl_.isotestflt_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.IsoTestFlt)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::release_isotestflt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::StatusSPS* released = _impl_.isotestflt_;
  _impl_.isotestflt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_isotestflt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.IsoTestFlt)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::StatusSPS* temp = _impl_.isotestflt_;
  _impl_.isotestflt_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_isotestflt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.isotestflt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.isotestflt_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.isotestflt_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::mutable_isotestflt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_isotestflt();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.IsoTestFlt)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_isotestflt(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.isotestflt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.isotestflt_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.IsoTestFlt)
}

// .commonmodule.StatusSPS ScTestFlt = 5;
inline bool EventAndStatusDESE::has_sctestflt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sctestflt_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::_internal_sctestflt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.sctestflt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::sctestflt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.ScTestFlt)
  return _internal_sctestflt();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_sctestflt(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sctestflt_);
  }
  _impl_.sctestflt_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.ScTestFlt)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::release_sctestflt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::StatusSPS* released = _impl_.sctestflt_;
  _impl_.sctestflt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_sctestflt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.ScTestFlt)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::StatusSPS* temp = _impl_.sctestflt_;
  _impl_.sctestflt_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_sctestflt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sctestflt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.sctestflt_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.sctestflt_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::mutable_sctestflt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_sctestflt();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.ScTestFlt)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_sctestflt(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sctestflt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.sctestflt_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.ScTestFlt)
}

// .commonmodule.StatusSPS DigCommLos = 6;
inline bool EventAndStatusDESE::has_digcommlos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.digcommlos_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::_internal_digcommlos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.digcommlos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::digcommlos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.DigCommLos)
  return _internal_digcommlos();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_digcommlos(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.digcommlos_);
  }
  _impl_.digcommlos_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.DigCommLos)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::release_digcommlos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::StatusSPS* released = _impl_.digcommlos_;
  _impl_.digcommlos_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_digcommlos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.DigCommLos)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::StatusSPS* temp = _impl_.digcommlos_;
  _impl_.digcommlos_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_digcommlos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.digcommlos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.digcommlos_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.digcommlos_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::mutable_digcommlos()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_digcommlos();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.DigCommLos)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_digcommlos(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.digcommlos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.digcommlos_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.DigCommLos)
}

// .commonmodule.StatusSPS WldDet = 7;
inline bool EventAndStatusDESE::has_wlddet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wlddet_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::_internal_wlddet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.wlddet_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& EventAndStatusDESE::wlddet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.WldDet)
  return _internal_wlddet();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_wlddet(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wlddet_);
  }
  _impl_.wlddet_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.WldDet)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::release_wlddet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::StatusSPS* released = _impl_.wlddet_;
  _impl_.wlddet_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_wlddet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.WldDet)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::StatusSPS* temp = _impl_.wlddet_;
  _impl_.wlddet_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_wlddet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.wlddet_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.wlddet_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.wlddet_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL EventAndStatusDESE::mutable_wlddet()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_wlddet();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.WldDet)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_wlddet(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wlddet_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.wlddet_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.WldDet)
}

// .evsemodule.EVSEPointStatus PointStatus = 8;
inline bool EventAndStatusDESE::has_pointstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pointstatus_ != nullptr);
  return value;
}
inline void EventAndStatusDESE::clear_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pointstatus_ != nullptr) _impl_.pointstatus_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::evsemodule::EVSEPointStatus& EventAndStatusDESE::_internal_pointstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEPointStatus* p = _impl_.pointstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEPointStatus&>(::evsemodule::_EVSEPointStatus_default_instance_);
}
inline const ::evsemodule::EVSEPointStatus& EventAndStatusDESE::pointstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EventAndStatusDESE.PointStatus)
  return _internal_pointstatus();
}
inline void EventAndStatusDESE::unsafe_arena_set_allocated_pointstatus(
    ::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pointstatus_);
  }
  _impl_.pointstatus_ = reinterpret_cast<::evsemodule::EVSEPointStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EventAndStatusDESE.PointStatus)
}
inline ::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE EventAndStatusDESE::release_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::evsemodule::EVSEPointStatus* released = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE EventAndStatusDESE::unsafe_arena_release_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EventAndStatusDESE.PointStatus)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::evsemodule::EVSEPointStatus* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEPointStatus* PROTOBUF_NONNULL EventAndStatusDESE::_internal_mutable_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pointstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEPointStatus>(GetArena());
    _impl_.pointstatus_ = reinterpret_cast<::evsemodule::EVSEPointStatus*>(p);
  }
  return _impl_.pointstatus_;
}
inline ::evsemodule::EVSEPointStatus* PROTOBUF_NONNULL EventAndStatusDESE::mutable_pointstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::evsemodule::EVSEPointStatus* _msg = _internal_mutable_pointstatus();
  // @@protoc_insertion_point(field_mutable:evsemodule.EventAndStatusDESE.PointStatus)
  return _msg;
}
inline void EventAndStatusDESE::set_allocated_pointstatus(::evsemodule::EVSEPointStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pointstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.pointstatus_ = reinterpret_cast<::evsemodule::EVSEPointStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EventAndStatusDESE.PointStatus)
}

// -------------------------------------------------------------------

// EVSEEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool EVSEEvent::has_eventvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::EventValue& EVSEEvent::_internal_eventvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& EVSEEvent::eventvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEEvent.eventValue)
  return _internal_eventvalue();
}
inline void EVSEEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = reinterpret_cast<::commonmodule::EventValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEEvent.eventValue)
}
inline ::commonmodule::EventValue* PROTOBUF_NULLABLE EVSEEvent::release_eventvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventValue* released = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::EventValue* PROTOBUF_NULLABLE EVSEEvent::unsafe_arena_release_eventvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEEvent.eventValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* PROTOBUF_NONNULL EVSEEvent::_internal_mutable_eventvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::EventValue>(GetArena());
    _impl_.eventvalue_ = reinterpret_cast<::commonmodule::EventValue*>(p);
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* PROTOBUF_NONNULL EVSEEvent::mutable_eventvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEEvent.eventValue)
  return _msg;
}
inline void EVSEEvent::set_allocated_eventvalue(::commonmodule::EventValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.eventvalue_ = reinterpret_cast<::commonmodule::EventValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEEvent.eventValue)
}

// repeated .evsemodule.EventAndStatusDESE eventAndStatusDESE = 2 [(.uml.option_multiplicity_min) = 0];
inline int EVSEEvent::_internal_eventandstatusdese_size() const {
  return _internal_eventandstatusdese().size();
}
inline int EVSEEvent::eventandstatusdese_size() const {
  return _internal_eventandstatusdese_size();
}
inline void EVSEEvent::clear_eventandstatusdese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eventandstatusdese_.Clear();
}
inline ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL EVSEEvent::mutable_eventandstatusdese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEEvent.eventAndStatusDESE)
  return _internal_mutable_eventandstatusdese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL EVSEEvent::mutable_eventandstatusdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSEEvent.eventAndStatusDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_eventandstatusdese();
}
inline const ::evsemodule::EventAndStatusDESE& EVSEEvent::eventandstatusdese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEEvent.eventAndStatusDESE)
  return _internal_eventandstatusdese().Get(index);
}
inline ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL EVSEEvent::add_eventandstatusdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::EventAndStatusDESE* _add = _internal_mutable_eventandstatusdese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSEEvent.eventAndStatusDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>& EVSEEvent::eventandstatusdese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSEEvent.eventAndStatusDESE)
  return _internal_eventandstatusdese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>&
EVSEEvent::_internal_eventandstatusdese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eventandstatusdese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL
EVSEEvent::_internal_mutable_eventandstatusdese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.eventandstatusdese_;
}

// -------------------------------------------------------------------

// EVSEEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EVSEEventProfile::has_eventmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::EventMessageInfo& EVSEEventProfile::_internal_eventmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& EVSEEventProfile::eventmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void EVSEEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = reinterpret_cast<::commonmodule::EventMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE EVSEEventProfile::release_eventmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventMessageInfo* released = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE EVSEEventProfile::unsafe_arena_release_eventmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEEventProfile.eventMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL EVSEEventProfile::_internal_mutable_eventmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::EventMessageInfo>(GetArena());
    _impl_.eventmessageinfo_ = reinterpret_cast<::commonmodule::EventMessageInfo*>(p);
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL EVSEEventProfile::mutable_eventmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEEventProfile.eventMessageInfo)
  return _msg;
}
inline void EVSEEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.eventmessageinfo_ = reinterpret_cast<::commonmodule::EventMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEEventProfile.eventMessageInfo)
}

// .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEEventProfile::has_evse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evse_ != nullptr);
  return value;
}
inline void EVSEEventProfile::clear_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ != nullptr) _impl_.evse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSE& EVSEEventProfile::_internal_evse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSE* p = _impl_.evse_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSE&>(::evsemodule::_EVSE_default_instance_);
}
inline const ::evsemodule::EVSE& EVSEEventProfile::evse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEEventProfile.evse)
  return _internal_evse();
}
inline void EVSEEventProfile::unsafe_arena_set_allocated_evse(
    ::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }
  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEEventProfile.evse)
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEEventProfile::release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* released = _impl_.evse_;
  _impl_.evse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEEventProfile::unsafe_arena_release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEEventProfile.evse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* temp = _impl_.evse_;
  _impl_.evse_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEEventProfile::_internal_mutable_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSE>(GetArena());
    _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(p);
  }
  return _impl_.evse_;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEEventProfile::mutable_evse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSE* _msg = _internal_mutable_evse();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEEventProfile.evse)
  return _msg;
}
inline void EVSEEventProfile::set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEEventProfile.evse)
}

// .evsemodule.EVSEEvent evseEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEEventProfile::has_evseevent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evseevent_ != nullptr);
  return value;
}
inline void EVSEEventProfile::clear_evseevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evseevent_ != nullptr) _impl_.evseevent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EVSEEvent& EVSEEventProfile::_internal_evseevent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEEvent* p = _impl_.evseevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEEvent&>(::evsemodule::_EVSEEvent_default_instance_);
}
inline const ::evsemodule::EVSEEvent& EVSEEventProfile::evseevent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEEventProfile.evseEvent)
  return _internal_evseevent();
}
inline void EVSEEventProfile::unsafe_arena_set_allocated_evseevent(
    ::evsemodule::EVSEEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evseevent_);
  }
  _impl_.evseevent_ = reinterpret_cast<::evsemodule::EVSEEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEEventProfile.evseEvent)
}
inline ::evsemodule::EVSEEvent* PROTOBUF_NULLABLE EVSEEventProfile::release_evseevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEEvent* released = _impl_.evseevent_;
  _impl_.evseevent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEEvent* PROTOBUF_NULLABLE EVSEEventProfile::unsafe_arena_release_evseevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEEventProfile.evseEvent)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEEvent* temp = _impl_.evseevent_;
  _impl_.evseevent_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEEvent* PROTOBUF_NONNULL EVSEEventProfile::_internal_mutable_evseevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evseevent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEEvent>(GetArena());
    _impl_.evseevent_ = reinterpret_cast<::evsemodule::EVSEEvent*>(p);
  }
  return _impl_.evseevent_;
}
inline ::evsemodule::EVSEEvent* PROTOBUF_NONNULL EVSEEventProfile::mutable_evseevent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EVSEEvent* _msg = _internal_mutable_evseevent();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEEventProfile.evseEvent)
  return _msg;
}
inline void EVSEEventProfile::set_allocated_evseevent(::evsemodule::EVSEEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evseevent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.evseevent_ = reinterpret_cast<::evsemodule::EVSEEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEEventProfile.evseEvent)
}

// -------------------------------------------------------------------

// ReadingDEEV

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingDEEV::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& ReadingDEEV::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& ReadingDEEV::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ReadingDEEV.logicalNode)
  return _internal_logicalnode();
}
inline void ReadingDEEV::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ReadingDEEV.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE ReadingDEEV::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE ReadingDEEV::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ReadingDEEV.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL ReadingDEEV::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL ReadingDEEV::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.ReadingDEEV.logicalNode)
  return _msg;
}
inline void ReadingDEEV::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ReadingDEEV.logicalNode)
}

// .commonmodule.MV Soc = 2;
inline bool ReadingDEEV::has_soc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.soc_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& ReadingDEEV::_internal_soc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.soc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& ReadingDEEV::soc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ReadingDEEV.Soc)
  return _internal_soc();
}
inline void ReadingDEEV::unsafe_arena_set_allocated_soc(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.soc_);
  }
  _impl_.soc_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ReadingDEEV.Soc)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE ReadingDEEV::release_soc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::MV* released = _impl_.soc_;
  _impl_.soc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE ReadingDEEV::unsafe_arena_release_soc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ReadingDEEV.Soc)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::MV* temp = _impl_.soc_;
  _impl_.soc_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL ReadingDEEV::_internal_mutable_soc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.soc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.soc_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.soc_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL ReadingDEEV::mutable_soc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::MV* _msg = _internal_mutable_soc();
  // @@protoc_insertion_point(field_mutable:evsemodule.ReadingDEEV.Soc)
  return _msg;
}
inline void ReadingDEEV::set_allocated_soc(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.soc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.soc_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ReadingDEEV.Soc)
}

// -------------------------------------------------------------------

// ReadingDEAO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingDEAO::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& ReadingDEAO::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& ReadingDEAO::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ReadingDEAO.logicalNode)
  return _internal_logicalnode();
}
inline void ReadingDEAO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ReadingDEAO.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE ReadingDEAO::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE ReadingDEAO::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ReadingDEAO.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL ReadingDEAO::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL ReadingDEAO::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.ReadingDEAO.logicalNode)
  return _msg;
}
inline void ReadingDEAO::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ReadingDEAO.logicalNode)
}

// .evsemodule.ReadingDEEV readingDEEV = 2;
inline bool ReadingDEAO::has_readingdeev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingdeev_ != nullptr);
  return value;
}
inline void ReadingDEAO::clear_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdeev_ != nullptr) _impl_.readingdeev_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::ReadingDEEV& ReadingDEAO::_internal_readingdeev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ReadingDEEV* p = _impl_.readingdeev_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ReadingDEEV&>(::evsemodule::_ReadingDEEV_default_instance_);
}
inline const ::evsemodule::ReadingDEEV& ReadingDEAO::readingdeev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ReadingDEAO.readingDEEV)
  return _internal_readingdeev();
}
inline void ReadingDEAO::unsafe_arena_set_allocated_readingdeev(
    ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdeev_);
  }
  _impl_.readingdeev_ = reinterpret_cast<::evsemodule::ReadingDEEV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ReadingDEAO.readingDEEV)
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE ReadingDEAO::release_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ReadingDEEV* released = _impl_.readingdeev_;
  _impl_.readingdeev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE ReadingDEAO::unsafe_arena_release_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ReadingDEAO.readingDEEV)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ReadingDEEV* temp = _impl_.readingdeev_;
  _impl_.readingdeev_ = nullptr;
  return temp;
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL ReadingDEAO::_internal_mutable_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdeev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ReadingDEEV>(GetArena());
    _impl_.readingdeev_ = reinterpret_cast<::evsemodule::ReadingDEEV*>(p);
  }
  return _impl_.readingdeev_;
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL ReadingDEAO::mutable_readingdeev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::ReadingDEEV* _msg = _internal_mutable_readingdeev();
  // @@protoc_insertion_point(field_mutable:evsemodule.ReadingDEAO.readingDEEV)
  return _msg;
}
inline void ReadingDEAO::set_allocated_readingdeev(::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdeev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.readingdeev_ = reinterpret_cast<::evsemodule::ReadingDEEV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ReadingDEAO.readingDEEV)
}

// -------------------------------------------------------------------

// ReadingDEDO

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool ReadingDEDO::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& ReadingDEDO::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& ReadingDEDO::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ReadingDEDO.logicalNode)
  return _internal_logicalnode();
}
inline void ReadingDEDO::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ReadingDEDO.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE ReadingDEDO::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE ReadingDEDO::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ReadingDEDO.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL ReadingDEDO::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL ReadingDEDO::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.ReadingDEDO.logicalNode)
  return _msg;
}
inline void ReadingDEDO::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ReadingDEDO.logicalNode)
}

// .evsemodule.ReadingDEEV readingDEEV = 2;
inline bool ReadingDEDO::has_readingdeev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingdeev_ != nullptr);
  return value;
}
inline void ReadingDEDO::clear_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdeev_ != nullptr) _impl_.readingdeev_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::ReadingDEEV& ReadingDEDO::_internal_readingdeev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ReadingDEEV* p = _impl_.readingdeev_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ReadingDEEV&>(::evsemodule::_ReadingDEEV_default_instance_);
}
inline const ::evsemodule::ReadingDEEV& ReadingDEDO::readingdeev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.ReadingDEDO.readingDEEV)
  return _internal_readingdeev();
}
inline void ReadingDEDO::unsafe_arena_set_allocated_readingdeev(
    ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdeev_);
  }
  _impl_.readingdeev_ = reinterpret_cast<::evsemodule::ReadingDEEV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.ReadingDEDO.readingDEEV)
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE ReadingDEDO::release_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ReadingDEEV* released = _impl_.readingdeev_;
  _impl_.readingdeev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE ReadingDEDO::unsafe_arena_release_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.ReadingDEDO.readingDEEV)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ReadingDEEV* temp = _impl_.readingdeev_;
  _impl_.readingdeev_ = nullptr;
  return temp;
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL ReadingDEDO::_internal_mutable_readingdeev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdeev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ReadingDEEV>(GetArena());
    _impl_.readingdeev_ = reinterpret_cast<::evsemodule::ReadingDEEV*>(p);
  }
  return _impl_.readingdeev_;
}
inline ::evsemodule::ReadingDEEV* PROTOBUF_NONNULL ReadingDEDO::mutable_readingdeev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::ReadingDEEV* _msg = _internal_mutable_readingdeev();
  // @@protoc_insertion_point(field_mutable:evsemodule.ReadingDEDO.readingDEEV)
  return _msg;
}
inline void ReadingDEDO::set_allocated_readingdeev(::evsemodule::ReadingDEEV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdeev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.readingdeev_ = reinterpret_cast<::evsemodule::ReadingDEEV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.ReadingDEDO.readingDEEV)
}

// -------------------------------------------------------------------

// EVSEReadingDESE

// .commonmodule.LogicalNode logicalNode = 1 [(.uml.option_parent_message) = true];
inline bool EVSEReadingDESE::has_logicalnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnode_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNode& EVSEReadingDESE::_internal_logicalnode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNode* p = _impl_.logicalnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNode&>(::commonmodule::_LogicalNode_default_instance_);
}
inline const ::commonmodule::LogicalNode& EVSEReadingDESE::logicalnode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingDESE.logicalNode)
  return _internal_logicalnode();
}
inline void EVSEReadingDESE::unsafe_arena_set_allocated_logicalnode(
    ::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }
  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingDESE.logicalNode)
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE EVSEReadingDESE::release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* released = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NULLABLE EVSEReadingDESE::unsafe_arena_release_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingDESE.logicalNode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNode* temp = _impl_.logicalnode_;
  _impl_.logicalnode_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL EVSEReadingDESE::_internal_mutable_logicalnode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNode>(GetArena());
    _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(p);
  }
  return _impl_.logicalnode_;
}
inline ::commonmodule::LogicalNode* PROTOBUF_NONNULL EVSEReadingDESE::mutable_logicalnode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNode* _msg = _internal_mutable_logicalnode();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingDESE.logicalNode)
  return _msg;
}
inline void EVSEReadingDESE::set_allocated_logicalnode(::commonmodule::LogicalNode* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnode_ = reinterpret_cast<::commonmodule::LogicalNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingDESE.logicalNode)
}

// .evsemodule.ReadingDEAO readingDEAO = 2;
inline bool EVSEReadingDESE::has_readingdeao() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingdeao_ != nullptr);
  return value;
}
inline void EVSEReadingDESE::clear_readingdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdeao_ != nullptr) _impl_.readingdeao_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::ReadingDEAO& EVSEReadingDESE::_internal_readingdeao() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ReadingDEAO* p = _impl_.readingdeao_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ReadingDEAO&>(::evsemodule::_ReadingDEAO_default_instance_);
}
inline const ::evsemodule::ReadingDEAO& EVSEReadingDESE::readingdeao() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingDESE.readingDEAO)
  return _internal_readingdeao();
}
inline void EVSEReadingDESE::unsafe_arena_set_allocated_readingdeao(
    ::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdeao_);
  }
  _impl_.readingdeao_ = reinterpret_cast<::evsemodule::ReadingDEAO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingDESE.readingDEAO)
}
inline ::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE EVSEReadingDESE::release_readingdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ReadingDEAO* released = _impl_.readingdeao_;
  _impl_.readingdeao_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE EVSEReadingDESE::unsafe_arena_release_readingdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingDESE.readingDEAO)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::ReadingDEAO* temp = _impl_.readingdeao_;
  _impl_.readingdeao_ = nullptr;
  return temp;
}
inline ::evsemodule::ReadingDEAO* PROTOBUF_NONNULL EVSEReadingDESE::_internal_mutable_readingdeao() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdeao_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ReadingDEAO>(GetArena());
    _impl_.readingdeao_ = reinterpret_cast<::evsemodule::ReadingDEAO*>(p);
  }
  return _impl_.readingdeao_;
}
inline ::evsemodule::ReadingDEAO* PROTOBUF_NONNULL EVSEReadingDESE::mutable_readingdeao()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::ReadingDEAO* _msg = _internal_mutable_readingdeao();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingDESE.readingDEAO)
  return _msg;
}
inline void EVSEReadingDESE::set_allocated_readingdeao(::evsemodule::ReadingDEAO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdeao_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.readingdeao_ = reinterpret_cast<::evsemodule::ReadingDEAO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingDESE.readingDEAO)
}

// .evsemodule.ReadingDEDO readingDEDO = 3;
inline bool EVSEReadingDESE::has_readingdedo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingdedo_ != nullptr);
  return value;
}
inline void EVSEReadingDESE::clear_readingdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdedo_ != nullptr) _impl_.readingdedo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::ReadingDEDO& EVSEReadingDESE::_internal_readingdedo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::ReadingDEDO* p = _impl_.readingdedo_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::ReadingDEDO&>(::evsemodule::_ReadingDEDO_default_instance_);
}
inline const ::evsemodule::ReadingDEDO& EVSEReadingDESE::readingdedo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingDESE.readingDEDO)
  return _internal_readingdedo();
}
inline void EVSEReadingDESE::unsafe_arena_set_allocated_readingdedo(
    ::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdedo_);
  }
  _impl_.readingdedo_ = reinterpret_cast<::evsemodule::ReadingDEDO*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingDESE.readingDEDO)
}
inline ::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE EVSEReadingDESE::release_readingdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::ReadingDEDO* released = _impl_.readingdedo_;
  _impl_.readingdedo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE EVSEReadingDESE::unsafe_arena_release_readingdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingDESE.readingDEDO)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::ReadingDEDO* temp = _impl_.readingdedo_;
  _impl_.readingdedo_ = nullptr;
  return temp;
}
inline ::evsemodule::ReadingDEDO* PROTOBUF_NONNULL EVSEReadingDESE::_internal_mutable_readingdedo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingdedo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::ReadingDEDO>(GetArena());
    _impl_.readingdedo_ = reinterpret_cast<::evsemodule::ReadingDEDO*>(p);
  }
  return _impl_.readingdedo_;
}
inline ::evsemodule::ReadingDEDO* PROTOBUF_NONNULL EVSEReadingDESE::mutable_readingdedo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::ReadingDEDO* _msg = _internal_mutable_readingdedo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingDESE.readingDEDO)
  return _msg;
}
inline void EVSEReadingDESE::set_allocated_readingdedo(::evsemodule::ReadingDEDO* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingdedo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.readingdedo_ = reinterpret_cast<::evsemodule::ReadingDEDO*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingDESE.readingDEDO)
}

// .commonmodule.MV ChaV = 4;
inline bool EVSEReadingDESE::has_chav() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chav_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& EVSEReadingDESE::_internal_chav() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.chav_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EVSEReadingDESE::chav() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingDESE.ChaV)
  return _internal_chav();
}
inline void EVSEReadingDESE::unsafe_arena_set_allocated_chav(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chav_);
  }
  _impl_.chav_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingDESE.ChaV)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::release_chav() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::MV* released = _impl_.chav_;
  _impl_.chav_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::unsafe_arena_release_chav() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingDESE.ChaV)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::MV* temp = _impl_.chav_;
  _impl_.chav_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::_internal_mutable_chav() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chav_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.chav_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.chav_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::mutable_chav()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::MV* _msg = _internal_mutable_chav();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingDESE.ChaV)
  return _msg;
}
inline void EVSEReadingDESE::set_allocated_chav(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chav_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.chav_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingDESE.ChaV)
}

// .commonmodule.MV ChaA = 5;
inline bool EVSEReadingDESE::has_chaa() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chaa_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& EVSEReadingDESE::_internal_chaa() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.chaa_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EVSEReadingDESE::chaa() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingDESE.ChaA)
  return _internal_chaa();
}
inline void EVSEReadingDESE::unsafe_arena_set_allocated_chaa(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaa_);
  }
  _impl_.chaa_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingDESE.ChaA)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::release_chaa() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::MV* released = _impl_.chaa_;
  _impl_.chaa_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::unsafe_arena_release_chaa() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingDESE.ChaA)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::MV* temp = _impl_.chaa_;
  _impl_.chaa_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::_internal_mutable_chaa() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chaa_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.chaa_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.chaa_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::mutable_chaa()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::MV* _msg = _internal_mutable_chaa();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingDESE.ChaA)
  return _msg;
}
inline void EVSEReadingDESE::set_allocated_chaa(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaa_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.chaa_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingDESE.ChaA)
}

// .commonmodule.MV ChaW = 6;
inline bool EVSEReadingDESE::has_chaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chaw_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& EVSEReadingDESE::_internal_chaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.chaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EVSEReadingDESE::chaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingDESE.ChaW)
  return _internal_chaw();
}
inline void EVSEReadingDESE::unsafe_arena_set_allocated_chaw(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaw_);
  }
  _impl_.chaw_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingDESE.ChaW)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::release_chaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::MV* released = _impl_.chaw_;
  _impl_.chaw_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::unsafe_arena_release_chaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingDESE.ChaW)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::MV* temp = _impl_.chaw_;
  _impl_.chaw_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::_internal_mutable_chaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chaw_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.chaw_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.chaw_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::mutable_chaw()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::MV* _msg = _internal_mutable_chaw();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingDESE.ChaW)
  return _msg;
}
inline void EVSEReadingDESE::set_allocated_chaw(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.chaw_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingDESE.ChaW)
}

// .commonmodule.MV ChaWh = 7;
inline bool EVSEReadingDESE::has_chawh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chawh_ != nullptr);
  return value;
}
inline const ::commonmodule::MV& EVSEReadingDESE::_internal_chawh() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::MV* p = _impl_.chawh_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::MV&>(::commonmodule::_MV_default_instance_);
}
inline const ::commonmodule::MV& EVSEReadingDESE::chawh() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingDESE.ChaWh)
  return _internal_chawh();
}
inline void EVSEReadingDESE::unsafe_arena_set_allocated_chawh(
    ::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chawh_);
  }
  _impl_.chawh_ = reinterpret_cast<::commonmodule::MV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingDESE.ChaWh)
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::release_chawh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::MV* released = _impl_.chawh_;
  _impl_.chawh_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::MV* PROTOBUF_NULLABLE EVSEReadingDESE::unsafe_arena_release_chawh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingDESE.ChaWh)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::MV* temp = _impl_.chawh_;
  _impl_.chawh_ = nullptr;
  return temp;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::_internal_mutable_chawh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chawh_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::MV>(GetArena());
    _impl_.chawh_ = reinterpret_cast<::commonmodule::MV*>(p);
  }
  return _impl_.chawh_;
}
inline ::commonmodule::MV* PROTOBUF_NONNULL EVSEReadingDESE::mutable_chawh()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::MV* _msg = _internal_mutable_chawh();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingDESE.ChaWh)
  return _msg;
}
inline void EVSEReadingDESE::set_allocated_chawh(::commonmodule::MV* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chawh_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.chawh_ = reinterpret_cast<::commonmodule::MV*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingDESE.ChaWh)
}

// -------------------------------------------------------------------

// EVSEReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool EVSEReading::has_conductingequipmentterminalreading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conductingequipmentterminalreading_ != nullptr);
  return value;
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& EVSEReading::_internal_conductingequipmentterminalreading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& EVSEReading::conductingequipmentterminalreading() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void EVSEReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = reinterpret_cast<::commonmodule::ConductingEquipmentTerminalReading*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE EVSEReading::release_conductingequipmentterminalreading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipmentTerminalReading* released = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE EVSEReading::unsafe_arena_release_conductingequipmentterminalreading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReading.conductingEquipmentTerminalReading)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL EVSEReading::_internal_mutable_conductingequipmentterminalreading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ConductingEquipmentTerminalReading>(GetArena());
    _impl_.conductingequipmentterminalreading_ = reinterpret_cast<::commonmodule::ConductingEquipmentTerminalReading*>(p);
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL EVSEReading::mutable_conductingequipmentterminalreading()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void EVSEReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.conductingequipmentterminalreading_ = reinterpret_cast<::commonmodule::ConductingEquipmentTerminalReading*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReading.conductingEquipmentTerminalReading)
}

// .commonmodule.ReadingMMXU readingMMXU = 2;
inline bool EVSEReading::has_readingmmxu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmmxu_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMMXU& EVSEReading::_internal_readingmmxu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& EVSEReading::readingmmxu() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void EVSEReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE EVSEReading::release_readingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ReadingMMXU* released = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE EVSEReading::unsafe_arena_release_readingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReading.readingMMXU)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL EVSEReading::_internal_mutable_readingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMMXU>(GetArena());
    _impl_.readingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(p);
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL EVSEReading::mutable_readingmmxu()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReading.readingMMXU)
  return _msg;
}
inline void EVSEReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmxu_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.readingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReading.readingMMXU)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool EVSEReading::has_readingmmtr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmmtr_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMMTR& EVSEReading::_internal_readingmmtr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& EVSEReading::readingmmtr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void EVSEReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = reinterpret_cast<::commonmodule::ReadingMMTR*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE EVSEReading::release_readingmmtr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ReadingMMTR* released = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE EVSEReading::unsafe_arena_release_readingmmtr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReading.readingMMTR)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL EVSEReading::_internal_mutable_readingmmtr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMMTR>(GetArena());
    _impl_.readingmmtr_ = reinterpret_cast<::commonmodule::ReadingMMTR*>(p);
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL EVSEReading::mutable_readingmmtr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReading.readingMMTR)
  return _msg;
}
inline void EVSEReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmtr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.readingmmtr_ = reinterpret_cast<::commonmodule::ReadingMMTR*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReading.readingMMTR)
}

// repeated .evsemodule.EVSEReadingDESE evseReadingDESE = 4 [(.uml.option_multiplicity_min) = 0];
inline int EVSEReading::_internal_evsereadingdese_size() const {
  return _internal_evsereadingdese().size();
}
inline int EVSEReading::evsereadingdese_size() const {
  return _internal_evsereadingdese_size();
}
inline void EVSEReading::clear_evsereadingdese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.evsereadingdese_.Clear();
}
inline ::evsemodule::EVSEReadingDESE* PROTOBUF_NONNULL EVSEReading::mutable_evsereadingdese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReading.evseReadingDESE)
  return _internal_mutable_evsereadingdese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>* PROTOBUF_NONNULL EVSEReading::mutable_evsereadingdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSEReading.evseReadingDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_evsereadingdese();
}
inline const ::evsemodule::EVSEReadingDESE& EVSEReading::evsereadingdese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReading.evseReadingDESE)
  return _internal_evsereadingdese().Get(index);
}
inline ::evsemodule::EVSEReadingDESE* PROTOBUF_NONNULL EVSEReading::add_evsereadingdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::EVSEReadingDESE* _add = _internal_mutable_evsereadingdese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSEReading.evseReadingDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>& EVSEReading::evsereadingdese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSEReading.evseReadingDESE)
  return _internal_evsereadingdese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>&
EVSEReading::_internal_evsereadingdese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.evsereadingdese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EVSEReadingDESE>* PROTOBUF_NONNULL
EVSEReading::_internal_mutable_evsereadingdese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.evsereadingdese_;
}

// .commonmodule.PhaseMMTN phaseMMTN = 5;
inline bool EVSEReading::has_phasemmtn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.phasemmtn_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseMMTN& EVSEReading::_internal_phasemmtn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& EVSEReading::phasemmtn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void EVSEReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = reinterpret_cast<::commonmodule::PhaseMMTN*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE EVSEReading::release_phasemmtn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::PhaseMMTN* released = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE EVSEReading::unsafe_arena_release_phasemmtn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReading.phaseMMTN)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL EVSEReading::_internal_mutable_phasemmtn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseMMTN>(GetArena());
    _impl_.phasemmtn_ = reinterpret_cast<::commonmodule::PhaseMMTN*>(p);
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL EVSEReading::mutable_phasemmtn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReading.phaseMMTN)
  return _msg;
}
inline void EVSEReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.phasemmtn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.phasemmtn_ = reinterpret_cast<::commonmodule::PhaseMMTN*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReading.phaseMMTN)
}

// .commonmodule.ReadingMMDC readingMMDC = 6;
inline bool EVSEReading::has_readingmmdc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmmdc_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMMDC& EVSEReading::_internal_readingmmdc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMMDC* p = _impl_.readingmmdc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMDC&>(::commonmodule::_ReadingMMDC_default_instance_);
}
inline const ::commonmodule::ReadingMMDC& EVSEReading::readingmmdc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReading.readingMMDC)
  return _internal_readingmmdc();
}
inline void EVSEReading::unsafe_arena_set_allocated_readingmmdc(
    ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmdc_);
  }
  _impl_.readingmmdc_ = reinterpret_cast<::commonmodule::ReadingMMDC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReading.readingMMDC)
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE EVSEReading::release_readingmmdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ReadingMMDC* released = _impl_.readingmmdc_;
  _impl_.readingmmdc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE EVSEReading::unsafe_arena_release_readingmmdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReading.readingMMDC)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ReadingMMDC* temp = _impl_.readingmmdc_;
  _impl_.readingmmdc_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL EVSEReading::_internal_mutable_readingmmdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmmdc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMMDC>(GetArena());
    _impl_.readingmmdc_ = reinterpret_cast<::commonmodule::ReadingMMDC*>(p);
  }
  return _impl_.readingmmdc_;
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL EVSEReading::mutable_readingmmdc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::ReadingMMDC* _msg = _internal_mutable_readingmmdc();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReading.readingMMDC)
  return _msg;
}
inline void EVSEReading::set_allocated_readingmmdc(::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmdc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.readingmmdc_ = reinterpret_cast<::commonmodule::ReadingMMDC*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReading.readingMMDC)
}

// -------------------------------------------------------------------

// EVSEReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EVSEReadingProfile::has_readingmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMessageInfo& EVSEReadingProfile::_internal_readingmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& EVSEReadingProfile::readingmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void EVSEReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = reinterpret_cast<::commonmodule::ReadingMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE EVSEReadingProfile::release_readingmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ReadingMessageInfo* released = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE EVSEReadingProfile::unsafe_arena_release_readingmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingProfile.readingMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL EVSEReadingProfile::_internal_mutable_readingmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMessageInfo>(GetArena());
    _impl_.readingmessageinfo_ = reinterpret_cast<::commonmodule::ReadingMessageInfo*>(p);
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL EVSEReadingProfile::mutable_readingmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingProfile.readingMessageInfo)
  return _msg;
}
inline void EVSEReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.readingmessageinfo_ = reinterpret_cast<::commonmodule::ReadingMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingProfile.readingMessageInfo)
}

// .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEReadingProfile::has_evse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evse_ != nullptr);
  return value;
}
inline void EVSEReadingProfile::clear_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ != nullptr) _impl_.evse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSE& EVSEReadingProfile::_internal_evse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSE* p = _impl_.evse_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSE&>(::evsemodule::_EVSE_default_instance_);
}
inline const ::evsemodule::EVSE& EVSEReadingProfile::evse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingProfile.evse)
  return _internal_evse();
}
inline void EVSEReadingProfile::unsafe_arena_set_allocated_evse(
    ::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }
  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingProfile.evse)
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEReadingProfile::release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* released = _impl_.evse_;
  _impl_.evse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEReadingProfile::unsafe_arena_release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingProfile.evse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* temp = _impl_.evse_;
  _impl_.evse_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEReadingProfile::_internal_mutable_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSE>(GetArena());
    _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(p);
  }
  return _impl_.evse_;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEReadingProfile::mutable_evse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSE* _msg = _internal_mutable_evse();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingProfile.evse)
  return _msg;
}
inline void EVSEReadingProfile::set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingProfile.evse)
}

// .evsemodule.EVSEReading evseReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEReadingProfile::has_evsereading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evsereading_ != nullptr);
  return value;
}
inline void EVSEReadingProfile::clear_evsereading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsereading_ != nullptr) _impl_.evsereading_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EVSEReading& EVSEReadingProfile::_internal_evsereading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEReading* p = _impl_.evsereading_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEReading&>(::evsemodule::_EVSEReading_default_instance_);
}
inline const ::evsemodule::EVSEReading& EVSEReadingProfile::evsereading() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEReadingProfile.evseReading)
  return _internal_evsereading();
}
inline void EVSEReadingProfile::unsafe_arena_set_allocated_evsereading(
    ::evsemodule::EVSEReading* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsereading_);
  }
  _impl_.evsereading_ = reinterpret_cast<::evsemodule::EVSEReading*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEReadingProfile.evseReading)
}
inline ::evsemodule::EVSEReading* PROTOBUF_NULLABLE EVSEReadingProfile::release_evsereading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEReading* released = _impl_.evsereading_;
  _impl_.evsereading_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEReading* PROTOBUF_NULLABLE EVSEReadingProfile::unsafe_arena_release_evsereading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEReadingProfile.evseReading)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEReading* temp = _impl_.evsereading_;
  _impl_.evsereading_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEReading* PROTOBUF_NONNULL EVSEReadingProfile::_internal_mutable_evsereading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsereading_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEReading>(GetArena());
    _impl_.evsereading_ = reinterpret_cast<::evsemodule::EVSEReading*>(p);
  }
  return _impl_.evsereading_;
}
inline ::evsemodule::EVSEReading* PROTOBUF_NONNULL EVSEReadingProfile::mutable_evsereading()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EVSEReading* _msg = _internal_mutable_evsereading();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEReadingProfile.evseReading)
  return _msg;
}
inline void EVSEReadingProfile::set_allocated_evsereading(::evsemodule::EVSEReading* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsereading_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.evsereading_ = reinterpret_cast<::evsemodule::EVSEReading*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEReadingProfile.evseReading)
}

// -------------------------------------------------------------------

// EVSEStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool EVSEStatus::has_statusvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statusvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusValue& EVSEStatus::_internal_statusvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& EVSEStatus::statusvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEStatus.statusValue)
  return _internal_statusvalue();
}
inline void EVSEStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = reinterpret_cast<::commonmodule::StatusValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEStatus.statusValue)
}
inline ::commonmodule::StatusValue* PROTOBUF_NULLABLE EVSEStatus::release_statusvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusValue* released = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusValue* PROTOBUF_NULLABLE EVSEStatus::unsafe_arena_release_statusvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEStatus.statusValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* PROTOBUF_NONNULL EVSEStatus::_internal_mutable_statusvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusValue>(GetArena());
    _impl_.statusvalue_ = reinterpret_cast<::commonmodule::StatusValue*>(p);
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* PROTOBUF_NONNULL EVSEStatus::mutable_statusvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEStatus.statusValue)
  return _msg;
}
inline void EVSEStatus::set_allocated_statusvalue(::commonmodule::StatusValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.statusvalue_ = reinterpret_cast<::commonmodule::StatusValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEStatus.statusValue)
}

// repeated .evsemodule.EventAndStatusDESE eventAndStatusDESE = 2 [(.uml.option_multiplicity_min) = 0];
inline int EVSEStatus::_internal_eventandstatusdese_size() const {
  return _internal_eventandstatusdese().size();
}
inline int EVSEStatus::eventandstatusdese_size() const {
  return _internal_eventandstatusdese_size();
}
inline void EVSEStatus::clear_eventandstatusdese() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eventandstatusdese_.Clear();
}
inline ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL EVSEStatus::mutable_eventandstatusdese(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEStatus.eventAndStatusDESE)
  return _internal_mutable_eventandstatusdese()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL EVSEStatus::mutable_eventandstatusdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:evsemodule.EVSEStatus.eventAndStatusDESE)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_eventandstatusdese();
}
inline const ::evsemodule::EventAndStatusDESE& EVSEStatus::eventandstatusdese(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEStatus.eventAndStatusDESE)
  return _internal_eventandstatusdese().Get(index);
}
inline ::evsemodule::EventAndStatusDESE* PROTOBUF_NONNULL EVSEStatus::add_eventandstatusdese()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::evsemodule::EventAndStatusDESE* _add = _internal_mutable_eventandstatusdese()->Add();
  // @@protoc_insertion_point(field_add:evsemodule.EVSEStatus.eventAndStatusDESE)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>& EVSEStatus::eventandstatusdese() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:evsemodule.EVSEStatus.eventAndStatusDESE)
  return _internal_eventandstatusdese();
}
inline const ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>&
EVSEStatus::_internal_eventandstatusdese() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eventandstatusdese_;
}
inline ::google::protobuf::RepeatedPtrField<::evsemodule::EventAndStatusDESE>* PROTOBUF_NONNULL
EVSEStatus::_internal_mutable_eventandstatusdese() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.eventandstatusdese_;
}

// -------------------------------------------------------------------

// EVSEStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool EVSEStatusProfile::has_statusmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statusmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusMessageInfo& EVSEStatusProfile::_internal_statusmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& EVSEStatusProfile::statusmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void EVSEStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = reinterpret_cast<::commonmodule::StatusMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE EVSEStatusProfile::release_statusmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusMessageInfo* released = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE EVSEStatusProfile::unsafe_arena_release_statusmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEStatusProfile.statusMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL EVSEStatusProfile::_internal_mutable_statusmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusMessageInfo>(GetArena());
    _impl_.statusmessageinfo_ = reinterpret_cast<::commonmodule::StatusMessageInfo*>(p);
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL EVSEStatusProfile::mutable_statusmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEStatusProfile.statusMessageInfo)
  return _msg;
}
inline void EVSEStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.statusmessageinfo_ = reinterpret_cast<::commonmodule::StatusMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEStatusProfile.statusMessageInfo)
}

// .evsemodule.EVSE evse = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEStatusProfile::has_evse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evse_ != nullptr);
  return value;
}
inline void EVSEStatusProfile::clear_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ != nullptr) _impl_.evse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::evsemodule::EVSE& EVSEStatusProfile::_internal_evse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSE* p = _impl_.evse_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSE&>(::evsemodule::_EVSE_default_instance_);
}
inline const ::evsemodule::EVSE& EVSEStatusProfile::evse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEStatusProfile.evse)
  return _internal_evse();
}
inline void EVSEStatusProfile::unsafe_arena_set_allocated_evse(
    ::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }
  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEStatusProfile.evse)
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEStatusProfile::release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* released = _impl_.evse_;
  _impl_.evse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSE* PROTOBUF_NULLABLE EVSEStatusProfile::unsafe_arena_release_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEStatusProfile.evse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::evsemodule::EVSE* temp = _impl_.evse_;
  _impl_.evse_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEStatusProfile::_internal_mutable_evse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSE>(GetArena());
    _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(p);
  }
  return _impl_.evse_;
}
inline ::evsemodule::EVSE* PROTOBUF_NONNULL EVSEStatusProfile::mutable_evse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::evsemodule::EVSE* _msg = _internal_mutable_evse();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEStatusProfile.evse)
  return _msg;
}
inline void EVSEStatusProfile::set_allocated_evse(::evsemodule::EVSE* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.evse_ = reinterpret_cast<::evsemodule::EVSE*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEStatusProfile.evse)
}

// .evsemodule.EVSEStatus evseStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool EVSEStatusProfile::has_evsestatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.evsestatus_ != nullptr);
  return value;
}
inline void EVSEStatusProfile::clear_evsestatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsestatus_ != nullptr) _impl_.evsestatus_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::evsemodule::EVSEStatus& EVSEStatusProfile::_internal_evsestatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::evsemodule::EVSEStatus* p = _impl_.evsestatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::evsemodule::EVSEStatus&>(::evsemodule::_EVSEStatus_default_instance_);
}
inline const ::evsemodule::EVSEStatus& EVSEStatusProfile::evsestatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:evsemodule.EVSEStatusProfile.evseStatus)
  return _internal_evsestatus();
}
inline void EVSEStatusProfile::unsafe_arena_set_allocated_evsestatus(
    ::evsemodule::EVSEStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsestatus_);
  }
  _impl_.evsestatus_ = reinterpret_cast<::evsemodule::EVSEStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:evsemodule.EVSEStatusProfile.evseStatus)
}
inline ::evsemodule::EVSEStatus* PROTOBUF_NULLABLE EVSEStatusProfile::release_evsestatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEStatus* released = _impl_.evsestatus_;
  _impl_.evsestatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::evsemodule::EVSEStatus* PROTOBUF_NULLABLE EVSEStatusProfile::unsafe_arena_release_evsestatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:evsemodule.EVSEStatusProfile.evseStatus)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::evsemodule::EVSEStatus* temp = _impl_.evsestatus_;
  _impl_.evsestatus_ = nullptr;
  return temp;
}
inline ::evsemodule::EVSEStatus* PROTOBUF_NONNULL EVSEStatusProfile::_internal_mutable_evsestatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.evsestatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::evsemodule::EVSEStatus>(GetArena());
    _impl_.evsestatus_ = reinterpret_cast<::evsemodule::EVSEStatus*>(p);
  }
  return _impl_.evsestatus_;
}
inline ::evsemodule::EVSEStatus* PROTOBUF_NONNULL EVSEStatusProfile::mutable_evsestatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::evsemodule::EVSEStatus* _msg = _internal_mutable_evsestatus();
  // @@protoc_insertion_point(field_mutable:evsemodule.EVSEStatusProfile.evseStatus)
  return _msg;
}
inline void EVSEStatusProfile::set_allocated_evsestatus(::evsemodule::EVSEStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.evsestatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.evsestatus_ = reinterpret_cast<::evsemodule::EVSEStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:evsemodule.EVSEStatusProfile.evseStatus)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace evsemodule


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::evsemodule::ChargingStateKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::ChargingStateKind>() {
  return ::evsemodule::ChargingStateKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVACConnectionStateKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVACConnectionStateKind>() {
  return ::evsemodule::EVACConnectionStateKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVACPlugStateKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVACPlugStateKind>() {
  return ::evsemodule::EVACPlugStateKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVACCableCapabilityKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVACCableCapabilityKind>() {
  return ::evsemodule::EVACCableCapabilityKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVConnectionChargingKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVConnectionChargingKind>() {
  return ::evsemodule::EVConnectionChargingKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVDCCableCapabilityKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVDCCableCapabilityKind>() {
  return ::evsemodule::EVDCCableCapabilityKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVDCConnectionStateAKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVDCConnectionStateAKind>() {
  return ::evsemodule::EVDCConnectionStateAKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVDCConnectionStateCKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVDCConnectionStateCKind>() {
  return ::evsemodule::EVDCConnectionStateCKind_descriptor();
}
template <>
struct is_proto_enum<::evsemodule::EVDCPlugStateKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::evsemodule::EVDCPlugStateKind>() {
  return ::evsemodule::EVDCPlugStateKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // evsemodule_2fevsemodule_2eproto_2epb_2eh
