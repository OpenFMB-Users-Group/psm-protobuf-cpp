// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interconnectionmodule/interconnectionmodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_interconnectionmodule_2finterconnectionmodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_interconnectionmodule_2finterconnectionmodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_interconnectionmodule_2finterconnectionmodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_interconnectionmodule_2finterconnectionmodule_2eproto;
namespace interconnectionmodule {
class InterconnectionCSG;
struct InterconnectionCSGDefaultTypeInternal;
extern InterconnectionCSGDefaultTypeInternal _InterconnectionCSG_default_instance_;
class InterconnectionControlScheduleFSCH;
struct InterconnectionControlScheduleFSCHDefaultTypeInternal;
extern InterconnectionControlScheduleFSCHDefaultTypeInternal _InterconnectionControlScheduleFSCH_default_instance_;
class InterconnectionPlannedScheduleProfile;
struct InterconnectionPlannedScheduleProfileDefaultTypeInternal;
extern InterconnectionPlannedScheduleProfileDefaultTypeInternal _InterconnectionPlannedScheduleProfile_default_instance_;
class InterconnectionPoint;
struct InterconnectionPointDefaultTypeInternal;
extern InterconnectionPointDefaultTypeInternal _InterconnectionPoint_default_instance_;
class InterconnectionRequestedScheduleProfile;
struct InterconnectionRequestedScheduleProfileDefaultTypeInternal;
extern InterconnectionRequestedScheduleProfileDefaultTypeInternal _InterconnectionRequestedScheduleProfile_default_instance_;
class InterconnectionSchedule;
struct InterconnectionScheduleDefaultTypeInternal;
extern InterconnectionScheduleDefaultTypeInternal _InterconnectionSchedule_default_instance_;
class InterconnectionScheduleFSCC;
struct InterconnectionScheduleFSCCDefaultTypeInternal;
extern InterconnectionScheduleFSCCDefaultTypeInternal _InterconnectionScheduleFSCC_default_instance_;
}  // namespace interconnectionmodule
PROTOBUF_NAMESPACE_OPEN
template <>
::interconnectionmodule::InterconnectionCSG* Arena::CreateMaybeMessage<::interconnectionmodule::InterconnectionCSG>(Arena*);
template <>
::interconnectionmodule::InterconnectionControlScheduleFSCH* Arena::CreateMaybeMessage<::interconnectionmodule::InterconnectionControlScheduleFSCH>(Arena*);
template <>
::interconnectionmodule::InterconnectionPlannedScheduleProfile* Arena::CreateMaybeMessage<::interconnectionmodule::InterconnectionPlannedScheduleProfile>(Arena*);
template <>
::interconnectionmodule::InterconnectionPoint* Arena::CreateMaybeMessage<::interconnectionmodule::InterconnectionPoint>(Arena*);
template <>
::interconnectionmodule::InterconnectionRequestedScheduleProfile* Arena::CreateMaybeMessage<::interconnectionmodule::InterconnectionRequestedScheduleProfile>(Arena*);
template <>
::interconnectionmodule::InterconnectionSchedule* Arena::CreateMaybeMessage<::interconnectionmodule::InterconnectionSchedule>(Arena*);
template <>
::interconnectionmodule::InterconnectionScheduleFSCC* Arena::CreateMaybeMessage<::interconnectionmodule::InterconnectionScheduleFSCC>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace interconnectionmodule {

// ===================================================================


// -------------------------------------------------------------------

class InterconnectionPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:interconnectionmodule.InterconnectionPoint) */ {
 public:
  inline InterconnectionPoint() : InterconnectionPoint(nullptr) {}
  ~InterconnectionPoint() override;
  explicit PROTOBUF_CONSTEXPR InterconnectionPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterconnectionPoint(const InterconnectionPoint& from);
  InterconnectionPoint(InterconnectionPoint&& from) noexcept
    : InterconnectionPoint() {
    *this = ::std::move(from);
  }

  inline InterconnectionPoint& operator=(const InterconnectionPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterconnectionPoint& operator=(InterconnectionPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterconnectionPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterconnectionPoint* internal_default_instance() {
    return reinterpret_cast<const InterconnectionPoint*>(
               &_InterconnectionPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InterconnectionPoint& a, InterconnectionPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(InterconnectionPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterconnectionPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterconnectionPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterconnectionPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterconnectionPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterconnectionPoint& from) {
    InterconnectionPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterconnectionPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "interconnectionmodule.InterconnectionPoint";
  }
  protected:
  explicit InterconnectionPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlackStartEnabledFieldNumber = 1,
    kFrequencySetPointEnabledFieldNumber = 2,
    kIslandFieldNumber = 3,
    kPctHzDroopFieldNumber = 4,
    kPctVDroopFieldNumber = 5,
    kRampRatesFieldNumber = 6,
    kReactivePwrSetPointEnabledFieldNumber = 7,
    kRealPwrSetPointEnabledFieldNumber = 8,
    kVoltageSetPointEnabledFieldNumber = 9,
    kStartTimeFieldNumber = 10,
  };
  // .commonmodule.ControlSPC blackStartEnabled = 1;
  bool has_blackstartenabled() const;
  private:
  bool _internal_has_blackstartenabled() const;

  public:
  void clear_blackstartenabled() ;
  const ::commonmodule::ControlSPC& blackstartenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_blackstartenabled();
  ::commonmodule::ControlSPC* mutable_blackstartenabled();
  void set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_blackstartenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_blackstartenabled();
  public:
  void unsafe_arena_set_allocated_blackstartenabled(
      ::commonmodule::ControlSPC* blackstartenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_blackstartenabled();
  // .commonmodule.ControlSPC frequencySetPointEnabled = 2;
  bool has_frequencysetpointenabled() const;
  private:
  bool _internal_has_frequencysetpointenabled() const;

  public:
  void clear_frequencysetpointenabled() ;
  const ::commonmodule::ControlSPC& frequencysetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_frequencysetpointenabled();
  ::commonmodule::ControlSPC* mutable_frequencysetpointenabled();
  void set_allocated_frequencysetpointenabled(::commonmodule::ControlSPC* frequencysetpointenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_frequencysetpointenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_frequencysetpointenabled();
  public:
  void unsafe_arena_set_allocated_frequencysetpointenabled(
      ::commonmodule::ControlSPC* frequencysetpointenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_frequencysetpointenabled();
  // .commonmodule.ControlSPC island = 3;
  bool has_island() const;
  private:
  bool _internal_has_island() const;

  public:
  void clear_island() ;
  const ::commonmodule::ControlSPC& island() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_island();
  ::commonmodule::ControlSPC* mutable_island();
  void set_allocated_island(::commonmodule::ControlSPC* island);
  private:
  const ::commonmodule::ControlSPC& _internal_island() const;
  ::commonmodule::ControlSPC* _internal_mutable_island();
  public:
  void unsafe_arena_set_allocated_island(
      ::commonmodule::ControlSPC* island);
  ::commonmodule::ControlSPC* unsafe_arena_release_island();
  // .google.protobuf.FloatValue pctHzDroop = 4;
  bool has_pcthzdroop() const;
  private:
  bool _internal_has_pcthzdroop() const;

  public:
  void clear_pcthzdroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pcthzdroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pcthzdroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pcthzdroop();
  void set_allocated_pcthzdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pcthzdroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pcthzdroop();
  public:
  void unsafe_arena_set_allocated_pcthzdroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pcthzdroop();
  // .google.protobuf.FloatValue pctVDroop = 5;
  bool has_pctvdroop() const;
  private:
  bool _internal_has_pctvdroop() const;

  public:
  void clear_pctvdroop() ;
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& pctvdroop() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FloatValue* release_pctvdroop();
  ::PROTOBUF_NAMESPACE_ID::FloatValue* mutable_pctvdroop();
  void set_allocated_pctvdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FloatValue& _internal_pctvdroop() const;
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _internal_mutable_pctvdroop();
  public:
  void unsafe_arena_set_allocated_pctvdroop(
      ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop);
  ::PROTOBUF_NAMESPACE_ID::FloatValue* unsafe_arena_release_pctvdroop();
  // .commonmodule.RampRate rampRates = 6;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.ControlSPC reactivePwrSetPointEnabled = 7;
  bool has_reactivepwrsetpointenabled() const;
  private:
  bool _internal_has_reactivepwrsetpointenabled() const;

  public:
  void clear_reactivepwrsetpointenabled() ;
  const ::commonmodule::ControlSPC& reactivepwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_reactivepwrsetpointenabled();
  ::commonmodule::ControlSPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlSPC* reactivepwrsetpointenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_reactivepwrsetpointenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_reactivepwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_reactivepwrsetpointenabled(
      ::commonmodule::ControlSPC* reactivepwrsetpointenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_reactivepwrsetpointenabled();
  // .commonmodule.ControlSPC realPwrSetPointEnabled = 8;
  bool has_realpwrsetpointenabled() const;
  private:
  bool _internal_has_realpwrsetpointenabled() const;

  public:
  void clear_realpwrsetpointenabled() ;
  const ::commonmodule::ControlSPC& realpwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_realpwrsetpointenabled();
  ::commonmodule::ControlSPC* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::ControlSPC* realpwrsetpointenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_realpwrsetpointenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_realpwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_realpwrsetpointenabled(
      ::commonmodule::ControlSPC* realpwrsetpointenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_realpwrsetpointenabled();
  // .commonmodule.ControlSPC voltageSetPointEnabled = 9;
  bool has_voltagesetpointenabled() const;
  private:
  bool _internal_has_voltagesetpointenabled() const;

  public:
  void clear_voltagesetpointenabled() ;
  const ::commonmodule::ControlSPC& voltagesetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_voltagesetpointenabled();
  ::commonmodule::ControlSPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::ControlSPC* voltagesetpointenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_voltagesetpointenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_voltagesetpointenabled();
  public:
  void unsafe_arena_set_allocated_voltagesetpointenabled(
      ::commonmodule::ControlSPC* voltagesetpointenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_voltagesetpointenabled();
  // .commonmodule.Timestamp startTime = 10 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;

  public:
  void clear_starttime() ;
  const ::commonmodule::Timestamp& starttime() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_starttime();
  ::commonmodule::Timestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::Timestamp* starttime);
  private:
  const ::commonmodule::Timestamp& _internal_starttime() const;
  ::commonmodule::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::commonmodule::Timestamp* starttime);
  ::commonmodule::Timestamp* unsafe_arena_release_starttime();
  // @@protoc_insertion_point(class_scope:interconnectionmodule.InterconnectionPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlSPC* blackstartenabled_;
    ::commonmodule::ControlSPC* frequencysetpointenabled_;
    ::commonmodule::ControlSPC* island_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop_;
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop_;
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::ControlSPC* reactivepwrsetpointenabled_;
    ::commonmodule::ControlSPC* realpwrsetpointenabled_;
    ::commonmodule::ControlSPC* voltagesetpointenabled_;
    ::commonmodule::Timestamp* starttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto;
};// -------------------------------------------------------------------

class InterconnectionCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:interconnectionmodule.InterconnectionCSG) */ {
 public:
  inline InterconnectionCSG() : InterconnectionCSG(nullptr) {}
  ~InterconnectionCSG() override;
  explicit PROTOBUF_CONSTEXPR InterconnectionCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterconnectionCSG(const InterconnectionCSG& from);
  InterconnectionCSG(InterconnectionCSG&& from) noexcept
    : InterconnectionCSG() {
    *this = ::std::move(from);
  }

  inline InterconnectionCSG& operator=(const InterconnectionCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterconnectionCSG& operator=(InterconnectionCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterconnectionCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterconnectionCSG* internal_default_instance() {
    return reinterpret_cast<const InterconnectionCSG*>(
               &_InterconnectionCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InterconnectionCSG& a, InterconnectionCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(InterconnectionCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterconnectionCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterconnectionCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterconnectionCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterconnectionCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterconnectionCSG& from) {
    InterconnectionCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterconnectionCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "interconnectionmodule.InterconnectionCSG";
  }
  protected:
  explicit InterconnectionCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .interconnectionmodule.InterconnectionPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::interconnectionmodule::InterconnectionPoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionPoint >*
      mutable_crvpts();
  private:
  const ::interconnectionmodule::InterconnectionPoint& _internal_crvpts(int index) const;
  ::interconnectionmodule::InterconnectionPoint* _internal_add_crvpts();
  public:
  const ::interconnectionmodule::InterconnectionPoint& crvpts(int index) const;
  ::interconnectionmodule::InterconnectionPoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionPoint >&
      crvpts() const;
  // @@protoc_insertion_point(class_scope:interconnectionmodule.InterconnectionCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionPoint > crvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto;
};// -------------------------------------------------------------------

class InterconnectionControlScheduleFSCH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:interconnectionmodule.InterconnectionControlScheduleFSCH) */ {
 public:
  inline InterconnectionControlScheduleFSCH() : InterconnectionControlScheduleFSCH(nullptr) {}
  ~InterconnectionControlScheduleFSCH() override;
  explicit PROTOBUF_CONSTEXPR InterconnectionControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterconnectionControlScheduleFSCH(const InterconnectionControlScheduleFSCH& from);
  InterconnectionControlScheduleFSCH(InterconnectionControlScheduleFSCH&& from) noexcept
    : InterconnectionControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline InterconnectionControlScheduleFSCH& operator=(const InterconnectionControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterconnectionControlScheduleFSCH& operator=(InterconnectionControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterconnectionControlScheduleFSCH& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterconnectionControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const InterconnectionControlScheduleFSCH*>(
               &_InterconnectionControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InterconnectionControlScheduleFSCH& a, InterconnectionControlScheduleFSCH& b) {
    a.Swap(&b);
  }
  inline void Swap(InterconnectionControlScheduleFSCH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterconnectionControlScheduleFSCH* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterconnectionControlScheduleFSCH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterconnectionControlScheduleFSCH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterconnectionControlScheduleFSCH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterconnectionControlScheduleFSCH& from) {
    InterconnectionControlScheduleFSCH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterconnectionControlScheduleFSCH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "interconnectionmodule.InterconnectionControlScheduleFSCH";
  }
  protected:
  explicit InterconnectionControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValDCSGFieldNumber = 1,
  };
  // .interconnectionmodule.InterconnectionCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  private:
  bool _internal_has_valdcsg() const;

  public:
  void clear_valdcsg() ;
  const ::interconnectionmodule::InterconnectionCSG& valdcsg() const;
  PROTOBUF_NODISCARD ::interconnectionmodule::InterconnectionCSG* release_valdcsg();
  ::interconnectionmodule::InterconnectionCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::interconnectionmodule::InterconnectionCSG* valdcsg);
  private:
  const ::interconnectionmodule::InterconnectionCSG& _internal_valdcsg() const;
  ::interconnectionmodule::InterconnectionCSG* _internal_mutable_valdcsg();
  public:
  void unsafe_arena_set_allocated_valdcsg(
      ::interconnectionmodule::InterconnectionCSG* valdcsg);
  ::interconnectionmodule::InterconnectionCSG* unsafe_arena_release_valdcsg();
  // @@protoc_insertion_point(class_scope:interconnectionmodule.InterconnectionControlScheduleFSCH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::interconnectionmodule::InterconnectionCSG* valdcsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto;
};// -------------------------------------------------------------------

class InterconnectionScheduleFSCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:interconnectionmodule.InterconnectionScheduleFSCC) */ {
 public:
  inline InterconnectionScheduleFSCC() : InterconnectionScheduleFSCC(nullptr) {}
  ~InterconnectionScheduleFSCC() override;
  explicit PROTOBUF_CONSTEXPR InterconnectionScheduleFSCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterconnectionScheduleFSCC(const InterconnectionScheduleFSCC& from);
  InterconnectionScheduleFSCC(InterconnectionScheduleFSCC&& from) noexcept
    : InterconnectionScheduleFSCC() {
    *this = ::std::move(from);
  }

  inline InterconnectionScheduleFSCC& operator=(const InterconnectionScheduleFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterconnectionScheduleFSCC& operator=(InterconnectionScheduleFSCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterconnectionScheduleFSCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterconnectionScheduleFSCC* internal_default_instance() {
    return reinterpret_cast<const InterconnectionScheduleFSCC*>(
               &_InterconnectionScheduleFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InterconnectionScheduleFSCC& a, InterconnectionScheduleFSCC& b) {
    a.Swap(&b);
  }
  inline void Swap(InterconnectionScheduleFSCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterconnectionScheduleFSCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterconnectionScheduleFSCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterconnectionScheduleFSCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterconnectionScheduleFSCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterconnectionScheduleFSCC& from) {
    InterconnectionScheduleFSCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterconnectionScheduleFSCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "interconnectionmodule.InterconnectionScheduleFSCC";
  }
  protected:
  explicit InterconnectionScheduleFSCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterconnectionControlScheduleFSCHFieldNumber = 2,
    kControlFSCCFieldNumber = 1,
  };
  // repeated .interconnectionmodule.InterconnectionControlScheduleFSCH interconnectionControlScheduleFSCH = 2 [(.uml.option_multiplicity_min) = 0];
  int interconnectioncontrolschedulefsch_size() const;
  private:
  int _internal_interconnectioncontrolschedulefsch_size() const;

  public:
  void clear_interconnectioncontrolschedulefsch() ;
  ::interconnectionmodule::InterconnectionControlScheduleFSCH* mutable_interconnectioncontrolschedulefsch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionControlScheduleFSCH >*
      mutable_interconnectioncontrolschedulefsch();
  private:
  const ::interconnectionmodule::InterconnectionControlScheduleFSCH& _internal_interconnectioncontrolschedulefsch(int index) const;
  ::interconnectionmodule::InterconnectionControlScheduleFSCH* _internal_add_interconnectioncontrolschedulefsch();
  public:
  const ::interconnectionmodule::InterconnectionControlScheduleFSCH& interconnectioncontrolschedulefsch(int index) const;
  ::interconnectionmodule::InterconnectionControlScheduleFSCH* add_interconnectioncontrolschedulefsch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionControlScheduleFSCH >&
      interconnectioncontrolschedulefsch() const;
  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  private:
  bool _internal_has_controlfscc() const;

  public:
  void clear_controlfscc() ;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);
  private:
  const ::commonmodule::ControlFSCC& _internal_controlfscc() const;
  ::commonmodule::ControlFSCC* _internal_mutable_controlfscc();
  public:
  void unsafe_arena_set_allocated_controlfscc(
      ::commonmodule::ControlFSCC* controlfscc);
  ::commonmodule::ControlFSCC* unsafe_arena_release_controlfscc();
  // @@protoc_insertion_point(class_scope:interconnectionmodule.InterconnectionScheduleFSCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionControlScheduleFSCH > interconnectioncontrolschedulefsch_;
    ::commonmodule::ControlFSCC* controlfscc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto;
};// -------------------------------------------------------------------

class InterconnectionSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:interconnectionmodule.InterconnectionSchedule) */ {
 public:
  inline InterconnectionSchedule() : InterconnectionSchedule(nullptr) {}
  ~InterconnectionSchedule() override;
  explicit PROTOBUF_CONSTEXPR InterconnectionSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterconnectionSchedule(const InterconnectionSchedule& from);
  InterconnectionSchedule(InterconnectionSchedule&& from) noexcept
    : InterconnectionSchedule() {
    *this = ::std::move(from);
  }

  inline InterconnectionSchedule& operator=(const InterconnectionSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterconnectionSchedule& operator=(InterconnectionSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterconnectionSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterconnectionSchedule* internal_default_instance() {
    return reinterpret_cast<const InterconnectionSchedule*>(
               &_InterconnectionSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InterconnectionSchedule& a, InterconnectionSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(InterconnectionSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterconnectionSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterconnectionSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterconnectionSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterconnectionSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterconnectionSchedule& from) {
    InterconnectionSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterconnectionSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "interconnectionmodule.InterconnectionSchedule";
  }
  protected:
  explicit InterconnectionSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiedObjectFieldNumber = 1,
    kCheckFieldNumber = 2,
    kInterconnectionScheduleFSCCFieldNumber = 3,
  };
  // .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
  bool has_identifiedobject() const;
  private:
  bool _internal_has_identifiedobject() const;

  public:
  void clear_identifiedobject() ;
  const ::commonmodule::IdentifiedObject& identifiedobject() const;
  PROTOBUF_NODISCARD ::commonmodule::IdentifiedObject* release_identifiedobject();
  ::commonmodule::IdentifiedObject* mutable_identifiedobject();
  void set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject);
  private:
  const ::commonmodule::IdentifiedObject& _internal_identifiedobject() const;
  ::commonmodule::IdentifiedObject* _internal_mutable_identifiedobject();
  public:
  void unsafe_arena_set_allocated_identifiedobject(
      ::commonmodule::IdentifiedObject* identifiedobject);
  ::commonmodule::IdentifiedObject* unsafe_arena_release_identifiedobject();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .interconnectionmodule.InterconnectionScheduleFSCC interconnectionScheduleFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_interconnectionschedulefscc() const;
  private:
  bool _internal_has_interconnectionschedulefscc() const;

  public:
  void clear_interconnectionschedulefscc() ;
  const ::interconnectionmodule::InterconnectionScheduleFSCC& interconnectionschedulefscc() const;
  PROTOBUF_NODISCARD ::interconnectionmodule::InterconnectionScheduleFSCC* release_interconnectionschedulefscc();
  ::interconnectionmodule::InterconnectionScheduleFSCC* mutable_interconnectionschedulefscc();
  void set_allocated_interconnectionschedulefscc(::interconnectionmodule::InterconnectionScheduleFSCC* interconnectionschedulefscc);
  private:
  const ::interconnectionmodule::InterconnectionScheduleFSCC& _internal_interconnectionschedulefscc() const;
  ::interconnectionmodule::InterconnectionScheduleFSCC* _internal_mutable_interconnectionschedulefscc();
  public:
  void unsafe_arena_set_allocated_interconnectionschedulefscc(
      ::interconnectionmodule::InterconnectionScheduleFSCC* interconnectionschedulefscc);
  ::interconnectionmodule::InterconnectionScheduleFSCC* unsafe_arena_release_interconnectionschedulefscc();
  // @@protoc_insertion_point(class_scope:interconnectionmodule.InterconnectionSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::IdentifiedObject* identifiedobject_;
    ::commonmodule::CheckConditions* check_;
    ::interconnectionmodule::InterconnectionScheduleFSCC* interconnectionschedulefscc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto;
};// -------------------------------------------------------------------

class InterconnectionPlannedScheduleProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:interconnectionmodule.InterconnectionPlannedScheduleProfile) */ {
 public:
  inline InterconnectionPlannedScheduleProfile() : InterconnectionPlannedScheduleProfile(nullptr) {}
  ~InterconnectionPlannedScheduleProfile() override;
  explicit PROTOBUF_CONSTEXPR InterconnectionPlannedScheduleProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterconnectionPlannedScheduleProfile(const InterconnectionPlannedScheduleProfile& from);
  InterconnectionPlannedScheduleProfile(InterconnectionPlannedScheduleProfile&& from) noexcept
    : InterconnectionPlannedScheduleProfile() {
    *this = ::std::move(from);
  }

  inline InterconnectionPlannedScheduleProfile& operator=(const InterconnectionPlannedScheduleProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterconnectionPlannedScheduleProfile& operator=(InterconnectionPlannedScheduleProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterconnectionPlannedScheduleProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterconnectionPlannedScheduleProfile* internal_default_instance() {
    return reinterpret_cast<const InterconnectionPlannedScheduleProfile*>(
               &_InterconnectionPlannedScheduleProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InterconnectionPlannedScheduleProfile& a, InterconnectionPlannedScheduleProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(InterconnectionPlannedScheduleProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterconnectionPlannedScheduleProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterconnectionPlannedScheduleProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterconnectionPlannedScheduleProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterconnectionPlannedScheduleProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterconnectionPlannedScheduleProfile& from) {
    InterconnectionPlannedScheduleProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterconnectionPlannedScheduleProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "interconnectionmodule.InterconnectionPlannedScheduleProfile";
  }
  protected:
  explicit InterconnectionPlannedScheduleProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kRequesterCircuitSegmentServiceFieldNumber = 2,
    kInterconnectionScheduleFieldNumber = 3,
    kTiePointFieldNumber = 4,
    kResponderCircuitSegmentServiceFieldNumber = 5,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .commonmodule.ApplicationSystem requesterCircuitSegmentService = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_requestercircuitsegmentservice() const;
  private:
  bool _internal_has_requestercircuitsegmentservice() const;

  public:
  void clear_requestercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& requestercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_requestercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_requestercircuitsegmentservice();
  void set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_requestercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_requestercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_requestercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_requestercircuitsegmentservice();
  // .interconnectionmodule.InterconnectionSchedule interconnectionSchedule = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_interconnectionschedule() const;
  private:
  bool _internal_has_interconnectionschedule() const;

  public:
  void clear_interconnectionschedule() ;
  const ::interconnectionmodule::InterconnectionSchedule& interconnectionschedule() const;
  PROTOBUF_NODISCARD ::interconnectionmodule::InterconnectionSchedule* release_interconnectionschedule();
  ::interconnectionmodule::InterconnectionSchedule* mutable_interconnectionschedule();
  void set_allocated_interconnectionschedule(::interconnectionmodule::InterconnectionSchedule* interconnectionschedule);
  private:
  const ::interconnectionmodule::InterconnectionSchedule& _internal_interconnectionschedule() const;
  ::interconnectionmodule::InterconnectionSchedule* _internal_mutable_interconnectionschedule();
  public:
  void unsafe_arena_set_allocated_interconnectionschedule(
      ::interconnectionmodule::InterconnectionSchedule* interconnectionschedule);
  ::interconnectionmodule::InterconnectionSchedule* unsafe_arena_release_interconnectionschedule();
  // .commonmodule.ConductingEquipment tiePoint = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_tiepoint() const;
  private:
  bool _internal_has_tiepoint() const;

  public:
  void clear_tiepoint() ;
  const ::commonmodule::ConductingEquipment& tiepoint() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_tiepoint();
  ::commonmodule::ConductingEquipment* mutable_tiepoint();
  void set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint);
  private:
  const ::commonmodule::ConductingEquipment& _internal_tiepoint() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_tiepoint();
  public:
  void unsafe_arena_set_allocated_tiepoint(
      ::commonmodule::ConductingEquipment* tiepoint);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_tiepoint();
  // .commonmodule.ApplicationSystem responderCircuitSegmentService = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_respondercircuitsegmentservice() const;
  private:
  bool _internal_has_respondercircuitsegmentservice() const;

  public:
  void clear_respondercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& respondercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_respondercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_respondercircuitsegmentservice();
  void set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_respondercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_respondercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_respondercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_respondercircuitsegmentservice();
  // @@protoc_insertion_point(class_scope:interconnectionmodule.InterconnectionPlannedScheduleProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice_;
    ::interconnectionmodule::InterconnectionSchedule* interconnectionschedule_;
    ::commonmodule::ConductingEquipment* tiepoint_;
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto;
};// -------------------------------------------------------------------

class InterconnectionRequestedScheduleProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:interconnectionmodule.InterconnectionRequestedScheduleProfile) */ {
 public:
  inline InterconnectionRequestedScheduleProfile() : InterconnectionRequestedScheduleProfile(nullptr) {}
  ~InterconnectionRequestedScheduleProfile() override;
  explicit PROTOBUF_CONSTEXPR InterconnectionRequestedScheduleProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterconnectionRequestedScheduleProfile(const InterconnectionRequestedScheduleProfile& from);
  InterconnectionRequestedScheduleProfile(InterconnectionRequestedScheduleProfile&& from) noexcept
    : InterconnectionRequestedScheduleProfile() {
    *this = ::std::move(from);
  }

  inline InterconnectionRequestedScheduleProfile& operator=(const InterconnectionRequestedScheduleProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterconnectionRequestedScheduleProfile& operator=(InterconnectionRequestedScheduleProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterconnectionRequestedScheduleProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterconnectionRequestedScheduleProfile* internal_default_instance() {
    return reinterpret_cast<const InterconnectionRequestedScheduleProfile*>(
               &_InterconnectionRequestedScheduleProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InterconnectionRequestedScheduleProfile& a, InterconnectionRequestedScheduleProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(InterconnectionRequestedScheduleProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterconnectionRequestedScheduleProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterconnectionRequestedScheduleProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterconnectionRequestedScheduleProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterconnectionRequestedScheduleProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterconnectionRequestedScheduleProfile& from) {
    InterconnectionRequestedScheduleProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterconnectionRequestedScheduleProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "interconnectionmodule.InterconnectionRequestedScheduleProfile";
  }
  protected:
  explicit InterconnectionRequestedScheduleProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kRequesterCircuitSegmentServiceFieldNumber = 2,
    kInterconnectionScheduleFieldNumber = 3,
    kTiePointFieldNumber = 4,
    kResponderCircuitSegmentServiceFieldNumber = 5,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .commonmodule.ApplicationSystem requesterCircuitSegmentService = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_requestercircuitsegmentservice() const;
  private:
  bool _internal_has_requestercircuitsegmentservice() const;

  public:
  void clear_requestercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& requestercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_requestercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_requestercircuitsegmentservice();
  void set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_requestercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_requestercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_requestercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* requestercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_requestercircuitsegmentservice();
  // .interconnectionmodule.InterconnectionSchedule interconnectionSchedule = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_interconnectionschedule() const;
  private:
  bool _internal_has_interconnectionschedule() const;

  public:
  void clear_interconnectionschedule() ;
  const ::interconnectionmodule::InterconnectionSchedule& interconnectionschedule() const;
  PROTOBUF_NODISCARD ::interconnectionmodule::InterconnectionSchedule* release_interconnectionschedule();
  ::interconnectionmodule::InterconnectionSchedule* mutable_interconnectionschedule();
  void set_allocated_interconnectionschedule(::interconnectionmodule::InterconnectionSchedule* interconnectionschedule);
  private:
  const ::interconnectionmodule::InterconnectionSchedule& _internal_interconnectionschedule() const;
  ::interconnectionmodule::InterconnectionSchedule* _internal_mutable_interconnectionschedule();
  public:
  void unsafe_arena_set_allocated_interconnectionschedule(
      ::interconnectionmodule::InterconnectionSchedule* interconnectionschedule);
  ::interconnectionmodule::InterconnectionSchedule* unsafe_arena_release_interconnectionschedule();
  // .commonmodule.ConductingEquipment tiePoint = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_tiepoint() const;
  private:
  bool _internal_has_tiepoint() const;

  public:
  void clear_tiepoint() ;
  const ::commonmodule::ConductingEquipment& tiepoint() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_tiepoint();
  ::commonmodule::ConductingEquipment* mutable_tiepoint();
  void set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint);
  private:
  const ::commonmodule::ConductingEquipment& _internal_tiepoint() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_tiepoint();
  public:
  void unsafe_arena_set_allocated_tiepoint(
      ::commonmodule::ConductingEquipment* tiepoint);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_tiepoint();
  // .commonmodule.ApplicationSystem responderCircuitSegmentService = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_respondercircuitsegmentservice() const;
  private:
  bool _internal_has_respondercircuitsegmentservice() const;

  public:
  void clear_respondercircuitsegmentservice() ;
  const ::commonmodule::ApplicationSystem& respondercircuitsegmentservice() const;
  PROTOBUF_NODISCARD ::commonmodule::ApplicationSystem* release_respondercircuitsegmentservice();
  ::commonmodule::ApplicationSystem* mutable_respondercircuitsegmentservice();
  void set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  private:
  const ::commonmodule::ApplicationSystem& _internal_respondercircuitsegmentservice() const;
  ::commonmodule::ApplicationSystem* _internal_mutable_respondercircuitsegmentservice();
  public:
  void unsafe_arena_set_allocated_respondercircuitsegmentservice(
      ::commonmodule::ApplicationSystem* respondercircuitsegmentservice);
  ::commonmodule::ApplicationSystem* unsafe_arena_release_respondercircuitsegmentservice();
  // @@protoc_insertion_point(class_scope:interconnectionmodule.InterconnectionRequestedScheduleProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice_;
    ::interconnectionmodule::InterconnectionSchedule* interconnectionschedule_;
    ::commonmodule::ConductingEquipment* tiepoint_;
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interconnectionmodule_2finterconnectionmodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InterconnectionPoint

// .commonmodule.ControlSPC blackStartEnabled = 1;
inline bool InterconnectionPoint::_internal_has_blackstartenabled() const {
  return this != internal_default_instance() && _impl_.blackstartenabled_ != nullptr;
}
inline bool InterconnectionPoint::has_blackstartenabled() const {
  return _internal_has_blackstartenabled();
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::_internal_blackstartenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.blackstartenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::blackstartenabled() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.blackStartEnabled)
  return _internal_blackstartenabled();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_blackstartenabled(
    ::commonmodule::ControlSPC* blackstartenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.blackStartEnabled)
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::release_blackstartenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::unsafe_arena_release_blackstartenabled() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.blackStartEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.blackstartenabled_;
  _impl_.blackstartenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::_internal_mutable_blackstartenabled() {
  
  if (_impl_.blackstartenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.blackstartenabled_ = p;
  }
  return _impl_.blackstartenabled_;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::mutable_blackstartenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_blackstartenabled();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.blackStartEnabled)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_blackstartenabled(::commonmodule::ControlSPC* blackstartenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blackstartenabled_);
  }
  if (blackstartenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blackstartenabled));
    if (message_arena != submessage_arena) {
      blackstartenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blackstartenabled, submessage_arena);
    }

  } else {

  }
  _impl_.blackstartenabled_ = blackstartenabled;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.blackStartEnabled)
}

// .commonmodule.ControlSPC frequencySetPointEnabled = 2;
inline bool InterconnectionPoint::_internal_has_frequencysetpointenabled() const {
  return this != internal_default_instance() && _impl_.frequencysetpointenabled_ != nullptr;
}
inline bool InterconnectionPoint::has_frequencysetpointenabled() const {
  return _internal_has_frequencysetpointenabled();
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::_internal_frequencysetpointenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.frequencysetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::frequencysetpointenabled() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.frequencySetPointEnabled)
  return _internal_frequencysetpointenabled();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_frequencysetpointenabled(
    ::commonmodule::ControlSPC* frequencysetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpointenabled_);
  }
  _impl_.frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.frequencySetPointEnabled)
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::release_frequencysetpointenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.frequencysetpointenabled_;
  _impl_.frequencysetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::unsafe_arena_release_frequencysetpointenabled() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.frequencySetPointEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.frequencysetpointenabled_;
  _impl_.frequencysetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::_internal_mutable_frequencysetpointenabled() {
  
  if (_impl_.frequencysetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.frequencysetpointenabled_ = p;
  }
  return _impl_.frequencysetpointenabled_;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::mutable_frequencysetpointenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_frequencysetpointenabled();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.frequencySetPointEnabled)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_frequencysetpointenabled(::commonmodule::ControlSPC* frequencysetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frequencysetpointenabled_);
  }
  if (frequencysetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequencysetpointenabled));
    if (message_arena != submessage_arena) {
      frequencysetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequencysetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.frequencysetpointenabled_ = frequencysetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.frequencySetPointEnabled)
}

// .commonmodule.ControlSPC island = 3;
inline bool InterconnectionPoint::_internal_has_island() const {
  return this != internal_default_instance() && _impl_.island_ != nullptr;
}
inline bool InterconnectionPoint::has_island() const {
  return _internal_has_island();
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::_internal_island() const {
  const ::commonmodule::ControlSPC* p = _impl_.island_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::island() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.island)
  return _internal_island();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_island(
    ::commonmodule::ControlSPC* island) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.island)
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::release_island() {
  
  ::commonmodule::ControlSPC* temp = _impl_.island_;
  _impl_.island_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::unsafe_arena_release_island() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.island)
  
  ::commonmodule::ControlSPC* temp = _impl_.island_;
  _impl_.island_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::_internal_mutable_island() {
  
  if (_impl_.island_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.island_ = p;
  }
  return _impl_.island_;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::mutable_island() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_island();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.island)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_island(::commonmodule::ControlSPC* island) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.island_);
  }
  if (island) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(island));
    if (message_arena != submessage_arena) {
      island = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, island, submessage_arena);
    }

  } else {

  }
  _impl_.island_ = island;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.island)
}

// .google.protobuf.FloatValue pctHzDroop = 4;
inline bool InterconnectionPoint::_internal_has_pcthzdroop() const {
  return this != internal_default_instance() && _impl_.pcthzdroop_ != nullptr;
}
inline bool InterconnectionPoint::has_pcthzdroop() const {
  return _internal_has_pcthzdroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& InterconnectionPoint::_internal_pcthzdroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pcthzdroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& InterconnectionPoint::pcthzdroop() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.pctHzDroop)
  return _internal_pcthzdroop();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_pcthzdroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pcthzdroop_);
  }
  _impl_.pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.pctHzDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::release_pcthzdroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pcthzdroop_;
  _impl_.pcthzdroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::unsafe_arena_release_pcthzdroop() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.pctHzDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pcthzdroop_;
  _impl_.pcthzdroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::_internal_mutable_pcthzdroop() {
  
  if (_impl_.pcthzdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pcthzdroop_ = p;
  }
  return _impl_.pcthzdroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::mutable_pcthzdroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pcthzdroop();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.pctHzDroop)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_pcthzdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pcthzdroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pcthzdroop_);
  }
  if (pcthzdroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcthzdroop));
    if (message_arena != submessage_arena) {
      pcthzdroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pcthzdroop, submessage_arena);
    }

  } else {

  }
  _impl_.pcthzdroop_ = pcthzdroop;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.pctHzDroop)
}

// .google.protobuf.FloatValue pctVDroop = 5;
inline bool InterconnectionPoint::_internal_has_pctvdroop() const {
  return this != internal_default_instance() && _impl_.pctvdroop_ != nullptr;
}
inline bool InterconnectionPoint::has_pctvdroop() const {
  return _internal_has_pctvdroop();
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& InterconnectionPoint::_internal_pctvdroop() const {
  const ::PROTOBUF_NAMESPACE_ID::FloatValue* p = _impl_.pctvdroop_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FloatValue&>(
      ::PROTOBUF_NAMESPACE_ID::_FloatValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FloatValue& InterconnectionPoint::pctvdroop() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.pctVDroop)
  return _internal_pctvdroop();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_pctvdroop(
    ::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pctvdroop_);
  }
  _impl_.pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.pctVDroop)
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::release_pctvdroop() {
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pctvdroop_;
  _impl_.pctvdroop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::unsafe_arena_release_pctvdroop() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.pctVDroop)
  
  ::PROTOBUF_NAMESPACE_ID::FloatValue* temp = _impl_.pctvdroop_;
  _impl_.pctvdroop_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::_internal_mutable_pctvdroop() {
  
  if (_impl_.pctvdroop_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FloatValue>(GetArenaForAllocation());
    _impl_.pctvdroop_ = p;
  }
  return _impl_.pctvdroop_;
}
inline ::PROTOBUF_NAMESPACE_ID::FloatValue* InterconnectionPoint::mutable_pctvdroop() {
  ::PROTOBUF_NAMESPACE_ID::FloatValue* _msg = _internal_mutable_pctvdroop();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.pctVDroop)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_pctvdroop(::PROTOBUF_NAMESPACE_ID::FloatValue* pctvdroop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pctvdroop_);
  }
  if (pctvdroop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pctvdroop));
    if (message_arena != submessage_arena) {
      pctvdroop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pctvdroop, submessage_arena);
    }

  } else {

  }
  _impl_.pctvdroop_ = pctvdroop;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.pctVDroop)
}

// .commonmodule.RampRate rampRates = 6;
inline bool InterconnectionPoint::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool InterconnectionPoint::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& InterconnectionPoint::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& InterconnectionPoint::ramprates() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.rampRates)
  return _internal_ramprates();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.rampRates)
}
inline ::commonmodule::RampRate* InterconnectionPoint::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* InterconnectionPoint::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* InterconnectionPoint::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* InterconnectionPoint::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.rampRates)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.rampRates)
}

// .commonmodule.ControlSPC reactivePwrSetPointEnabled = 7;
inline bool InterconnectionPoint::_internal_has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.reactivepwrsetpointenabled_ != nullptr;
}
inline bool InterconnectionPoint::has_reactivepwrsetpointenabled() const {
  return _internal_has_reactivepwrsetpointenabled();
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::_internal_reactivepwrsetpointenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.reactivepwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::reactivepwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.reactivePwrSetPointEnabled)
  return _internal_reactivepwrsetpointenabled();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_reactivepwrsetpointenabled(
    ::commonmodule::ControlSPC* reactivepwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.reactivePwrSetPointEnabled)
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::release_reactivepwrsetpointenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::unsafe_arena_release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.reactivePwrSetPointEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::_internal_mutable_reactivepwrsetpointenabled() {
  
  if (_impl_.reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.reactivepwrsetpointenabled_ = p;
  }
  return _impl_.reactivepwrsetpointenabled_;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::mutable_reactivepwrsetpointenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_reactivepwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.reactivePwrSetPointEnabled)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlSPC* reactivepwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reactivepwrsetpointenabled));
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.reactivePwrSetPointEnabled)
}

// .commonmodule.ControlSPC realPwrSetPointEnabled = 8;
inline bool InterconnectionPoint::_internal_has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.realpwrsetpointenabled_ != nullptr;
}
inline bool InterconnectionPoint::has_realpwrsetpointenabled() const {
  return _internal_has_realpwrsetpointenabled();
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::_internal_realpwrsetpointenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.realpwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::realpwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.realPwrSetPointEnabled)
  return _internal_realpwrsetpointenabled();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_realpwrsetpointenabled(
    ::commonmodule::ControlSPC* realpwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.realPwrSetPointEnabled)
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::release_realpwrsetpointenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::unsafe_arena_release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.realPwrSetPointEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::_internal_mutable_realpwrsetpointenabled() {
  
  if (_impl_.realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.realpwrsetpointenabled_ = p;
  }
  return _impl_.realpwrsetpointenabled_;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::mutable_realpwrsetpointenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_realpwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.realPwrSetPointEnabled)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_realpwrsetpointenabled(::commonmodule::ControlSPC* realpwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(realpwrsetpointenabled));
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.realPwrSetPointEnabled)
}

// .commonmodule.ControlSPC voltageSetPointEnabled = 9;
inline bool InterconnectionPoint::_internal_has_voltagesetpointenabled() const {
  return this != internal_default_instance() && _impl_.voltagesetpointenabled_ != nullptr;
}
inline bool InterconnectionPoint::has_voltagesetpointenabled() const {
  return _internal_has_voltagesetpointenabled();
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::_internal_voltagesetpointenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.voltagesetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& InterconnectionPoint::voltagesetpointenabled() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.voltageSetPointEnabled)
  return _internal_voltagesetpointenabled();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_voltagesetpointenabled(
    ::commonmodule::ControlSPC* voltagesetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.voltageSetPointEnabled)
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::release_voltagesetpointenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::unsafe_arena_release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.voltageSetPointEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::_internal_mutable_voltagesetpointenabled() {
  
  if (_impl_.voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.voltagesetpointenabled_ = p;
  }
  return _impl_.voltagesetpointenabled_;
}
inline ::commonmodule::ControlSPC* InterconnectionPoint::mutable_voltagesetpointenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_voltagesetpointenabled();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.voltageSetPointEnabled)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_voltagesetpointenabled(::commonmodule::ControlSPC* voltagesetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesetpointenabled));
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.voltageSetPointEnabled)
}

// .commonmodule.Timestamp startTime = 10 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionPoint::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool InterconnectionPoint::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::commonmodule::Timestamp& InterconnectionPoint::_internal_starttime() const {
  const ::commonmodule::Timestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& InterconnectionPoint::starttime() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPoint.startTime)
  return _internal_starttime();
}
inline void InterconnectionPoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::Timestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPoint.startTime)
}
inline ::commonmodule::Timestamp* InterconnectionPoint::release_starttime() {
  
  ::commonmodule::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* InterconnectionPoint::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPoint.startTime)
  
  ::commonmodule::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* InterconnectionPoint::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::commonmodule::Timestamp* InterconnectionPoint::mutable_starttime() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPoint.startTime)
  return _msg;
}
inline void InterconnectionPoint::set_allocated_starttime(::commonmodule::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }

  } else {

  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPoint.startTime)
}

// -------------------------------------------------------------------

// InterconnectionCSG

// repeated .interconnectionmodule.InterconnectionPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int InterconnectionCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int InterconnectionCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void InterconnectionCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::interconnectionmodule::InterconnectionPoint* InterconnectionCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionPoint >*
InterconnectionCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:interconnectionmodule.InterconnectionCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::interconnectionmodule::InterconnectionPoint& InterconnectionCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::interconnectionmodule::InterconnectionPoint& InterconnectionCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::interconnectionmodule::InterconnectionPoint* InterconnectionCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::interconnectionmodule::InterconnectionPoint* InterconnectionCSG::add_crvpts() {
  ::interconnectionmodule::InterconnectionPoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:interconnectionmodule.InterconnectionCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionPoint >&
InterconnectionCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:interconnectionmodule.InterconnectionCSG.crvPts)
  return _impl_.crvpts_;
}

// -------------------------------------------------------------------

// InterconnectionControlScheduleFSCH

// .interconnectionmodule.InterconnectionCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionControlScheduleFSCH::_internal_has_valdcsg() const {
  return this != internal_default_instance() && _impl_.valdcsg_ != nullptr;
}
inline bool InterconnectionControlScheduleFSCH::has_valdcsg() const {
  return _internal_has_valdcsg();
}
inline void InterconnectionControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaForAllocation() == nullptr && _impl_.valdcsg_ != nullptr) {
    delete _impl_.valdcsg_;
  }
  _impl_.valdcsg_ = nullptr;
}
inline const ::interconnectionmodule::InterconnectionCSG& InterconnectionControlScheduleFSCH::_internal_valdcsg() const {
  const ::interconnectionmodule::InterconnectionCSG* p = _impl_.valdcsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::interconnectionmodule::InterconnectionCSG&>(
      ::interconnectionmodule::_InterconnectionCSG_default_instance_);
}
inline const ::interconnectionmodule::InterconnectionCSG& InterconnectionControlScheduleFSCH::valdcsg() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionControlScheduleFSCH.ValDCSG)
  return _internal_valdcsg();
}
inline void InterconnectionControlScheduleFSCH::unsafe_arena_set_allocated_valdcsg(
    ::interconnectionmodule::InterconnectionCSG* valdcsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valdcsg_);
  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionControlScheduleFSCH.ValDCSG)
}
inline ::interconnectionmodule::InterconnectionCSG* InterconnectionControlScheduleFSCH::release_valdcsg() {
  
  ::interconnectionmodule::InterconnectionCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::interconnectionmodule::InterconnectionCSG* InterconnectionControlScheduleFSCH::unsafe_arena_release_valdcsg() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionControlScheduleFSCH.ValDCSG)
  
  ::interconnectionmodule::InterconnectionCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  return temp;
}
inline ::interconnectionmodule::InterconnectionCSG* InterconnectionControlScheduleFSCH::_internal_mutable_valdcsg() {
  
  if (_impl_.valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::interconnectionmodule::InterconnectionCSG>(GetArenaForAllocation());
    _impl_.valdcsg_ = p;
  }
  return _impl_.valdcsg_;
}
inline ::interconnectionmodule::InterconnectionCSG* InterconnectionControlScheduleFSCH::mutable_valdcsg() {
  ::interconnectionmodule::InterconnectionCSG* _msg = _internal_mutable_valdcsg();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionControlScheduleFSCH.ValDCSG)
  return _msg;
}
inline void InterconnectionControlScheduleFSCH::set_allocated_valdcsg(::interconnectionmodule::InterconnectionCSG* valdcsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.valdcsg_;
  }
  if (valdcsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(valdcsg);
    if (message_arena != submessage_arena) {
      valdcsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }

  } else {

  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// InterconnectionScheduleFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool InterconnectionScheduleFSCC::_internal_has_controlfscc() const {
  return this != internal_default_instance() && _impl_.controlfscc_ != nullptr;
}
inline bool InterconnectionScheduleFSCC::has_controlfscc() const {
  return _internal_has_controlfscc();
}
inline const ::commonmodule::ControlFSCC& InterconnectionScheduleFSCC::_internal_controlfscc() const {
  const ::commonmodule::ControlFSCC* p = _impl_.controlfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlFSCC&>(
      ::commonmodule::_ControlFSCC_default_instance_);
}
inline const ::commonmodule::ControlFSCC& InterconnectionScheduleFSCC::controlfscc() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionScheduleFSCC.controlFSCC)
  return _internal_controlfscc();
}
inline void InterconnectionScheduleFSCC::unsafe_arena_set_allocated_controlfscc(
    ::commonmodule::ControlFSCC* controlfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionScheduleFSCC.controlFSCC)
}
inline ::commonmodule::ControlFSCC* InterconnectionScheduleFSCC::release_controlfscc() {
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlFSCC* InterconnectionScheduleFSCC::unsafe_arena_release_controlfscc() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionScheduleFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* InterconnectionScheduleFSCC::_internal_mutable_controlfscc() {
  
  if (_impl_.controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaForAllocation());
    _impl_.controlfscc_ = p;
  }
  return _impl_.controlfscc_;
}
inline ::commonmodule::ControlFSCC* InterconnectionScheduleFSCC::mutable_controlfscc() {
  ::commonmodule::ControlFSCC* _msg = _internal_mutable_controlfscc();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionScheduleFSCC.controlFSCC)
  return _msg;
}
inline void InterconnectionScheduleFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  if (controlfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlfscc));
    if (message_arena != submessage_arena) {
      controlfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }

  } else {

  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionScheduleFSCC.controlFSCC)
}

// repeated .interconnectionmodule.InterconnectionControlScheduleFSCH interconnectionControlScheduleFSCH = 2 [(.uml.option_multiplicity_min) = 0];
inline int InterconnectionScheduleFSCC::_internal_interconnectioncontrolschedulefsch_size() const {
  return _impl_.interconnectioncontrolschedulefsch_.size();
}
inline int InterconnectionScheduleFSCC::interconnectioncontrolschedulefsch_size() const {
  return _internal_interconnectioncontrolschedulefsch_size();
}
inline void InterconnectionScheduleFSCC::clear_interconnectioncontrolschedulefsch() {
  _impl_.interconnectioncontrolschedulefsch_.Clear();
}
inline ::interconnectionmodule::InterconnectionControlScheduleFSCH* InterconnectionScheduleFSCC::mutable_interconnectioncontrolschedulefsch(int index) {
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionScheduleFSCC.interconnectionControlScheduleFSCH)
  return _impl_.interconnectioncontrolschedulefsch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionControlScheduleFSCH >*
InterconnectionScheduleFSCC::mutable_interconnectioncontrolschedulefsch() {
  // @@protoc_insertion_point(field_mutable_list:interconnectionmodule.InterconnectionScheduleFSCC.interconnectionControlScheduleFSCH)
  return &_impl_.interconnectioncontrolschedulefsch_;
}
inline const ::interconnectionmodule::InterconnectionControlScheduleFSCH& InterconnectionScheduleFSCC::_internal_interconnectioncontrolschedulefsch(int index) const {
  return _impl_.interconnectioncontrolschedulefsch_.Get(index);
}
inline const ::interconnectionmodule::InterconnectionControlScheduleFSCH& InterconnectionScheduleFSCC::interconnectioncontrolschedulefsch(int index) const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionScheduleFSCC.interconnectionControlScheduleFSCH)
  return _internal_interconnectioncontrolschedulefsch(index);
}
inline ::interconnectionmodule::InterconnectionControlScheduleFSCH* InterconnectionScheduleFSCC::_internal_add_interconnectioncontrolschedulefsch() {
  return _impl_.interconnectioncontrolschedulefsch_.Add();
}
inline ::interconnectionmodule::InterconnectionControlScheduleFSCH* InterconnectionScheduleFSCC::add_interconnectioncontrolschedulefsch() {
  ::interconnectionmodule::InterconnectionControlScheduleFSCH* _add = _internal_add_interconnectioncontrolschedulefsch();
  // @@protoc_insertion_point(field_add:interconnectionmodule.InterconnectionScheduleFSCC.interconnectionControlScheduleFSCH)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::interconnectionmodule::InterconnectionControlScheduleFSCH >&
InterconnectionScheduleFSCC::interconnectioncontrolschedulefsch() const {
  // @@protoc_insertion_point(field_list:interconnectionmodule.InterconnectionScheduleFSCC.interconnectionControlScheduleFSCH)
  return _impl_.interconnectioncontrolschedulefsch_;
}

// -------------------------------------------------------------------

// InterconnectionSchedule

// .commonmodule.IdentifiedObject identifiedObject = 1 [(.uml.option_parent_message) = true];
inline bool InterconnectionSchedule::_internal_has_identifiedobject() const {
  return this != internal_default_instance() && _impl_.identifiedobject_ != nullptr;
}
inline bool InterconnectionSchedule::has_identifiedobject() const {
  return _internal_has_identifiedobject();
}
inline const ::commonmodule::IdentifiedObject& InterconnectionSchedule::_internal_identifiedobject() const {
  const ::commonmodule::IdentifiedObject* p = _impl_.identifiedobject_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::IdentifiedObject&>(
      ::commonmodule::_IdentifiedObject_default_instance_);
}
inline const ::commonmodule::IdentifiedObject& InterconnectionSchedule::identifiedobject() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionSchedule.identifiedObject)
  return _internal_identifiedobject();
}
inline void InterconnectionSchedule::unsafe_arena_set_allocated_identifiedobject(
    ::commonmodule::IdentifiedObject* identifiedobject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionSchedule.identifiedObject)
}
inline ::commonmodule::IdentifiedObject* InterconnectionSchedule::release_identifiedobject() {
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::IdentifiedObject* InterconnectionSchedule::unsafe_arena_release_identifiedobject() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionSchedule.identifiedObject)
  
  ::commonmodule::IdentifiedObject* temp = _impl_.identifiedobject_;
  _impl_.identifiedobject_ = nullptr;
  return temp;
}
inline ::commonmodule::IdentifiedObject* InterconnectionSchedule::_internal_mutable_identifiedobject() {
  
  if (_impl_.identifiedobject_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::IdentifiedObject>(GetArenaForAllocation());
    _impl_.identifiedobject_ = p;
  }
  return _impl_.identifiedobject_;
}
inline ::commonmodule::IdentifiedObject* InterconnectionSchedule::mutable_identifiedobject() {
  ::commonmodule::IdentifiedObject* _msg = _internal_mutable_identifiedobject();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionSchedule.identifiedObject)
  return _msg;
}
inline void InterconnectionSchedule::set_allocated_identifiedobject(::commonmodule::IdentifiedObject* identifiedobject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifiedobject_);
  }
  if (identifiedobject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifiedobject));
    if (message_arena != submessage_arena) {
      identifiedobject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifiedobject, submessage_arena);
    }

  } else {

  }
  _impl_.identifiedobject_ = identifiedobject;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionSchedule.identifiedObject)
}

// .commonmodule.CheckConditions check = 2;
inline bool InterconnectionSchedule::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool InterconnectionSchedule::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& InterconnectionSchedule::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& InterconnectionSchedule::check() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionSchedule.check)
  return _internal_check();
}
inline void InterconnectionSchedule::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionSchedule.check)
}
inline ::commonmodule::CheckConditions* InterconnectionSchedule::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* InterconnectionSchedule::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionSchedule.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* InterconnectionSchedule::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* InterconnectionSchedule::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionSchedule.check)
  return _msg;
}
inline void InterconnectionSchedule::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionSchedule.check)
}

// .interconnectionmodule.InterconnectionScheduleFSCC interconnectionScheduleFSCC = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionSchedule::_internal_has_interconnectionschedulefscc() const {
  return this != internal_default_instance() && _impl_.interconnectionschedulefscc_ != nullptr;
}
inline bool InterconnectionSchedule::has_interconnectionschedulefscc() const {
  return _internal_has_interconnectionschedulefscc();
}
inline void InterconnectionSchedule::clear_interconnectionschedulefscc() {
  if (GetArenaForAllocation() == nullptr && _impl_.interconnectionschedulefscc_ != nullptr) {
    delete _impl_.interconnectionschedulefscc_;
  }
  _impl_.interconnectionschedulefscc_ = nullptr;
}
inline const ::interconnectionmodule::InterconnectionScheduleFSCC& InterconnectionSchedule::_internal_interconnectionschedulefscc() const {
  const ::interconnectionmodule::InterconnectionScheduleFSCC* p = _impl_.interconnectionschedulefscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::interconnectionmodule::InterconnectionScheduleFSCC&>(
      ::interconnectionmodule::_InterconnectionScheduleFSCC_default_instance_);
}
inline const ::interconnectionmodule::InterconnectionScheduleFSCC& InterconnectionSchedule::interconnectionschedulefscc() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionSchedule.interconnectionScheduleFSCC)
  return _internal_interconnectionschedulefscc();
}
inline void InterconnectionSchedule::unsafe_arena_set_allocated_interconnectionschedulefscc(
    ::interconnectionmodule::InterconnectionScheduleFSCC* interconnectionschedulefscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interconnectionschedulefscc_);
  }
  _impl_.interconnectionschedulefscc_ = interconnectionschedulefscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionSchedule.interconnectionScheduleFSCC)
}
inline ::interconnectionmodule::InterconnectionScheduleFSCC* InterconnectionSchedule::release_interconnectionschedulefscc() {
  
  ::interconnectionmodule::InterconnectionScheduleFSCC* temp = _impl_.interconnectionschedulefscc_;
  _impl_.interconnectionschedulefscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::interconnectionmodule::InterconnectionScheduleFSCC* InterconnectionSchedule::unsafe_arena_release_interconnectionschedulefscc() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionSchedule.interconnectionScheduleFSCC)
  
  ::interconnectionmodule::InterconnectionScheduleFSCC* temp = _impl_.interconnectionschedulefscc_;
  _impl_.interconnectionschedulefscc_ = nullptr;
  return temp;
}
inline ::interconnectionmodule::InterconnectionScheduleFSCC* InterconnectionSchedule::_internal_mutable_interconnectionschedulefscc() {
  
  if (_impl_.interconnectionschedulefscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::interconnectionmodule::InterconnectionScheduleFSCC>(GetArenaForAllocation());
    _impl_.interconnectionschedulefscc_ = p;
  }
  return _impl_.interconnectionschedulefscc_;
}
inline ::interconnectionmodule::InterconnectionScheduleFSCC* InterconnectionSchedule::mutable_interconnectionschedulefscc() {
  ::interconnectionmodule::InterconnectionScheduleFSCC* _msg = _internal_mutable_interconnectionschedulefscc();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionSchedule.interconnectionScheduleFSCC)
  return _msg;
}
inline void InterconnectionSchedule::set_allocated_interconnectionschedulefscc(::interconnectionmodule::InterconnectionScheduleFSCC* interconnectionschedulefscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.interconnectionschedulefscc_;
  }
  if (interconnectionschedulefscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interconnectionschedulefscc);
    if (message_arena != submessage_arena) {
      interconnectionschedulefscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interconnectionschedulefscc, submessage_arena);
    }

  } else {

  }
  _impl_.interconnectionschedulefscc_ = interconnectionschedulefscc;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionSchedule.interconnectionScheduleFSCC)
}

// -------------------------------------------------------------------

// InterconnectionPlannedScheduleProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool InterconnectionPlannedScheduleProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool InterconnectionPlannedScheduleProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& InterconnectionPlannedScheduleProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& InterconnectionPlannedScheduleProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPlannedScheduleProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void InterconnectionPlannedScheduleProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* InterconnectionPlannedScheduleProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* InterconnectionPlannedScheduleProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPlannedScheduleProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* InterconnectionPlannedScheduleProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* InterconnectionPlannedScheduleProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPlannedScheduleProfile.controlMessageInfo)
  return _msg;
}
inline void InterconnectionPlannedScheduleProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.controlMessageInfo)
}

// .commonmodule.ApplicationSystem requesterCircuitSegmentService = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionPlannedScheduleProfile::_internal_has_requestercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.requestercircuitsegmentservice_ != nullptr;
}
inline bool InterconnectionPlannedScheduleProfile::has_requestercircuitsegmentservice() const {
  return _internal_has_requestercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& InterconnectionPlannedScheduleProfile::_internal_requestercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.requestercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& InterconnectionPlannedScheduleProfile::requestercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPlannedScheduleProfile.requesterCircuitSegmentService)
  return _internal_requestercircuitsegmentservice();
}
inline void InterconnectionPlannedScheduleProfile::unsafe_arena_set_allocated_requestercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.requesterCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::release_requestercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::unsafe_arena_release_requestercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPlannedScheduleProfile.requesterCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::_internal_mutable_requestercircuitsegmentservice() {
  
  if (_impl_.requestercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.requestercircuitsegmentservice_ = p;
  }
  return _impl_.requestercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::mutable_requestercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_requestercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPlannedScheduleProfile.requesterCircuitSegmentService)
  return _msg;
}
inline void InterconnectionPlannedScheduleProfile::set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  if (requestercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requestercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      requestercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.requesterCircuitSegmentService)
}

// .interconnectionmodule.InterconnectionSchedule interconnectionSchedule = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionPlannedScheduleProfile::_internal_has_interconnectionschedule() const {
  return this != internal_default_instance() && _impl_.interconnectionschedule_ != nullptr;
}
inline bool InterconnectionPlannedScheduleProfile::has_interconnectionschedule() const {
  return _internal_has_interconnectionschedule();
}
inline void InterconnectionPlannedScheduleProfile::clear_interconnectionschedule() {
  if (GetArenaForAllocation() == nullptr && _impl_.interconnectionschedule_ != nullptr) {
    delete _impl_.interconnectionschedule_;
  }
  _impl_.interconnectionschedule_ = nullptr;
}
inline const ::interconnectionmodule::InterconnectionSchedule& InterconnectionPlannedScheduleProfile::_internal_interconnectionschedule() const {
  const ::interconnectionmodule::InterconnectionSchedule* p = _impl_.interconnectionschedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::interconnectionmodule::InterconnectionSchedule&>(
      ::interconnectionmodule::_InterconnectionSchedule_default_instance_);
}
inline const ::interconnectionmodule::InterconnectionSchedule& InterconnectionPlannedScheduleProfile::interconnectionschedule() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPlannedScheduleProfile.interconnectionSchedule)
  return _internal_interconnectionschedule();
}
inline void InterconnectionPlannedScheduleProfile::unsafe_arena_set_allocated_interconnectionschedule(
    ::interconnectionmodule::InterconnectionSchedule* interconnectionschedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interconnectionschedule_);
  }
  _impl_.interconnectionschedule_ = interconnectionschedule;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.interconnectionSchedule)
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionPlannedScheduleProfile::release_interconnectionschedule() {
  
  ::interconnectionmodule::InterconnectionSchedule* temp = _impl_.interconnectionschedule_;
  _impl_.interconnectionschedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionPlannedScheduleProfile::unsafe_arena_release_interconnectionschedule() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPlannedScheduleProfile.interconnectionSchedule)
  
  ::interconnectionmodule::InterconnectionSchedule* temp = _impl_.interconnectionschedule_;
  _impl_.interconnectionschedule_ = nullptr;
  return temp;
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionPlannedScheduleProfile::_internal_mutable_interconnectionschedule() {
  
  if (_impl_.interconnectionschedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::interconnectionmodule::InterconnectionSchedule>(GetArenaForAllocation());
    _impl_.interconnectionschedule_ = p;
  }
  return _impl_.interconnectionschedule_;
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionPlannedScheduleProfile::mutable_interconnectionschedule() {
  ::interconnectionmodule::InterconnectionSchedule* _msg = _internal_mutable_interconnectionschedule();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPlannedScheduleProfile.interconnectionSchedule)
  return _msg;
}
inline void InterconnectionPlannedScheduleProfile::set_allocated_interconnectionschedule(::interconnectionmodule::InterconnectionSchedule* interconnectionschedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.interconnectionschedule_;
  }
  if (interconnectionschedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interconnectionschedule);
    if (message_arena != submessage_arena) {
      interconnectionschedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interconnectionschedule, submessage_arena);
    }

  } else {

  }
  _impl_.interconnectionschedule_ = interconnectionschedule;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.interconnectionSchedule)
}

// .commonmodule.ConductingEquipment tiePoint = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionPlannedScheduleProfile::_internal_has_tiepoint() const {
  return this != internal_default_instance() && _impl_.tiepoint_ != nullptr;
}
inline bool InterconnectionPlannedScheduleProfile::has_tiepoint() const {
  return _internal_has_tiepoint();
}
inline const ::commonmodule::ConductingEquipment& InterconnectionPlannedScheduleProfile::_internal_tiepoint() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.tiepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& InterconnectionPlannedScheduleProfile::tiepoint() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPlannedScheduleProfile.tiePoint)
  return _internal_tiepoint();
}
inline void InterconnectionPlannedScheduleProfile::unsafe_arena_set_allocated_tiepoint(
    ::commonmodule::ConductingEquipment* tiepoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.tiePoint)
}
inline ::commonmodule::ConductingEquipment* InterconnectionPlannedScheduleProfile::release_tiepoint() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* InterconnectionPlannedScheduleProfile::unsafe_arena_release_tiepoint() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPlannedScheduleProfile.tiePoint)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* InterconnectionPlannedScheduleProfile::_internal_mutable_tiepoint() {
  
  if (_impl_.tiepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.tiepoint_ = p;
  }
  return _impl_.tiepoint_;
}
inline ::commonmodule::ConductingEquipment* InterconnectionPlannedScheduleProfile::mutable_tiepoint() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_tiepoint();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPlannedScheduleProfile.tiePoint)
  return _msg;
}
inline void InterconnectionPlannedScheduleProfile::set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  if (tiepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tiepoint));
    if (message_arena != submessage_arena) {
      tiepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tiepoint, submessage_arena);
    }

  } else {

  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.tiePoint)
}

// .commonmodule.ApplicationSystem responderCircuitSegmentService = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionPlannedScheduleProfile::_internal_has_respondercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.respondercircuitsegmentservice_ != nullptr;
}
inline bool InterconnectionPlannedScheduleProfile::has_respondercircuitsegmentservice() const {
  return _internal_has_respondercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& InterconnectionPlannedScheduleProfile::_internal_respondercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.respondercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& InterconnectionPlannedScheduleProfile::respondercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionPlannedScheduleProfile.responderCircuitSegmentService)
  return _internal_respondercircuitsegmentservice();
}
inline void InterconnectionPlannedScheduleProfile::unsafe_arena_set_allocated_respondercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.responderCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::release_respondercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::unsafe_arena_release_respondercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionPlannedScheduleProfile.responderCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::_internal_mutable_respondercircuitsegmentservice() {
  
  if (_impl_.respondercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.respondercircuitsegmentservice_ = p;
  }
  return _impl_.respondercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* InterconnectionPlannedScheduleProfile::mutable_respondercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_respondercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionPlannedScheduleProfile.responderCircuitSegmentService)
  return _msg;
}
inline void InterconnectionPlannedScheduleProfile::set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  if (respondercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(respondercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      respondercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, respondercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionPlannedScheduleProfile.responderCircuitSegmentService)
}

// -------------------------------------------------------------------

// InterconnectionRequestedScheduleProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool InterconnectionRequestedScheduleProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool InterconnectionRequestedScheduleProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& InterconnectionRequestedScheduleProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& InterconnectionRequestedScheduleProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionRequestedScheduleProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void InterconnectionRequestedScheduleProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* InterconnectionRequestedScheduleProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* InterconnectionRequestedScheduleProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionRequestedScheduleProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* InterconnectionRequestedScheduleProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* InterconnectionRequestedScheduleProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionRequestedScheduleProfile.controlMessageInfo)
  return _msg;
}
inline void InterconnectionRequestedScheduleProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.controlMessageInfo)
}

// .commonmodule.ApplicationSystem requesterCircuitSegmentService = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionRequestedScheduleProfile::_internal_has_requestercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.requestercircuitsegmentservice_ != nullptr;
}
inline bool InterconnectionRequestedScheduleProfile::has_requestercircuitsegmentservice() const {
  return _internal_has_requestercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& InterconnectionRequestedScheduleProfile::_internal_requestercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.requestercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& InterconnectionRequestedScheduleProfile::requestercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionRequestedScheduleProfile.requesterCircuitSegmentService)
  return _internal_requestercircuitsegmentservice();
}
inline void InterconnectionRequestedScheduleProfile::unsafe_arena_set_allocated_requestercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.requesterCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::release_requestercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::unsafe_arena_release_requestercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionRequestedScheduleProfile.requesterCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.requestercircuitsegmentservice_;
  _impl_.requestercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::_internal_mutable_requestercircuitsegmentservice() {
  
  if (_impl_.requestercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.requestercircuitsegmentservice_ = p;
  }
  return _impl_.requestercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::mutable_requestercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_requestercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionRequestedScheduleProfile.requesterCircuitSegmentService)
  return _msg;
}
inline void InterconnectionRequestedScheduleProfile::set_allocated_requestercircuitsegmentservice(::commonmodule::ApplicationSystem* requestercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requestercircuitsegmentservice_);
  }
  if (requestercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requestercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      requestercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requestercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.requestercircuitsegmentservice_ = requestercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.requesterCircuitSegmentService)
}

// .interconnectionmodule.InterconnectionSchedule interconnectionSchedule = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionRequestedScheduleProfile::_internal_has_interconnectionschedule() const {
  return this != internal_default_instance() && _impl_.interconnectionschedule_ != nullptr;
}
inline bool InterconnectionRequestedScheduleProfile::has_interconnectionschedule() const {
  return _internal_has_interconnectionschedule();
}
inline void InterconnectionRequestedScheduleProfile::clear_interconnectionschedule() {
  if (GetArenaForAllocation() == nullptr && _impl_.interconnectionschedule_ != nullptr) {
    delete _impl_.interconnectionschedule_;
  }
  _impl_.interconnectionschedule_ = nullptr;
}
inline const ::interconnectionmodule::InterconnectionSchedule& InterconnectionRequestedScheduleProfile::_internal_interconnectionschedule() const {
  const ::interconnectionmodule::InterconnectionSchedule* p = _impl_.interconnectionschedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::interconnectionmodule::InterconnectionSchedule&>(
      ::interconnectionmodule::_InterconnectionSchedule_default_instance_);
}
inline const ::interconnectionmodule::InterconnectionSchedule& InterconnectionRequestedScheduleProfile::interconnectionschedule() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionRequestedScheduleProfile.interconnectionSchedule)
  return _internal_interconnectionschedule();
}
inline void InterconnectionRequestedScheduleProfile::unsafe_arena_set_allocated_interconnectionschedule(
    ::interconnectionmodule::InterconnectionSchedule* interconnectionschedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interconnectionschedule_);
  }
  _impl_.interconnectionschedule_ = interconnectionschedule;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.interconnectionSchedule)
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionRequestedScheduleProfile::release_interconnectionschedule() {
  
  ::interconnectionmodule::InterconnectionSchedule* temp = _impl_.interconnectionschedule_;
  _impl_.interconnectionschedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionRequestedScheduleProfile::unsafe_arena_release_interconnectionschedule() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionRequestedScheduleProfile.interconnectionSchedule)
  
  ::interconnectionmodule::InterconnectionSchedule* temp = _impl_.interconnectionschedule_;
  _impl_.interconnectionschedule_ = nullptr;
  return temp;
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionRequestedScheduleProfile::_internal_mutable_interconnectionschedule() {
  
  if (_impl_.interconnectionschedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::interconnectionmodule::InterconnectionSchedule>(GetArenaForAllocation());
    _impl_.interconnectionschedule_ = p;
  }
  return _impl_.interconnectionschedule_;
}
inline ::interconnectionmodule::InterconnectionSchedule* InterconnectionRequestedScheduleProfile::mutable_interconnectionschedule() {
  ::interconnectionmodule::InterconnectionSchedule* _msg = _internal_mutable_interconnectionschedule();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionRequestedScheduleProfile.interconnectionSchedule)
  return _msg;
}
inline void InterconnectionRequestedScheduleProfile::set_allocated_interconnectionschedule(::interconnectionmodule::InterconnectionSchedule* interconnectionschedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.interconnectionschedule_;
  }
  if (interconnectionschedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interconnectionschedule);
    if (message_arena != submessage_arena) {
      interconnectionschedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interconnectionschedule, submessage_arena);
    }

  } else {

  }
  _impl_.interconnectionschedule_ = interconnectionschedule;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.interconnectionSchedule)
}

// .commonmodule.ConductingEquipment tiePoint = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionRequestedScheduleProfile::_internal_has_tiepoint() const {
  return this != internal_default_instance() && _impl_.tiepoint_ != nullptr;
}
inline bool InterconnectionRequestedScheduleProfile::has_tiepoint() const {
  return _internal_has_tiepoint();
}
inline const ::commonmodule::ConductingEquipment& InterconnectionRequestedScheduleProfile::_internal_tiepoint() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.tiepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& InterconnectionRequestedScheduleProfile::tiepoint() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionRequestedScheduleProfile.tiePoint)
  return _internal_tiepoint();
}
inline void InterconnectionRequestedScheduleProfile::unsafe_arena_set_allocated_tiepoint(
    ::commonmodule::ConductingEquipment* tiepoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.tiePoint)
}
inline ::commonmodule::ConductingEquipment* InterconnectionRequestedScheduleProfile::release_tiepoint() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* InterconnectionRequestedScheduleProfile::unsafe_arena_release_tiepoint() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionRequestedScheduleProfile.tiePoint)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.tiepoint_;
  _impl_.tiepoint_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* InterconnectionRequestedScheduleProfile::_internal_mutable_tiepoint() {
  
  if (_impl_.tiepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.tiepoint_ = p;
  }
  return _impl_.tiepoint_;
}
inline ::commonmodule::ConductingEquipment* InterconnectionRequestedScheduleProfile::mutable_tiepoint() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_tiepoint();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionRequestedScheduleProfile.tiePoint)
  return _msg;
}
inline void InterconnectionRequestedScheduleProfile::set_allocated_tiepoint(::commonmodule::ConductingEquipment* tiepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiepoint_);
  }
  if (tiepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tiepoint));
    if (message_arena != submessage_arena) {
      tiepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tiepoint, submessage_arena);
    }

  } else {

  }
  _impl_.tiepoint_ = tiepoint;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.tiePoint)
}

// .commonmodule.ApplicationSystem responderCircuitSegmentService = 5 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool InterconnectionRequestedScheduleProfile::_internal_has_respondercircuitsegmentservice() const {
  return this != internal_default_instance() && _impl_.respondercircuitsegmentservice_ != nullptr;
}
inline bool InterconnectionRequestedScheduleProfile::has_respondercircuitsegmentservice() const {
  return _internal_has_respondercircuitsegmentservice();
}
inline const ::commonmodule::ApplicationSystem& InterconnectionRequestedScheduleProfile::_internal_respondercircuitsegmentservice() const {
  const ::commonmodule::ApplicationSystem* p = _impl_.respondercircuitsegmentservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ApplicationSystem&>(
      ::commonmodule::_ApplicationSystem_default_instance_);
}
inline const ::commonmodule::ApplicationSystem& InterconnectionRequestedScheduleProfile::respondercircuitsegmentservice() const {
  // @@protoc_insertion_point(field_get:interconnectionmodule.InterconnectionRequestedScheduleProfile.responderCircuitSegmentService)
  return _internal_respondercircuitsegmentservice();
}
inline void InterconnectionRequestedScheduleProfile::unsafe_arena_set_allocated_respondercircuitsegmentservice(
    ::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.responderCircuitSegmentService)
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::release_respondercircuitsegmentservice() {
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::unsafe_arena_release_respondercircuitsegmentservice() {
  // @@protoc_insertion_point(field_release:interconnectionmodule.InterconnectionRequestedScheduleProfile.responderCircuitSegmentService)
  
  ::commonmodule::ApplicationSystem* temp = _impl_.respondercircuitsegmentservice_;
  _impl_.respondercircuitsegmentservice_ = nullptr;
  return temp;
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::_internal_mutable_respondercircuitsegmentservice() {
  
  if (_impl_.respondercircuitsegmentservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ApplicationSystem>(GetArenaForAllocation());
    _impl_.respondercircuitsegmentservice_ = p;
  }
  return _impl_.respondercircuitsegmentservice_;
}
inline ::commonmodule::ApplicationSystem* InterconnectionRequestedScheduleProfile::mutable_respondercircuitsegmentservice() {
  ::commonmodule::ApplicationSystem* _msg = _internal_mutable_respondercircuitsegmentservice();
  // @@protoc_insertion_point(field_mutable:interconnectionmodule.InterconnectionRequestedScheduleProfile.responderCircuitSegmentService)
  return _msg;
}
inline void InterconnectionRequestedScheduleProfile::set_allocated_respondercircuitsegmentservice(::commonmodule::ApplicationSystem* respondercircuitsegmentservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.respondercircuitsegmentservice_);
  }
  if (respondercircuitsegmentservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(respondercircuitsegmentservice));
    if (message_arena != submessage_arena) {
      respondercircuitsegmentservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, respondercircuitsegmentservice, submessage_arena);
    }

  } else {

  }
  _impl_.respondercircuitsegmentservice_ = respondercircuitsegmentservice;
  // @@protoc_insertion_point(field_set_allocated:interconnectionmodule.InterconnectionRequestedScheduleProfile.responderCircuitSegmentService)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace interconnectionmodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_interconnectionmodule_2finterconnectionmodule_2eproto_2epb_2eh
