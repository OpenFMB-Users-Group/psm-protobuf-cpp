// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loadmodule/loadmodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_loadmodule_2floadmodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_loadmodule_2floadmodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_loadmodule_2floadmodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_loadmodule_2floadmodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_loadmodule_2floadmodule_2eproto;
namespace loadmodule {
class LoadCSG;
struct LoadCSGDefaultTypeInternal;
extern LoadCSGDefaultTypeInternal _LoadCSG_default_instance_;
class LoadControl;
struct LoadControlDefaultTypeInternal;
extern LoadControlDefaultTypeInternal _LoadControl_default_instance_;
class LoadControlFSCC;
struct LoadControlFSCCDefaultTypeInternal;
extern LoadControlFSCCDefaultTypeInternal _LoadControlFSCC_default_instance_;
class LoadControlProfile;
struct LoadControlProfileDefaultTypeInternal;
extern LoadControlProfileDefaultTypeInternal _LoadControlProfile_default_instance_;
class LoadControlScheduleFSCH;
struct LoadControlScheduleFSCHDefaultTypeInternal;
extern LoadControlScheduleFSCHDefaultTypeInternal _LoadControlScheduleFSCH_default_instance_;
class LoadEvent;
struct LoadEventDefaultTypeInternal;
extern LoadEventDefaultTypeInternal _LoadEvent_default_instance_;
class LoadEventAndStatusZGLD;
struct LoadEventAndStatusZGLDDefaultTypeInternal;
extern LoadEventAndStatusZGLDDefaultTypeInternal _LoadEventAndStatusZGLD_default_instance_;
class LoadEventProfile;
struct LoadEventProfileDefaultTypeInternal;
extern LoadEventProfileDefaultTypeInternal _LoadEventProfile_default_instance_;
class LoadEventZGLD;
struct LoadEventZGLDDefaultTypeInternal;
extern LoadEventZGLDDefaultTypeInternal _LoadEventZGLD_default_instance_;
class LoadPoint;
struct LoadPointDefaultTypeInternal;
extern LoadPointDefaultTypeInternal _LoadPoint_default_instance_;
class LoadPointStatus;
struct LoadPointStatusDefaultTypeInternal;
extern LoadPointStatusDefaultTypeInternal _LoadPointStatus_default_instance_;
class LoadReading;
struct LoadReadingDefaultTypeInternal;
extern LoadReadingDefaultTypeInternal _LoadReading_default_instance_;
class LoadReadingProfile;
struct LoadReadingProfileDefaultTypeInternal;
extern LoadReadingProfileDefaultTypeInternal _LoadReadingProfile_default_instance_;
class LoadStatus;
struct LoadStatusDefaultTypeInternal;
extern LoadStatusDefaultTypeInternal _LoadStatus_default_instance_;
class LoadStatusProfile;
struct LoadStatusProfileDefaultTypeInternal;
extern LoadStatusProfileDefaultTypeInternal _LoadStatusProfile_default_instance_;
class LoadStatusZGLD;
struct LoadStatusZGLDDefaultTypeInternal;
extern LoadStatusZGLDDefaultTypeInternal _LoadStatusZGLD_default_instance_;
}  // namespace loadmodule
PROTOBUF_NAMESPACE_OPEN
template <>
::loadmodule::LoadCSG* Arena::CreateMaybeMessage<::loadmodule::LoadCSG>(Arena*);
template <>
::loadmodule::LoadControl* Arena::CreateMaybeMessage<::loadmodule::LoadControl>(Arena*);
template <>
::loadmodule::LoadControlFSCC* Arena::CreateMaybeMessage<::loadmodule::LoadControlFSCC>(Arena*);
template <>
::loadmodule::LoadControlProfile* Arena::CreateMaybeMessage<::loadmodule::LoadControlProfile>(Arena*);
template <>
::loadmodule::LoadControlScheduleFSCH* Arena::CreateMaybeMessage<::loadmodule::LoadControlScheduleFSCH>(Arena*);
template <>
::loadmodule::LoadEvent* Arena::CreateMaybeMessage<::loadmodule::LoadEvent>(Arena*);
template <>
::loadmodule::LoadEventAndStatusZGLD* Arena::CreateMaybeMessage<::loadmodule::LoadEventAndStatusZGLD>(Arena*);
template <>
::loadmodule::LoadEventProfile* Arena::CreateMaybeMessage<::loadmodule::LoadEventProfile>(Arena*);
template <>
::loadmodule::LoadEventZGLD* Arena::CreateMaybeMessage<::loadmodule::LoadEventZGLD>(Arena*);
template <>
::loadmodule::LoadPoint* Arena::CreateMaybeMessage<::loadmodule::LoadPoint>(Arena*);
template <>
::loadmodule::LoadPointStatus* Arena::CreateMaybeMessage<::loadmodule::LoadPointStatus>(Arena*);
template <>
::loadmodule::LoadReading* Arena::CreateMaybeMessage<::loadmodule::LoadReading>(Arena*);
template <>
::loadmodule::LoadReadingProfile* Arena::CreateMaybeMessage<::loadmodule::LoadReadingProfile>(Arena*);
template <>
::loadmodule::LoadStatus* Arena::CreateMaybeMessage<::loadmodule::LoadStatus>(Arena*);
template <>
::loadmodule::LoadStatusProfile* Arena::CreateMaybeMessage<::loadmodule::LoadStatusProfile>(Arena*);
template <>
::loadmodule::LoadStatusZGLD* Arena::CreateMaybeMessage<::loadmodule::LoadStatusZGLD>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace loadmodule {

// ===================================================================


// -------------------------------------------------------------------

class LoadPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadPoint) */ {
 public:
  inline LoadPoint() : LoadPoint(nullptr) {}
  ~LoadPoint() override;
  explicit PROTOBUF_CONSTEXPR LoadPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadPoint(const LoadPoint& from);
  LoadPoint(LoadPoint&& from) noexcept
    : LoadPoint() {
    *this = ::std::move(from);
  }

  inline LoadPoint& operator=(const LoadPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadPoint& operator=(LoadPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadPoint* internal_default_instance() {
    return reinterpret_cast<const LoadPoint*>(
               &_LoadPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoadPoint& a, LoadPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadPoint& from) {
    LoadPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadPoint";
  }
  protected:
  explicit LoadPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRampRatesFieldNumber = 1,
    kReactivePwrSetPointEnabledFieldNumber = 2,
    kRealPwrSetPointEnabledFieldNumber = 3,
    kResetFieldNumber = 4,
    kStateFieldNumber = 5,
    kStartTimeFieldNumber = 6,
  };
  // .commonmodule.RampRate rampRates = 1;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.ControlSPC reactivePwrSetPointEnabled = 2;
  bool has_reactivepwrsetpointenabled() const;
  private:
  bool _internal_has_reactivepwrsetpointenabled() const;

  public:
  void clear_reactivepwrsetpointenabled() ;
  const ::commonmodule::ControlSPC& reactivepwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_reactivepwrsetpointenabled();
  ::commonmodule::ControlSPC* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlSPC* reactivepwrsetpointenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_reactivepwrsetpointenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_reactivepwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_reactivepwrsetpointenabled(
      ::commonmodule::ControlSPC* reactivepwrsetpointenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_reactivepwrsetpointenabled();
  // .commonmodule.ControlSPC realPwrSetPointEnabled = 3;
  bool has_realpwrsetpointenabled() const;
  private:
  bool _internal_has_realpwrsetpointenabled() const;

  public:
  void clear_realpwrsetpointenabled() ;
  const ::commonmodule::ControlSPC& realpwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_realpwrsetpointenabled();
  ::commonmodule::ControlSPC* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::ControlSPC* realpwrsetpointenabled);
  private:
  const ::commonmodule::ControlSPC& _internal_realpwrsetpointenabled() const;
  ::commonmodule::ControlSPC* _internal_mutable_realpwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_realpwrsetpointenabled(
      ::commonmodule::ControlSPC* realpwrsetpointenabled);
  ::commonmodule::ControlSPC* unsafe_arena_release_realpwrsetpointenabled();
  // .commonmodule.ControlSPC reset = 4;
  bool has_reset() const;
  private:
  bool _internal_has_reset() const;

  public:
  void clear_reset() ;
  const ::commonmodule::ControlSPC& reset() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlSPC* release_reset();
  ::commonmodule::ControlSPC* mutable_reset();
  void set_allocated_reset(::commonmodule::ControlSPC* reset);
  private:
  const ::commonmodule::ControlSPC& _internal_reset() const;
  ::commonmodule::ControlSPC* _internal_mutable_reset();
  public:
  void unsafe_arena_set_allocated_reset(
      ::commonmodule::ControlSPC* reset);
  ::commonmodule::ControlSPC* unsafe_arena_release_reset();
  // .commonmodule.Optional_StateKind state = 5;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // .commonmodule.ControlTimestamp startTime = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;

  public:
  void clear_starttime() ;
  const ::commonmodule::ControlTimestamp& starttime() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlTimestamp* release_starttime();
  ::commonmodule::ControlTimestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::ControlTimestamp* starttime);
  private:
  const ::commonmodule::ControlTimestamp& _internal_starttime() const;
  ::commonmodule::ControlTimestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::commonmodule::ControlTimestamp* starttime);
  ::commonmodule::ControlTimestamp* unsafe_arena_release_starttime();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::ControlSPC* reactivepwrsetpointenabled_;
    ::commonmodule::ControlSPC* realpwrsetpointenabled_;
    ::commonmodule::ControlSPC* reset_;
    ::commonmodule::Optional_StateKind* state_;
    ::commonmodule::ControlTimestamp* starttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadCSG) */ {
 public:
  inline LoadCSG() : LoadCSG(nullptr) {}
  ~LoadCSG() override;
  explicit PROTOBUF_CONSTEXPR LoadCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadCSG(const LoadCSG& from);
  LoadCSG(LoadCSG&& from) noexcept
    : LoadCSG() {
    *this = ::std::move(from);
  }

  inline LoadCSG& operator=(const LoadCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadCSG& operator=(LoadCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadCSG* internal_default_instance() {
    return reinterpret_cast<const LoadCSG*>(
               &_LoadCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoadCSG& a, LoadCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadCSG& from) {
    LoadCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadCSG";
  }
  protected:
  explicit LoadCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .loadmodule.LoadPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::loadmodule::LoadPoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loadmodule::LoadPoint >*
      mutable_crvpts();
  private:
  const ::loadmodule::LoadPoint& _internal_crvpts(int index) const;
  ::loadmodule::LoadPoint* _internal_add_crvpts();
  public:
  const ::loadmodule::LoadPoint& crvpts(int index) const;
  ::loadmodule::LoadPoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loadmodule::LoadPoint >&
      crvpts() const;
  // @@protoc_insertion_point(class_scope:loadmodule.LoadCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loadmodule::LoadPoint > crvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadControlScheduleFSCH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadControlScheduleFSCH) */ {
 public:
  inline LoadControlScheduleFSCH() : LoadControlScheduleFSCH(nullptr) {}
  ~LoadControlScheduleFSCH() override;
  explicit PROTOBUF_CONSTEXPR LoadControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadControlScheduleFSCH(const LoadControlScheduleFSCH& from);
  LoadControlScheduleFSCH(LoadControlScheduleFSCH&& from) noexcept
    : LoadControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline LoadControlScheduleFSCH& operator=(const LoadControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadControlScheduleFSCH& operator=(LoadControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadControlScheduleFSCH& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const LoadControlScheduleFSCH*>(
               &_LoadControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoadControlScheduleFSCH& a, LoadControlScheduleFSCH& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadControlScheduleFSCH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadControlScheduleFSCH* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadControlScheduleFSCH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadControlScheduleFSCH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadControlScheduleFSCH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadControlScheduleFSCH& from) {
    LoadControlScheduleFSCH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadControlScheduleFSCH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadControlScheduleFSCH";
  }
  protected:
  explicit LoadControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValDCSGFieldNumber = 1,
  };
  // .loadmodule.LoadCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  private:
  bool _internal_has_valdcsg() const;

  public:
  void clear_valdcsg() ;
  const ::loadmodule::LoadCSG& valdcsg() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadCSG* release_valdcsg();
  ::loadmodule::LoadCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::loadmodule::LoadCSG* valdcsg);
  private:
  const ::loadmodule::LoadCSG& _internal_valdcsg() const;
  ::loadmodule::LoadCSG* _internal_mutable_valdcsg();
  public:
  void unsafe_arena_set_allocated_valdcsg(
      ::loadmodule::LoadCSG* valdcsg);
  ::loadmodule::LoadCSG* unsafe_arena_release_valdcsg();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadControlScheduleFSCH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::loadmodule::LoadCSG* valdcsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadControlFSCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadControlFSCC) */ {
 public:
  inline LoadControlFSCC() : LoadControlFSCC(nullptr) {}
  ~LoadControlFSCC() override;
  explicit PROTOBUF_CONSTEXPR LoadControlFSCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadControlFSCC(const LoadControlFSCC& from);
  LoadControlFSCC(LoadControlFSCC&& from) noexcept
    : LoadControlFSCC() {
    *this = ::std::move(from);
  }

  inline LoadControlFSCC& operator=(const LoadControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadControlFSCC& operator=(LoadControlFSCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadControlFSCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadControlFSCC* internal_default_instance() {
    return reinterpret_cast<const LoadControlFSCC*>(
               &_LoadControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoadControlFSCC& a, LoadControlFSCC& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadControlFSCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadControlFSCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadControlFSCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadControlFSCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadControlFSCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadControlFSCC& from) {
    LoadControlFSCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadControlFSCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadControlFSCC";
  }
  protected:
  explicit LoadControlFSCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFSCCFieldNumber = 1,
    kLoadControlScheduleFSCHFieldNumber = 2,
  };
  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  private:
  bool _internal_has_controlfscc() const;

  public:
  void clear_controlfscc() ;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);
  private:
  const ::commonmodule::ControlFSCC& _internal_controlfscc() const;
  ::commonmodule::ControlFSCC* _internal_mutable_controlfscc();
  public:
  void unsafe_arena_set_allocated_controlfscc(
      ::commonmodule::ControlFSCC* controlfscc);
  ::commonmodule::ControlFSCC* unsafe_arena_release_controlfscc();
  // .loadmodule.LoadControlScheduleFSCH loadControlScheduleFSCH = 2;
  bool has_loadcontrolschedulefsch() const;
  private:
  bool _internal_has_loadcontrolschedulefsch() const;

  public:
  void clear_loadcontrolschedulefsch() ;
  const ::loadmodule::LoadControlScheduleFSCH& loadcontrolschedulefsch() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadControlScheduleFSCH* release_loadcontrolschedulefsch();
  ::loadmodule::LoadControlScheduleFSCH* mutable_loadcontrolschedulefsch();
  void set_allocated_loadcontrolschedulefsch(::loadmodule::LoadControlScheduleFSCH* loadcontrolschedulefsch);
  private:
  const ::loadmodule::LoadControlScheduleFSCH& _internal_loadcontrolschedulefsch() const;
  ::loadmodule::LoadControlScheduleFSCH* _internal_mutable_loadcontrolschedulefsch();
  public:
  void unsafe_arena_set_allocated_loadcontrolschedulefsch(
      ::loadmodule::LoadControlScheduleFSCH* loadcontrolschedulefsch);
  ::loadmodule::LoadControlScheduleFSCH* unsafe_arena_release_loadcontrolschedulefsch();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadControlFSCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlFSCC* controlfscc_;
    ::loadmodule::LoadControlScheduleFSCH* loadcontrolschedulefsch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadControl) */ {
 public:
  inline LoadControl() : LoadControl(nullptr) {}
  ~LoadControl() override;
  explicit PROTOBUF_CONSTEXPR LoadControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadControl(const LoadControl& from);
  LoadControl(LoadControl&& from) noexcept
    : LoadControl() {
    *this = ::std::move(from);
  }

  inline LoadControl& operator=(const LoadControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadControl& operator=(LoadControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadControl* internal_default_instance() {
    return reinterpret_cast<const LoadControl*>(
               &_LoadControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoadControl& a, LoadControl& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadControl& from) {
    LoadControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadControl";
  }
  protected:
  explicit LoadControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kLoadControlFSCCFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .loadmodule.LoadControlFSCC loadControlFSCC = 3;
  bool has_loadcontrolfscc() const;
  private:
  bool _internal_has_loadcontrolfscc() const;

  public:
  void clear_loadcontrolfscc() ;
  const ::loadmodule::LoadControlFSCC& loadcontrolfscc() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadControlFSCC* release_loadcontrolfscc();
  ::loadmodule::LoadControlFSCC* mutable_loadcontrolfscc();
  void set_allocated_loadcontrolfscc(::loadmodule::LoadControlFSCC* loadcontrolfscc);
  private:
  const ::loadmodule::LoadControlFSCC& _internal_loadcontrolfscc() const;
  ::loadmodule::LoadControlFSCC* _internal_mutable_loadcontrolfscc();
  public:
  void unsafe_arena_set_allocated_loadcontrolfscc(
      ::loadmodule::LoadControlFSCC* loadcontrolfscc);
  ::loadmodule::LoadControlFSCC* unsafe_arena_release_loadcontrolfscc();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::loadmodule::LoadControlFSCC* loadcontrolfscc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadControlProfile) */ {
 public:
  inline LoadControlProfile() : LoadControlProfile(nullptr) {}
  ~LoadControlProfile() override;
  explicit PROTOBUF_CONSTEXPR LoadControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadControlProfile(const LoadControlProfile& from);
  LoadControlProfile(LoadControlProfile&& from) noexcept
    : LoadControlProfile() {
    *this = ::std::move(from);
  }

  inline LoadControlProfile& operator=(const LoadControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadControlProfile& operator=(LoadControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadControlProfile* internal_default_instance() {
    return reinterpret_cast<const LoadControlProfile*>(
               &_LoadControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoadControlProfile& a, LoadControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadControlProfile& from) {
    LoadControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadControlProfile";
  }
  protected:
  explicit LoadControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kEnergyConsumerFieldNumber = 2,
    kLoadControlFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_energyconsumer() const;
  private:
  bool _internal_has_energyconsumer() const;

  public:
  void clear_energyconsumer() ;
  const ::commonmodule::EnergyConsumer& energyconsumer() const;
  PROTOBUF_NODISCARD ::commonmodule::EnergyConsumer* release_energyconsumer();
  ::commonmodule::EnergyConsumer* mutable_energyconsumer();
  void set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer);
  private:
  const ::commonmodule::EnergyConsumer& _internal_energyconsumer() const;
  ::commonmodule::EnergyConsumer* _internal_mutable_energyconsumer();
  public:
  void unsafe_arena_set_allocated_energyconsumer(
      ::commonmodule::EnergyConsumer* energyconsumer);
  ::commonmodule::EnergyConsumer* unsafe_arena_release_energyconsumer();
  // .loadmodule.LoadControl loadControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_loadcontrol() const;
  private:
  bool _internal_has_loadcontrol() const;

  public:
  void clear_loadcontrol() ;
  const ::loadmodule::LoadControl& loadcontrol() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadControl* release_loadcontrol();
  ::loadmodule::LoadControl* mutable_loadcontrol();
  void set_allocated_loadcontrol(::loadmodule::LoadControl* loadcontrol);
  private:
  const ::loadmodule::LoadControl& _internal_loadcontrol() const;
  ::loadmodule::LoadControl* _internal_mutable_loadcontrol();
  public:
  void unsafe_arena_set_allocated_loadcontrol(
      ::loadmodule::LoadControl* loadcontrol);
  ::loadmodule::LoadControl* unsafe_arena_release_loadcontrol();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::commonmodule::EnergyConsumer* energyconsumer_;
    ::loadmodule::LoadControl* loadcontrol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadPointStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadPointStatus) */ {
 public:
  inline LoadPointStatus() : LoadPointStatus(nullptr) {}
  ~LoadPointStatus() override;
  explicit PROTOBUF_CONSTEXPR LoadPointStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadPointStatus(const LoadPointStatus& from);
  LoadPointStatus(LoadPointStatus&& from) noexcept
    : LoadPointStatus() {
    *this = ::std::move(from);
  }

  inline LoadPointStatus& operator=(const LoadPointStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadPointStatus& operator=(LoadPointStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadPointStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadPointStatus* internal_default_instance() {
    return reinterpret_cast<const LoadPointStatus*>(
               &_LoadPointStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadPointStatus& a, LoadPointStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadPointStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadPointStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadPointStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadPointStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadPointStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadPointStatus& from) {
    LoadPointStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadPointStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadPointStatus";
  }
  protected:
  explicit LoadPointStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRampRatesFieldNumber = 1,
    kReactivePwrSetPointEnabledFieldNumber = 2,
    kRealPwrSetPointEnabledFieldNumber = 3,
    kResetFieldNumber = 4,
    kStateFieldNumber = 5,
  };
  // .commonmodule.RampRate rampRates = 1;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.StatusSPS reactivePwrSetPointEnabled = 2;
  bool has_reactivepwrsetpointenabled() const;
  private:
  bool _internal_has_reactivepwrsetpointenabled() const;

  public:
  void clear_reactivepwrsetpointenabled() ;
  const ::commonmodule::StatusSPS& reactivepwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_reactivepwrsetpointenabled();
  ::commonmodule::StatusSPS* mutable_reactivepwrsetpointenabled();
  void set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPS* reactivepwrsetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_reactivepwrsetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_reactivepwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_reactivepwrsetpointenabled(
      ::commonmodule::StatusSPS* reactivepwrsetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_reactivepwrsetpointenabled();
  // .commonmodule.StatusSPS realPwrSetPointEnabled = 3;
  bool has_realpwrsetpointenabled() const;
  private:
  bool _internal_has_realpwrsetpointenabled() const;

  public:
  void clear_realpwrsetpointenabled() ;
  const ::commonmodule::StatusSPS& realpwrsetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_realpwrsetpointenabled();
  ::commonmodule::StatusSPS* mutable_realpwrsetpointenabled();
  void set_allocated_realpwrsetpointenabled(::commonmodule::StatusSPS* realpwrsetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_realpwrsetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_realpwrsetpointenabled();
  public:
  void unsafe_arena_set_allocated_realpwrsetpointenabled(
      ::commonmodule::StatusSPS* realpwrsetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_realpwrsetpointenabled();
  // .commonmodule.StatusSPS reset = 4;
  bool has_reset() const;
  private:
  bool _internal_has_reset() const;

  public:
  void clear_reset() ;
  const ::commonmodule::StatusSPS& reset() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_reset();
  ::commonmodule::StatusSPS* mutable_reset();
  void set_allocated_reset(::commonmodule::StatusSPS* reset);
  private:
  const ::commonmodule::StatusSPS& _internal_reset() const;
  ::commonmodule::StatusSPS* _internal_mutable_reset();
  public:
  void unsafe_arena_set_allocated_reset(
      ::commonmodule::StatusSPS* reset);
  ::commonmodule::StatusSPS* unsafe_arena_release_reset();
  // .commonmodule.Optional_StateKind state = 5;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadPointStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::StatusSPS* reactivepwrsetpointenabled_;
    ::commonmodule::StatusSPS* realpwrsetpointenabled_;
    ::commonmodule::StatusSPS* reset_;
    ::commonmodule::Optional_StateKind* state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadEventAndStatusZGLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadEventAndStatusZGLD) */ {
 public:
  inline LoadEventAndStatusZGLD() : LoadEventAndStatusZGLD(nullptr) {}
  ~LoadEventAndStatusZGLD() override;
  explicit PROTOBUF_CONSTEXPR LoadEventAndStatusZGLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadEventAndStatusZGLD(const LoadEventAndStatusZGLD& from);
  LoadEventAndStatusZGLD(LoadEventAndStatusZGLD&& from) noexcept
    : LoadEventAndStatusZGLD() {
    *this = ::std::move(from);
  }

  inline LoadEventAndStatusZGLD& operator=(const LoadEventAndStatusZGLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadEventAndStatusZGLD& operator=(LoadEventAndStatusZGLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadEventAndStatusZGLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadEventAndStatusZGLD* internal_default_instance() {
    return reinterpret_cast<const LoadEventAndStatusZGLD*>(
               &_LoadEventAndStatusZGLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoadEventAndStatusZGLD& a, LoadEventAndStatusZGLD& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadEventAndStatusZGLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadEventAndStatusZGLD* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadEventAndStatusZGLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadEventAndStatusZGLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadEventAndStatusZGLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadEventAndStatusZGLD& from) {
    LoadEventAndStatusZGLD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadEventAndStatusZGLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadEventAndStatusZGLD";
  }
  protected:
  explicit LoadEventAndStatusZGLD(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kDynamicTestFieldNumber = 2,
    kEmgStopFieldNumber = 3,
    kPointStatusFieldNumber = 4,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  private:
  bool _internal_has_dynamictest() const;

  public:
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);
  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* _internal_mutable_dynamictest();
  public:
  void unsafe_arena_set_allocated_dynamictest(
      ::commonmodule::ENS_DynamicTestKind* dynamictest);
  ::commonmodule::ENS_DynamicTestKind* unsafe_arena_release_dynamictest();
  // .commonmodule.StatusSPS EmgStop = 3;
  bool has_emgstop() const;
  private:
  bool _internal_has_emgstop() const;

  public:
  void clear_emgstop() ;
  const ::commonmodule::StatusSPS& emgstop() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_emgstop();
  ::commonmodule::StatusSPS* mutable_emgstop();
  void set_allocated_emgstop(::commonmodule::StatusSPS* emgstop);
  private:
  const ::commonmodule::StatusSPS& _internal_emgstop() const;
  ::commonmodule::StatusSPS* _internal_mutable_emgstop();
  public:
  void unsafe_arena_set_allocated_emgstop(
      ::commonmodule::StatusSPS* emgstop);
  ::commonmodule::StatusSPS* unsafe_arena_release_emgstop();
  // .loadmodule.LoadPointStatus PointStatus = 4;
  bool has_pointstatus() const;
  private:
  bool _internal_has_pointstatus() const;

  public:
  void clear_pointstatus() ;
  const ::loadmodule::LoadPointStatus& pointstatus() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadPointStatus* release_pointstatus();
  ::loadmodule::LoadPointStatus* mutable_pointstatus();
  void set_allocated_pointstatus(::loadmodule::LoadPointStatus* pointstatus);
  private:
  const ::loadmodule::LoadPointStatus& _internal_pointstatus() const;
  ::loadmodule::LoadPointStatus* _internal_mutable_pointstatus();
  public:
  void unsafe_arena_set_allocated_pointstatus(
      ::loadmodule::LoadPointStatus* pointstatus);
  ::loadmodule::LoadPointStatus* unsafe_arena_release_pointstatus();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadEventAndStatusZGLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::ENS_DynamicTestKind* dynamictest_;
    ::commonmodule::StatusSPS* emgstop_;
    ::loadmodule::LoadPointStatus* pointstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadEventZGLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadEventZGLD) */ {
 public:
  inline LoadEventZGLD() : LoadEventZGLD(nullptr) {}
  ~LoadEventZGLD() override;
  explicit PROTOBUF_CONSTEXPR LoadEventZGLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadEventZGLD(const LoadEventZGLD& from);
  LoadEventZGLD(LoadEventZGLD&& from) noexcept
    : LoadEventZGLD() {
    *this = ::std::move(from);
  }

  inline LoadEventZGLD& operator=(const LoadEventZGLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadEventZGLD& operator=(LoadEventZGLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadEventZGLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadEventZGLD* internal_default_instance() {
    return reinterpret_cast<const LoadEventZGLD*>(
               &_LoadEventZGLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoadEventZGLD& a, LoadEventZGLD& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadEventZGLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadEventZGLD* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadEventZGLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadEventZGLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadEventZGLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadEventZGLD& from) {
    LoadEventZGLD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadEventZGLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadEventZGLD";
  }
  protected:
  explicit LoadEventZGLD(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoadEventAndStatusZGLDFieldNumber = 1,
  };
  // .loadmodule.LoadEventAndStatusZGLD loadEventAndStatusZGLD = 1 [(.uml.option_parent_message) = true];
  bool has_loadeventandstatuszgld() const;
  private:
  bool _internal_has_loadeventandstatuszgld() const;

  public:
  void clear_loadeventandstatuszgld() ;
  const ::loadmodule::LoadEventAndStatusZGLD& loadeventandstatuszgld() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadEventAndStatusZGLD* release_loadeventandstatuszgld();
  ::loadmodule::LoadEventAndStatusZGLD* mutable_loadeventandstatuszgld();
  void set_allocated_loadeventandstatuszgld(::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld);
  private:
  const ::loadmodule::LoadEventAndStatusZGLD& _internal_loadeventandstatuszgld() const;
  ::loadmodule::LoadEventAndStatusZGLD* _internal_mutable_loadeventandstatuszgld();
  public:
  void unsafe_arena_set_allocated_loadeventandstatuszgld(
      ::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld);
  ::loadmodule::LoadEventAndStatusZGLD* unsafe_arena_release_loadeventandstatuszgld();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadEventZGLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadEvent) */ {
 public:
  inline LoadEvent() : LoadEvent(nullptr) {}
  ~LoadEvent() override;
  explicit PROTOBUF_CONSTEXPR LoadEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadEvent(const LoadEvent& from);
  LoadEvent(LoadEvent&& from) noexcept
    : LoadEvent() {
    *this = ::std::move(from);
  }

  inline LoadEvent& operator=(const LoadEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadEvent& operator=(LoadEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadEvent* internal_default_instance() {
    return reinterpret_cast<const LoadEvent*>(
               &_LoadEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LoadEvent& a, LoadEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadEvent& from) {
    LoadEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadEvent";
  }
  protected:
  explicit LoadEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventValueFieldNumber = 1,
    kLoadEventZGLDFieldNumber = 2,
  };
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  private:
  bool _internal_has_eventvalue() const;

  public:
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);
  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* _internal_mutable_eventvalue();
  public:
  void unsafe_arena_set_allocated_eventvalue(
      ::commonmodule::EventValue* eventvalue);
  ::commonmodule::EventValue* unsafe_arena_release_eventvalue();
  // .loadmodule.LoadEventZGLD loadEventZGLD = 2;
  bool has_loadeventzgld() const;
  private:
  bool _internal_has_loadeventzgld() const;

  public:
  void clear_loadeventzgld() ;
  const ::loadmodule::LoadEventZGLD& loadeventzgld() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadEventZGLD* release_loadeventzgld();
  ::loadmodule::LoadEventZGLD* mutable_loadeventzgld();
  void set_allocated_loadeventzgld(::loadmodule::LoadEventZGLD* loadeventzgld);
  private:
  const ::loadmodule::LoadEventZGLD& _internal_loadeventzgld() const;
  ::loadmodule::LoadEventZGLD* _internal_mutable_loadeventzgld();
  public:
  void unsafe_arena_set_allocated_loadeventzgld(
      ::loadmodule::LoadEventZGLD* loadeventzgld);
  ::loadmodule::LoadEventZGLD* unsafe_arena_release_loadeventzgld();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventValue* eventvalue_;
    ::loadmodule::LoadEventZGLD* loadeventzgld_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadEventProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadEventProfile) */ {
 public:
  inline LoadEventProfile() : LoadEventProfile(nullptr) {}
  ~LoadEventProfile() override;
  explicit PROTOBUF_CONSTEXPR LoadEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadEventProfile(const LoadEventProfile& from);
  LoadEventProfile(LoadEventProfile&& from) noexcept
    : LoadEventProfile() {
    *this = ::std::move(from);
  }

  inline LoadEventProfile& operator=(const LoadEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadEventProfile& operator=(LoadEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadEventProfile* internal_default_instance() {
    return reinterpret_cast<const LoadEventProfile*>(
               &_LoadEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LoadEventProfile& a, LoadEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadEventProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadEventProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadEventProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadEventProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadEventProfile& from) {
    LoadEventProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadEventProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadEventProfile";
  }
  protected:
  explicit LoadEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kEnergyConsumerFieldNumber = 2,
    kLoadEventFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;

  public:
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();
  // .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_energyconsumer() const;
  private:
  bool _internal_has_energyconsumer() const;

  public:
  void clear_energyconsumer() ;
  const ::commonmodule::EnergyConsumer& energyconsumer() const;
  PROTOBUF_NODISCARD ::commonmodule::EnergyConsumer* release_energyconsumer();
  ::commonmodule::EnergyConsumer* mutable_energyconsumer();
  void set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer);
  private:
  const ::commonmodule::EnergyConsumer& _internal_energyconsumer() const;
  ::commonmodule::EnergyConsumer* _internal_mutable_energyconsumer();
  public:
  void unsafe_arena_set_allocated_energyconsumer(
      ::commonmodule::EnergyConsumer* energyconsumer);
  ::commonmodule::EnergyConsumer* unsafe_arena_release_energyconsumer();
  // .loadmodule.LoadEvent loadEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_loadevent() const;
  private:
  bool _internal_has_loadevent() const;

  public:
  void clear_loadevent() ;
  const ::loadmodule::LoadEvent& loadevent() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadEvent* release_loadevent();
  ::loadmodule::LoadEvent* mutable_loadevent();
  void set_allocated_loadevent(::loadmodule::LoadEvent* loadevent);
  private:
  const ::loadmodule::LoadEvent& _internal_loadevent() const;
  ::loadmodule::LoadEvent* _internal_mutable_loadevent();
  public:
  void unsafe_arena_set_allocated_loadevent(
      ::loadmodule::LoadEvent* loadevent);
  ::loadmodule::LoadEvent* unsafe_arena_release_loadevent();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventMessageInfo* eventmessageinfo_;
    ::commonmodule::EnergyConsumer* energyconsumer_;
    ::loadmodule::LoadEvent* loadevent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadReading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadReading) */ {
 public:
  inline LoadReading() : LoadReading(nullptr) {}
  ~LoadReading() override;
  explicit PROTOBUF_CONSTEXPR LoadReading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadReading(const LoadReading& from);
  LoadReading(LoadReading&& from) noexcept
    : LoadReading() {
    *this = ::std::move(from);
  }

  inline LoadReading& operator=(const LoadReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadReading& operator=(LoadReading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadReading& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadReading* internal_default_instance() {
    return reinterpret_cast<const LoadReading*>(
               &_LoadReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LoadReading& a, LoadReading& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadReading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadReading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadReading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadReading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadReading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadReading& from) {
    LoadReading::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadReading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadReading";
  }
  protected:
  explicit LoadReading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kPhaseMMTNFieldNumber = 2,
    kReadingMMTRFieldNumber = 3,
    kReadingMMXUFieldNumber = 4,
  };
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  private:
  bool _internal_has_conductingequipmentterminalreading() const;

  public:
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* _internal_mutable_conductingequipmentterminalreading();
  public:
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(
      ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  ::commonmodule::ConductingEquipmentTerminalReading* unsafe_arena_release_conductingequipmentterminalreading();
  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  private:
  bool _internal_has_phasemmtn() const;

  public:
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);
  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* _internal_mutable_phasemmtn();
  public:
  void unsafe_arena_set_allocated_phasemmtn(
      ::commonmodule::PhaseMMTN* phasemmtn);
  ::commonmodule::PhaseMMTN* unsafe_arena_release_phasemmtn();
  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  private:
  bool _internal_has_readingmmtr() const;

  public:
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);
  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* _internal_mutable_readingmmtr();
  public:
  void unsafe_arena_set_allocated_readingmmtr(
      ::commonmodule::ReadingMMTR* readingmmtr);
  ::commonmodule::ReadingMMTR* unsafe_arena_release_readingmmtr();
  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  private:
  bool _internal_has_readingmmxu() const;

  public:
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_readingmmxu();
  public:
  void unsafe_arena_set_allocated_readingmmxu(
      ::commonmodule::ReadingMMXU* readingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_readingmmxu();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadReading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
    ::commonmodule::PhaseMMTN* phasemmtn_;
    ::commonmodule::ReadingMMTR* readingmmtr_;
    ::commonmodule::ReadingMMXU* readingmmxu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadReadingProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadReadingProfile) */ {
 public:
  inline LoadReadingProfile() : LoadReadingProfile(nullptr) {}
  ~LoadReadingProfile() override;
  explicit PROTOBUF_CONSTEXPR LoadReadingProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadReadingProfile(const LoadReadingProfile& from);
  LoadReadingProfile(LoadReadingProfile&& from) noexcept
    : LoadReadingProfile() {
    *this = ::std::move(from);
  }

  inline LoadReadingProfile& operator=(const LoadReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadReadingProfile& operator=(LoadReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadReadingProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadReadingProfile* internal_default_instance() {
    return reinterpret_cast<const LoadReadingProfile*>(
               &_LoadReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LoadReadingProfile& a, LoadReadingProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadReadingProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadReadingProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadReadingProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadReadingProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadReadingProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadReadingProfile& from) {
    LoadReadingProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadReadingProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadReadingProfile";
  }
  protected:
  explicit LoadReadingProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadingMessageInfoFieldNumber = 1,
    kEnergyConsumerFieldNumber = 2,
    kLoadReadingFieldNumber = 3,
  };
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  private:
  bool _internal_has_readingmessageinfo() const;

  public:
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);
  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* _internal_mutable_readingmessageinfo();
  public:
  void unsafe_arena_set_allocated_readingmessageinfo(
      ::commonmodule::ReadingMessageInfo* readingmessageinfo);
  ::commonmodule::ReadingMessageInfo* unsafe_arena_release_readingmessageinfo();
  // .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_energyconsumer() const;
  private:
  bool _internal_has_energyconsumer() const;

  public:
  void clear_energyconsumer() ;
  const ::commonmodule::EnergyConsumer& energyconsumer() const;
  PROTOBUF_NODISCARD ::commonmodule::EnergyConsumer* release_energyconsumer();
  ::commonmodule::EnergyConsumer* mutable_energyconsumer();
  void set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer);
  private:
  const ::commonmodule::EnergyConsumer& _internal_energyconsumer() const;
  ::commonmodule::EnergyConsumer* _internal_mutable_energyconsumer();
  public:
  void unsafe_arena_set_allocated_energyconsumer(
      ::commonmodule::EnergyConsumer* energyconsumer);
  ::commonmodule::EnergyConsumer* unsafe_arena_release_energyconsumer();
  // .loadmodule.LoadReading loadReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_loadreading() const;
  private:
  bool _internal_has_loadreading() const;

  public:
  void clear_loadreading() ;
  const ::loadmodule::LoadReading& loadreading() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadReading* release_loadreading();
  ::loadmodule::LoadReading* mutable_loadreading();
  void set_allocated_loadreading(::loadmodule::LoadReading* loadreading);
  private:
  const ::loadmodule::LoadReading& _internal_loadreading() const;
  ::loadmodule::LoadReading* _internal_mutable_loadreading();
  public:
  void unsafe_arena_set_allocated_loadreading(
      ::loadmodule::LoadReading* loadreading);
  ::loadmodule::LoadReading* unsafe_arena_release_loadreading();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadReadingProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
    ::commonmodule::EnergyConsumer* energyconsumer_;
    ::loadmodule::LoadReading* loadreading_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadStatusZGLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadStatusZGLD) */ {
 public:
  inline LoadStatusZGLD() : LoadStatusZGLD(nullptr) {}
  ~LoadStatusZGLD() override;
  explicit PROTOBUF_CONSTEXPR LoadStatusZGLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadStatusZGLD(const LoadStatusZGLD& from);
  LoadStatusZGLD(LoadStatusZGLD&& from) noexcept
    : LoadStatusZGLD() {
    *this = ::std::move(from);
  }

  inline LoadStatusZGLD& operator=(const LoadStatusZGLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadStatusZGLD& operator=(LoadStatusZGLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadStatusZGLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadStatusZGLD* internal_default_instance() {
    return reinterpret_cast<const LoadStatusZGLD*>(
               &_LoadStatusZGLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LoadStatusZGLD& a, LoadStatusZGLD& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadStatusZGLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadStatusZGLD* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadStatusZGLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadStatusZGLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadStatusZGLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadStatusZGLD& from) {
    LoadStatusZGLD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStatusZGLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadStatusZGLD";
  }
  protected:
  explicit LoadStatusZGLD(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoadEventAndStatusZGLDFieldNumber = 1,
  };
  // .loadmodule.LoadEventAndStatusZGLD loadEventAndStatusZGLD = 1 [(.uml.option_parent_message) = true];
  bool has_loadeventandstatuszgld() const;
  private:
  bool _internal_has_loadeventandstatuszgld() const;

  public:
  void clear_loadeventandstatuszgld() ;
  const ::loadmodule::LoadEventAndStatusZGLD& loadeventandstatuszgld() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadEventAndStatusZGLD* release_loadeventandstatuszgld();
  ::loadmodule::LoadEventAndStatusZGLD* mutable_loadeventandstatuszgld();
  void set_allocated_loadeventandstatuszgld(::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld);
  private:
  const ::loadmodule::LoadEventAndStatusZGLD& _internal_loadeventandstatuszgld() const;
  ::loadmodule::LoadEventAndStatusZGLD* _internal_mutable_loadeventandstatuszgld();
  public:
  void unsafe_arena_set_allocated_loadeventandstatuszgld(
      ::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld);
  ::loadmodule::LoadEventAndStatusZGLD* unsafe_arena_release_loadeventandstatuszgld();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadStatusZGLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadStatus) */ {
 public:
  inline LoadStatus() : LoadStatus(nullptr) {}
  ~LoadStatus() override;
  explicit PROTOBUF_CONSTEXPR LoadStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadStatus(const LoadStatus& from);
  LoadStatus(LoadStatus&& from) noexcept
    : LoadStatus() {
    *this = ::std::move(from);
  }

  inline LoadStatus& operator=(const LoadStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadStatus& operator=(LoadStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadStatus* internal_default_instance() {
    return reinterpret_cast<const LoadStatus*>(
               &_LoadStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LoadStatus& a, LoadStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadStatus& from) {
    LoadStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadStatus";
  }
  protected:
  explicit LoadStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusValueFieldNumber = 1,
    kIsUncontrollableFieldNumber = 2,
    kLoadStatusZGLDFieldNumber = 3,
  };
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  private:
  bool _internal_has_statusvalue() const;

  public:
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);
  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* _internal_mutable_statusvalue();
  public:
  void unsafe_arena_set_allocated_statusvalue(
      ::commonmodule::StatusValue* statusvalue);
  ::commonmodule::StatusValue* unsafe_arena_release_statusvalue();
  // .google.protobuf.BoolValue isUncontrollable = 2;
  bool has_isuncontrollable() const;
  private:
  bool _internal_has_isuncontrollable() const;

  public:
  void clear_isuncontrollable() ;
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& isuncontrollable() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_isuncontrollable();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_isuncontrollable();
  void set_allocated_isuncontrollable(::PROTOBUF_NAMESPACE_ID::BoolValue* isuncontrollable);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_isuncontrollable() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_isuncontrollable();
  public:
  void unsafe_arena_set_allocated_isuncontrollable(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* isuncontrollable);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_isuncontrollable();
  // .loadmodule.LoadStatusZGLD loadStatusZGLD = 3;
  bool has_loadstatuszgld() const;
  private:
  bool _internal_has_loadstatuszgld() const;

  public:
  void clear_loadstatuszgld() ;
  const ::loadmodule::LoadStatusZGLD& loadstatuszgld() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadStatusZGLD* release_loadstatuszgld();
  ::loadmodule::LoadStatusZGLD* mutable_loadstatuszgld();
  void set_allocated_loadstatuszgld(::loadmodule::LoadStatusZGLD* loadstatuszgld);
  private:
  const ::loadmodule::LoadStatusZGLD& _internal_loadstatuszgld() const;
  ::loadmodule::LoadStatusZGLD* _internal_mutable_loadstatuszgld();
  public:
  void unsafe_arena_set_allocated_loadstatuszgld(
      ::loadmodule::LoadStatusZGLD* loadstatuszgld);
  ::loadmodule::LoadStatusZGLD* unsafe_arena_release_loadstatuszgld();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusValue* statusvalue_;
    ::PROTOBUF_NAMESPACE_ID::BoolValue* isuncontrollable_;
    ::loadmodule::LoadStatusZGLD* loadstatuszgld_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};// -------------------------------------------------------------------

class LoadStatusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loadmodule.LoadStatusProfile) */ {
 public:
  inline LoadStatusProfile() : LoadStatusProfile(nullptr) {}
  ~LoadStatusProfile() override;
  explicit PROTOBUF_CONSTEXPR LoadStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadStatusProfile(const LoadStatusProfile& from);
  LoadStatusProfile(LoadStatusProfile&& from) noexcept
    : LoadStatusProfile() {
    *this = ::std::move(from);
  }

  inline LoadStatusProfile& operator=(const LoadStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadStatusProfile& operator=(LoadStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadStatusProfile* internal_default_instance() {
    return reinterpret_cast<const LoadStatusProfile*>(
               &_LoadStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LoadStatusProfile& a, LoadStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadStatusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadStatusProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadStatusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadStatusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadStatusProfile& from) {
    LoadStatusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStatusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "loadmodule.LoadStatusProfile";
  }
  protected:
  explicit LoadStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kEnergyConsumerFieldNumber = 2,
    kLoadStatusFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  private:
  bool _internal_has_statusmessageinfo() const;

  public:
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);
  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* _internal_mutable_statusmessageinfo();
  public:
  void unsafe_arena_set_allocated_statusmessageinfo(
      ::commonmodule::StatusMessageInfo* statusmessageinfo);
  ::commonmodule::StatusMessageInfo* unsafe_arena_release_statusmessageinfo();
  // .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_energyconsumer() const;
  private:
  bool _internal_has_energyconsumer() const;

  public:
  void clear_energyconsumer() ;
  const ::commonmodule::EnergyConsumer& energyconsumer() const;
  PROTOBUF_NODISCARD ::commonmodule::EnergyConsumer* release_energyconsumer();
  ::commonmodule::EnergyConsumer* mutable_energyconsumer();
  void set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer);
  private:
  const ::commonmodule::EnergyConsumer& _internal_energyconsumer() const;
  ::commonmodule::EnergyConsumer* _internal_mutable_energyconsumer();
  public:
  void unsafe_arena_set_allocated_energyconsumer(
      ::commonmodule::EnergyConsumer* energyconsumer);
  ::commonmodule::EnergyConsumer* unsafe_arena_release_energyconsumer();
  // .loadmodule.LoadStatus loadStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_loadstatus() const;
  private:
  bool _internal_has_loadstatus() const;

  public:
  void clear_loadstatus() ;
  const ::loadmodule::LoadStatus& loadstatus() const;
  PROTOBUF_NODISCARD ::loadmodule::LoadStatus* release_loadstatus();
  ::loadmodule::LoadStatus* mutable_loadstatus();
  void set_allocated_loadstatus(::loadmodule::LoadStatus* loadstatus);
  private:
  const ::loadmodule::LoadStatus& _internal_loadstatus() const;
  ::loadmodule::LoadStatus* _internal_mutable_loadstatus();
  public:
  void unsafe_arena_set_allocated_loadstatus(
      ::loadmodule::LoadStatus* loadstatus);
  ::loadmodule::LoadStatus* unsafe_arena_release_loadstatus();
  // @@protoc_insertion_point(class_scope:loadmodule.LoadStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusMessageInfo* statusmessageinfo_;
    ::commonmodule::EnergyConsumer* energyconsumer_;
    ::loadmodule::LoadStatus* loadstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_loadmodule_2floadmodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// LoadPoint

// .commonmodule.RampRate rampRates = 1;
inline bool LoadPoint::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool LoadPoint::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& LoadPoint::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& LoadPoint::ramprates() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPoint.rampRates)
  return _internal_ramprates();
}
inline void LoadPoint::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPoint.rampRates)
}
inline ::commonmodule::RampRate* LoadPoint::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* LoadPoint::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPoint.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* LoadPoint::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* LoadPoint::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPoint.rampRates)
  return _msg;
}
inline void LoadPoint::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPoint.rampRates)
}

// .commonmodule.ControlSPC reactivePwrSetPointEnabled = 2;
inline bool LoadPoint::_internal_has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.reactivepwrsetpointenabled_ != nullptr;
}
inline bool LoadPoint::has_reactivepwrsetpointenabled() const {
  return _internal_has_reactivepwrsetpointenabled();
}
inline const ::commonmodule::ControlSPC& LoadPoint::_internal_reactivepwrsetpointenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.reactivepwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& LoadPoint::reactivepwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPoint.reactivePwrSetPointEnabled)
  return _internal_reactivepwrsetpointenabled();
}
inline void LoadPoint::unsafe_arena_set_allocated_reactivepwrsetpointenabled(
    ::commonmodule::ControlSPC* reactivepwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPoint.reactivePwrSetPointEnabled)
}
inline ::commonmodule::ControlSPC* LoadPoint::release_reactivepwrsetpointenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* LoadPoint::unsafe_arena_release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPoint.reactivePwrSetPointEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* LoadPoint::_internal_mutable_reactivepwrsetpointenabled() {
  
  if (_impl_.reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.reactivepwrsetpointenabled_ = p;
  }
  return _impl_.reactivepwrsetpointenabled_;
}
inline ::commonmodule::ControlSPC* LoadPoint::mutable_reactivepwrsetpointenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_reactivepwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPoint.reactivePwrSetPointEnabled)
  return _msg;
}
inline void LoadPoint::set_allocated_reactivepwrsetpointenabled(::commonmodule::ControlSPC* reactivepwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reactivepwrsetpointenabled));
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPoint.reactivePwrSetPointEnabled)
}

// .commonmodule.ControlSPC realPwrSetPointEnabled = 3;
inline bool LoadPoint::_internal_has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.realpwrsetpointenabled_ != nullptr;
}
inline bool LoadPoint::has_realpwrsetpointenabled() const {
  return _internal_has_realpwrsetpointenabled();
}
inline const ::commonmodule::ControlSPC& LoadPoint::_internal_realpwrsetpointenabled() const {
  const ::commonmodule::ControlSPC* p = _impl_.realpwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& LoadPoint::realpwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPoint.realPwrSetPointEnabled)
  return _internal_realpwrsetpointenabled();
}
inline void LoadPoint::unsafe_arena_set_allocated_realpwrsetpointenabled(
    ::commonmodule::ControlSPC* realpwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPoint.realPwrSetPointEnabled)
}
inline ::commonmodule::ControlSPC* LoadPoint::release_realpwrsetpointenabled() {
  
  ::commonmodule::ControlSPC* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* LoadPoint::unsafe_arena_release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPoint.realPwrSetPointEnabled)
  
  ::commonmodule::ControlSPC* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* LoadPoint::_internal_mutable_realpwrsetpointenabled() {
  
  if (_impl_.realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.realpwrsetpointenabled_ = p;
  }
  return _impl_.realpwrsetpointenabled_;
}
inline ::commonmodule::ControlSPC* LoadPoint::mutable_realpwrsetpointenabled() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_realpwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPoint.realPwrSetPointEnabled)
  return _msg;
}
inline void LoadPoint::set_allocated_realpwrsetpointenabled(::commonmodule::ControlSPC* realpwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(realpwrsetpointenabled));
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPoint.realPwrSetPointEnabled)
}

// .commonmodule.ControlSPC reset = 4;
inline bool LoadPoint::_internal_has_reset() const {
  return this != internal_default_instance() && _impl_.reset_ != nullptr;
}
inline bool LoadPoint::has_reset() const {
  return _internal_has_reset();
}
inline const ::commonmodule::ControlSPC& LoadPoint::_internal_reset() const {
  const ::commonmodule::ControlSPC* p = _impl_.reset_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlSPC&>(
      ::commonmodule::_ControlSPC_default_instance_);
}
inline const ::commonmodule::ControlSPC& LoadPoint::reset() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPoint.reset)
  return _internal_reset();
}
inline void LoadPoint::unsafe_arena_set_allocated_reset(
    ::commonmodule::ControlSPC* reset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPoint.reset)
}
inline ::commonmodule::ControlSPC* LoadPoint::release_reset() {
  
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlSPC* LoadPoint::unsafe_arena_release_reset() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPoint.reset)
  
  ::commonmodule::ControlSPC* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlSPC* LoadPoint::_internal_mutable_reset() {
  
  if (_impl_.reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlSPC>(GetArenaForAllocation());
    _impl_.reset_ = p;
  }
  return _impl_.reset_;
}
inline ::commonmodule::ControlSPC* LoadPoint::mutable_reset() {
  ::commonmodule::ControlSPC* _msg = _internal_mutable_reset();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPoint.reset)
  return _msg;
}
inline void LoadPoint::set_allocated_reset(::commonmodule::ControlSPC* reset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  if (reset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reset));
    if (message_arena != submessage_arena) {
      reset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }

  } else {

  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPoint.reset)
}

// .commonmodule.Optional_StateKind state = 5;
inline bool LoadPoint::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool LoadPoint::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& LoadPoint::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& LoadPoint::state() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPoint.state)
  return _internal_state();
}
inline void LoadPoint::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPoint.state)
}
inline ::commonmodule::Optional_StateKind* LoadPoint::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* LoadPoint::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPoint.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* LoadPoint::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* LoadPoint::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPoint.state)
  return _msg;
}
inline void LoadPoint::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPoint.state)
}

// .commonmodule.ControlTimestamp startTime = 6 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadPoint::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool LoadPoint::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::commonmodule::ControlTimestamp& LoadPoint::_internal_starttime() const {
  const ::commonmodule::ControlTimestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlTimestamp&>(
      ::commonmodule::_ControlTimestamp_default_instance_);
}
inline const ::commonmodule::ControlTimestamp& LoadPoint::starttime() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPoint.startTime)
  return _internal_starttime();
}
inline void LoadPoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::ControlTimestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPoint.startTime)
}
inline ::commonmodule::ControlTimestamp* LoadPoint::release_starttime() {
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlTimestamp* LoadPoint::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPoint.startTime)
  
  ::commonmodule::ControlTimestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlTimestamp* LoadPoint::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlTimestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::commonmodule::ControlTimestamp* LoadPoint::mutable_starttime() {
  ::commonmodule::ControlTimestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPoint.startTime)
  return _msg;
}
inline void LoadPoint::set_allocated_starttime(::commonmodule::ControlTimestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }

  } else {

  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPoint.startTime)
}

// -------------------------------------------------------------------

// LoadCSG

// repeated .loadmodule.LoadPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int LoadCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int LoadCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void LoadCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::loadmodule::LoadPoint* LoadCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loadmodule::LoadPoint >*
LoadCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:loadmodule.LoadCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::loadmodule::LoadPoint& LoadCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::loadmodule::LoadPoint& LoadCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::loadmodule::LoadPoint* LoadCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::loadmodule::LoadPoint* LoadCSG::add_crvpts() {
  ::loadmodule::LoadPoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:loadmodule.LoadCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loadmodule::LoadPoint >&
LoadCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:loadmodule.LoadCSG.crvPts)
  return _impl_.crvpts_;
}

// -------------------------------------------------------------------

// LoadControlScheduleFSCH

// .loadmodule.LoadCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadControlScheduleFSCH::_internal_has_valdcsg() const {
  return this != internal_default_instance() && _impl_.valdcsg_ != nullptr;
}
inline bool LoadControlScheduleFSCH::has_valdcsg() const {
  return _internal_has_valdcsg();
}
inline void LoadControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaForAllocation() == nullptr && _impl_.valdcsg_ != nullptr) {
    delete _impl_.valdcsg_;
  }
  _impl_.valdcsg_ = nullptr;
}
inline const ::loadmodule::LoadCSG& LoadControlScheduleFSCH::_internal_valdcsg() const {
  const ::loadmodule::LoadCSG* p = _impl_.valdcsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadCSG&>(
      ::loadmodule::_LoadCSG_default_instance_);
}
inline const ::loadmodule::LoadCSG& LoadControlScheduleFSCH::valdcsg() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControlScheduleFSCH.ValDCSG)
  return _internal_valdcsg();
}
inline void LoadControlScheduleFSCH::unsafe_arena_set_allocated_valdcsg(
    ::loadmodule::LoadCSG* valdcsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valdcsg_);
  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControlScheduleFSCH.ValDCSG)
}
inline ::loadmodule::LoadCSG* LoadControlScheduleFSCH::release_valdcsg() {
  
  ::loadmodule::LoadCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadCSG* LoadControlScheduleFSCH::unsafe_arena_release_valdcsg() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControlScheduleFSCH.ValDCSG)
  
  ::loadmodule::LoadCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadCSG* LoadControlScheduleFSCH::_internal_mutable_valdcsg() {
  
  if (_impl_.valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadCSG>(GetArenaForAllocation());
    _impl_.valdcsg_ = p;
  }
  return _impl_.valdcsg_;
}
inline ::loadmodule::LoadCSG* LoadControlScheduleFSCH::mutable_valdcsg() {
  ::loadmodule::LoadCSG* _msg = _internal_mutable_valdcsg();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControlScheduleFSCH.ValDCSG)
  return _msg;
}
inline void LoadControlScheduleFSCH::set_allocated_valdcsg(::loadmodule::LoadCSG* valdcsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.valdcsg_;
  }
  if (valdcsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(valdcsg);
    if (message_arena != submessage_arena) {
      valdcsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }

  } else {

  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// LoadControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool LoadControlFSCC::_internal_has_controlfscc() const {
  return this != internal_default_instance() && _impl_.controlfscc_ != nullptr;
}
inline bool LoadControlFSCC::has_controlfscc() const {
  return _internal_has_controlfscc();
}
inline const ::commonmodule::ControlFSCC& LoadControlFSCC::_internal_controlfscc() const {
  const ::commonmodule::ControlFSCC* p = _impl_.controlfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlFSCC&>(
      ::commonmodule::_ControlFSCC_default_instance_);
}
inline const ::commonmodule::ControlFSCC& LoadControlFSCC::controlfscc() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControlFSCC.controlFSCC)
  return _internal_controlfscc();
}
inline void LoadControlFSCC::unsafe_arena_set_allocated_controlfscc(
    ::commonmodule::ControlFSCC* controlfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControlFSCC.controlFSCC)
}
inline ::commonmodule::ControlFSCC* LoadControlFSCC::release_controlfscc() {
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlFSCC* LoadControlFSCC::unsafe_arena_release_controlfscc() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControlFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* LoadControlFSCC::_internal_mutable_controlfscc() {
  
  if (_impl_.controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaForAllocation());
    _impl_.controlfscc_ = p;
  }
  return _impl_.controlfscc_;
}
inline ::commonmodule::ControlFSCC* LoadControlFSCC::mutable_controlfscc() {
  ::commonmodule::ControlFSCC* _msg = _internal_mutable_controlfscc();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControlFSCC.controlFSCC)
  return _msg;
}
inline void LoadControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  if (controlfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlfscc));
    if (message_arena != submessage_arena) {
      controlfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }

  } else {

  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControlFSCC.controlFSCC)
}

// .loadmodule.LoadControlScheduleFSCH loadControlScheduleFSCH = 2;
inline bool LoadControlFSCC::_internal_has_loadcontrolschedulefsch() const {
  return this != internal_default_instance() && _impl_.loadcontrolschedulefsch_ != nullptr;
}
inline bool LoadControlFSCC::has_loadcontrolschedulefsch() const {
  return _internal_has_loadcontrolschedulefsch();
}
inline void LoadControlFSCC::clear_loadcontrolschedulefsch() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadcontrolschedulefsch_ != nullptr) {
    delete _impl_.loadcontrolschedulefsch_;
  }
  _impl_.loadcontrolschedulefsch_ = nullptr;
}
inline const ::loadmodule::LoadControlScheduleFSCH& LoadControlFSCC::_internal_loadcontrolschedulefsch() const {
  const ::loadmodule::LoadControlScheduleFSCH* p = _impl_.loadcontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadControlScheduleFSCH&>(
      ::loadmodule::_LoadControlScheduleFSCH_default_instance_);
}
inline const ::loadmodule::LoadControlScheduleFSCH& LoadControlFSCC::loadcontrolschedulefsch() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControlFSCC.loadControlScheduleFSCH)
  return _internal_loadcontrolschedulefsch();
}
inline void LoadControlFSCC::unsafe_arena_set_allocated_loadcontrolschedulefsch(
    ::loadmodule::LoadControlScheduleFSCH* loadcontrolschedulefsch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadcontrolschedulefsch_);
  }
  _impl_.loadcontrolschedulefsch_ = loadcontrolschedulefsch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControlFSCC.loadControlScheduleFSCH)
}
inline ::loadmodule::LoadControlScheduleFSCH* LoadControlFSCC::release_loadcontrolschedulefsch() {
  
  ::loadmodule::LoadControlScheduleFSCH* temp = _impl_.loadcontrolschedulefsch_;
  _impl_.loadcontrolschedulefsch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadControlScheduleFSCH* LoadControlFSCC::unsafe_arena_release_loadcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControlFSCC.loadControlScheduleFSCH)
  
  ::loadmodule::LoadControlScheduleFSCH* temp = _impl_.loadcontrolschedulefsch_;
  _impl_.loadcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadControlScheduleFSCH* LoadControlFSCC::_internal_mutable_loadcontrolschedulefsch() {
  
  if (_impl_.loadcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadControlScheduleFSCH>(GetArenaForAllocation());
    _impl_.loadcontrolschedulefsch_ = p;
  }
  return _impl_.loadcontrolschedulefsch_;
}
inline ::loadmodule::LoadControlScheduleFSCH* LoadControlFSCC::mutable_loadcontrolschedulefsch() {
  ::loadmodule::LoadControlScheduleFSCH* _msg = _internal_mutable_loadcontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControlFSCC.loadControlScheduleFSCH)
  return _msg;
}
inline void LoadControlFSCC::set_allocated_loadcontrolschedulefsch(::loadmodule::LoadControlScheduleFSCH* loadcontrolschedulefsch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadcontrolschedulefsch_;
  }
  if (loadcontrolschedulefsch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadcontrolschedulefsch);
    if (message_arena != submessage_arena) {
      loadcontrolschedulefsch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadcontrolschedulefsch, submessage_arena);
    }

  } else {

  }
  _impl_.loadcontrolschedulefsch_ = loadcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControlFSCC.loadControlScheduleFSCH)
}

// -------------------------------------------------------------------

// LoadControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool LoadControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool LoadControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& LoadControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& LoadControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControl.controlValue)
  return _internal_controlvalue();
}
inline void LoadControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControl.controlValue)
}
inline ::commonmodule::ControlValue* LoadControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* LoadControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* LoadControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* LoadControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControl.controlValue)
  return _msg;
}
inline void LoadControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool LoadControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool LoadControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& LoadControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& LoadControl::check() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControl.check)
  return _internal_check();
}
inline void LoadControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControl.check)
}
inline ::commonmodule::CheckConditions* LoadControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* LoadControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* LoadControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* LoadControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControl.check)
  return _msg;
}
inline void LoadControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControl.check)
}

// .loadmodule.LoadControlFSCC loadControlFSCC = 3;
inline bool LoadControl::_internal_has_loadcontrolfscc() const {
  return this != internal_default_instance() && _impl_.loadcontrolfscc_ != nullptr;
}
inline bool LoadControl::has_loadcontrolfscc() const {
  return _internal_has_loadcontrolfscc();
}
inline void LoadControl::clear_loadcontrolfscc() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadcontrolfscc_ != nullptr) {
    delete _impl_.loadcontrolfscc_;
  }
  _impl_.loadcontrolfscc_ = nullptr;
}
inline const ::loadmodule::LoadControlFSCC& LoadControl::_internal_loadcontrolfscc() const {
  const ::loadmodule::LoadControlFSCC* p = _impl_.loadcontrolfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadControlFSCC&>(
      ::loadmodule::_LoadControlFSCC_default_instance_);
}
inline const ::loadmodule::LoadControlFSCC& LoadControl::loadcontrolfscc() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControl.loadControlFSCC)
  return _internal_loadcontrolfscc();
}
inline void LoadControl::unsafe_arena_set_allocated_loadcontrolfscc(
    ::loadmodule::LoadControlFSCC* loadcontrolfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadcontrolfscc_);
  }
  _impl_.loadcontrolfscc_ = loadcontrolfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControl.loadControlFSCC)
}
inline ::loadmodule::LoadControlFSCC* LoadControl::release_loadcontrolfscc() {
  
  ::loadmodule::LoadControlFSCC* temp = _impl_.loadcontrolfscc_;
  _impl_.loadcontrolfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadControlFSCC* LoadControl::unsafe_arena_release_loadcontrolfscc() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControl.loadControlFSCC)
  
  ::loadmodule::LoadControlFSCC* temp = _impl_.loadcontrolfscc_;
  _impl_.loadcontrolfscc_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadControlFSCC* LoadControl::_internal_mutable_loadcontrolfscc() {
  
  if (_impl_.loadcontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadControlFSCC>(GetArenaForAllocation());
    _impl_.loadcontrolfscc_ = p;
  }
  return _impl_.loadcontrolfscc_;
}
inline ::loadmodule::LoadControlFSCC* LoadControl::mutable_loadcontrolfscc() {
  ::loadmodule::LoadControlFSCC* _msg = _internal_mutable_loadcontrolfscc();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControl.loadControlFSCC)
  return _msg;
}
inline void LoadControl::set_allocated_loadcontrolfscc(::loadmodule::LoadControlFSCC* loadcontrolfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadcontrolfscc_;
  }
  if (loadcontrolfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadcontrolfscc);
    if (message_arena != submessage_arena) {
      loadcontrolfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadcontrolfscc, submessage_arena);
    }

  } else {

  }
  _impl_.loadcontrolfscc_ = loadcontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControl.loadControlFSCC)
}

// -------------------------------------------------------------------

// LoadControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool LoadControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool LoadControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& LoadControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& LoadControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void LoadControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* LoadControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* LoadControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* LoadControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* LoadControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControlProfile.controlMessageInfo)
  return _msg;
}
inline void LoadControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControlProfile.controlMessageInfo)
}

// .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadControlProfile::_internal_has_energyconsumer() const {
  return this != internal_default_instance() && _impl_.energyconsumer_ != nullptr;
}
inline bool LoadControlProfile::has_energyconsumer() const {
  return _internal_has_energyconsumer();
}
inline const ::commonmodule::EnergyConsumer& LoadControlProfile::_internal_energyconsumer() const {
  const ::commonmodule::EnergyConsumer* p = _impl_.energyconsumer_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnergyConsumer&>(
      ::commonmodule::_EnergyConsumer_default_instance_);
}
inline const ::commonmodule::EnergyConsumer& LoadControlProfile::energyconsumer() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControlProfile.energyConsumer)
  return _internal_energyconsumer();
}
inline void LoadControlProfile::unsafe_arena_set_allocated_energyconsumer(
    ::commonmodule::EnergyConsumer* energyconsumer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControlProfile.energyConsumer)
}
inline ::commonmodule::EnergyConsumer* LoadControlProfile::release_energyconsumer() {
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadControlProfile::unsafe_arena_release_energyconsumer() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControlProfile.energyConsumer)
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadControlProfile::_internal_mutable_energyconsumer() {
  
  if (_impl_.energyconsumer_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnergyConsumer>(GetArenaForAllocation());
    _impl_.energyconsumer_ = p;
  }
  return _impl_.energyconsumer_;
}
inline ::commonmodule::EnergyConsumer* LoadControlProfile::mutable_energyconsumer() {
  ::commonmodule::EnergyConsumer* _msg = _internal_mutable_energyconsumer();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControlProfile.energyConsumer)
  return _msg;
}
inline void LoadControlProfile::set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  if (energyconsumer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(energyconsumer));
    if (message_arena != submessage_arena) {
      energyconsumer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, energyconsumer, submessage_arena);
    }

  } else {

  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControlProfile.energyConsumer)
}

// .loadmodule.LoadControl loadControl = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadControlProfile::_internal_has_loadcontrol() const {
  return this != internal_default_instance() && _impl_.loadcontrol_ != nullptr;
}
inline bool LoadControlProfile::has_loadcontrol() const {
  return _internal_has_loadcontrol();
}
inline void LoadControlProfile::clear_loadcontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadcontrol_ != nullptr) {
    delete _impl_.loadcontrol_;
  }
  _impl_.loadcontrol_ = nullptr;
}
inline const ::loadmodule::LoadControl& LoadControlProfile::_internal_loadcontrol() const {
  const ::loadmodule::LoadControl* p = _impl_.loadcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadControl&>(
      ::loadmodule::_LoadControl_default_instance_);
}
inline const ::loadmodule::LoadControl& LoadControlProfile::loadcontrol() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadControlProfile.loadControl)
  return _internal_loadcontrol();
}
inline void LoadControlProfile::unsafe_arena_set_allocated_loadcontrol(
    ::loadmodule::LoadControl* loadcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadcontrol_);
  }
  _impl_.loadcontrol_ = loadcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadControlProfile.loadControl)
}
inline ::loadmodule::LoadControl* LoadControlProfile::release_loadcontrol() {
  
  ::loadmodule::LoadControl* temp = _impl_.loadcontrol_;
  _impl_.loadcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadControl* LoadControlProfile::unsafe_arena_release_loadcontrol() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadControlProfile.loadControl)
  
  ::loadmodule::LoadControl* temp = _impl_.loadcontrol_;
  _impl_.loadcontrol_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadControl* LoadControlProfile::_internal_mutable_loadcontrol() {
  
  if (_impl_.loadcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadControl>(GetArenaForAllocation());
    _impl_.loadcontrol_ = p;
  }
  return _impl_.loadcontrol_;
}
inline ::loadmodule::LoadControl* LoadControlProfile::mutable_loadcontrol() {
  ::loadmodule::LoadControl* _msg = _internal_mutable_loadcontrol();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadControlProfile.loadControl)
  return _msg;
}
inline void LoadControlProfile::set_allocated_loadcontrol(::loadmodule::LoadControl* loadcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadcontrol_;
  }
  if (loadcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadcontrol);
    if (message_arena != submessage_arena) {
      loadcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.loadcontrol_ = loadcontrol;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadControlProfile.loadControl)
}

// -------------------------------------------------------------------

// LoadPointStatus

// .commonmodule.RampRate rampRates = 1;
inline bool LoadPointStatus::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool LoadPointStatus::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& LoadPointStatus::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& LoadPointStatus::ramprates() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPointStatus.rampRates)
  return _internal_ramprates();
}
inline void LoadPointStatus::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPointStatus.rampRates)
}
inline ::commonmodule::RampRate* LoadPointStatus::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* LoadPointStatus::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPointStatus.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* LoadPointStatus::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* LoadPointStatus::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPointStatus.rampRates)
  return _msg;
}
inline void LoadPointStatus::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPointStatus.rampRates)
}

// .commonmodule.StatusSPS reactivePwrSetPointEnabled = 2;
inline bool LoadPointStatus::_internal_has_reactivepwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.reactivepwrsetpointenabled_ != nullptr;
}
inline bool LoadPointStatus::has_reactivepwrsetpointenabled() const {
  return _internal_has_reactivepwrsetpointenabled();
}
inline const ::commonmodule::StatusSPS& LoadPointStatus::_internal_reactivepwrsetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.reactivepwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& LoadPointStatus::reactivepwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPointStatus.reactivePwrSetPointEnabled)
  return _internal_reactivepwrsetpointenabled();
}
inline void LoadPointStatus::unsafe_arena_set_allocated_reactivepwrsetpointenabled(
    ::commonmodule::StatusSPS* reactivepwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPointStatus.reactivePwrSetPointEnabled)
}
inline ::commonmodule::StatusSPS* LoadPointStatus::release_reactivepwrsetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::unsafe_arena_release_reactivepwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPointStatus.reactivePwrSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.reactivepwrsetpointenabled_;
  _impl_.reactivepwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::_internal_mutable_reactivepwrsetpointenabled() {
  
  if (_impl_.reactivepwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.reactivepwrsetpointenabled_ = p;
  }
  return _impl_.reactivepwrsetpointenabled_;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::mutable_reactivepwrsetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_reactivepwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPointStatus.reactivePwrSetPointEnabled)
  return _msg;
}
inline void LoadPointStatus::set_allocated_reactivepwrsetpointenabled(::commonmodule::StatusSPS* reactivepwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reactivepwrsetpointenabled_);
  }
  if (reactivepwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reactivepwrsetpointenabled));
    if (message_arena != submessage_arena) {
      reactivepwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reactivepwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.reactivepwrsetpointenabled_ = reactivepwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPointStatus.reactivePwrSetPointEnabled)
}

// .commonmodule.StatusSPS realPwrSetPointEnabled = 3;
inline bool LoadPointStatus::_internal_has_realpwrsetpointenabled() const {
  return this != internal_default_instance() && _impl_.realpwrsetpointenabled_ != nullptr;
}
inline bool LoadPointStatus::has_realpwrsetpointenabled() const {
  return _internal_has_realpwrsetpointenabled();
}
inline const ::commonmodule::StatusSPS& LoadPointStatus::_internal_realpwrsetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.realpwrsetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& LoadPointStatus::realpwrsetpointenabled() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPointStatus.realPwrSetPointEnabled)
  return _internal_realpwrsetpointenabled();
}
inline void LoadPointStatus::unsafe_arena_set_allocated_realpwrsetpointenabled(
    ::commonmodule::StatusSPS* realpwrsetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPointStatus.realPwrSetPointEnabled)
}
inline ::commonmodule::StatusSPS* LoadPointStatus::release_realpwrsetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::unsafe_arena_release_realpwrsetpointenabled() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPointStatus.realPwrSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.realpwrsetpointenabled_;
  _impl_.realpwrsetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::_internal_mutable_realpwrsetpointenabled() {
  
  if (_impl_.realpwrsetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.realpwrsetpointenabled_ = p;
  }
  return _impl_.realpwrsetpointenabled_;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::mutable_realpwrsetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_realpwrsetpointenabled();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPointStatus.realPwrSetPointEnabled)
  return _msg;
}
inline void LoadPointStatus::set_allocated_realpwrsetpointenabled(::commonmodule::StatusSPS* realpwrsetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.realpwrsetpointenabled_);
  }
  if (realpwrsetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(realpwrsetpointenabled));
    if (message_arena != submessage_arena) {
      realpwrsetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, realpwrsetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.realpwrsetpointenabled_ = realpwrsetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPointStatus.realPwrSetPointEnabled)
}

// .commonmodule.StatusSPS reset = 4;
inline bool LoadPointStatus::_internal_has_reset() const {
  return this != internal_default_instance() && _impl_.reset_ != nullptr;
}
inline bool LoadPointStatus::has_reset() const {
  return _internal_has_reset();
}
inline const ::commonmodule::StatusSPS& LoadPointStatus::_internal_reset() const {
  const ::commonmodule::StatusSPS* p = _impl_.reset_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& LoadPointStatus::reset() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPointStatus.reset)
  return _internal_reset();
}
inline void LoadPointStatus::unsafe_arena_set_allocated_reset(
    ::commonmodule::StatusSPS* reset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPointStatus.reset)
}
inline ::commonmodule::StatusSPS* LoadPointStatus::release_reset() {
  
  ::commonmodule::StatusSPS* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::unsafe_arena_release_reset() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPointStatus.reset)
  
  ::commonmodule::StatusSPS* temp = _impl_.reset_;
  _impl_.reset_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::_internal_mutable_reset() {
  
  if (_impl_.reset_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.reset_ = p;
  }
  return _impl_.reset_;
}
inline ::commonmodule::StatusSPS* LoadPointStatus::mutable_reset() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_reset();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPointStatus.reset)
  return _msg;
}
inline void LoadPointStatus::set_allocated_reset(::commonmodule::StatusSPS* reset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_);
  }
  if (reset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reset));
    if (message_arena != submessage_arena) {
      reset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset, submessage_arena);
    }

  } else {

  }
  _impl_.reset_ = reset;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPointStatus.reset)
}

// .commonmodule.Optional_StateKind state = 5;
inline bool LoadPointStatus::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool LoadPointStatus::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& LoadPointStatus::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& LoadPointStatus::state() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadPointStatus.state)
  return _internal_state();
}
inline void LoadPointStatus::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadPointStatus.state)
}
inline ::commonmodule::Optional_StateKind* LoadPointStatus::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* LoadPointStatus::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadPointStatus.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* LoadPointStatus::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* LoadPointStatus::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadPointStatus.state)
  return _msg;
}
inline void LoadPointStatus::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadPointStatus.state)
}

// -------------------------------------------------------------------

// LoadEventAndStatusZGLD

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool LoadEventAndStatusZGLD::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool LoadEventAndStatusZGLD::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& LoadEventAndStatusZGLD::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& LoadEventAndStatusZGLD::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventAndStatusZGLD.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void LoadEventAndStatusZGLD::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventAndStatusZGLD.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* LoadEventAndStatusZGLD::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* LoadEventAndStatusZGLD::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventAndStatusZGLD.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* LoadEventAndStatusZGLD::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* LoadEventAndStatusZGLD::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventAndStatusZGLD.logicalNodeForEventAndStatus)
  return _msg;
}
inline void LoadEventAndStatusZGLD::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventAndStatusZGLD.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool LoadEventAndStatusZGLD::_internal_has_dynamictest() const {
  return this != internal_default_instance() && _impl_.dynamictest_ != nullptr;
}
inline bool LoadEventAndStatusZGLD::has_dynamictest() const {
  return _internal_has_dynamictest();
}
inline const ::commonmodule::ENS_DynamicTestKind& LoadEventAndStatusZGLD::_internal_dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(
      ::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& LoadEventAndStatusZGLD::dynamictest() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventAndStatusZGLD.DynamicTest)
  return _internal_dynamictest();
}
inline void LoadEventAndStatusZGLD::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* dynamictest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventAndStatusZGLD.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* LoadEventAndStatusZGLD::release_dynamictest() {
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* LoadEventAndStatusZGLD::unsafe_arena_release_dynamictest() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventAndStatusZGLD.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* LoadEventAndStatusZGLD::_internal_mutable_dynamictest() {
  
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaForAllocation());
    _impl_.dynamictest_ = p;
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* LoadEventAndStatusZGLD::mutable_dynamictest() {
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventAndStatusZGLD.DynamicTest)
  return _msg;
}
inline void LoadEventAndStatusZGLD::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  if (dynamictest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamictest));
    if (message_arena != submessage_arena) {
      dynamictest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }

  } else {

  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventAndStatusZGLD.DynamicTest)
}

// .commonmodule.StatusSPS EmgStop = 3;
inline bool LoadEventAndStatusZGLD::_internal_has_emgstop() const {
  return this != internal_default_instance() && _impl_.emgstop_ != nullptr;
}
inline bool LoadEventAndStatusZGLD::has_emgstop() const {
  return _internal_has_emgstop();
}
inline const ::commonmodule::StatusSPS& LoadEventAndStatusZGLD::_internal_emgstop() const {
  const ::commonmodule::StatusSPS* p = _impl_.emgstop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& LoadEventAndStatusZGLD::emgstop() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventAndStatusZGLD.EmgStop)
  return _internal_emgstop();
}
inline void LoadEventAndStatusZGLD::unsafe_arena_set_allocated_emgstop(
    ::commonmodule::StatusSPS* emgstop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emgstop_);
  }
  _impl_.emgstop_ = emgstop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventAndStatusZGLD.EmgStop)
}
inline ::commonmodule::StatusSPS* LoadEventAndStatusZGLD::release_emgstop() {
  
  ::commonmodule::StatusSPS* temp = _impl_.emgstop_;
  _impl_.emgstop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* LoadEventAndStatusZGLD::unsafe_arena_release_emgstop() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventAndStatusZGLD.EmgStop)
  
  ::commonmodule::StatusSPS* temp = _impl_.emgstop_;
  _impl_.emgstop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* LoadEventAndStatusZGLD::_internal_mutable_emgstop() {
  
  if (_impl_.emgstop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.emgstop_ = p;
  }
  return _impl_.emgstop_;
}
inline ::commonmodule::StatusSPS* LoadEventAndStatusZGLD::mutable_emgstop() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_emgstop();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventAndStatusZGLD.EmgStop)
  return _msg;
}
inline void LoadEventAndStatusZGLD::set_allocated_emgstop(::commonmodule::StatusSPS* emgstop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.emgstop_);
  }
  if (emgstop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emgstop));
    if (message_arena != submessage_arena) {
      emgstop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emgstop, submessage_arena);
    }

  } else {

  }
  _impl_.emgstop_ = emgstop;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventAndStatusZGLD.EmgStop)
}

// .loadmodule.LoadPointStatus PointStatus = 4;
inline bool LoadEventAndStatusZGLD::_internal_has_pointstatus() const {
  return this != internal_default_instance() && _impl_.pointstatus_ != nullptr;
}
inline bool LoadEventAndStatusZGLD::has_pointstatus() const {
  return _internal_has_pointstatus();
}
inline void LoadEventAndStatusZGLD::clear_pointstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.pointstatus_ != nullptr) {
    delete _impl_.pointstatus_;
  }
  _impl_.pointstatus_ = nullptr;
}
inline const ::loadmodule::LoadPointStatus& LoadEventAndStatusZGLD::_internal_pointstatus() const {
  const ::loadmodule::LoadPointStatus* p = _impl_.pointstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadPointStatus&>(
      ::loadmodule::_LoadPointStatus_default_instance_);
}
inline const ::loadmodule::LoadPointStatus& LoadEventAndStatusZGLD::pointstatus() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventAndStatusZGLD.PointStatus)
  return _internal_pointstatus();
}
inline void LoadEventAndStatusZGLD::unsafe_arena_set_allocated_pointstatus(
    ::loadmodule::LoadPointStatus* pointstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointstatus_);
  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventAndStatusZGLD.PointStatus)
}
inline ::loadmodule::LoadPointStatus* LoadEventAndStatusZGLD::release_pointstatus() {
  
  ::loadmodule::LoadPointStatus* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadPointStatus* LoadEventAndStatusZGLD::unsafe_arena_release_pointstatus() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventAndStatusZGLD.PointStatus)
  
  ::loadmodule::LoadPointStatus* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadPointStatus* LoadEventAndStatusZGLD::_internal_mutable_pointstatus() {
  
  if (_impl_.pointstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadPointStatus>(GetArenaForAllocation());
    _impl_.pointstatus_ = p;
  }
  return _impl_.pointstatus_;
}
inline ::loadmodule::LoadPointStatus* LoadEventAndStatusZGLD::mutable_pointstatus() {
  ::loadmodule::LoadPointStatus* _msg = _internal_mutable_pointstatus();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventAndStatusZGLD.PointStatus)
  return _msg;
}
inline void LoadEventAndStatusZGLD::set_allocated_pointstatus(::loadmodule::LoadPointStatus* pointstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pointstatus_;
  }
  if (pointstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pointstatus);
    if (message_arena != submessage_arena) {
      pointstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointstatus, submessage_arena);
    }

  } else {

  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventAndStatusZGLD.PointStatus)
}

// -------------------------------------------------------------------

// LoadEventZGLD

// .loadmodule.LoadEventAndStatusZGLD loadEventAndStatusZGLD = 1 [(.uml.option_parent_message) = true];
inline bool LoadEventZGLD::_internal_has_loadeventandstatuszgld() const {
  return this != internal_default_instance() && _impl_.loadeventandstatuszgld_ != nullptr;
}
inline bool LoadEventZGLD::has_loadeventandstatuszgld() const {
  return _internal_has_loadeventandstatuszgld();
}
inline void LoadEventZGLD::clear_loadeventandstatuszgld() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadeventandstatuszgld_ != nullptr) {
    delete _impl_.loadeventandstatuszgld_;
  }
  _impl_.loadeventandstatuszgld_ = nullptr;
}
inline const ::loadmodule::LoadEventAndStatusZGLD& LoadEventZGLD::_internal_loadeventandstatuszgld() const {
  const ::loadmodule::LoadEventAndStatusZGLD* p = _impl_.loadeventandstatuszgld_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadEventAndStatusZGLD&>(
      ::loadmodule::_LoadEventAndStatusZGLD_default_instance_);
}
inline const ::loadmodule::LoadEventAndStatusZGLD& LoadEventZGLD::loadeventandstatuszgld() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventZGLD.loadEventAndStatusZGLD)
  return _internal_loadeventandstatuszgld();
}
inline void LoadEventZGLD::unsafe_arena_set_allocated_loadeventandstatuszgld(
    ::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadeventandstatuszgld_);
  }
  _impl_.loadeventandstatuszgld_ = loadeventandstatuszgld;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventZGLD.loadEventAndStatusZGLD)
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadEventZGLD::release_loadeventandstatuszgld() {
  
  ::loadmodule::LoadEventAndStatusZGLD* temp = _impl_.loadeventandstatuszgld_;
  _impl_.loadeventandstatuszgld_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadEventZGLD::unsafe_arena_release_loadeventandstatuszgld() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventZGLD.loadEventAndStatusZGLD)
  
  ::loadmodule::LoadEventAndStatusZGLD* temp = _impl_.loadeventandstatuszgld_;
  _impl_.loadeventandstatuszgld_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadEventZGLD::_internal_mutable_loadeventandstatuszgld() {
  
  if (_impl_.loadeventandstatuszgld_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadEventAndStatusZGLD>(GetArenaForAllocation());
    _impl_.loadeventandstatuszgld_ = p;
  }
  return _impl_.loadeventandstatuszgld_;
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadEventZGLD::mutable_loadeventandstatuszgld() {
  ::loadmodule::LoadEventAndStatusZGLD* _msg = _internal_mutable_loadeventandstatuszgld();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventZGLD.loadEventAndStatusZGLD)
  return _msg;
}
inline void LoadEventZGLD::set_allocated_loadeventandstatuszgld(::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadeventandstatuszgld_;
  }
  if (loadeventandstatuszgld) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadeventandstatuszgld);
    if (message_arena != submessage_arena) {
      loadeventandstatuszgld = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadeventandstatuszgld, submessage_arena);
    }

  } else {

  }
  _impl_.loadeventandstatuszgld_ = loadeventandstatuszgld;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventZGLD.loadEventAndStatusZGLD)
}

// -------------------------------------------------------------------

// LoadEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool LoadEvent::_internal_has_eventvalue() const {
  return this != internal_default_instance() && _impl_.eventvalue_ != nullptr;
}
inline bool LoadEvent::has_eventvalue() const {
  return _internal_has_eventvalue();
}
inline const ::commonmodule::EventValue& LoadEvent::_internal_eventvalue() const {
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(
      ::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& LoadEvent::eventvalue() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEvent.eventValue)
  return _internal_eventvalue();
}
inline void LoadEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* eventvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEvent.eventValue)
}
inline ::commonmodule::EventValue* LoadEvent::release_eventvalue() {
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventValue* LoadEvent::unsafe_arena_release_eventvalue() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEvent.eventValue)
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* LoadEvent::_internal_mutable_eventvalue() {
  
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaForAllocation());
    _impl_.eventvalue_ = p;
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* LoadEvent::mutable_eventvalue() {
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEvent.eventValue)
  return _msg;
}
inline void LoadEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  if (eventvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventvalue));
    if (message_arena != submessage_arena) {
      eventvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }

  } else {

  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEvent.eventValue)
}

// .loadmodule.LoadEventZGLD loadEventZGLD = 2;
inline bool LoadEvent::_internal_has_loadeventzgld() const {
  return this != internal_default_instance() && _impl_.loadeventzgld_ != nullptr;
}
inline bool LoadEvent::has_loadeventzgld() const {
  return _internal_has_loadeventzgld();
}
inline void LoadEvent::clear_loadeventzgld() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadeventzgld_ != nullptr) {
    delete _impl_.loadeventzgld_;
  }
  _impl_.loadeventzgld_ = nullptr;
}
inline const ::loadmodule::LoadEventZGLD& LoadEvent::_internal_loadeventzgld() const {
  const ::loadmodule::LoadEventZGLD* p = _impl_.loadeventzgld_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadEventZGLD&>(
      ::loadmodule::_LoadEventZGLD_default_instance_);
}
inline const ::loadmodule::LoadEventZGLD& LoadEvent::loadeventzgld() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEvent.loadEventZGLD)
  return _internal_loadeventzgld();
}
inline void LoadEvent::unsafe_arena_set_allocated_loadeventzgld(
    ::loadmodule::LoadEventZGLD* loadeventzgld) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadeventzgld_);
  }
  _impl_.loadeventzgld_ = loadeventzgld;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEvent.loadEventZGLD)
}
inline ::loadmodule::LoadEventZGLD* LoadEvent::release_loadeventzgld() {
  
  ::loadmodule::LoadEventZGLD* temp = _impl_.loadeventzgld_;
  _impl_.loadeventzgld_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadEventZGLD* LoadEvent::unsafe_arena_release_loadeventzgld() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEvent.loadEventZGLD)
  
  ::loadmodule::LoadEventZGLD* temp = _impl_.loadeventzgld_;
  _impl_.loadeventzgld_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadEventZGLD* LoadEvent::_internal_mutable_loadeventzgld() {
  
  if (_impl_.loadeventzgld_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadEventZGLD>(GetArenaForAllocation());
    _impl_.loadeventzgld_ = p;
  }
  return _impl_.loadeventzgld_;
}
inline ::loadmodule::LoadEventZGLD* LoadEvent::mutable_loadeventzgld() {
  ::loadmodule::LoadEventZGLD* _msg = _internal_mutable_loadeventzgld();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEvent.loadEventZGLD)
  return _msg;
}
inline void LoadEvent::set_allocated_loadeventzgld(::loadmodule::LoadEventZGLD* loadeventzgld) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadeventzgld_;
  }
  if (loadeventzgld) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadeventzgld);
    if (message_arena != submessage_arena) {
      loadeventzgld = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadeventzgld, submessage_arena);
    }

  } else {

  }
  _impl_.loadeventzgld_ = loadeventzgld;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEvent.loadEventZGLD)
}

// -------------------------------------------------------------------

// LoadEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool LoadEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && _impl_.eventmessageinfo_ != nullptr;
}
inline bool LoadEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& LoadEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& LoadEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void LoadEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* LoadEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventMessageInfo* LoadEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* LoadEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaForAllocation());
    _impl_.eventmessageinfo_ = p;
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* LoadEventProfile::mutable_eventmessageinfo() {
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventProfile.eventMessageInfo)
  return _msg;
}
inline void LoadEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo));
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventProfile.eventMessageInfo)
}

// .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadEventProfile::_internal_has_energyconsumer() const {
  return this != internal_default_instance() && _impl_.energyconsumer_ != nullptr;
}
inline bool LoadEventProfile::has_energyconsumer() const {
  return _internal_has_energyconsumer();
}
inline const ::commonmodule::EnergyConsumer& LoadEventProfile::_internal_energyconsumer() const {
  const ::commonmodule::EnergyConsumer* p = _impl_.energyconsumer_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnergyConsumer&>(
      ::commonmodule::_EnergyConsumer_default_instance_);
}
inline const ::commonmodule::EnergyConsumer& LoadEventProfile::energyconsumer() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventProfile.energyConsumer)
  return _internal_energyconsumer();
}
inline void LoadEventProfile::unsafe_arena_set_allocated_energyconsumer(
    ::commonmodule::EnergyConsumer* energyconsumer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventProfile.energyConsumer)
}
inline ::commonmodule::EnergyConsumer* LoadEventProfile::release_energyconsumer() {
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadEventProfile::unsafe_arena_release_energyconsumer() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventProfile.energyConsumer)
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadEventProfile::_internal_mutable_energyconsumer() {
  
  if (_impl_.energyconsumer_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnergyConsumer>(GetArenaForAllocation());
    _impl_.energyconsumer_ = p;
  }
  return _impl_.energyconsumer_;
}
inline ::commonmodule::EnergyConsumer* LoadEventProfile::mutable_energyconsumer() {
  ::commonmodule::EnergyConsumer* _msg = _internal_mutable_energyconsumer();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventProfile.energyConsumer)
  return _msg;
}
inline void LoadEventProfile::set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  if (energyconsumer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(energyconsumer));
    if (message_arena != submessage_arena) {
      energyconsumer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, energyconsumer, submessage_arena);
    }

  } else {

  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventProfile.energyConsumer)
}

// .loadmodule.LoadEvent loadEvent = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadEventProfile::_internal_has_loadevent() const {
  return this != internal_default_instance() && _impl_.loadevent_ != nullptr;
}
inline bool LoadEventProfile::has_loadevent() const {
  return _internal_has_loadevent();
}
inline void LoadEventProfile::clear_loadevent() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadevent_ != nullptr) {
    delete _impl_.loadevent_;
  }
  _impl_.loadevent_ = nullptr;
}
inline const ::loadmodule::LoadEvent& LoadEventProfile::_internal_loadevent() const {
  const ::loadmodule::LoadEvent* p = _impl_.loadevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadEvent&>(
      ::loadmodule::_LoadEvent_default_instance_);
}
inline const ::loadmodule::LoadEvent& LoadEventProfile::loadevent() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadEventProfile.loadEvent)
  return _internal_loadevent();
}
inline void LoadEventProfile::unsafe_arena_set_allocated_loadevent(
    ::loadmodule::LoadEvent* loadevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadevent_);
  }
  _impl_.loadevent_ = loadevent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadEventProfile.loadEvent)
}
inline ::loadmodule::LoadEvent* LoadEventProfile::release_loadevent() {
  
  ::loadmodule::LoadEvent* temp = _impl_.loadevent_;
  _impl_.loadevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadEvent* LoadEventProfile::unsafe_arena_release_loadevent() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadEventProfile.loadEvent)
  
  ::loadmodule::LoadEvent* temp = _impl_.loadevent_;
  _impl_.loadevent_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadEvent* LoadEventProfile::_internal_mutable_loadevent() {
  
  if (_impl_.loadevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadEvent>(GetArenaForAllocation());
    _impl_.loadevent_ = p;
  }
  return _impl_.loadevent_;
}
inline ::loadmodule::LoadEvent* LoadEventProfile::mutable_loadevent() {
  ::loadmodule::LoadEvent* _msg = _internal_mutable_loadevent();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadEventProfile.loadEvent)
  return _msg;
}
inline void LoadEventProfile::set_allocated_loadevent(::loadmodule::LoadEvent* loadevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadevent_;
  }
  if (loadevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadevent);
    if (message_arena != submessage_arena) {
      loadevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadevent, submessage_arena);
    }

  } else {

  }
  _impl_.loadevent_ = loadevent;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadEventProfile.loadEvent)
}

// -------------------------------------------------------------------

// LoadReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool LoadReading::_internal_has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && _impl_.conductingequipmentterminalreading_ != nullptr;
}
inline bool LoadReading::has_conductingequipmentterminalreading() const {
  return _internal_has_conductingequipmentterminalreading();
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& LoadReading::_internal_conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(
      ::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& LoadReading::conductingequipmentterminalreading() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void LoadReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* LoadReading::release_conductingequipmentterminalreading() {
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* LoadReading::unsafe_arena_release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* LoadReading::_internal_mutable_conductingequipmentterminalreading() {
  
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaForAllocation());
    _impl_.conductingequipmentterminalreading_ = p;
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* LoadReading::mutable_conductingequipmentterminalreading() {
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void LoadReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipmentterminalreading));
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool LoadReading::_internal_has_phasemmtn() const {
  return this != internal_default_instance() && _impl_.phasemmtn_ != nullptr;
}
inline bool LoadReading::has_phasemmtn() const {
  return _internal_has_phasemmtn();
}
inline const ::commonmodule::PhaseMMTN& LoadReading::_internal_phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(
      ::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& LoadReading::phasemmtn() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void LoadReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* phasemmtn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* LoadReading::release_phasemmtn() {
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseMMTN* LoadReading::unsafe_arena_release_phasemmtn() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* LoadReading::_internal_mutable_phasemmtn() {
  
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaForAllocation());
    _impl_.phasemmtn_ = p;
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* LoadReading::mutable_phasemmtn() {
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadReading.phaseMMTN)
  return _msg;
}
inline void LoadReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  if (phasemmtn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phasemmtn));
    if (message_arena != submessage_arena) {
      phasemmtn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }

  } else {

  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool LoadReading::_internal_has_readingmmtr() const {
  return this != internal_default_instance() && _impl_.readingmmtr_ != nullptr;
}
inline bool LoadReading::has_readingmmtr() const {
  return _internal_has_readingmmtr();
}
inline const ::commonmodule::ReadingMMTR& LoadReading::_internal_readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(
      ::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& LoadReading::readingmmtr() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void LoadReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* readingmmtr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* LoadReading::release_readingmmtr() {
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTR* LoadReading::unsafe_arena_release_readingmmtr() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* LoadReading::_internal_mutable_readingmmtr() {
  
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaForAllocation());
    _impl_.readingmmtr_ = p;
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* LoadReading::mutable_readingmmtr() {
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadReading.readingMMTR)
  return _msg;
}
inline void LoadReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  if (readingmmtr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmtr));
    if (message_arena != submessage_arena) {
      readingmmtr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool LoadReading::_internal_has_readingmmxu() const {
  return this != internal_default_instance() && _impl_.readingmmxu_ != nullptr;
}
inline bool LoadReading::has_readingmmxu() const {
  return _internal_has_readingmmxu();
}
inline const ::commonmodule::ReadingMMXU& LoadReading::_internal_readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& LoadReading::readingmmxu() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void LoadReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* readingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* LoadReading::release_readingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* LoadReading::unsafe_arena_release_readingmmxu() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* LoadReading::_internal_mutable_readingmmxu() {
  
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.readingmmxu_ = p;
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* LoadReading::mutable_readingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadReading.readingMMXU)
  return _msg;
}
inline void LoadReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  if (readingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmxu));
    if (message_arena != submessage_arena) {
      readingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadReading.readingMMXU)
}

// -------------------------------------------------------------------

// LoadReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool LoadReadingProfile::_internal_has_readingmessageinfo() const {
  return this != internal_default_instance() && _impl_.readingmessageinfo_ != nullptr;
}
inline bool LoadReadingProfile::has_readingmessageinfo() const {
  return _internal_has_readingmessageinfo();
}
inline const ::commonmodule::ReadingMessageInfo& LoadReadingProfile::_internal_readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(
      ::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& LoadReadingProfile::readingmessageinfo() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void LoadReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* LoadReadingProfile::release_readingmessageinfo() {
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* LoadReadingProfile::unsafe_arena_release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* LoadReadingProfile::_internal_mutable_readingmessageinfo() {
  
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaForAllocation());
    _impl_.readingmessageinfo_ = p;
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* LoadReadingProfile::mutable_readingmessageinfo() {
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadReadingProfile.readingMessageInfo)
  return _msg;
}
inline void LoadReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmessageinfo));
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadReadingProfile.readingMessageInfo)
}

// .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadReadingProfile::_internal_has_energyconsumer() const {
  return this != internal_default_instance() && _impl_.energyconsumer_ != nullptr;
}
inline bool LoadReadingProfile::has_energyconsumer() const {
  return _internal_has_energyconsumer();
}
inline const ::commonmodule::EnergyConsumer& LoadReadingProfile::_internal_energyconsumer() const {
  const ::commonmodule::EnergyConsumer* p = _impl_.energyconsumer_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnergyConsumer&>(
      ::commonmodule::_EnergyConsumer_default_instance_);
}
inline const ::commonmodule::EnergyConsumer& LoadReadingProfile::energyconsumer() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadReadingProfile.energyConsumer)
  return _internal_energyconsumer();
}
inline void LoadReadingProfile::unsafe_arena_set_allocated_energyconsumer(
    ::commonmodule::EnergyConsumer* energyconsumer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadReadingProfile.energyConsumer)
}
inline ::commonmodule::EnergyConsumer* LoadReadingProfile::release_energyconsumer() {
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadReadingProfile::unsafe_arena_release_energyconsumer() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadReadingProfile.energyConsumer)
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadReadingProfile::_internal_mutable_energyconsumer() {
  
  if (_impl_.energyconsumer_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnergyConsumer>(GetArenaForAllocation());
    _impl_.energyconsumer_ = p;
  }
  return _impl_.energyconsumer_;
}
inline ::commonmodule::EnergyConsumer* LoadReadingProfile::mutable_energyconsumer() {
  ::commonmodule::EnergyConsumer* _msg = _internal_mutable_energyconsumer();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadReadingProfile.energyConsumer)
  return _msg;
}
inline void LoadReadingProfile::set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  if (energyconsumer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(energyconsumer));
    if (message_arena != submessage_arena) {
      energyconsumer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, energyconsumer, submessage_arena);
    }

  } else {

  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadReadingProfile.energyConsumer)
}

// .loadmodule.LoadReading loadReading = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadReadingProfile::_internal_has_loadreading() const {
  return this != internal_default_instance() && _impl_.loadreading_ != nullptr;
}
inline bool LoadReadingProfile::has_loadreading() const {
  return _internal_has_loadreading();
}
inline void LoadReadingProfile::clear_loadreading() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadreading_ != nullptr) {
    delete _impl_.loadreading_;
  }
  _impl_.loadreading_ = nullptr;
}
inline const ::loadmodule::LoadReading& LoadReadingProfile::_internal_loadreading() const {
  const ::loadmodule::LoadReading* p = _impl_.loadreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadReading&>(
      ::loadmodule::_LoadReading_default_instance_);
}
inline const ::loadmodule::LoadReading& LoadReadingProfile::loadreading() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadReadingProfile.loadReading)
  return _internal_loadreading();
}
inline void LoadReadingProfile::unsafe_arena_set_allocated_loadreading(
    ::loadmodule::LoadReading* loadreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadreading_);
  }
  _impl_.loadreading_ = loadreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadReadingProfile.loadReading)
}
inline ::loadmodule::LoadReading* LoadReadingProfile::release_loadreading() {
  
  ::loadmodule::LoadReading* temp = _impl_.loadreading_;
  _impl_.loadreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadReading* LoadReadingProfile::unsafe_arena_release_loadreading() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadReadingProfile.loadReading)
  
  ::loadmodule::LoadReading* temp = _impl_.loadreading_;
  _impl_.loadreading_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadReading* LoadReadingProfile::_internal_mutable_loadreading() {
  
  if (_impl_.loadreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadReading>(GetArenaForAllocation());
    _impl_.loadreading_ = p;
  }
  return _impl_.loadreading_;
}
inline ::loadmodule::LoadReading* LoadReadingProfile::mutable_loadreading() {
  ::loadmodule::LoadReading* _msg = _internal_mutable_loadreading();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadReadingProfile.loadReading)
  return _msg;
}
inline void LoadReadingProfile::set_allocated_loadreading(::loadmodule::LoadReading* loadreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadreading_;
  }
  if (loadreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadreading);
    if (message_arena != submessage_arena) {
      loadreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadreading, submessage_arena);
    }

  } else {

  }
  _impl_.loadreading_ = loadreading;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadReadingProfile.loadReading)
}

// -------------------------------------------------------------------

// LoadStatusZGLD

// .loadmodule.LoadEventAndStatusZGLD loadEventAndStatusZGLD = 1 [(.uml.option_parent_message) = true];
inline bool LoadStatusZGLD::_internal_has_loadeventandstatuszgld() const {
  return this != internal_default_instance() && _impl_.loadeventandstatuszgld_ != nullptr;
}
inline bool LoadStatusZGLD::has_loadeventandstatuszgld() const {
  return _internal_has_loadeventandstatuszgld();
}
inline void LoadStatusZGLD::clear_loadeventandstatuszgld() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadeventandstatuszgld_ != nullptr) {
    delete _impl_.loadeventandstatuszgld_;
  }
  _impl_.loadeventandstatuszgld_ = nullptr;
}
inline const ::loadmodule::LoadEventAndStatusZGLD& LoadStatusZGLD::_internal_loadeventandstatuszgld() const {
  const ::loadmodule::LoadEventAndStatusZGLD* p = _impl_.loadeventandstatuszgld_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadEventAndStatusZGLD&>(
      ::loadmodule::_LoadEventAndStatusZGLD_default_instance_);
}
inline const ::loadmodule::LoadEventAndStatusZGLD& LoadStatusZGLD::loadeventandstatuszgld() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadStatusZGLD.loadEventAndStatusZGLD)
  return _internal_loadeventandstatuszgld();
}
inline void LoadStatusZGLD::unsafe_arena_set_allocated_loadeventandstatuszgld(
    ::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadeventandstatuszgld_);
  }
  _impl_.loadeventandstatuszgld_ = loadeventandstatuszgld;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadStatusZGLD.loadEventAndStatusZGLD)
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadStatusZGLD::release_loadeventandstatuszgld() {
  
  ::loadmodule::LoadEventAndStatusZGLD* temp = _impl_.loadeventandstatuszgld_;
  _impl_.loadeventandstatuszgld_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadStatusZGLD::unsafe_arena_release_loadeventandstatuszgld() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadStatusZGLD.loadEventAndStatusZGLD)
  
  ::loadmodule::LoadEventAndStatusZGLD* temp = _impl_.loadeventandstatuszgld_;
  _impl_.loadeventandstatuszgld_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadStatusZGLD::_internal_mutable_loadeventandstatuszgld() {
  
  if (_impl_.loadeventandstatuszgld_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadEventAndStatusZGLD>(GetArenaForAllocation());
    _impl_.loadeventandstatuszgld_ = p;
  }
  return _impl_.loadeventandstatuszgld_;
}
inline ::loadmodule::LoadEventAndStatusZGLD* LoadStatusZGLD::mutable_loadeventandstatuszgld() {
  ::loadmodule::LoadEventAndStatusZGLD* _msg = _internal_mutable_loadeventandstatuszgld();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadStatusZGLD.loadEventAndStatusZGLD)
  return _msg;
}
inline void LoadStatusZGLD::set_allocated_loadeventandstatuszgld(::loadmodule::LoadEventAndStatusZGLD* loadeventandstatuszgld) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadeventandstatuszgld_;
  }
  if (loadeventandstatuszgld) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadeventandstatuszgld);
    if (message_arena != submessage_arena) {
      loadeventandstatuszgld = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadeventandstatuszgld, submessage_arena);
    }

  } else {

  }
  _impl_.loadeventandstatuszgld_ = loadeventandstatuszgld;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadStatusZGLD.loadEventAndStatusZGLD)
}

// -------------------------------------------------------------------

// LoadStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool LoadStatus::_internal_has_statusvalue() const {
  return this != internal_default_instance() && _impl_.statusvalue_ != nullptr;
}
inline bool LoadStatus::has_statusvalue() const {
  return _internal_has_statusvalue();
}
inline const ::commonmodule::StatusValue& LoadStatus::_internal_statusvalue() const {
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(
      ::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& LoadStatus::statusvalue() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadStatus.statusValue)
  return _internal_statusvalue();
}
inline void LoadStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* statusvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadStatus.statusValue)
}
inline ::commonmodule::StatusValue* LoadStatus::release_statusvalue() {
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusValue* LoadStatus::unsafe_arena_release_statusvalue() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* LoadStatus::_internal_mutable_statusvalue() {
  
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaForAllocation());
    _impl_.statusvalue_ = p;
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* LoadStatus::mutable_statusvalue() {
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadStatus.statusValue)
  return _msg;
}
inline void LoadStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  if (statusvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusvalue));
    if (message_arena != submessage_arena) {
      statusvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }

  } else {

  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadStatus.statusValue)
}

// .google.protobuf.BoolValue isUncontrollable = 2;
inline bool LoadStatus::_internal_has_isuncontrollable() const {
  return this != internal_default_instance() && _impl_.isuncontrollable_ != nullptr;
}
inline bool LoadStatus::has_isuncontrollable() const {
  return _internal_has_isuncontrollable();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& LoadStatus::_internal_isuncontrollable() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = _impl_.isuncontrollable_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& LoadStatus::isuncontrollable() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadStatus.isUncontrollable)
  return _internal_isuncontrollable();
}
inline void LoadStatus::unsafe_arena_set_allocated_isuncontrollable(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* isuncontrollable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.isuncontrollable_);
  }
  _impl_.isuncontrollable_ = isuncontrollable;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadStatus.isUncontrollable)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* LoadStatus::release_isuncontrollable() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.isuncontrollable_;
  _impl_.isuncontrollable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* LoadStatus::unsafe_arena_release_isuncontrollable() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadStatus.isUncontrollable)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = _impl_.isuncontrollable_;
  _impl_.isuncontrollable_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* LoadStatus::_internal_mutable_isuncontrollable() {
  
  if (_impl_.isuncontrollable_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    _impl_.isuncontrollable_ = p;
  }
  return _impl_.isuncontrollable_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* LoadStatus::mutable_isuncontrollable() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_isuncontrollable();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadStatus.isUncontrollable)
  return _msg;
}
inline void LoadStatus::set_allocated_isuncontrollable(::PROTOBUF_NAMESPACE_ID::BoolValue* isuncontrollable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.isuncontrollable_);
  }
  if (isuncontrollable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(isuncontrollable));
    if (message_arena != submessage_arena) {
      isuncontrollable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, isuncontrollable, submessage_arena);
    }

  } else {

  }
  _impl_.isuncontrollable_ = isuncontrollable;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadStatus.isUncontrollable)
}

// .loadmodule.LoadStatusZGLD loadStatusZGLD = 3;
inline bool LoadStatus::_internal_has_loadstatuszgld() const {
  return this != internal_default_instance() && _impl_.loadstatuszgld_ != nullptr;
}
inline bool LoadStatus::has_loadstatuszgld() const {
  return _internal_has_loadstatuszgld();
}
inline void LoadStatus::clear_loadstatuszgld() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadstatuszgld_ != nullptr) {
    delete _impl_.loadstatuszgld_;
  }
  _impl_.loadstatuszgld_ = nullptr;
}
inline const ::loadmodule::LoadStatusZGLD& LoadStatus::_internal_loadstatuszgld() const {
  const ::loadmodule::LoadStatusZGLD* p = _impl_.loadstatuszgld_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadStatusZGLD&>(
      ::loadmodule::_LoadStatusZGLD_default_instance_);
}
inline const ::loadmodule::LoadStatusZGLD& LoadStatus::loadstatuszgld() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadStatus.loadStatusZGLD)
  return _internal_loadstatuszgld();
}
inline void LoadStatus::unsafe_arena_set_allocated_loadstatuszgld(
    ::loadmodule::LoadStatusZGLD* loadstatuszgld) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadstatuszgld_);
  }
  _impl_.loadstatuszgld_ = loadstatuszgld;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadStatus.loadStatusZGLD)
}
inline ::loadmodule::LoadStatusZGLD* LoadStatus::release_loadstatuszgld() {
  
  ::loadmodule::LoadStatusZGLD* temp = _impl_.loadstatuszgld_;
  _impl_.loadstatuszgld_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadStatusZGLD* LoadStatus::unsafe_arena_release_loadstatuszgld() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadStatus.loadStatusZGLD)
  
  ::loadmodule::LoadStatusZGLD* temp = _impl_.loadstatuszgld_;
  _impl_.loadstatuszgld_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadStatusZGLD* LoadStatus::_internal_mutable_loadstatuszgld() {
  
  if (_impl_.loadstatuszgld_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadStatusZGLD>(GetArenaForAllocation());
    _impl_.loadstatuszgld_ = p;
  }
  return _impl_.loadstatuszgld_;
}
inline ::loadmodule::LoadStatusZGLD* LoadStatus::mutable_loadstatuszgld() {
  ::loadmodule::LoadStatusZGLD* _msg = _internal_mutable_loadstatuszgld();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadStatus.loadStatusZGLD)
  return _msg;
}
inline void LoadStatus::set_allocated_loadstatuszgld(::loadmodule::LoadStatusZGLD* loadstatuszgld) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadstatuszgld_;
  }
  if (loadstatuszgld) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadstatuszgld);
    if (message_arena != submessage_arena) {
      loadstatuszgld = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadstatuszgld, submessage_arena);
    }

  } else {

  }
  _impl_.loadstatuszgld_ = loadstatuszgld;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadStatus.loadStatusZGLD)
}

// -------------------------------------------------------------------

// LoadStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool LoadStatusProfile::_internal_has_statusmessageinfo() const {
  return this != internal_default_instance() && _impl_.statusmessageinfo_ != nullptr;
}
inline bool LoadStatusProfile::has_statusmessageinfo() const {
  return _internal_has_statusmessageinfo();
}
inline const ::commonmodule::StatusMessageInfo& LoadStatusProfile::_internal_statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(
      ::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& LoadStatusProfile::statusmessageinfo() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void LoadStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* statusmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* LoadStatusProfile::release_statusmessageinfo() {
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusMessageInfo* LoadStatusProfile::unsafe_arena_release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* LoadStatusProfile::_internal_mutable_statusmessageinfo() {
  
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaForAllocation());
    _impl_.statusmessageinfo_ = p;
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* LoadStatusProfile::mutable_statusmessageinfo() {
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadStatusProfile.statusMessageInfo)
  return _msg;
}
inline void LoadStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusmessageinfo));
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadStatusProfile.statusMessageInfo)
}

// .commonmodule.EnergyConsumer energyConsumer = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadStatusProfile::_internal_has_energyconsumer() const {
  return this != internal_default_instance() && _impl_.energyconsumer_ != nullptr;
}
inline bool LoadStatusProfile::has_energyconsumer() const {
  return _internal_has_energyconsumer();
}
inline const ::commonmodule::EnergyConsumer& LoadStatusProfile::_internal_energyconsumer() const {
  const ::commonmodule::EnergyConsumer* p = _impl_.energyconsumer_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EnergyConsumer&>(
      ::commonmodule::_EnergyConsumer_default_instance_);
}
inline const ::commonmodule::EnergyConsumer& LoadStatusProfile::energyconsumer() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadStatusProfile.energyConsumer)
  return _internal_energyconsumer();
}
inline void LoadStatusProfile::unsafe_arena_set_allocated_energyconsumer(
    ::commonmodule::EnergyConsumer* energyconsumer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadStatusProfile.energyConsumer)
}
inline ::commonmodule::EnergyConsumer* LoadStatusProfile::release_energyconsumer() {
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadStatusProfile::unsafe_arena_release_energyconsumer() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadStatusProfile.energyConsumer)
  
  ::commonmodule::EnergyConsumer* temp = _impl_.energyconsumer_;
  _impl_.energyconsumer_ = nullptr;
  return temp;
}
inline ::commonmodule::EnergyConsumer* LoadStatusProfile::_internal_mutable_energyconsumer() {
  
  if (_impl_.energyconsumer_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EnergyConsumer>(GetArenaForAllocation());
    _impl_.energyconsumer_ = p;
  }
  return _impl_.energyconsumer_;
}
inline ::commonmodule::EnergyConsumer* LoadStatusProfile::mutable_energyconsumer() {
  ::commonmodule::EnergyConsumer* _msg = _internal_mutable_energyconsumer();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadStatusProfile.energyConsumer)
  return _msg;
}
inline void LoadStatusProfile::set_allocated_energyconsumer(::commonmodule::EnergyConsumer* energyconsumer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.energyconsumer_);
  }
  if (energyconsumer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(energyconsumer));
    if (message_arena != submessage_arena) {
      energyconsumer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, energyconsumer, submessage_arena);
    }

  } else {

  }
  _impl_.energyconsumer_ = energyconsumer;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadStatusProfile.energyConsumer)
}

// .loadmodule.LoadStatus loadStatus = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool LoadStatusProfile::_internal_has_loadstatus() const {
  return this != internal_default_instance() && _impl_.loadstatus_ != nullptr;
}
inline bool LoadStatusProfile::has_loadstatus() const {
  return _internal_has_loadstatus();
}
inline void LoadStatusProfile::clear_loadstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.loadstatus_ != nullptr) {
    delete _impl_.loadstatus_;
  }
  _impl_.loadstatus_ = nullptr;
}
inline const ::loadmodule::LoadStatus& LoadStatusProfile::_internal_loadstatus() const {
  const ::loadmodule::LoadStatus* p = _impl_.loadstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::loadmodule::LoadStatus&>(
      ::loadmodule::_LoadStatus_default_instance_);
}
inline const ::loadmodule::LoadStatus& LoadStatusProfile::loadstatus() const {
  // @@protoc_insertion_point(field_get:loadmodule.LoadStatusProfile.loadStatus)
  return _internal_loadstatus();
}
inline void LoadStatusProfile::unsafe_arena_set_allocated_loadstatus(
    ::loadmodule::LoadStatus* loadstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loadstatus_);
  }
  _impl_.loadstatus_ = loadstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loadmodule.LoadStatusProfile.loadStatus)
}
inline ::loadmodule::LoadStatus* LoadStatusProfile::release_loadstatus() {
  
  ::loadmodule::LoadStatus* temp = _impl_.loadstatus_;
  _impl_.loadstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loadmodule::LoadStatus* LoadStatusProfile::unsafe_arena_release_loadstatus() {
  // @@protoc_insertion_point(field_release:loadmodule.LoadStatusProfile.loadStatus)
  
  ::loadmodule::LoadStatus* temp = _impl_.loadstatus_;
  _impl_.loadstatus_ = nullptr;
  return temp;
}
inline ::loadmodule::LoadStatus* LoadStatusProfile::_internal_mutable_loadstatus() {
  
  if (_impl_.loadstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::loadmodule::LoadStatus>(GetArenaForAllocation());
    _impl_.loadstatus_ = p;
  }
  return _impl_.loadstatus_;
}
inline ::loadmodule::LoadStatus* LoadStatusProfile::mutable_loadstatus() {
  ::loadmodule::LoadStatus* _msg = _internal_mutable_loadstatus();
  // @@protoc_insertion_point(field_mutable:loadmodule.LoadStatusProfile.loadStatus)
  return _msg;
}
inline void LoadStatusProfile::set_allocated_loadstatus(::loadmodule::LoadStatus* loadstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loadstatus_;
  }
  if (loadstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loadstatus);
    if (message_arena != submessage_arena) {
      loadstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadstatus, submessage_arena);
    }

  } else {

  }
  _impl_.loadstatus_ = loadstatus;
  // @@protoc_insertion_point(field_set_allocated:loadmodule.LoadStatusProfile.loadStatus)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace loadmodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_loadmodule_2floadmodule_2eproto_2epb_2eh
