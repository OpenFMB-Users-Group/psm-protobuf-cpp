// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: regulatormodule/regulatormodule.proto
// Protobuf C++ Version: 6.31.1

#ifndef regulatormodule_2fregulatormodule_2eproto_2epb_2eh
#define regulatormodule_2fregulatormodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_regulatormodule_2fregulatormodule_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_regulatormodule_2fregulatormodule_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_regulatormodule_2fregulatormodule_2eproto;
}  // extern "C"
namespace regulatormodule {
class DirectionalATCC;
struct DirectionalATCCDefaultTypeInternal;
extern DirectionalATCCDefaultTypeInternal _DirectionalATCC_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DirectionalATCC_class_data_;
class RegulatorCSG;
struct RegulatorCSGDefaultTypeInternal;
extern RegulatorCSGDefaultTypeInternal _RegulatorCSG_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorCSG_class_data_;
class RegulatorControl;
struct RegulatorControlDefaultTypeInternal;
extern RegulatorControlDefaultTypeInternal _RegulatorControl_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorControl_class_data_;
class RegulatorControlATCC;
struct RegulatorControlATCCDefaultTypeInternal;
extern RegulatorControlATCCDefaultTypeInternal _RegulatorControlATCC_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorControlATCC_class_data_;
class RegulatorControlFSCC;
struct RegulatorControlFSCCDefaultTypeInternal;
extern RegulatorControlFSCCDefaultTypeInternal _RegulatorControlFSCC_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorControlFSCC_class_data_;
class RegulatorControlProfile;
struct RegulatorControlProfileDefaultTypeInternal;
extern RegulatorControlProfileDefaultTypeInternal _RegulatorControlProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorControlProfile_class_data_;
class RegulatorControlScheduleFSCH;
struct RegulatorControlScheduleFSCHDefaultTypeInternal;
extern RegulatorControlScheduleFSCHDefaultTypeInternal _RegulatorControlScheduleFSCH_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorControlScheduleFSCH_class_data_;
class RegulatorDiscreteControl;
struct RegulatorDiscreteControlDefaultTypeInternal;
extern RegulatorDiscreteControlDefaultTypeInternal _RegulatorDiscreteControl_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorDiscreteControl_class_data_;
class RegulatorDiscreteControlProfile;
struct RegulatorDiscreteControlProfileDefaultTypeInternal;
extern RegulatorDiscreteControlProfileDefaultTypeInternal _RegulatorDiscreteControlProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorDiscreteControlProfile_class_data_;
class RegulatorEvent;
struct RegulatorEventDefaultTypeInternal;
extern RegulatorEventDefaultTypeInternal _RegulatorEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorEvent_class_data_;
class RegulatorEventAndStatusANCR;
struct RegulatorEventAndStatusANCRDefaultTypeInternal;
extern RegulatorEventAndStatusANCRDefaultTypeInternal _RegulatorEventAndStatusANCR_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorEventAndStatusANCR_class_data_;
class RegulatorEventAndStatusATCC;
struct RegulatorEventAndStatusATCCDefaultTypeInternal;
extern RegulatorEventAndStatusATCCDefaultTypeInternal _RegulatorEventAndStatusATCC_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorEventAndStatusATCC_class_data_;
class RegulatorEventProfile;
struct RegulatorEventProfileDefaultTypeInternal;
extern RegulatorEventProfileDefaultTypeInternal _RegulatorEventProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorEventProfile_class_data_;
class RegulatorPoint;
struct RegulatorPointDefaultTypeInternal;
extern RegulatorPointDefaultTypeInternal _RegulatorPoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorPoint_class_data_;
class RegulatorReading;
struct RegulatorReadingDefaultTypeInternal;
extern RegulatorReadingDefaultTypeInternal _RegulatorReading_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorReading_class_data_;
class RegulatorReadingProfile;
struct RegulatorReadingProfileDefaultTypeInternal;
extern RegulatorReadingProfileDefaultTypeInternal _RegulatorReadingProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorReadingProfile_class_data_;
class RegulatorStatus;
struct RegulatorStatusDefaultTypeInternal;
extern RegulatorStatusDefaultTypeInternal _RegulatorStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorStatus_class_data_;
class RegulatorStatusProfile;
struct RegulatorStatusProfileDefaultTypeInternal;
extern RegulatorStatusProfileDefaultTypeInternal _RegulatorStatusProfile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorStatusProfile_class_data_;
class RegulatorSystem;
struct RegulatorSystemDefaultTypeInternal;
extern RegulatorSystemDefaultTypeInternal _RegulatorSystem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegulatorSystem_class_data_;
}  // namespace regulatormodule
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace regulatormodule {

// ===================================================================


// -------------------------------------------------------------------

class DirectionalATCC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.DirectionalATCC) */ {
 public:
  inline DirectionalATCC() : DirectionalATCC(nullptr) {}
  ~DirectionalATCC() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DirectionalATCC* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DirectionalATCC));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DirectionalATCC(::google::protobuf::internal::ConstantInitialized);

  inline DirectionalATCC(const DirectionalATCC& from) : DirectionalATCC(nullptr, from) {}
  inline DirectionalATCC(DirectionalATCC&& from) noexcept
      : DirectionalATCC(nullptr, ::std::move(from)) {}
  inline DirectionalATCC& operator=(const DirectionalATCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionalATCC& operator=(DirectionalATCC&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectionalATCC& default_instance() {
    return *reinterpret_cast<const DirectionalATCC*>(
        &_DirectionalATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(DirectionalATCC& a, DirectionalATCC& b) { a.Swap(&b); }
  inline void Swap(DirectionalATCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionalATCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionalATCC* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DirectionalATCC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DirectionalATCC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DirectionalATCC& from) { DirectionalATCC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DirectionalATCC* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.DirectionalATCC"; }

 protected:
  explicit DirectionalATCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DirectionalATCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DirectionalATCC& from);
  DirectionalATCC(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DirectionalATCC&& from) noexcept
      : DirectionalATCC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBndWidFieldNumber = 1,
    kCtlDlTmmsFieldNumber = 2,
    kLDCRFieldNumber = 3,
    kLDCXFieldNumber = 4,
    kVolSptFieldNumber = 5,
    kVoltageSetPointEnabledFieldNumber = 6,
  };
  // .commonmodule.PhaseAPC BndWid = 1;
  bool has_bndwid() const;
  void clear_bndwid() ;
  const ::commonmodule::PhaseAPC& bndwid() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_bndwid();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_bndwid();
  void set_allocated_bndwid(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bndwid(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_bndwid();

  private:
  const ::commonmodule::PhaseAPC& _internal_bndwid() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_bndwid();

  public:
  // .commonmodule.PhaseISC CtlDlTmms = 2;
  bool has_ctldltmms() const;
  void clear_ctldltmms() ;
  const ::commonmodule::PhaseISC& ctldltmms() const;
  [[nodiscard]] ::commonmodule::PhaseISC* PROTOBUF_NULLABLE release_ctldltmms();
  ::commonmodule::PhaseISC* PROTOBUF_NONNULL mutable_ctldltmms();
  void set_allocated_ctldltmms(::commonmodule::PhaseISC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ctldltmms(::commonmodule::PhaseISC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseISC* PROTOBUF_NULLABLE unsafe_arena_release_ctldltmms();

  private:
  const ::commonmodule::PhaseISC& _internal_ctldltmms() const;
  ::commonmodule::PhaseISC* PROTOBUF_NONNULL _internal_mutable_ctldltmms();

  public:
  // .commonmodule.PhaseAPC LDCR = 3;
  bool has_ldcr() const;
  void clear_ldcr() ;
  const ::commonmodule::PhaseAPC& ldcr() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_ldcr();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_ldcr();
  void set_allocated_ldcr(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ldcr(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_ldcr();

  private:
  const ::commonmodule::PhaseAPC& _internal_ldcr() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_ldcr();

  public:
  // .commonmodule.PhaseAPC LDCX = 4;
  bool has_ldcx() const;
  void clear_ldcx() ;
  const ::commonmodule::PhaseAPC& ldcx() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_ldcx();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_ldcx();
  void set_allocated_ldcx(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ldcx(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_ldcx();

  private:
  const ::commonmodule::PhaseAPC& _internal_ldcx() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_ldcx();

  public:
  // .commonmodule.PhaseAPC VolSpt = 5;
  bool has_volspt() const;
  void clear_volspt() ;
  const ::commonmodule::PhaseAPC& volspt() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_volspt();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_volspt();
  void set_allocated_volspt(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_volspt(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_volspt();

  private:
  const ::commonmodule::PhaseAPC& _internal_volspt() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_volspt();

  public:
  // .commonmodule.PhaseDPC voltageSetPointEnabled = 6;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled() ;
  const ::commonmodule::PhaseDPC& voltagesetpointenabled() const;
  [[nodiscard]] ::commonmodule::PhaseDPC* PROTOBUF_NULLABLE release_voltagesetpointenabled();
  ::commonmodule::PhaseDPC* PROTOBUF_NONNULL mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::PhaseDPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltagesetpointenabled(::commonmodule::PhaseDPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseDPC* PROTOBUF_NULLABLE unsafe_arena_release_voltagesetpointenabled();

  private:
  const ::commonmodule::PhaseDPC& _internal_voltagesetpointenabled() const;
  ::commonmodule::PhaseDPC* PROTOBUF_NONNULL _internal_mutable_voltagesetpointenabled();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.DirectionalATCC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DirectionalATCC& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE bndwid_;
    ::commonmodule::PhaseISC* PROTOBUF_NULLABLE ctldltmms_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE ldcr_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE ldcx_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE volspt_;
    ::commonmodule::PhaseDPC* PROTOBUF_NULLABLE voltagesetpointenabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DirectionalATCC_class_data_;
// -------------------------------------------------------------------

class RegulatorSystem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorSystem) */ {
 public:
  inline RegulatorSystem() : RegulatorSystem(nullptr) {}
  ~RegulatorSystem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorSystem* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorSystem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorSystem(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorSystem(const RegulatorSystem& from) : RegulatorSystem(nullptr, from) {}
  inline RegulatorSystem(RegulatorSystem&& from) noexcept
      : RegulatorSystem(nullptr, ::std::move(from)) {}
  inline RegulatorSystem& operator=(const RegulatorSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorSystem& operator=(RegulatorSystem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorSystem& default_instance() {
    return *reinterpret_cast<const RegulatorSystem*>(
        &_RegulatorSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RegulatorSystem& a, RegulatorSystem& b) { a.Swap(&b); }
  inline void Swap(RegulatorSystem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorSystem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorSystem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorSystem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorSystem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorSystem& from) { RegulatorSystem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorSystem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorSystem"; }

 protected:
  explicit RegulatorSystem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorSystem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorSystem& from);
  RegulatorSystem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorSystem&& from) noexcept
      : RegulatorSystem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  [[nodiscard]] ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE release_conductingequipment();
  ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conductingequipment(::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value);
  ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE unsafe_arena_release_conductingequipment();

  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL _internal_mutable_conductingequipment();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorSystem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorSystem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE conductingequipment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorSystem_class_data_;
// -------------------------------------------------------------------

class RegulatorEventAndStatusATCC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventAndStatusATCC) */ {
 public:
  inline RegulatorEventAndStatusATCC() : RegulatorEventAndStatusATCC(nullptr) {}
  ~RegulatorEventAndStatusATCC() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorEventAndStatusATCC* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorEventAndStatusATCC));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorEventAndStatusATCC(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorEventAndStatusATCC(const RegulatorEventAndStatusATCC& from) : RegulatorEventAndStatusATCC(nullptr, from) {}
  inline RegulatorEventAndStatusATCC(RegulatorEventAndStatusATCC&& from) noexcept
      : RegulatorEventAndStatusATCC(nullptr, ::std::move(from)) {}
  inline RegulatorEventAndStatusATCC& operator=(const RegulatorEventAndStatusATCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEventAndStatusATCC& operator=(RegulatorEventAndStatusATCC&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEventAndStatusATCC& default_instance() {
    return *reinterpret_cast<const RegulatorEventAndStatusATCC*>(
        &_RegulatorEventAndStatusATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RegulatorEventAndStatusATCC& a, RegulatorEventAndStatusATCC& b) { a.Swap(&b); }
  inline void Swap(RegulatorEventAndStatusATCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEventAndStatusATCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEventAndStatusATCC* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorEventAndStatusATCC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorEventAndStatusATCC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorEventAndStatusATCC& from) { RegulatorEventAndStatusATCC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorEventAndStatusATCC* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorEventAndStatusATCC"; }

 protected:
  explicit RegulatorEventAndStatusATCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorEventAndStatusATCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorEventAndStatusATCC& from);
  RegulatorEventAndStatusATCC(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorEventAndStatusATCC&& from) noexcept
      : RegulatorEventAndStatusATCC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBndCtrFieldNumber = 1,
    kBndWidFieldNumber = 2,
    kBndWidHiFieldNumber = 3,
    kBndWidLoFieldNumber = 4,
    kDirCtlRevFieldNumber = 5,
    kDirIndtFieldNumber = 6,
    kDirRevFieldNumber = 7,
    kLDCRFieldNumber = 8,
    kLDCXFieldNumber = 9,
    kParOpFieldNumber = 10,
    kRampRatesFieldNumber = 11,
    kStateFieldNumber = 12,
    kStDlTmmsFieldNumber = 13,
    kTapOpErrFieldNumber = 14,
    kTapPosFieldNumber = 15,
    kVolLmtHiFieldNumber = 16,
    kVolLmtLoFieldNumber = 17,
    kVolSptFieldNumber = 18,
    kVoltageSetPointEnabledFieldNumber = 19,
    kDirModFieldNumber = 20,
    kVolLmtModeFieldNumber = 21,
  };
  // .commonmodule.ASG BndCtr = 1;
  bool has_bndctr() const;
  void clear_bndctr() ;
  const ::commonmodule::ASG& bndctr() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_bndctr();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_bndctr();
  void set_allocated_bndctr(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bndctr(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_bndctr();

  private:
  const ::commonmodule::ASG& _internal_bndctr() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_bndctr();

  public:
  // .commonmodule.ASG BndWid = 2;
  bool has_bndwid() const;
  void clear_bndwid() ;
  const ::commonmodule::ASG& bndwid() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_bndwid();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_bndwid();
  void set_allocated_bndwid(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bndwid(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_bndwid();

  private:
  const ::commonmodule::ASG& _internal_bndwid() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_bndwid();

  public:
  // .commonmodule.PhaseSPS BndWidHi = 3;
  bool has_bndwidhi() const;
  void clear_bndwidhi() ;
  const ::commonmodule::PhaseSPS& bndwidhi() const;
  [[nodiscard]] ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE release_bndwidhi();
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL mutable_bndwidhi();
  void set_allocated_bndwidhi(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bndwidhi(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE unsafe_arena_release_bndwidhi();

  private:
  const ::commonmodule::PhaseSPS& _internal_bndwidhi() const;
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL _internal_mutable_bndwidhi();

  public:
  // .commonmodule.PhaseSPS BndWidLo = 4;
  bool has_bndwidlo() const;
  void clear_bndwidlo() ;
  const ::commonmodule::PhaseSPS& bndwidlo() const;
  [[nodiscard]] ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE release_bndwidlo();
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL mutable_bndwidlo();
  void set_allocated_bndwidlo(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bndwidlo(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE unsafe_arena_release_bndwidlo();

  private:
  const ::commonmodule::PhaseSPS& _internal_bndwidlo() const;
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL _internal_mutable_bndwidlo();

  public:
  // .commonmodule.PhaseSPS DirCtlRev = 5;
  bool has_dirctlrev() const;
  void clear_dirctlrev() ;
  const ::commonmodule::PhaseSPS& dirctlrev() const;
  [[nodiscard]] ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE release_dirctlrev();
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL mutable_dirctlrev();
  void set_allocated_dirctlrev(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirctlrev(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE unsafe_arena_release_dirctlrev();

  private:
  const ::commonmodule::PhaseSPS& _internal_dirctlrev() const;
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL _internal_mutable_dirctlrev();

  public:
  // .commonmodule.PhaseSPS DirIndt = 6;
  bool has_dirindt() const;
  void clear_dirindt() ;
  const ::commonmodule::PhaseSPS& dirindt() const;
  [[nodiscard]] ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE release_dirindt();
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL mutable_dirindt();
  void set_allocated_dirindt(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirindt(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE unsafe_arena_release_dirindt();

  private:
  const ::commonmodule::PhaseSPS& _internal_dirindt() const;
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL _internal_mutable_dirindt();

  public:
  // .commonmodule.PhaseSPS DirRev = 7;
  bool has_dirrev() const;
  void clear_dirrev() ;
  const ::commonmodule::PhaseSPS& dirrev() const;
  [[nodiscard]] ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE release_dirrev();
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL mutable_dirrev();
  void set_allocated_dirrev(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirrev(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE unsafe_arena_release_dirrev();

  private:
  const ::commonmodule::PhaseSPS& _internal_dirrev() const;
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL _internal_mutable_dirrev();

  public:
  // .commonmodule.ASG LDCR = 8;
  bool has_ldcr() const;
  void clear_ldcr() ;
  const ::commonmodule::ASG& ldcr() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_ldcr();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_ldcr();
  void set_allocated_ldcr(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ldcr(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_ldcr();

  private:
  const ::commonmodule::ASG& _internal_ldcr() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_ldcr();

  public:
  // .commonmodule.ASG LDCX = 9;
  bool has_ldcx() const;
  void clear_ldcx() ;
  const ::commonmodule::ASG& ldcx() const;
  [[nodiscard]] ::commonmodule::ASG* PROTOBUF_NULLABLE release_ldcx();
  ::commonmodule::ASG* PROTOBUF_NONNULL mutable_ldcx();
  void set_allocated_ldcx(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ldcx(::commonmodule::ASG* PROTOBUF_NULLABLE value);
  ::commonmodule::ASG* PROTOBUF_NULLABLE unsafe_arena_release_ldcx();

  private:
  const ::commonmodule::ASG& _internal_ldcx() const;
  ::commonmodule::ASG* PROTOBUF_NONNULL _internal_mutable_ldcx();

  public:
  // .commonmodule.StatusSPS ParOp = 10;
  bool has_parop() const;
  void clear_parop() ;
  const ::commonmodule::StatusSPS& parop() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_parop();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_parop();
  void set_allocated_parop(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_parop(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_parop();

  private:
  const ::commonmodule::StatusSPS& _internal_parop() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_parop();

  public:
  // .commonmodule.RampRate rampRates = 11;
  bool has_ramprates() const;
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  [[nodiscard]] ::commonmodule::RampRate* PROTOBUF_NULLABLE release_ramprates();
  ::commonmodule::RampRate* PROTOBUF_NONNULL mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  ::commonmodule::RampRate* PROTOBUF_NULLABLE unsafe_arena_release_ramprates();

  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* PROTOBUF_NONNULL _internal_mutable_ramprates();

  public:
  // .commonmodule.Optional_StateKind state = 12;
  bool has_state() const;
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  [[nodiscard]] ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE release_state();
  ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_state(::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value);
  ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE unsafe_arena_release_state();

  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // .commonmodule.StatusINC StDlTmms = 13;
  bool has_stdltmms() const;
  void clear_stdltmms() ;
  const ::commonmodule::StatusINC& stdltmms() const;
  [[nodiscard]] ::commonmodule::StatusINC* PROTOBUF_NULLABLE release_stdltmms();
  ::commonmodule::StatusINC* PROTOBUF_NONNULL mutable_stdltmms();
  void set_allocated_stdltmms(::commonmodule::StatusINC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_stdltmms(::commonmodule::StatusINC* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusINC* PROTOBUF_NULLABLE unsafe_arena_release_stdltmms();

  private:
  const ::commonmodule::StatusINC& _internal_stdltmms() const;
  ::commonmodule::StatusINC* PROTOBUF_NONNULL _internal_mutable_stdltmms();

  public:
  // .commonmodule.StatusSPS TapOpErr = 14;
  bool has_tapoperr() const;
  void clear_tapoperr() ;
  const ::commonmodule::StatusSPS& tapoperr() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_tapoperr();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_tapoperr();
  void set_allocated_tapoperr(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tapoperr(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_tapoperr();

  private:
  const ::commonmodule::StatusSPS& _internal_tapoperr() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_tapoperr();

  public:
  // .commonmodule.PhaseINS TapPos = 15;
  bool has_tappos() const;
  void clear_tappos() ;
  const ::commonmodule::PhaseINS& tappos() const;
  [[nodiscard]] ::commonmodule::PhaseINS* PROTOBUF_NULLABLE release_tappos();
  ::commonmodule::PhaseINS* PROTOBUF_NONNULL mutable_tappos();
  void set_allocated_tappos(::commonmodule::PhaseINS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tappos(::commonmodule::PhaseINS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseINS* PROTOBUF_NULLABLE unsafe_arena_release_tappos();

  private:
  const ::commonmodule::PhaseINS& _internal_tappos() const;
  ::commonmodule::PhaseINS* PROTOBUF_NONNULL _internal_mutable_tappos();

  public:
  // .commonmodule.PhaseSPS VolLmtHi = 16;
  bool has_vollmthi() const;
  void clear_vollmthi() ;
  const ::commonmodule::PhaseSPS& vollmthi() const;
  [[nodiscard]] ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE release_vollmthi();
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL mutable_vollmthi();
  void set_allocated_vollmthi(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vollmthi(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE unsafe_arena_release_vollmthi();

  private:
  const ::commonmodule::PhaseSPS& _internal_vollmthi() const;
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL _internal_mutable_vollmthi();

  public:
  // .commonmodule.PhaseSPS VolLmtLo = 17;
  bool has_vollmtlo() const;
  void clear_vollmtlo() ;
  const ::commonmodule::PhaseSPS& vollmtlo() const;
  [[nodiscard]] ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE release_vollmtlo();
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL mutable_vollmtlo();
  void set_allocated_vollmtlo(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vollmtlo(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE unsafe_arena_release_vollmtlo();

  private:
  const ::commonmodule::PhaseSPS& _internal_vollmtlo() const;
  ::commonmodule::PhaseSPS* PROTOBUF_NONNULL _internal_mutable_vollmtlo();

  public:
  // .commonmodule.PhaseAPC VolSpt = 18;
  bool has_volspt() const;
  void clear_volspt() ;
  const ::commonmodule::PhaseAPC& volspt() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_volspt();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_volspt();
  void set_allocated_volspt(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_volspt(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_volspt();

  private:
  const ::commonmodule::PhaseAPC& _internal_volspt() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_volspt();

  public:
  // .commonmodule.StatusSPS voltageSetPointEnabled = 19;
  bool has_voltagesetpointenabled() const;
  void clear_voltagesetpointenabled() ;
  const ::commonmodule::StatusSPS& voltagesetpointenabled() const;
  [[nodiscard]] ::commonmodule::StatusSPS* PROTOBUF_NULLABLE release_voltagesetpointenabled();
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusSPS* PROTOBUF_NULLABLE unsafe_arena_release_voltagesetpointenabled();

  private:
  const ::commonmodule::StatusSPS& _internal_voltagesetpointenabled() const;
  ::commonmodule::StatusSPS* PROTOBUF_NONNULL _internal_mutable_voltagesetpointenabled();

  public:
  // .commonmodule.Optional_DirectionModeKind DirMod = 20;
  bool has_dirmod() const;
  void clear_dirmod() ;
  const ::commonmodule::Optional_DirectionModeKind& dirmod() const;
  [[nodiscard]] ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE release_dirmod();
  ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL mutable_dirmod();
  void set_allocated_dirmod(::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirmod(::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value);
  ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE unsafe_arena_release_dirmod();

  private:
  const ::commonmodule::Optional_DirectionModeKind& _internal_dirmod() const;
  ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL _internal_mutable_dirmod();

  public:
  // .commonmodule.Optional_VoltLimitModeKind VolLmtMode = 21;
  bool has_vollmtmode() const;
  void clear_vollmtmode() ;
  const ::commonmodule::Optional_VoltLimitModeKind& vollmtmode() const;
  [[nodiscard]] ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE release_vollmtmode();
  ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL mutable_vollmtmode();
  void set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value);
  ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE unsafe_arena_release_vollmtmode();

  private:
  const ::commonmodule::Optional_VoltLimitModeKind& _internal_vollmtmode() const;
  ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL _internal_mutable_vollmtmode();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventAndStatusATCC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 21,
                                   21, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorEventAndStatusATCC& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE bndctr_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE bndwid_;
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE bndwidhi_;
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE bndwidlo_;
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE dirctlrev_;
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE dirindt_;
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE dirrev_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE ldcr_;
    ::commonmodule::ASG* PROTOBUF_NULLABLE ldcx_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE parop_;
    ::commonmodule::RampRate* PROTOBUF_NULLABLE ramprates_;
    ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE state_;
    ::commonmodule::StatusINC* PROTOBUF_NULLABLE stdltmms_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE tapoperr_;
    ::commonmodule::PhaseINS* PROTOBUF_NULLABLE tappos_;
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE vollmthi_;
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE vollmtlo_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE volspt_;
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE voltagesetpointenabled_;
    ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE dirmod_;
    ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE vollmtmode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorEventAndStatusATCC_class_data_;
// -------------------------------------------------------------------

class RegulatorControlATCC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlATCC) */ {
 public:
  inline RegulatorControlATCC() : RegulatorControlATCC(nullptr) {}
  ~RegulatorControlATCC() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorControlATCC* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorControlATCC));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorControlATCC(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorControlATCC(const RegulatorControlATCC& from) : RegulatorControlATCC(nullptr, from) {}
  inline RegulatorControlATCC(RegulatorControlATCC&& from) noexcept
      : RegulatorControlATCC(nullptr, ::std::move(from)) {}
  inline RegulatorControlATCC& operator=(const RegulatorControlATCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlATCC& operator=(RegulatorControlATCC&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlATCC& default_instance() {
    return *reinterpret_cast<const RegulatorControlATCC*>(
        &_RegulatorControlATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RegulatorControlATCC& a, RegulatorControlATCC& b) { a.Swap(&b); }
  inline void Swap(RegulatorControlATCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlATCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlATCC* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorControlATCC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorControlATCC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorControlATCC& from) { RegulatorControlATCC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorControlATCC* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorControlATCC"; }

 protected:
  explicit RegulatorControlATCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorControlATCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorControlATCC& from);
  RegulatorControlATCC(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorControlATCC&& from) noexcept
      : RegulatorControlATCC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kDirFwdFieldNumber = 2,
    kDirModeFieldNumber = 3,
    kDirRevFieldNumber = 4,
    kDirThdFieldNumber = 5,
    kParOpFieldNumber = 6,
    kRampRatesFieldNumber = 7,
    kStateFieldNumber = 8,
    kTapOpLFieldNumber = 9,
    kTapOpRFieldNumber = 10,
    kVolLmtHiFieldNumber = 11,
    kVolLmtLoFieldNumber = 12,
    kVolLmtModeFieldNumber = 13,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforcontrol();

  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL _internal_mutable_logicalnodeforcontrol();

  public:
  // .regulatormodule.DirectionalATCC DirFwd = 2;
  bool has_dirfwd() const;
  void clear_dirfwd() ;
  const ::regulatormodule::DirectionalATCC& dirfwd() const;
  [[nodiscard]] ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE release_dirfwd();
  ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL mutable_dirfwd();
  void set_allocated_dirfwd(::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirfwd(::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value);
  ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE unsafe_arena_release_dirfwd();

  private:
  const ::regulatormodule::DirectionalATCC& _internal_dirfwd() const;
  ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL _internal_mutable_dirfwd();

  public:
  // .commonmodule.Optional_DirectionModeKind DirMode = 3;
  bool has_dirmode() const;
  void clear_dirmode() ;
  const ::commonmodule::Optional_DirectionModeKind& dirmode() const;
  [[nodiscard]] ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE release_dirmode();
  ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL mutable_dirmode();
  void set_allocated_dirmode(::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirmode(::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value);
  ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE unsafe_arena_release_dirmode();

  private:
  const ::commonmodule::Optional_DirectionModeKind& _internal_dirmode() const;
  ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL _internal_mutable_dirmode();

  public:
  // .regulatormodule.DirectionalATCC DirRev = 4;
  bool has_dirrev() const;
  void clear_dirrev() ;
  const ::regulatormodule::DirectionalATCC& dirrev() const;
  [[nodiscard]] ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE release_dirrev();
  ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL mutable_dirrev();
  void set_allocated_dirrev(::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirrev(::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value);
  ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE unsafe_arena_release_dirrev();

  private:
  const ::regulatormodule::DirectionalATCC& _internal_dirrev() const;
  ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL _internal_mutable_dirrev();

  public:
  // .commonmodule.PhaseAPC DirThd = 5;
  bool has_dirthd() const;
  void clear_dirthd() ;
  const ::commonmodule::PhaseAPC& dirthd() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_dirthd();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_dirthd();
  void set_allocated_dirthd(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dirthd(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_dirthd();

  private:
  const ::commonmodule::PhaseAPC& _internal_dirthd() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_dirthd();

  public:
  // .commonmodule.PhaseSPC ParOp = 6;
  bool has_parop() const;
  void clear_parop() ;
  const ::commonmodule::PhaseSPC& parop() const;
  [[nodiscard]] ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE release_parop();
  ::commonmodule::PhaseSPC* PROTOBUF_NONNULL mutable_parop();
  void set_allocated_parop(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_parop(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE unsafe_arena_release_parop();

  private:
  const ::commonmodule::PhaseSPC& _internal_parop() const;
  ::commonmodule::PhaseSPC* PROTOBUF_NONNULL _internal_mutable_parop();

  public:
  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  [[nodiscard]] ::commonmodule::RampRate* PROTOBUF_NULLABLE release_ramprates();
  ::commonmodule::RampRate* PROTOBUF_NONNULL mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value);
  ::commonmodule::RampRate* PROTOBUF_NULLABLE unsafe_arena_release_ramprates();

  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* PROTOBUF_NONNULL _internal_mutable_ramprates();

  public:
  // .commonmodule.Optional_StateKind state = 8;
  bool has_state() const;
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  [[nodiscard]] ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE release_state();
  ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_state(::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value);
  ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE unsafe_arena_release_state();

  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // .commonmodule.PhaseSPC TapOpL = 9;
  bool has_tapopl() const;
  void clear_tapopl() ;
  const ::commonmodule::PhaseSPC& tapopl() const;
  [[nodiscard]] ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE release_tapopl();
  ::commonmodule::PhaseSPC* PROTOBUF_NONNULL mutable_tapopl();
  void set_allocated_tapopl(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tapopl(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE unsafe_arena_release_tapopl();

  private:
  const ::commonmodule::PhaseSPC& _internal_tapopl() const;
  ::commonmodule::PhaseSPC* PROTOBUF_NONNULL _internal_mutable_tapopl();

  public:
  // .commonmodule.PhaseSPC TapOpR = 10;
  bool has_tapopr() const;
  void clear_tapopr() ;
  const ::commonmodule::PhaseSPC& tapopr() const;
  [[nodiscard]] ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE release_tapopr();
  ::commonmodule::PhaseSPC* PROTOBUF_NONNULL mutable_tapopr();
  void set_allocated_tapopr(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tapopr(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE unsafe_arena_release_tapopr();

  private:
  const ::commonmodule::PhaseSPC& _internal_tapopr() const;
  ::commonmodule::PhaseSPC* PROTOBUF_NONNULL _internal_mutable_tapopr();

  public:
  // .commonmodule.PhaseAPC VolLmtHi = 11;
  bool has_vollmthi() const;
  void clear_vollmthi() ;
  const ::commonmodule::PhaseAPC& vollmthi() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_vollmthi();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_vollmthi();
  void set_allocated_vollmthi(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vollmthi(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_vollmthi();

  private:
  const ::commonmodule::PhaseAPC& _internal_vollmthi() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_vollmthi();

  public:
  // .commonmodule.PhaseAPC VolLmtLo = 12;
  bool has_vollmtlo() const;
  void clear_vollmtlo() ;
  const ::commonmodule::PhaseAPC& vollmtlo() const;
  [[nodiscard]] ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE release_vollmtlo();
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL mutable_vollmtlo();
  void set_allocated_vollmtlo(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vollmtlo(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE unsafe_arena_release_vollmtlo();

  private:
  const ::commonmodule::PhaseAPC& _internal_vollmtlo() const;
  ::commonmodule::PhaseAPC* PROTOBUF_NONNULL _internal_mutable_vollmtlo();

  public:
  // .commonmodule.Optional_VoltLimitModeKind VolLmtMode = 13;
  bool has_vollmtmode() const;
  void clear_vollmtmode() ;
  const ::commonmodule::Optional_VoltLimitModeKind& vollmtmode() const;
  [[nodiscard]] ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE release_vollmtmode();
  ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL mutable_vollmtmode();
  void set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value);
  ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE unsafe_arena_release_vollmtmode();

  private:
  const ::commonmodule::Optional_VoltLimitModeKind& _internal_vollmtmode() const;
  ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL _internal_mutable_vollmtmode();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlATCC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13,
                                   13, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorControlATCC& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE logicalnodeforcontrol_;
    ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE dirfwd_;
    ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE dirmode_;
    ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE dirrev_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE dirthd_;
    ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE parop_;
    ::commonmodule::RampRate* PROTOBUF_NULLABLE ramprates_;
    ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE state_;
    ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE tapopl_;
    ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE tapopr_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE vollmthi_;
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE vollmtlo_;
    ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE vollmtmode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorControlATCC_class_data_;
// -------------------------------------------------------------------

class RegulatorReading final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorReading) */ {
 public:
  inline RegulatorReading() : RegulatorReading(nullptr) {}
  ~RegulatorReading() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorReading* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorReading));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorReading(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorReading(const RegulatorReading& from) : RegulatorReading(nullptr, from) {}
  inline RegulatorReading(RegulatorReading&& from) noexcept
      : RegulatorReading(nullptr, ::std::move(from)) {}
  inline RegulatorReading& operator=(const RegulatorReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorReading& operator=(RegulatorReading&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorReading& default_instance() {
    return *reinterpret_cast<const RegulatorReading*>(
        &_RegulatorReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(RegulatorReading& a, RegulatorReading& b) { a.Swap(&b); }
  inline void Swap(RegulatorReading* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorReading* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorReading* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorReading>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorReading& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorReading& from) { RegulatorReading::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorReading* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorReading"; }

 protected:
  explicit RegulatorReading(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorReading(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorReading& from);
  RegulatorReading(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorReading&& from) noexcept
      : RegulatorReading(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kPhaseMMTNFieldNumber = 2,
    kReadingMMTRFieldNumber = 3,
    kReadingMMXUFieldNumber = 4,
    kSecondaryReadingMMXUFieldNumber = 5,
    kReadingMMDCFieldNumber = 6,
  };
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  [[nodiscard]] ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value);
  ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE unsafe_arena_release_conductingequipmentterminalreading();

  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL _internal_mutable_conductingequipmentterminalreading();

  public:
  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  [[nodiscard]] ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE release_phasemmtn();
  ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_phasemmtn(::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value);
  ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE unsafe_arena_release_phasemmtn();

  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL _internal_mutable_phasemmtn();

  public:
  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  [[nodiscard]] ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE release_readingmmtr();
  ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmmtr(::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE unsafe_arena_release_readingmmtr();

  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL _internal_mutable_readingmmtr();

  public:
  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  [[nodiscard]] ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE release_readingmmxu();
  ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE unsafe_arena_release_readingmmxu();

  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL _internal_mutable_readingmmxu();

  public:
  // .commonmodule.ReadingMMXU secondaryReadingMMXU = 5;
  bool has_secondaryreadingmmxu() const;
  void clear_secondaryreadingmmxu() ;
  const ::commonmodule::ReadingMMXU& secondaryreadingmmxu() const;
  [[nodiscard]] ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE release_secondaryreadingmmxu();
  ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL mutable_secondaryreadingmmxu();
  void set_allocated_secondaryreadingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_secondaryreadingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE unsafe_arena_release_secondaryreadingmmxu();

  private:
  const ::commonmodule::ReadingMMXU& _internal_secondaryreadingmmxu() const;
  ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL _internal_mutable_secondaryreadingmmxu();

  public:
  // .commonmodule.ReadingMMDC readingMMDC = 6;
  bool has_readingmmdc() const;
  void clear_readingmmdc() ;
  const ::commonmodule::ReadingMMDC& readingmmdc() const;
  [[nodiscard]] ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE release_readingmmdc();
  ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL mutable_readingmmdc();
  void set_allocated_readingmmdc(::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmmdc(::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE unsafe_arena_release_readingmmdc();

  private:
  const ::commonmodule::ReadingMMDC& _internal_readingmmdc() const;
  ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL _internal_mutable_readingmmdc();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorReading)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorReading& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE conductingequipmentterminalreading_;
    ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE phasemmtn_;
    ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE readingmmtr_;
    ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE readingmmxu_;
    ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE secondaryreadingmmxu_;
    ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE readingmmdc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorReading_class_data_;
// -------------------------------------------------------------------

class RegulatorPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorPoint) */ {
 public:
  inline RegulatorPoint() : RegulatorPoint(nullptr) {}
  ~RegulatorPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorPoint* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorPoint(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorPoint(const RegulatorPoint& from) : RegulatorPoint(nullptr, from) {}
  inline RegulatorPoint(RegulatorPoint&& from) noexcept
      : RegulatorPoint(nullptr, ::std::move(from)) {}
  inline RegulatorPoint& operator=(const RegulatorPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorPoint& operator=(RegulatorPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorPoint& default_instance() {
    return *reinterpret_cast<const RegulatorPoint*>(
        &_RegulatorPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RegulatorPoint& a, RegulatorPoint& b) { a.Swap(&b); }
  inline void Swap(RegulatorPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorPoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorPoint& from) { RegulatorPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorPoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorPoint"; }

 protected:
  explicit RegulatorPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorPoint& from);
  RegulatorPoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorPoint&& from) noexcept
      : RegulatorPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlFieldNumber = 1,
    kStartTimeFieldNumber = 8,
  };
  // .regulatormodule.RegulatorControlATCC control = 1;
  bool has_control() const;
  void clear_control() ;
  const ::regulatormodule::RegulatorControlATCC& control() const;
  [[nodiscard]] ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE release_control();
  ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL mutable_control();
  void set_allocated_control(::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_control(::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE unsafe_arena_release_control();

  private:
  const ::regulatormodule::RegulatorControlATCC& _internal_control() const;
  ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL _internal_mutable_control();

  public:
  // .commonmodule.Timestamp startTime = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  void clear_starttime() ;
  const ::commonmodule::Timestamp& starttime() const;
  [[nodiscard]] ::commonmodule::Timestamp* PROTOBUF_NULLABLE release_starttime();
  ::commonmodule::Timestamp* PROTOBUF_NONNULL mutable_starttime();
  void set_allocated_starttime(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_starttime(::commonmodule::Timestamp* PROTOBUF_NULLABLE value);
  ::commonmodule::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_starttime();

  private:
  const ::commonmodule::Timestamp& _internal_starttime() const;
  ::commonmodule::Timestamp* PROTOBUF_NONNULL _internal_mutable_starttime();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE control_;
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE starttime_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorPoint_class_data_;
// -------------------------------------------------------------------

class RegulatorEventAndStatusANCR final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventAndStatusANCR) */ {
 public:
  inline RegulatorEventAndStatusANCR() : RegulatorEventAndStatusANCR(nullptr) {}
  ~RegulatorEventAndStatusANCR() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorEventAndStatusANCR* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorEventAndStatusANCR));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorEventAndStatusANCR(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorEventAndStatusANCR(const RegulatorEventAndStatusANCR& from) : RegulatorEventAndStatusANCR(nullptr, from) {}
  inline RegulatorEventAndStatusANCR(RegulatorEventAndStatusANCR&& from) noexcept
      : RegulatorEventAndStatusANCR(nullptr, ::std::move(from)) {}
  inline RegulatorEventAndStatusANCR& operator=(const RegulatorEventAndStatusANCR& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEventAndStatusANCR& operator=(RegulatorEventAndStatusANCR&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEventAndStatusANCR& default_instance() {
    return *reinterpret_cast<const RegulatorEventAndStatusANCR*>(
        &_RegulatorEventAndStatusANCR_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RegulatorEventAndStatusANCR& a, RegulatorEventAndStatusANCR& b) { a.Swap(&b); }
  inline void Swap(RegulatorEventAndStatusANCR* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEventAndStatusANCR* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEventAndStatusANCR* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorEventAndStatusANCR>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorEventAndStatusANCR& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorEventAndStatusANCR& from) { RegulatorEventAndStatusANCR::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorEventAndStatusANCR* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorEventAndStatusANCR"; }

 protected:
  explicit RegulatorEventAndStatusANCR(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorEventAndStatusANCR(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorEventAndStatusANCR& from);
  RegulatorEventAndStatusANCR(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorEventAndStatusANCR&& from) noexcept
      : RegulatorEventAndStatusANCR(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kDynamicTestFieldNumber = 2,
    kPointStatusFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  [[nodiscard]] ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value);
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE unsafe_arena_release_logicalnodeforeventandstatus();

  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL _internal_mutable_logicalnodeforeventandstatus();

  public:
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  [[nodiscard]] ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NONNULL mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE value);
  ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE unsafe_arena_release_dynamictest();

  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NONNULL _internal_mutable_dynamictest();

  public:
  // .regulatormodule.RegulatorEventAndStatusATCC PointStatus = 3;
  bool has_pointstatus() const;
  void clear_pointstatus() ;
  const ::regulatormodule::RegulatorEventAndStatusATCC& pointstatus() const;
  [[nodiscard]] ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE release_pointstatus();
  ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NONNULL mutable_pointstatus();
  void set_allocated_pointstatus(::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pointstatus(::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE unsafe_arena_release_pointstatus();

  private:
  const ::regulatormodule::RegulatorEventAndStatusATCC& _internal_pointstatus() const;
  ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NONNULL _internal_mutable_pointstatus();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventAndStatusANCR)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorEventAndStatusANCR& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE logicalnodeforeventandstatus_;
    ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE dynamictest_;
    ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE pointstatus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorEventAndStatusANCR_class_data_;
// -------------------------------------------------------------------

class RegulatorDiscreteControl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorDiscreteControl) */ {
 public:
  inline RegulatorDiscreteControl() : RegulatorDiscreteControl(nullptr) {}
  ~RegulatorDiscreteControl() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorDiscreteControl* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorDiscreteControl));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorDiscreteControl(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorDiscreteControl(const RegulatorDiscreteControl& from) : RegulatorDiscreteControl(nullptr, from) {}
  inline RegulatorDiscreteControl(RegulatorDiscreteControl&& from) noexcept
      : RegulatorDiscreteControl(nullptr, ::std::move(from)) {}
  inline RegulatorDiscreteControl& operator=(const RegulatorDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorDiscreteControl& operator=(RegulatorDiscreteControl&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorDiscreteControl& default_instance() {
    return *reinterpret_cast<const RegulatorDiscreteControl*>(
        &_RegulatorDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RegulatorDiscreteControl& a, RegulatorDiscreteControl& b) { a.Swap(&b); }
  inline void Swap(RegulatorDiscreteControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorDiscreteControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorDiscreteControl* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorDiscreteControl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorDiscreteControl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorDiscreteControl& from) { RegulatorDiscreteControl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorDiscreteControl* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorDiscreteControl"; }

 protected:
  explicit RegulatorDiscreteControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorDiscreteControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorDiscreteControl& from);
  RegulatorDiscreteControl(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorDiscreteControl&& from) noexcept
      : RegulatorDiscreteControl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kRegulatorControlATCCFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  [[nodiscard]] ::commonmodule::ControlValue* PROTOBUF_NULLABLE release_controlvalue();
  ::commonmodule::ControlValue* PROTOBUF_NONNULL mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlValue* PROTOBUF_NULLABLE unsafe_arena_release_controlvalue();

  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* PROTOBUF_NONNULL _internal_mutable_controlvalue();

  public:
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  [[nodiscard]] ::commonmodule::CheckConditions* PROTOBUF_NULLABLE release_check();
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  ::commonmodule::CheckConditions* PROTOBUF_NULLABLE unsafe_arena_release_check();

  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL _internal_mutable_check();

  public:
  // .regulatormodule.RegulatorControlATCC regulatorControlATCC = 3;
  bool has_regulatorcontrolatcc() const;
  void clear_regulatorcontrolatcc() ;
  const ::regulatormodule::RegulatorControlATCC& regulatorcontrolatcc() const;
  [[nodiscard]] ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE release_regulatorcontrolatcc();
  ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL mutable_regulatorcontrolatcc();
  void set_allocated_regulatorcontrolatcc(::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorcontrolatcc(::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE unsafe_arena_release_regulatorcontrolatcc();

  private:
  const ::regulatormodule::RegulatorControlATCC& _internal_regulatorcontrolatcc() const;
  ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL _internal_mutable_regulatorcontrolatcc();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorDiscreteControl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorDiscreteControl& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE controlvalue_;
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE check_;
    ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE regulatorcontrolatcc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorDiscreteControl_class_data_;
// -------------------------------------------------------------------

class RegulatorStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorStatus) */ {
 public:
  inline RegulatorStatus() : RegulatorStatus(nullptr) {}
  ~RegulatorStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorStatus(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorStatus(const RegulatorStatus& from) : RegulatorStatus(nullptr, from) {}
  inline RegulatorStatus(RegulatorStatus&& from) noexcept
      : RegulatorStatus(nullptr, ::std::move(from)) {}
  inline RegulatorStatus& operator=(const RegulatorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorStatus& operator=(RegulatorStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorStatus& default_instance() {
    return *reinterpret_cast<const RegulatorStatus*>(
        &_RegulatorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RegulatorStatus& a, RegulatorStatus& b) { a.Swap(&b); }
  inline void Swap(RegulatorStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorStatus& from) { RegulatorStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorStatus"; }

 protected:
  explicit RegulatorStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorStatus& from);
  RegulatorStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorStatus&& from) noexcept
      : RegulatorStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusValueFieldNumber = 1,
    kRegulatorEventAndStatusANCRFieldNumber = 2,
  };
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  [[nodiscard]] ::commonmodule::StatusValue* PROTOBUF_NULLABLE release_statusvalue();
  ::commonmodule::StatusValue* PROTOBUF_NONNULL mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_statusvalue(::commonmodule::StatusValue* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusValue* PROTOBUF_NULLABLE unsafe_arena_release_statusvalue();

  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* PROTOBUF_NONNULL _internal_mutable_statusvalue();

  public:
  // .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
  bool has_regulatoreventandstatusancr() const;
  void clear_regulatoreventandstatusancr() ;
  const ::regulatormodule::RegulatorEventAndStatusANCR& regulatoreventandstatusancr() const;
  [[nodiscard]] ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE release_regulatoreventandstatusancr();
  ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL mutable_regulatoreventandstatusancr();
  void set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE unsafe_arena_release_regulatoreventandstatusancr();

  private:
  const ::regulatormodule::RegulatorEventAndStatusANCR& _internal_regulatoreventandstatusancr() const;
  ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL _internal_mutable_regulatoreventandstatusancr();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::StatusValue* PROTOBUF_NULLABLE statusvalue_;
    ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE regulatoreventandstatusancr_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorStatus_class_data_;
// -------------------------------------------------------------------

class RegulatorReadingProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorReadingProfile) */ {
 public:
  inline RegulatorReadingProfile() : RegulatorReadingProfile(nullptr) {}
  ~RegulatorReadingProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorReadingProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorReadingProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorReadingProfile(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorReadingProfile(const RegulatorReadingProfile& from) : RegulatorReadingProfile(nullptr, from) {}
  inline RegulatorReadingProfile(RegulatorReadingProfile&& from) noexcept
      : RegulatorReadingProfile(nullptr, ::std::move(from)) {}
  inline RegulatorReadingProfile& operator=(const RegulatorReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorReadingProfile& operator=(RegulatorReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorReadingProfile& default_instance() {
    return *reinterpret_cast<const RegulatorReadingProfile*>(
        &_RegulatorReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RegulatorReadingProfile& a, RegulatorReadingProfile& b) { a.Swap(&b); }
  inline void Swap(RegulatorReadingProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorReadingProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorReadingProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorReadingProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorReadingProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorReadingProfile& from) { RegulatorReadingProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorReadingProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorReadingProfile"; }

 protected:
  explicit RegulatorReadingProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorReadingProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorReadingProfile& from);
  RegulatorReadingProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorReadingProfile&& from) noexcept
      : RegulatorReadingProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRegulatorReadingFieldNumber = 2,
    kReadingMessageInfoFieldNumber = 1,
    kRegulatorSystemFieldNumber = 3,
  };
  // repeated .regulatormodule.RegulatorReading regulatorReading = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
  int regulatorreading_size() const;
  private:
  int _internal_regulatorreading_size() const;

  public:
  void clear_regulatorreading() ;
  ::regulatormodule::RegulatorReading* PROTOBUF_NONNULL mutable_regulatorreading(int index);
  ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>* PROTOBUF_NONNULL mutable_regulatorreading();

  private:
  const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>& _internal_regulatorreading() const;
  ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>* PROTOBUF_NONNULL _internal_mutable_regulatorreading();
  public:
  const ::regulatormodule::RegulatorReading& regulatorreading(int index) const;
  ::regulatormodule::RegulatorReading* PROTOBUF_NONNULL add_regulatorreading();
  const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>& regulatorreading() const;
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  [[nodiscard]] ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_readingmessageinfo();

  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL _internal_mutable_readingmessageinfo();

  public:
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  [[nodiscard]] ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE unsafe_arena_release_regulatorsystem();

  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL _internal_mutable_regulatorsystem();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorReadingProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorReadingProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorReading > regulatorreading_;
    ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE readingmessageinfo_;
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE regulatorsystem_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorReadingProfile_class_data_;
// -------------------------------------------------------------------

class RegulatorEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEvent) */ {
 public:
  inline RegulatorEvent() : RegulatorEvent(nullptr) {}
  ~RegulatorEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorEvent* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorEvent(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorEvent(const RegulatorEvent& from) : RegulatorEvent(nullptr, from) {}
  inline RegulatorEvent(RegulatorEvent&& from) noexcept
      : RegulatorEvent(nullptr, ::std::move(from)) {}
  inline RegulatorEvent& operator=(const RegulatorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEvent& operator=(RegulatorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEvent& default_instance() {
    return *reinterpret_cast<const RegulatorEvent*>(
        &_RegulatorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RegulatorEvent& a, RegulatorEvent& b) { a.Swap(&b); }
  inline void Swap(RegulatorEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorEvent& from) { RegulatorEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorEvent"; }

 protected:
  explicit RegulatorEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorEvent& from);
  RegulatorEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorEvent&& from) noexcept
      : RegulatorEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventValueFieldNumber = 1,
    kRegulatorEventAndStatusANCRFieldNumber = 2,
  };
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  [[nodiscard]] ::commonmodule::EventValue* PROTOBUF_NULLABLE release_eventvalue();
  ::commonmodule::EventValue* PROTOBUF_NONNULL mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventvalue(::commonmodule::EventValue* PROTOBUF_NULLABLE value);
  ::commonmodule::EventValue* PROTOBUF_NULLABLE unsafe_arena_release_eventvalue();

  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* PROTOBUF_NONNULL _internal_mutable_eventvalue();

  public:
  // .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
  bool has_regulatoreventandstatusancr() const;
  void clear_regulatoreventandstatusancr() ;
  const ::regulatormodule::RegulatorEventAndStatusANCR& regulatoreventandstatusancr() const;
  [[nodiscard]] ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE release_regulatoreventandstatusancr();
  ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL mutable_regulatoreventandstatusancr();
  void set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE unsafe_arena_release_regulatoreventandstatusancr();

  private:
  const ::regulatormodule::RegulatorEventAndStatusANCR& _internal_regulatoreventandstatusancr() const;
  ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL _internal_mutable_regulatoreventandstatusancr();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::EventValue* PROTOBUF_NULLABLE eventvalue_;
    ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE regulatoreventandstatusancr_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorEvent_class_data_;
// -------------------------------------------------------------------

class RegulatorDiscreteControlProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorDiscreteControlProfile) */ {
 public:
  inline RegulatorDiscreteControlProfile() : RegulatorDiscreteControlProfile(nullptr) {}
  ~RegulatorDiscreteControlProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorDiscreteControlProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorDiscreteControlProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorDiscreteControlProfile(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorDiscreteControlProfile(const RegulatorDiscreteControlProfile& from) : RegulatorDiscreteControlProfile(nullptr, from) {}
  inline RegulatorDiscreteControlProfile(RegulatorDiscreteControlProfile&& from) noexcept
      : RegulatorDiscreteControlProfile(nullptr, ::std::move(from)) {}
  inline RegulatorDiscreteControlProfile& operator=(const RegulatorDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorDiscreteControlProfile& operator=(RegulatorDiscreteControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorDiscreteControlProfile& default_instance() {
    return *reinterpret_cast<const RegulatorDiscreteControlProfile*>(
        &_RegulatorDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RegulatorDiscreteControlProfile& a, RegulatorDiscreteControlProfile& b) { a.Swap(&b); }
  inline void Swap(RegulatorDiscreteControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorDiscreteControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorDiscreteControlProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorDiscreteControlProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorDiscreteControlProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorDiscreteControlProfile& from) { RegulatorDiscreteControlProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorDiscreteControlProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorDiscreteControlProfile"; }

 protected:
  explicit RegulatorDiscreteControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorDiscreteControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorDiscreteControlProfile& from);
  RegulatorDiscreteControlProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorDiscreteControlProfile&& from) noexcept
      : RegulatorDiscreteControlProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kRegulatorDiscreteControlFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  [[nodiscard]] ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_controlmessageinfo();

  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL _internal_mutable_controlmessageinfo();

  public:
  // .regulatormodule.RegulatorDiscreteControl regulatorDiscreteControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatordiscretecontrol() const;
  void clear_regulatordiscretecontrol() ;
  const ::regulatormodule::RegulatorDiscreteControl& regulatordiscretecontrol() const;
  [[nodiscard]] ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE release_regulatordiscretecontrol();
  ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NONNULL mutable_regulatordiscretecontrol();
  void set_allocated_regulatordiscretecontrol(::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatordiscretecontrol(::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE unsafe_arena_release_regulatordiscretecontrol();

  private:
  const ::regulatormodule::RegulatorDiscreteControl& _internal_regulatordiscretecontrol() const;
  ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NONNULL _internal_mutable_regulatordiscretecontrol();

  public:
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  [[nodiscard]] ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE unsafe_arena_release_regulatorsystem();

  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL _internal_mutable_regulatorsystem();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorDiscreteControlProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorDiscreteControlProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE controlmessageinfo_;
    ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE regulatordiscretecontrol_;
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE regulatorsystem_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorDiscreteControlProfile_class_data_;
// -------------------------------------------------------------------

class RegulatorCSG final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorCSG) */ {
 public:
  inline RegulatorCSG() : RegulatorCSG(nullptr) {}
  ~RegulatorCSG() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorCSG* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorCSG));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorCSG(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorCSG(const RegulatorCSG& from) : RegulatorCSG(nullptr, from) {}
  inline RegulatorCSG(RegulatorCSG&& from) noexcept
      : RegulatorCSG(nullptr, ::std::move(from)) {}
  inline RegulatorCSG& operator=(const RegulatorCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorCSG& operator=(RegulatorCSG&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorCSG& default_instance() {
    return *reinterpret_cast<const RegulatorCSG*>(
        &_RegulatorCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(RegulatorCSG& a, RegulatorCSG& b) { a.Swap(&b); }
  inline void Swap(RegulatorCSG* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorCSG* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorCSG* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorCSG>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorCSG& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorCSG& from) { RegulatorCSG::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorCSG* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorCSG"; }

 protected:
  explicit RegulatorCSG(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorCSG(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorCSG& from);
  RegulatorCSG(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorCSG&& from) noexcept
      : RegulatorCSG(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .regulatormodule.RegulatorPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::regulatormodule::RegulatorPoint* PROTOBUF_NONNULL mutable_crvpts(int index);
  ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>* PROTOBUF_NONNULL mutable_crvpts();

  private:
  const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>& _internal_crvpts() const;
  ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>* PROTOBUF_NONNULL _internal_mutable_crvpts();
  public:
  const ::regulatormodule::RegulatorPoint& crvpts(int index) const;
  ::regulatormodule::RegulatorPoint* PROTOBUF_NONNULL add_crvpts();
  const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>& crvpts() const;
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorCSG)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorCSG& from_msg);
    ::google::protobuf::RepeatedPtrField< ::regulatormodule::RegulatorPoint > crvpts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorCSG_class_data_;
// -------------------------------------------------------------------

class RegulatorStatusProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorStatusProfile) */ {
 public:
  inline RegulatorStatusProfile() : RegulatorStatusProfile(nullptr) {}
  ~RegulatorStatusProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorStatusProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorStatusProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorStatusProfile(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorStatusProfile(const RegulatorStatusProfile& from) : RegulatorStatusProfile(nullptr, from) {}
  inline RegulatorStatusProfile(RegulatorStatusProfile&& from) noexcept
      : RegulatorStatusProfile(nullptr, ::std::move(from)) {}
  inline RegulatorStatusProfile& operator=(const RegulatorStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorStatusProfile& operator=(RegulatorStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorStatusProfile& default_instance() {
    return *reinterpret_cast<const RegulatorStatusProfile*>(
        &_RegulatorStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RegulatorStatusProfile& a, RegulatorStatusProfile& b) { a.Swap(&b); }
  inline void Swap(RegulatorStatusProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorStatusProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorStatusProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorStatusProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorStatusProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorStatusProfile& from) { RegulatorStatusProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorStatusProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorStatusProfile"; }

 protected:
  explicit RegulatorStatusProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorStatusProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorStatusProfile& from);
  RegulatorStatusProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorStatusProfile&& from) noexcept
      : RegulatorStatusProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kRegulatorStatusFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  [[nodiscard]] ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_statusmessageinfo();

  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL _internal_mutable_statusmessageinfo();

  public:
  // .regulatormodule.RegulatorStatus regulatorStatus = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorstatus() const;
  void clear_regulatorstatus() ;
  const ::regulatormodule::RegulatorStatus& regulatorstatus() const;
  [[nodiscard]] ::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE release_regulatorstatus();
  ::regulatormodule::RegulatorStatus* PROTOBUF_NONNULL mutable_regulatorstatus();
  void set_allocated_regulatorstatus(::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorstatus(::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE unsafe_arena_release_regulatorstatus();

  private:
  const ::regulatormodule::RegulatorStatus& _internal_regulatorstatus() const;
  ::regulatormodule::RegulatorStatus* PROTOBUF_NONNULL _internal_mutable_regulatorstatus();

  public:
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  [[nodiscard]] ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE unsafe_arena_release_regulatorsystem();

  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL _internal_mutable_regulatorsystem();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorStatusProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorStatusProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE statusmessageinfo_;
    ::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE regulatorstatus_;
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE regulatorsystem_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorStatusProfile_class_data_;
// -------------------------------------------------------------------

class RegulatorEventProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventProfile) */ {
 public:
  inline RegulatorEventProfile() : RegulatorEventProfile(nullptr) {}
  ~RegulatorEventProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorEventProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorEventProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorEventProfile(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorEventProfile(const RegulatorEventProfile& from) : RegulatorEventProfile(nullptr, from) {}
  inline RegulatorEventProfile(RegulatorEventProfile&& from) noexcept
      : RegulatorEventProfile(nullptr, ::std::move(from)) {}
  inline RegulatorEventProfile& operator=(const RegulatorEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEventProfile& operator=(RegulatorEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEventProfile& default_instance() {
    return *reinterpret_cast<const RegulatorEventProfile*>(
        &_RegulatorEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(RegulatorEventProfile& a, RegulatorEventProfile& b) { a.Swap(&b); }
  inline void Swap(RegulatorEventProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEventProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEventProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorEventProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorEventProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorEventProfile& from) { RegulatorEventProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorEventProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorEventProfile"; }

 protected:
  explicit RegulatorEventProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorEventProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorEventProfile& from);
  RegulatorEventProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorEventProfile&& from) noexcept
      : RegulatorEventProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kRegulatorEventFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  [[nodiscard]] ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_eventmessageinfo();

  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL _internal_mutable_eventmessageinfo();

  public:
  // .regulatormodule.RegulatorEvent regulatorEvent = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorevent() const;
  void clear_regulatorevent() ;
  const ::regulatormodule::RegulatorEvent& regulatorevent() const;
  [[nodiscard]] ::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE release_regulatorevent();
  ::regulatormodule::RegulatorEvent* PROTOBUF_NONNULL mutable_regulatorevent();
  void set_allocated_regulatorevent(::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorevent(::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE unsafe_arena_release_regulatorevent();

  private:
  const ::regulatormodule::RegulatorEvent& _internal_regulatorevent() const;
  ::regulatormodule::RegulatorEvent* PROTOBUF_NONNULL _internal_mutable_regulatorevent();

  public:
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  [[nodiscard]] ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE unsafe_arena_release_regulatorsystem();

  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL _internal_mutable_regulatorsystem();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorEventProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE eventmessageinfo_;
    ::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE regulatorevent_;
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE regulatorsystem_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorEventProfile_class_data_;
// -------------------------------------------------------------------

class RegulatorControlScheduleFSCH final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlScheduleFSCH) */ {
 public:
  inline RegulatorControlScheduleFSCH() : RegulatorControlScheduleFSCH(nullptr) {}
  ~RegulatorControlScheduleFSCH() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorControlScheduleFSCH* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorControlScheduleFSCH));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorControlScheduleFSCH(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorControlScheduleFSCH(const RegulatorControlScheduleFSCH& from) : RegulatorControlScheduleFSCH(nullptr, from) {}
  inline RegulatorControlScheduleFSCH(RegulatorControlScheduleFSCH&& from) noexcept
      : RegulatorControlScheduleFSCH(nullptr, ::std::move(from)) {}
  inline RegulatorControlScheduleFSCH& operator=(const RegulatorControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlScheduleFSCH& operator=(RegulatorControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlScheduleFSCH& default_instance() {
    return *reinterpret_cast<const RegulatorControlScheduleFSCH*>(
        &_RegulatorControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RegulatorControlScheduleFSCH& a, RegulatorControlScheduleFSCH& b) { a.Swap(&b); }
  inline void Swap(RegulatorControlScheduleFSCH* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlScheduleFSCH* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlScheduleFSCH* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorControlScheduleFSCH>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorControlScheduleFSCH& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorControlScheduleFSCH& from) { RegulatorControlScheduleFSCH::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorControlScheduleFSCH* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorControlScheduleFSCH"; }

 protected:
  explicit RegulatorControlScheduleFSCH(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorControlScheduleFSCH(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorControlScheduleFSCH& from);
  RegulatorControlScheduleFSCH(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorControlScheduleFSCH&& from) noexcept
      : RegulatorControlScheduleFSCH(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValDCSGFieldNumber = 1,
  };
  // .regulatormodule.RegulatorCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  void clear_valdcsg() ;
  const ::regulatormodule::RegulatorCSG& valdcsg() const;
  [[nodiscard]] ::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE release_valdcsg();
  ::regulatormodule::RegulatorCSG* PROTOBUF_NONNULL mutable_valdcsg();
  void set_allocated_valdcsg(::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_valdcsg(::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE unsafe_arena_release_valdcsg();

  private:
  const ::regulatormodule::RegulatorCSG& _internal_valdcsg() const;
  ::regulatormodule::RegulatorCSG* PROTOBUF_NONNULL _internal_mutable_valdcsg();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlScheduleFSCH)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorControlScheduleFSCH& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE valdcsg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorControlScheduleFSCH_class_data_;
// -------------------------------------------------------------------

class RegulatorControlFSCC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlFSCC) */ {
 public:
  inline RegulatorControlFSCC() : RegulatorControlFSCC(nullptr) {}
  ~RegulatorControlFSCC() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorControlFSCC* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorControlFSCC));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorControlFSCC(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorControlFSCC(const RegulatorControlFSCC& from) : RegulatorControlFSCC(nullptr, from) {}
  inline RegulatorControlFSCC(RegulatorControlFSCC&& from) noexcept
      : RegulatorControlFSCC(nullptr, ::std::move(from)) {}
  inline RegulatorControlFSCC& operator=(const RegulatorControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlFSCC& operator=(RegulatorControlFSCC&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlFSCC& default_instance() {
    return *reinterpret_cast<const RegulatorControlFSCC*>(
        &_RegulatorControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RegulatorControlFSCC& a, RegulatorControlFSCC& b) { a.Swap(&b); }
  inline void Swap(RegulatorControlFSCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlFSCC* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlFSCC* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorControlFSCC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorControlFSCC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorControlFSCC& from) { RegulatorControlFSCC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorControlFSCC* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorControlFSCC"; }

 protected:
  explicit RegulatorControlFSCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorControlFSCC(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorControlFSCC& from);
  RegulatorControlFSCC(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorControlFSCC&& from) noexcept
      : RegulatorControlFSCC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlFSCCFieldNumber = 1,
    kRegulatorControlScheduleFSCHFieldNumber = 2,
  };
  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  void clear_controlfscc() ;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  [[nodiscard]] ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE release_controlfscc();
  ::commonmodule::ControlFSCC* PROTOBUF_NONNULL mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlfscc(::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE unsafe_arena_release_controlfscc();

  private:
  const ::commonmodule::ControlFSCC& _internal_controlfscc() const;
  ::commonmodule::ControlFSCC* PROTOBUF_NONNULL _internal_mutable_controlfscc();

  public:
  // .regulatormodule.RegulatorControlScheduleFSCH regulatorControlScheduleFSCH = 2;
  bool has_regulatorcontrolschedulefsch() const;
  void clear_regulatorcontrolschedulefsch() ;
  const ::regulatormodule::RegulatorControlScheduleFSCH& regulatorcontrolschedulefsch() const;
  [[nodiscard]] ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE release_regulatorcontrolschedulefsch();
  ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NONNULL mutable_regulatorcontrolschedulefsch();
  void set_allocated_regulatorcontrolschedulefsch(::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorcontrolschedulefsch(::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE unsafe_arena_release_regulatorcontrolschedulefsch();

  private:
  const ::regulatormodule::RegulatorControlScheduleFSCH& _internal_regulatorcontrolschedulefsch() const;
  ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NONNULL _internal_mutable_regulatorcontrolschedulefsch();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlFSCC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorControlFSCC& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE controlfscc_;
    ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE regulatorcontrolschedulefsch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorControlFSCC_class_data_;
// -------------------------------------------------------------------

class RegulatorControl final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControl) */ {
 public:
  inline RegulatorControl() : RegulatorControl(nullptr) {}
  ~RegulatorControl() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorControl* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorControl));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorControl(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorControl(const RegulatorControl& from) : RegulatorControl(nullptr, from) {}
  inline RegulatorControl(RegulatorControl&& from) noexcept
      : RegulatorControl(nullptr, ::std::move(from)) {}
  inline RegulatorControl& operator=(const RegulatorControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControl& operator=(RegulatorControl&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControl& default_instance() {
    return *reinterpret_cast<const RegulatorControl*>(
        &_RegulatorControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(RegulatorControl& a, RegulatorControl& b) { a.Swap(&b); }
  inline void Swap(RegulatorControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControl* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControl* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorControl>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorControl& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorControl& from) { RegulatorControl::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorControl* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorControl"; }

 protected:
  explicit RegulatorControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorControl(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorControl& from);
  RegulatorControl(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorControl&& from) noexcept
      : RegulatorControl(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kRegulatorControlFSCCFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  [[nodiscard]] ::commonmodule::ControlValue* PROTOBUF_NULLABLE release_controlvalue();
  ::commonmodule::ControlValue* PROTOBUF_NONNULL mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlValue* PROTOBUF_NULLABLE unsafe_arena_release_controlvalue();

  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* PROTOBUF_NONNULL _internal_mutable_controlvalue();

  public:
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  [[nodiscard]] ::commonmodule::CheckConditions* PROTOBUF_NULLABLE release_check();
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value);
  ::commonmodule::CheckConditions* PROTOBUF_NULLABLE unsafe_arena_release_check();

  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* PROTOBUF_NONNULL _internal_mutable_check();

  public:
  // .regulatormodule.RegulatorControlFSCC regulatorControlFSCC = 3;
  bool has_regulatorcontrolfscc() const;
  void clear_regulatorcontrolfscc() ;
  const ::regulatormodule::RegulatorControlFSCC& regulatorcontrolfscc() const;
  [[nodiscard]] ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE release_regulatorcontrolfscc();
  ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NONNULL mutable_regulatorcontrolfscc();
  void set_allocated_regulatorcontrolfscc(::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorcontrolfscc(::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE unsafe_arena_release_regulatorcontrolfscc();

  private:
  const ::regulatormodule::RegulatorControlFSCC& _internal_regulatorcontrolfscc() const;
  ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NONNULL _internal_mutable_regulatorcontrolfscc();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControl)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorControl& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE controlvalue_;
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE check_;
    ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE regulatorcontrolfscc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorControl_class_data_;
// -------------------------------------------------------------------

class RegulatorControlProfile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlProfile) */ {
 public:
  inline RegulatorControlProfile() : RegulatorControlProfile(nullptr) {}
  ~RegulatorControlProfile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegulatorControlProfile* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegulatorControlProfile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegulatorControlProfile(::google::protobuf::internal::ConstantInitialized);

  inline RegulatorControlProfile(const RegulatorControlProfile& from) : RegulatorControlProfile(nullptr, from) {}
  inline RegulatorControlProfile(RegulatorControlProfile&& from) noexcept
      : RegulatorControlProfile(nullptr, ::std::move(from)) {}
  inline RegulatorControlProfile& operator=(const RegulatorControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlProfile& operator=(RegulatorControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlProfile& default_instance() {
    return *reinterpret_cast<const RegulatorControlProfile*>(
        &_RegulatorControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RegulatorControlProfile& a, RegulatorControlProfile& b) { a.Swap(&b); }
  inline void Swap(RegulatorControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlProfile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlProfile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegulatorControlProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegulatorControlProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegulatorControlProfile& from) { RegulatorControlProfile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegulatorControlProfile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "regulatormodule.RegulatorControlProfile"; }

 protected:
  explicit RegulatorControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegulatorControlProfile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegulatorControlProfile& from);
  RegulatorControlProfile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegulatorControlProfile&& from) noexcept
      : RegulatorControlProfile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kRegulatorControlFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  [[nodiscard]] ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value);
  ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE unsafe_arena_release_controlmessageinfo();

  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL _internal_mutable_controlmessageinfo();

  public:
  // .regulatormodule.RegulatorControl regulatorControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorcontrol() const;
  void clear_regulatorcontrol() ;
  const ::regulatormodule::RegulatorControl& regulatorcontrol() const;
  [[nodiscard]] ::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE release_regulatorcontrol();
  ::regulatormodule::RegulatorControl* PROTOBUF_NONNULL mutable_regulatorcontrol();
  void set_allocated_regulatorcontrol(::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorcontrol(::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE unsafe_arena_release_regulatorcontrol();

  private:
  const ::regulatormodule::RegulatorControl& _internal_regulatorcontrol() const;
  ::regulatormodule::RegulatorControl* PROTOBUF_NONNULL _internal_mutable_regulatorcontrol();

  public:
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  [[nodiscard]] ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value);
  ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE unsafe_arena_release_regulatorsystem();

  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL _internal_mutable_regulatorsystem();

  public:
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlProfile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegulatorControlProfile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE controlmessageinfo_;
    ::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE regulatorcontrol_;
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE regulatorsystem_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegulatorControlProfile_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DirectionalATCC

// .commonmodule.PhaseAPC BndWid = 1;
inline bool DirectionalATCC::has_bndwid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bndwid_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_bndwid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.bndwid_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::bndwid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.BndWid)
  return _internal_bndwid();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_bndwid(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwid_);
  }
  _impl_.bndwid_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.BndWid)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::release_bndwid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::PhaseAPC* released = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::unsafe_arena_release_bndwid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.BndWid)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::PhaseAPC* temp = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::_internal_mutable_bndwid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bndwid_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.bndwid_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.bndwid_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::mutable_bndwid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_bndwid();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.BndWid)
  return _msg;
}
inline void DirectionalATCC::set_allocated_bndwid(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bndwid_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.BndWid)
}

// .commonmodule.PhaseISC CtlDlTmms = 2;
inline bool DirectionalATCC::has_ctldltmms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ctldltmms_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseISC& DirectionalATCC::_internal_ctldltmms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseISC* p = _impl_.ctldltmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseISC&>(::commonmodule::_PhaseISC_default_instance_);
}
inline const ::commonmodule::PhaseISC& DirectionalATCC::ctldltmms() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.CtlDlTmms)
  return _internal_ctldltmms();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_ctldltmms(
    ::commonmodule::PhaseISC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ctldltmms_);
  }
  _impl_.ctldltmms_ = reinterpret_cast<::commonmodule::PhaseISC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.CtlDlTmms)
}
inline ::commonmodule::PhaseISC* PROTOBUF_NULLABLE DirectionalATCC::release_ctldltmms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::PhaseISC* released = _impl_.ctldltmms_;
  _impl_.ctldltmms_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseISC* PROTOBUF_NULLABLE DirectionalATCC::unsafe_arena_release_ctldltmms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.CtlDlTmms)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::PhaseISC* temp = _impl_.ctldltmms_;
  _impl_.ctldltmms_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseISC* PROTOBUF_NONNULL DirectionalATCC::_internal_mutable_ctldltmms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ctldltmms_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseISC>(GetArena());
    _impl_.ctldltmms_ = reinterpret_cast<::commonmodule::PhaseISC*>(p);
  }
  return _impl_.ctldltmms_;
}
inline ::commonmodule::PhaseISC* PROTOBUF_NONNULL DirectionalATCC::mutable_ctldltmms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::PhaseISC* _msg = _internal_mutable_ctldltmms();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.CtlDlTmms)
  return _msg;
}
inline void DirectionalATCC::set_allocated_ctldltmms(::commonmodule::PhaseISC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ctldltmms_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ctldltmms_ = reinterpret_cast<::commonmodule::PhaseISC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.CtlDlTmms)
}

// .commonmodule.PhaseAPC LDCR = 3;
inline bool DirectionalATCC::has_ldcr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ldcr_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_ldcr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.ldcr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::ldcr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.LDCR)
  return _internal_ldcr();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_ldcr(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcr_);
  }
  _impl_.ldcr_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.LDCR)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::release_ldcr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::PhaseAPC* released = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::unsafe_arena_release_ldcr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.LDCR)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::PhaseAPC* temp = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::_internal_mutable_ldcr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ldcr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.ldcr_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.ldcr_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::mutable_ldcr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_ldcr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.LDCR)
  return _msg;
}
inline void DirectionalATCC::set_allocated_ldcr(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ldcr_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.LDCR)
}

// .commonmodule.PhaseAPC LDCX = 4;
inline bool DirectionalATCC::has_ldcx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ldcx_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_ldcx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.ldcx_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::ldcx() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.LDCX)
  return _internal_ldcx();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_ldcx(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcx_);
  }
  _impl_.ldcx_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.LDCX)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::release_ldcx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::PhaseAPC* released = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::unsafe_arena_release_ldcx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.LDCX)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::PhaseAPC* temp = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::_internal_mutable_ldcx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ldcx_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.ldcx_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.ldcx_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::mutable_ldcx()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_ldcx();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.LDCX)
  return _msg;
}
inline void DirectionalATCC::set_allocated_ldcx(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcx_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.ldcx_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.LDCX)
}

// .commonmodule.PhaseAPC VolSpt = 5;
inline bool DirectionalATCC::has_volspt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volspt_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_volspt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.volspt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::volspt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.VolSpt)
  return _internal_volspt();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_volspt(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volspt_);
  }
  _impl_.volspt_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.VolSpt)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::release_volspt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::PhaseAPC* released = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE DirectionalATCC::unsafe_arena_release_volspt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.VolSpt)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::PhaseAPC* temp = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::_internal_mutable_volspt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.volspt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.volspt_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.volspt_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL DirectionalATCC::mutable_volspt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_volspt();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.VolSpt)
  return _msg;
}
inline void DirectionalATCC::set_allocated_volspt(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volspt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.volspt_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.VolSpt)
}

// .commonmodule.PhaseDPC voltageSetPointEnabled = 6;
inline bool DirectionalATCC::has_voltagesetpointenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltagesetpointenabled_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseDPC& DirectionalATCC::_internal_voltagesetpointenabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseDPC* p = _impl_.voltagesetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseDPC&>(::commonmodule::_PhaseDPC_default_instance_);
}
inline const ::commonmodule::PhaseDPC& DirectionalATCC::voltagesetpointenabled() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
  return _internal_voltagesetpointenabled();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_voltagesetpointenabled(
    ::commonmodule::PhaseDPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  _impl_.voltagesetpointenabled_ = reinterpret_cast<::commonmodule::PhaseDPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
}
inline ::commonmodule::PhaseDPC* PROTOBUF_NULLABLE DirectionalATCC::release_voltagesetpointenabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::PhaseDPC* released = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseDPC* PROTOBUF_NULLABLE DirectionalATCC::unsafe_arena_release_voltagesetpointenabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.voltageSetPointEnabled)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::PhaseDPC* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseDPC* PROTOBUF_NONNULL DirectionalATCC::_internal_mutable_voltagesetpointenabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltagesetpointenabled_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseDPC>(GetArena());
    _impl_.voltagesetpointenabled_ = reinterpret_cast<::commonmodule::PhaseDPC*>(p);
  }
  return _impl_.voltagesetpointenabled_;
}
inline ::commonmodule::PhaseDPC* PROTOBUF_NONNULL DirectionalATCC::mutable_voltagesetpointenabled()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::PhaseDPC* _msg = _internal_mutable_voltagesetpointenabled();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
  return _msg;
}
inline void DirectionalATCC::set_allocated_voltagesetpointenabled(::commonmodule::PhaseDPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagesetpointenabled_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.voltagesetpointenabled_ = reinterpret_cast<::commonmodule::PhaseDPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
}

// -------------------------------------------------------------------

// RegulatorControlATCC

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlATCC::has_logicalnodeforcontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforcontrol_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForControl& RegulatorControlATCC::_internal_logicalnodeforcontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& RegulatorControlATCC::logicalnodeforcontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE RegulatorControlATCC::release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* released = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.logicalNodeForControl)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_logicalnodeforcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForControl>(GetArena());
    _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(p);
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* PROTOBUF_NONNULL RegulatorControlATCC::mutable_logicalnodeforcontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforcontrol_ = reinterpret_cast<::commonmodule::LogicalNodeForControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
}

// .regulatormodule.DirectionalATCC DirFwd = 2;
inline bool RegulatorControlATCC::has_dirfwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirfwd_ != nullptr);
  return value;
}
inline void RegulatorControlATCC::clear_dirfwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirfwd_ != nullptr) _impl_.dirfwd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::_internal_dirfwd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::DirectionalATCC* p = _impl_.dirfwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::DirectionalATCC&>(::regulatormodule::_DirectionalATCC_default_instance_);
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::dirfwd() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirFwd)
  return _internal_dirfwd();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirfwd(
    ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirfwd_);
  }
  _impl_.dirfwd_ = reinterpret_cast<::regulatormodule::DirectionalATCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirFwd)
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE RegulatorControlATCC::release_dirfwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::DirectionalATCC* released = _impl_.dirfwd_;
  _impl_.dirfwd_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_dirfwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirFwd)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::DirectionalATCC* temp = _impl_.dirfwd_;
  _impl_.dirfwd_ = nullptr;
  return temp;
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_dirfwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirfwd_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::DirectionalATCC>(GetArena());
    _impl_.dirfwd_ = reinterpret_cast<::regulatormodule::DirectionalATCC*>(p);
  }
  return _impl_.dirfwd_;
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_dirfwd()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::DirectionalATCC* _msg = _internal_mutable_dirfwd();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirFwd)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirfwd(::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirfwd_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dirfwd_ = reinterpret_cast<::regulatormodule::DirectionalATCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirFwd)
}

// .commonmodule.Optional_DirectionModeKind DirMode = 3;
inline bool RegulatorControlATCC::has_dirmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirmode_ != nullptr);
  return value;
}
inline const ::commonmodule::Optional_DirectionModeKind& RegulatorControlATCC::_internal_dirmode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Optional_DirectionModeKind* p = _impl_.dirmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_DirectionModeKind&>(::commonmodule::_Optional_DirectionModeKind_default_instance_);
}
inline const ::commonmodule::Optional_DirectionModeKind& RegulatorControlATCC::dirmode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirMode)
  return _internal_dirmode();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirmode(
    ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirmode_);
  }
  _impl_.dirmode_ = reinterpret_cast<::commonmodule::Optional_DirectionModeKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirMode)
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE RegulatorControlATCC::release_dirmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::Optional_DirectionModeKind* released = _impl_.dirmode_;
  _impl_.dirmode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_dirmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirMode)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::Optional_DirectionModeKind* temp = _impl_.dirmode_;
  _impl_.dirmode_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_dirmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirmode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Optional_DirectionModeKind>(GetArena());
    _impl_.dirmode_ = reinterpret_cast<::commonmodule::Optional_DirectionModeKind*>(p);
  }
  return _impl_.dirmode_;
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL RegulatorControlATCC::mutable_dirmode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::Optional_DirectionModeKind* _msg = _internal_mutable_dirmode();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirMode)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirmode(::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirmode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dirmode_ = reinterpret_cast<::commonmodule::Optional_DirectionModeKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirMode)
}

// .regulatormodule.DirectionalATCC DirRev = 4;
inline bool RegulatorControlATCC::has_dirrev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirrev_ != nullptr);
  return value;
}
inline void RegulatorControlATCC::clear_dirrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirrev_ != nullptr) _impl_.dirrev_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::_internal_dirrev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::DirectionalATCC* p = _impl_.dirrev_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::DirectionalATCC&>(::regulatormodule::_DirectionalATCC_default_instance_);
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::dirrev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirRev)
  return _internal_dirrev();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirrev(
    ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirrev_);
  }
  _impl_.dirrev_ = reinterpret_cast<::regulatormodule::DirectionalATCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirRev)
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE RegulatorControlATCC::release_dirrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::regulatormodule::DirectionalATCC* released = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_dirrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirRev)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::regulatormodule::DirectionalATCC* temp = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
  return temp;
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_dirrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirrev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::DirectionalATCC>(GetArena());
    _impl_.dirrev_ = reinterpret_cast<::regulatormodule::DirectionalATCC*>(p);
  }
  return _impl_.dirrev_;
}
inline ::regulatormodule::DirectionalATCC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_dirrev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::regulatormodule::DirectionalATCC* _msg = _internal_mutable_dirrev();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirRev)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirrev(::regulatormodule::DirectionalATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirrev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.dirrev_ = reinterpret_cast<::regulatormodule::DirectionalATCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirRev)
}

// .commonmodule.PhaseAPC DirThd = 5;
inline bool RegulatorControlATCC::has_dirthd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirthd_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::_internal_dirthd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.dirthd_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::dirthd() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirThd)
  return _internal_dirthd();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirthd(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirthd_);
  }
  _impl_.dirthd_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirThd)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorControlATCC::release_dirthd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::PhaseAPC* released = _impl_.dirthd_;
  _impl_.dirthd_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_dirthd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirThd)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::PhaseAPC* temp = _impl_.dirthd_;
  _impl_.dirthd_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_dirthd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirthd_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.dirthd_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.dirthd_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_dirthd()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_dirthd();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirThd)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirthd(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirthd_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.dirthd_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirThd)
}

// .commonmodule.PhaseSPC ParOp = 6;
inline bool RegulatorControlATCC::has_parop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parop_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::_internal_parop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPC* p = _impl_.parop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPC&>(::commonmodule::_PhaseSPC_default_instance_);
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::parop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.ParOp)
  return _internal_parop();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_parop(
    ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parop_);
  }
  _impl_.parop_ = reinterpret_cast<::commonmodule::PhaseSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.ParOp)
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE RegulatorControlATCC::release_parop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::PhaseSPC* released = _impl_.parop_;
  _impl_.parop_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_parop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.ParOp)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::PhaseSPC* temp = _impl_.parop_;
  _impl_.parop_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_parop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parop_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPC>(GetArena());
    _impl_.parop_ = reinterpret_cast<::commonmodule::PhaseSPC*>(p);
  }
  return _impl_.parop_;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_parop()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::PhaseSPC* _msg = _internal_mutable_parop();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.ParOp)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_parop(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parop_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.parop_ = reinterpret_cast<::commonmodule::PhaseSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.ParOp)
}

// .commonmodule.RampRate rampRates = 7;
inline bool RegulatorControlATCC::has_ramprates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ramprates_ != nullptr);
  return value;
}
inline const ::commonmodule::RampRate& RegulatorControlATCC::_internal_ramprates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& RegulatorControlATCC::ramprates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.rampRates)
  return _internal_ramprates();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.rampRates)
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE RegulatorControlATCC::release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::RampRate* released = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.rampRates)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ramprates_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::RampRate>(GetArena());
    _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(p);
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL RegulatorControlATCC::mutable_ramprates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.rampRates)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.rampRates)
}

// .commonmodule.Optional_StateKind state = 8;
inline bool RegulatorControlATCC::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::commonmodule::Optional_StateKind& RegulatorControlATCC::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& RegulatorControlATCC::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.state)
  return _internal_state();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::commonmodule::Optional_StateKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.state)
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE RegulatorControlATCC::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::Optional_StateKind* released = _impl_.state_;
  _impl_.state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.state)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Optional_StateKind>(GetArena());
    _impl_.state_ = reinterpret_cast<::commonmodule::Optional_StateKind*>(p);
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL RegulatorControlATCC::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.state)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_state(::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.state_ = reinterpret_cast<::commonmodule::Optional_StateKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.state)
}

// .commonmodule.PhaseSPC TapOpL = 9;
inline bool RegulatorControlATCC::has_tapopl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tapopl_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::_internal_tapopl() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPC* p = _impl_.tapopl_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPC&>(::commonmodule::_PhaseSPC_default_instance_);
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::tapopl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.TapOpL)
  return _internal_tapopl();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_tapopl(
    ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tapopl_);
  }
  _impl_.tapopl_ = reinterpret_cast<::commonmodule::PhaseSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.TapOpL)
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE RegulatorControlATCC::release_tapopl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::PhaseSPC* released = _impl_.tapopl_;
  _impl_.tapopl_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_tapopl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.TapOpL)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::PhaseSPC* temp = _impl_.tapopl_;
  _impl_.tapopl_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_tapopl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tapopl_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPC>(GetArena());
    _impl_.tapopl_ = reinterpret_cast<::commonmodule::PhaseSPC*>(p);
  }
  return _impl_.tapopl_;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_tapopl()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::commonmodule::PhaseSPC* _msg = _internal_mutable_tapopl();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.TapOpL)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_tapopl(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tapopl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.tapopl_ = reinterpret_cast<::commonmodule::PhaseSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.TapOpL)
}

// .commonmodule.PhaseSPC TapOpR = 10;
inline bool RegulatorControlATCC::has_tapopr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tapopr_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::_internal_tapopr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPC* p = _impl_.tapopr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPC&>(::commonmodule::_PhaseSPC_default_instance_);
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::tapopr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.TapOpR)
  return _internal_tapopr();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_tapopr(
    ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tapopr_);
  }
  _impl_.tapopr_ = reinterpret_cast<::commonmodule::PhaseSPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.TapOpR)
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE RegulatorControlATCC::release_tapopr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::PhaseSPC* released = _impl_.tapopr_;
  _impl_.tapopr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_tapopr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.TapOpR)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::PhaseSPC* temp = _impl_.tapopr_;
  _impl_.tapopr_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_tapopr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tapopr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPC>(GetArena());
    _impl_.tapopr_ = reinterpret_cast<::commonmodule::PhaseSPC*>(p);
  }
  return _impl_.tapopr_;
}
inline ::commonmodule::PhaseSPC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_tapopr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::commonmodule::PhaseSPC* _msg = _internal_mutable_tapopr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.TapOpR)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_tapopr(::commonmodule::PhaseSPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tapopr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.tapopr_ = reinterpret_cast<::commonmodule::PhaseSPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.TapOpR)
}

// .commonmodule.PhaseAPC VolLmtHi = 11;
inline bool RegulatorControlATCC::has_vollmthi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vollmthi_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::_internal_vollmthi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.vollmthi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::vollmthi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.VolLmtHi)
  return _internal_vollmthi();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_vollmthi(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmthi_);
  }
  _impl_.vollmthi_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtHi)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorControlATCC::release_vollmthi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::PhaseAPC* released = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_vollmthi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.VolLmtHi)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::PhaseAPC* temp = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_vollmthi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vollmthi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.vollmthi_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.vollmthi_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_vollmthi()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_vollmthi();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.VolLmtHi)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_vollmthi(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmthi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.vollmthi_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtHi)
}

// .commonmodule.PhaseAPC VolLmtLo = 12;
inline bool RegulatorControlATCC::has_vollmtlo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vollmtlo_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::_internal_vollmtlo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.vollmtlo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::vollmtlo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.VolLmtLo)
  return _internal_vollmtlo();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_vollmtlo(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtlo_);
  }
  _impl_.vollmtlo_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtLo)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorControlATCC::release_vollmtlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::PhaseAPC* released = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_vollmtlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.VolLmtLo)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::PhaseAPC* temp = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_vollmtlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vollmtlo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.vollmtlo_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.vollmtlo_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorControlATCC::mutable_vollmtlo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_vollmtlo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.VolLmtLo)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_vollmtlo(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtlo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.vollmtlo_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtLo)
}

// .commonmodule.Optional_VoltLimitModeKind VolLmtMode = 13;
inline bool RegulatorControlATCC::has_vollmtmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vollmtmode_ != nullptr);
  return value;
}
inline const ::commonmodule::Optional_VoltLimitModeKind& RegulatorControlATCC::_internal_vollmtmode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Optional_VoltLimitModeKind* p = _impl_.vollmtmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_VoltLimitModeKind&>(::commonmodule::_Optional_VoltLimitModeKind_default_instance_);
}
inline const ::commonmodule::Optional_VoltLimitModeKind& RegulatorControlATCC::vollmtmode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.VolLmtMode)
  return _internal_vollmtmode();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_vollmtmode(
    ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtmode_);
  }
  _impl_.vollmtmode_ = reinterpret_cast<::commonmodule::Optional_VoltLimitModeKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtMode)
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE RegulatorControlATCC::release_vollmtmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::Optional_VoltLimitModeKind* released = _impl_.vollmtmode_;
  _impl_.vollmtmode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE RegulatorControlATCC::unsafe_arena_release_vollmtmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.VolLmtMode)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::Optional_VoltLimitModeKind* temp = _impl_.vollmtmode_;
  _impl_.vollmtmode_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL RegulatorControlATCC::_internal_mutable_vollmtmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vollmtmode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Optional_VoltLimitModeKind>(GetArena());
    _impl_.vollmtmode_ = reinterpret_cast<::commonmodule::Optional_VoltLimitModeKind*>(p);
  }
  return _impl_.vollmtmode_;
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL RegulatorControlATCC::mutable_vollmtmode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00001000u;
  ::commonmodule::Optional_VoltLimitModeKind* _msg = _internal_mutable_vollmtmode();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.VolLmtMode)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtmode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.vollmtmode_ = reinterpret_cast<::commonmodule::Optional_VoltLimitModeKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtMode)
}

// -------------------------------------------------------------------

// RegulatorPoint

// .regulatormodule.RegulatorControlATCC control = 1;
inline bool RegulatorPoint::has_control() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_ != nullptr);
  return value;
}
inline void RegulatorPoint::clear_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.control_ != nullptr) _impl_.control_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorPoint::_internal_control() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorControlATCC* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlATCC&>(::regulatormodule::_RegulatorControlATCC_default_instance_);
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorPoint::control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.control)
  return _internal_control();
}
inline void RegulatorPoint::unsafe_arena_set_allocated_control(
    ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = reinterpret_cast<::regulatormodule::RegulatorControlATCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorPoint.control)
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE RegulatorPoint::release_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::regulatormodule::RegulatorControlATCC* released = _impl_.control_;
  _impl_.control_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE RegulatorPoint::unsafe_arena_release_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.control)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::regulatormodule::RegulatorControlATCC* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL RegulatorPoint::_internal_mutable_control() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.control_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorControlATCC>(GetArena());
    _impl_.control_ = reinterpret_cast<::regulatormodule::RegulatorControlATCC*>(p);
  }
  return _impl_.control_;
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL RegulatorPoint::mutable_control()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::regulatormodule::RegulatorControlATCC* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.control)
  return _msg;
}
inline void RegulatorPoint::set_allocated_control(::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.control_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.control_ = reinterpret_cast<::regulatormodule::RegulatorControlATCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.control)
}

// .commonmodule.Timestamp startTime = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorPoint::has_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starttime_ != nullptr);
  return value;
}
inline const ::commonmodule::Timestamp& RegulatorPoint::_internal_starttime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Timestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& RegulatorPoint::starttime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.startTime)
  return _internal_starttime();
}
inline void RegulatorPoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorPoint.startTime)
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE RegulatorPoint::release_starttime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* released = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Timestamp* PROTOBUF_NULLABLE RegulatorPoint::unsafe_arena_release_starttime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.startTime)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL RegulatorPoint::_internal_mutable_starttime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.starttime_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Timestamp>(GetArena());
    _impl_.starttime_ = reinterpret_cast<::commonmodule::Timestamp*>(p);
  }
  return _impl_.starttime_;
}
inline ::commonmodule::Timestamp* PROTOBUF_NONNULL RegulatorPoint::mutable_starttime()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.startTime)
  return _msg;
}
inline void RegulatorPoint::set_allocated_starttime(::commonmodule::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.starttime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.starttime_ = reinterpret_cast<::commonmodule::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.startTime)
}

// -------------------------------------------------------------------

// RegulatorCSG

// repeated .regulatormodule.RegulatorPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int RegulatorCSG::_internal_crvpts_size() const {
  return _internal_crvpts().size();
}
inline int RegulatorCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void RegulatorCSG::clear_crvpts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.crvpts_.Clear();
}
inline ::regulatormodule::RegulatorPoint* PROTOBUF_NONNULL RegulatorCSG::mutable_crvpts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorCSG.crvPts)
  return _internal_mutable_crvpts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>* PROTOBUF_NONNULL RegulatorCSG::mutable_crvpts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:regulatormodule.RegulatorCSG.crvPts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_crvpts();
}
inline const ::regulatormodule::RegulatorPoint& RegulatorCSG::crvpts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorCSG.crvPts)
  return _internal_crvpts().Get(index);
}
inline ::regulatormodule::RegulatorPoint* PROTOBUF_NONNULL RegulatorCSG::add_crvpts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::regulatormodule::RegulatorPoint* _add = _internal_mutable_crvpts()->Add();
  // @@protoc_insertion_point(field_add:regulatormodule.RegulatorCSG.crvPts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>& RegulatorCSG::crvpts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:regulatormodule.RegulatorCSG.crvPts)
  return _internal_crvpts();
}
inline const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>&
RegulatorCSG::_internal_crvpts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.crvpts_;
}
inline ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorPoint>* PROTOBUF_NONNULL
RegulatorCSG::_internal_mutable_crvpts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.crvpts_;
}

// -------------------------------------------------------------------

// RegulatorControlScheduleFSCH

// .regulatormodule.RegulatorCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlScheduleFSCH::has_valdcsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.valdcsg_ != nullptr);
  return value;
}
inline void RegulatorControlScheduleFSCH::clear_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.valdcsg_ != nullptr) _impl_.valdcsg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::regulatormodule::RegulatorCSG& RegulatorControlScheduleFSCH::_internal_valdcsg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorCSG* p = _impl_.valdcsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorCSG&>(::regulatormodule::_RegulatorCSG_default_instance_);
}
inline const ::regulatormodule::RegulatorCSG& RegulatorControlScheduleFSCH::valdcsg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  return _internal_valdcsg();
}
inline void RegulatorControlScheduleFSCH::unsafe_arena_set_allocated_valdcsg(
    ::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.valdcsg_);
  }
  _impl_.valdcsg_ = reinterpret_cast<::regulatormodule::RegulatorCSG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
}
inline ::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE RegulatorControlScheduleFSCH::release_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::regulatormodule::RegulatorCSG* released = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE RegulatorControlScheduleFSCH::unsafe_arena_release_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::regulatormodule::RegulatorCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorCSG* PROTOBUF_NONNULL RegulatorControlScheduleFSCH::_internal_mutable_valdcsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.valdcsg_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorCSG>(GetArena());
    _impl_.valdcsg_ = reinterpret_cast<::regulatormodule::RegulatorCSG*>(p);
  }
  return _impl_.valdcsg_;
}
inline ::regulatormodule::RegulatorCSG* PROTOBUF_NONNULL RegulatorControlScheduleFSCH::mutable_valdcsg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::regulatormodule::RegulatorCSG* _msg = _internal_mutable_valdcsg();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  return _msg;
}
inline void RegulatorControlScheduleFSCH::set_allocated_valdcsg(::regulatormodule::RegulatorCSG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.valdcsg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.valdcsg_ = reinterpret_cast<::regulatormodule::RegulatorCSG*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// RegulatorControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlFSCC::has_controlfscc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlfscc_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlFSCC& RegulatorControlFSCC::_internal_controlfscc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlFSCC* p = _impl_.controlfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlFSCC&>(::commonmodule::_ControlFSCC_default_instance_);
}
inline const ::commonmodule::ControlFSCC& RegulatorControlFSCC::controlfscc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlFSCC.controlFSCC)
  return _internal_controlfscc();
}
inline void RegulatorControlFSCC::unsafe_arena_set_allocated_controlfscc(
    ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlfscc_);
  }
  _impl_.controlfscc_ = reinterpret_cast<::commonmodule::ControlFSCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlFSCC.controlFSCC)
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE RegulatorControlFSCC::release_controlfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlFSCC* released = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NULLABLE RegulatorControlFSCC::unsafe_arena_release_controlfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlFSCC.controlFSCC)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NONNULL RegulatorControlFSCC::_internal_mutable_controlfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlfscc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlFSCC>(GetArena());
    _impl_.controlfscc_ = reinterpret_cast<::commonmodule::ControlFSCC*>(p);
  }
  return _impl_.controlfscc_;
}
inline ::commonmodule::ControlFSCC* PROTOBUF_NONNULL RegulatorControlFSCC::mutable_controlfscc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlFSCC* _msg = _internal_mutable_controlfscc();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlFSCC.controlFSCC)
  return _msg;
}
inline void RegulatorControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlfscc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlfscc_ = reinterpret_cast<::commonmodule::ControlFSCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlFSCC.controlFSCC)
}

// .regulatormodule.RegulatorControlScheduleFSCH regulatorControlScheduleFSCH = 2;
inline bool RegulatorControlFSCC::has_regulatorcontrolschedulefsch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorcontrolschedulefsch_ != nullptr);
  return value;
}
inline void RegulatorControlFSCC::clear_regulatorcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrolschedulefsch_ != nullptr) _impl_.regulatorcontrolschedulefsch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorControlScheduleFSCH& RegulatorControlFSCC::_internal_regulatorcontrolschedulefsch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorControlScheduleFSCH* p = _impl_.regulatorcontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlScheduleFSCH&>(::regulatormodule::_RegulatorControlScheduleFSCH_default_instance_);
}
inline const ::regulatormodule::RegulatorControlScheduleFSCH& RegulatorControlFSCC::regulatorcontrolschedulefsch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  return _internal_regulatorcontrolschedulefsch();
}
inline void RegulatorControlFSCC::unsafe_arena_set_allocated_regulatorcontrolschedulefsch(
    ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrolschedulefsch_);
  }
  _impl_.regulatorcontrolschedulefsch_ = reinterpret_cast<::regulatormodule::RegulatorControlScheduleFSCH*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE RegulatorControlFSCC::release_regulatorcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorControlScheduleFSCH* released = _impl_.regulatorcontrolschedulefsch_;
  _impl_.regulatorcontrolschedulefsch_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE RegulatorControlFSCC::unsafe_arena_release_regulatorcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorControlScheduleFSCH* temp = _impl_.regulatorcontrolschedulefsch_;
  _impl_.regulatorcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NONNULL RegulatorControlFSCC::_internal_mutable_regulatorcontrolschedulefsch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrolschedulefsch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorControlScheduleFSCH>(GetArena());
    _impl_.regulatorcontrolschedulefsch_ = reinterpret_cast<::regulatormodule::RegulatorControlScheduleFSCH*>(p);
  }
  return _impl_.regulatorcontrolschedulefsch_;
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NONNULL RegulatorControlFSCC::mutable_regulatorcontrolschedulefsch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorControlScheduleFSCH* _msg = _internal_mutable_regulatorcontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  return _msg;
}
inline void RegulatorControlFSCC::set_allocated_regulatorcontrolschedulefsch(::regulatormodule::RegulatorControlScheduleFSCH* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrolschedulefsch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatorcontrolschedulefsch_ = reinterpret_cast<::regulatormodule::RegulatorControlScheduleFSCH*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
}

// -------------------------------------------------------------------

// RegulatorControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControl::has_controlvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlValue& RegulatorControl::_internal_controlvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& RegulatorControl::controlvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.controlValue)
  return _internal_controlvalue();
}
inline void RegulatorControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControl.controlValue)
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE RegulatorControl::release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* released = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE RegulatorControl::unsafe_arena_release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.controlValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL RegulatorControl::_internal_mutable_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlValue>(GetArena());
    _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(p);
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL RegulatorControl::mutable_controlvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.controlValue)
  return _msg;
}
inline void RegulatorControl::set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool RegulatorControl::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_ != nullptr);
  return value;
}
inline const ::commonmodule::CheckConditions& RegulatorControl::_internal_check() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& RegulatorControl::check() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.check)
  return _internal_check();
}
inline void RegulatorControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControl.check)
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE RegulatorControl::release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* released = _impl_.check_;
  _impl_.check_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE RegulatorControl::unsafe_arena_release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.check)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL RegulatorControl::_internal_mutable_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.check_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::CheckConditions>(GetArena());
    _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(p);
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL RegulatorControl::mutable_check()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.check)
  return _msg;
}
inline void RegulatorControl::set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.check)
}

// .regulatormodule.RegulatorControlFSCC regulatorControlFSCC = 3;
inline bool RegulatorControl::has_regulatorcontrolfscc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorcontrolfscc_ != nullptr);
  return value;
}
inline void RegulatorControl::clear_regulatorcontrolfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrolfscc_ != nullptr) _impl_.regulatorcontrolfscc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::regulatormodule::RegulatorControlFSCC& RegulatorControl::_internal_regulatorcontrolfscc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorControlFSCC* p = _impl_.regulatorcontrolfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlFSCC&>(::regulatormodule::_RegulatorControlFSCC_default_instance_);
}
inline const ::regulatormodule::RegulatorControlFSCC& RegulatorControl::regulatorcontrolfscc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.regulatorControlFSCC)
  return _internal_regulatorcontrolfscc();
}
inline void RegulatorControl::unsafe_arena_set_allocated_regulatorcontrolfscc(
    ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrolfscc_);
  }
  _impl_.regulatorcontrolfscc_ = reinterpret_cast<::regulatormodule::RegulatorControlFSCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControl.regulatorControlFSCC)
}
inline ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE RegulatorControl::release_regulatorcontrolfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorControlFSCC* released = _impl_.regulatorcontrolfscc_;
  _impl_.regulatorcontrolfscc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE RegulatorControl::unsafe_arena_release_regulatorcontrolfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.regulatorControlFSCC)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorControlFSCC* temp = _impl_.regulatorcontrolfscc_;
  _impl_.regulatorcontrolfscc_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NONNULL RegulatorControl::_internal_mutable_regulatorcontrolfscc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrolfscc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorControlFSCC>(GetArena());
    _impl_.regulatorcontrolfscc_ = reinterpret_cast<::regulatormodule::RegulatorControlFSCC*>(p);
  }
  return _impl_.regulatorcontrolfscc_;
}
inline ::regulatormodule::RegulatorControlFSCC* PROTOBUF_NONNULL RegulatorControl::mutable_regulatorcontrolfscc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::regulatormodule::RegulatorControlFSCC* _msg = _internal_mutable_regulatorcontrolfscc();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.regulatorControlFSCC)
  return _msg;
}
inline void RegulatorControl::set_allocated_regulatorcontrolfscc(::regulatormodule::RegulatorControlFSCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrolfscc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.regulatorcontrolfscc_ = reinterpret_cast<::regulatormodule::RegulatorControlFSCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.regulatorControlFSCC)
}

// -------------------------------------------------------------------

// RegulatorSystem

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorSystem::has_conductingequipment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conductingequipment_ != nullptr);
  return value;
}
inline const ::commonmodule::ConductingEquipment& RegulatorSystem::_internal_conductingequipment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& RegulatorSystem::conductingequipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorSystem.conductingEquipment)
  return _internal_conductingequipment();
}
inline void RegulatorSystem::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = reinterpret_cast<::commonmodule::ConductingEquipment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorSystem.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE RegulatorSystem::release_conductingequipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipment* released = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE RegulatorSystem::unsafe_arena_release_conductingequipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorSystem.conductingEquipment)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL RegulatorSystem::_internal_mutable_conductingequipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ConductingEquipment>(GetArena());
    _impl_.conductingequipment_ = reinterpret_cast<::commonmodule::ConductingEquipment*>(p);
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* PROTOBUF_NONNULL RegulatorSystem::mutable_conductingequipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorSystem.conductingEquipment)
  return _msg;
}
inline void RegulatorSystem::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipment_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.conductingequipment_ = reinterpret_cast<::commonmodule::ConductingEquipment*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorSystem.conductingEquipment)
}

// -------------------------------------------------------------------

// RegulatorControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlProfile::has_controlmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlMessageInfo& RegulatorControlProfile::_internal_controlmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& RegulatorControlProfile::controlmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void RegulatorControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE RegulatorControlProfile::release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* released = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE RegulatorControlProfile::unsafe_arena_release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.controlMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL RegulatorControlProfile::_internal_mutable_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlMessageInfo>(GetArena());
    _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(p);
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL RegulatorControlProfile::mutable_controlmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  return _msg;
}
inline void RegulatorControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.controlMessageInfo)
}

// .regulatormodule.RegulatorControl regulatorControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlProfile::has_regulatorcontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorcontrol_ != nullptr);
  return value;
}
inline void RegulatorControlProfile::clear_regulatorcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrol_ != nullptr) _impl_.regulatorcontrol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorControl& RegulatorControlProfile::_internal_regulatorcontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorControl* p = _impl_.regulatorcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControl&>(::regulatormodule::_RegulatorControl_default_instance_);
}
inline const ::regulatormodule::RegulatorControl& RegulatorControlProfile::regulatorcontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.regulatorControl)
  return _internal_regulatorcontrol();
}
inline void RegulatorControlProfile::unsafe_arena_set_allocated_regulatorcontrol(
    ::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrol_);
  }
  _impl_.regulatorcontrol_ = reinterpret_cast<::regulatormodule::RegulatorControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlProfile.regulatorControl)
}
inline ::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE RegulatorControlProfile::release_regulatorcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorControl* released = _impl_.regulatorcontrol_;
  _impl_.regulatorcontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE RegulatorControlProfile::unsafe_arena_release_regulatorcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.regulatorControl)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorControl* temp = _impl_.regulatorcontrol_;
  _impl_.regulatorcontrol_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControl* PROTOBUF_NONNULL RegulatorControlProfile::_internal_mutable_regulatorcontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorControl>(GetArena());
    _impl_.regulatorcontrol_ = reinterpret_cast<::regulatormodule::RegulatorControl*>(p);
  }
  return _impl_.regulatorcontrol_;
}
inline ::regulatormodule::RegulatorControl* PROTOBUF_NONNULL RegulatorControlProfile::mutable_regulatorcontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorControl* _msg = _internal_mutable_regulatorcontrol();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.regulatorControl)
  return _msg;
}
inline void RegulatorControlProfile::set_allocated_regulatorcontrol(::regulatormodule::RegulatorControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatorcontrol_ = reinterpret_cast<::regulatormodule::RegulatorControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.regulatorControl)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlProfile::has_regulatorsystem() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorsystem_ != nullptr);
  return value;
}
inline void RegulatorControlProfile::clear_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ != nullptr) _impl_.regulatorsystem_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorControlProfile::_internal_regulatorsystem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorControlProfile::regulatorsystem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorControlProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorControlProfile::release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* released = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorControlProfile::unsafe_arena_release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.regulatorSystem)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorControlProfile::_internal_mutable_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorSystem>(GetArena());
    _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(p);
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorControlProfile::mutable_regulatorsystem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorControlProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorDiscreteControl::has_controlvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlValue& RegulatorDiscreteControl::_internal_controlvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& RegulatorDiscreteControl::controlvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControl.controlValue)
  return _internal_controlvalue();
}
inline void RegulatorDiscreteControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControl.controlValue)
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE RegulatorDiscreteControl::release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* released = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlValue* PROTOBUF_NULLABLE RegulatorDiscreteControl::unsafe_arena_release_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControl.controlValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL RegulatorDiscreteControl::_internal_mutable_controlvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlValue>(GetArena());
    _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(p);
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* PROTOBUF_NONNULL RegulatorDiscreteControl::mutable_controlvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControl.controlValue)
  return _msg;
}
inline void RegulatorDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlvalue_ = reinterpret_cast<::commonmodule::ControlValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool RegulatorDiscreteControl::has_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_ != nullptr);
  return value;
}
inline const ::commonmodule::CheckConditions& RegulatorDiscreteControl::_internal_check() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& RegulatorDiscreteControl::check() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControl.check)
  return _internal_check();
}
inline void RegulatorDiscreteControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControl.check)
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE RegulatorDiscreteControl::release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* released = _impl_.check_;
  _impl_.check_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NULLABLE RegulatorDiscreteControl::unsafe_arena_release_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControl.check)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL RegulatorDiscreteControl::_internal_mutable_check() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.check_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::CheckConditions>(GetArena());
    _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(p);
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* PROTOBUF_NONNULL RegulatorDiscreteControl::mutable_check()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControl.check)
  return _msg;
}
inline void RegulatorDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.check_ = reinterpret_cast<::commonmodule::CheckConditions*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControl.check)
}

// .regulatormodule.RegulatorControlATCC regulatorControlATCC = 3;
inline bool RegulatorDiscreteControl::has_regulatorcontrolatcc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorcontrolatcc_ != nullptr);
  return value;
}
inline void RegulatorDiscreteControl::clear_regulatorcontrolatcc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrolatcc_ != nullptr) _impl_.regulatorcontrolatcc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorDiscreteControl::_internal_regulatorcontrolatcc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorControlATCC* p = _impl_.regulatorcontrolatcc_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlATCC&>(::regulatormodule::_RegulatorControlATCC_default_instance_);
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorDiscreteControl::regulatorcontrolatcc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
  return _internal_regulatorcontrolatcc();
}
inline void RegulatorDiscreteControl::unsafe_arena_set_allocated_regulatorcontrolatcc(
    ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrolatcc_);
  }
  _impl_.regulatorcontrolatcc_ = reinterpret_cast<::regulatormodule::RegulatorControlATCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE RegulatorDiscreteControl::release_regulatorcontrolatcc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorControlATCC* released = _impl_.regulatorcontrolatcc_;
  _impl_.regulatorcontrolatcc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE RegulatorDiscreteControl::unsafe_arena_release_regulatorcontrolatcc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorControlATCC* temp = _impl_.regulatorcontrolatcc_;
  _impl_.regulatorcontrolatcc_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL RegulatorDiscreteControl::_internal_mutable_regulatorcontrolatcc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorcontrolatcc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorControlATCC>(GetArena());
    _impl_.regulatorcontrolatcc_ = reinterpret_cast<::regulatormodule::RegulatorControlATCC*>(p);
  }
  return _impl_.regulatorcontrolatcc_;
}
inline ::regulatormodule::RegulatorControlATCC* PROTOBUF_NONNULL RegulatorDiscreteControl::mutable_regulatorcontrolatcc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::regulatormodule::RegulatorControlATCC* _msg = _internal_mutable_regulatorcontrolatcc();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
  return _msg;
}
inline void RegulatorDiscreteControl::set_allocated_regulatorcontrolatcc(::regulatormodule::RegulatorControlATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorcontrolatcc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.regulatorcontrolatcc_ = reinterpret_cast<::regulatormodule::RegulatorControlATCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
}

// -------------------------------------------------------------------

// RegulatorDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorDiscreteControlProfile::has_controlmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.controlmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::ControlMessageInfo& RegulatorDiscreteControlProfile::_internal_controlmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& RegulatorDiscreteControlProfile::controlmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void RegulatorDiscreteControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE RegulatorDiscreteControlProfile::release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* released = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE RegulatorDiscreteControlProfile::unsafe_arena_release_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL RegulatorDiscreteControlProfile::_internal_mutable_controlmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ControlMessageInfo>(GetArena());
    _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(p);
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* PROTOBUF_NONNULL RegulatorDiscreteControlProfile::mutable_controlmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
  return _msg;
}
inline void RegulatorDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.controlmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.controlmessageinfo_ = reinterpret_cast<::commonmodule::ControlMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
}

// .regulatormodule.RegulatorDiscreteControl regulatorDiscreteControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorDiscreteControlProfile::has_regulatordiscretecontrol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatordiscretecontrol_ != nullptr);
  return value;
}
inline void RegulatorDiscreteControlProfile::clear_regulatordiscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatordiscretecontrol_ != nullptr) _impl_.regulatordiscretecontrol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorDiscreteControl& RegulatorDiscreteControlProfile::_internal_regulatordiscretecontrol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorDiscreteControl* p = _impl_.regulatordiscretecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorDiscreteControl&>(::regulatormodule::_RegulatorDiscreteControl_default_instance_);
}
inline const ::regulatormodule::RegulatorDiscreteControl& RegulatorDiscreteControlProfile::regulatordiscretecontrol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
  return _internal_regulatordiscretecontrol();
}
inline void RegulatorDiscreteControlProfile::unsafe_arena_set_allocated_regulatordiscretecontrol(
    ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatordiscretecontrol_);
  }
  _impl_.regulatordiscretecontrol_ = reinterpret_cast<::regulatormodule::RegulatorDiscreteControl*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
}
inline ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE RegulatorDiscreteControlProfile::release_regulatordiscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorDiscreteControl* released = _impl_.regulatordiscretecontrol_;
  _impl_.regulatordiscretecontrol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE RegulatorDiscreteControlProfile::unsafe_arena_release_regulatordiscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorDiscreteControl* temp = _impl_.regulatordiscretecontrol_;
  _impl_.regulatordiscretecontrol_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NONNULL RegulatorDiscreteControlProfile::_internal_mutable_regulatordiscretecontrol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatordiscretecontrol_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorDiscreteControl>(GetArena());
    _impl_.regulatordiscretecontrol_ = reinterpret_cast<::regulatormodule::RegulatorDiscreteControl*>(p);
  }
  return _impl_.regulatordiscretecontrol_;
}
inline ::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NONNULL RegulatorDiscreteControlProfile::mutable_regulatordiscretecontrol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorDiscreteControl* _msg = _internal_mutable_regulatordiscretecontrol();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
  return _msg;
}
inline void RegulatorDiscreteControlProfile::set_allocated_regulatordiscretecontrol(::regulatormodule::RegulatorDiscreteControl* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatordiscretecontrol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatordiscretecontrol_ = reinterpret_cast<::regulatormodule::RegulatorDiscreteControl*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorDiscreteControlProfile::has_regulatorsystem() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorsystem_ != nullptr);
  return value;
}
inline void RegulatorDiscreteControlProfile::clear_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ != nullptr) _impl_.regulatorsystem_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorDiscreteControlProfile::_internal_regulatorsystem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorDiscreteControlProfile::regulatorsystem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorDiscreteControlProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorDiscreteControlProfile::release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* released = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorDiscreteControlProfile::unsafe_arena_release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorDiscreteControlProfile::_internal_mutable_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorSystem>(GetArena());
    _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(p);
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorDiscreteControlProfile::mutable_regulatorsystem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorDiscreteControlProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorEventAndStatusATCC

// .commonmodule.ASG BndCtr = 1;
inline bool RegulatorEventAndStatusATCC::has_bndctr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bndctr_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_bndctr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.bndctr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::bndctr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  return _internal_bndctr();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndctr(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndctr_);
  }
  _impl_.bndctr_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_bndctr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ASG* released = _impl_.bndctr_;
  _impl_.bndctr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_bndctr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ASG* temp = _impl_.bndctr_;
  _impl_.bndctr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_bndctr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bndctr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.bndctr_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.bndctr_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_bndctr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ASG* _msg = _internal_mutable_bndctr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndctr(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndctr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bndctr_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
}

// .commonmodule.ASG BndWid = 2;
inline bool RegulatorEventAndStatusATCC::has_bndwid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bndwid_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_bndwid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.bndwid_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::bndwid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  return _internal_bndwid();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndwid(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwid_);
  }
  _impl_.bndwid_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_bndwid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ASG* released = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_bndwid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndWid)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ASG* temp = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_bndwid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bndwid_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.bndwid_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.bndwid_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_bndwid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ASG* _msg = _internal_mutable_bndwid();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndwid(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.bndwid_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
}

// .commonmodule.PhaseSPS BndWidHi = 3;
inline bool RegulatorEventAndStatusATCC::has_bndwidhi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bndwidhi_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_bndwidhi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPS* p = _impl_.bndwidhi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::bndwidhi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
  return _internal_bndwidhi();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndwidhi(
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwidhi_);
  }
  _impl_.bndwidhi_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_bndwidhi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::PhaseSPS* released = _impl_.bndwidhi_;
  _impl_.bndwidhi_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_bndwidhi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::PhaseSPS* temp = _impl_.bndwidhi_;
  _impl_.bndwidhi_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_bndwidhi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bndwidhi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPS>(GetArena());
    _impl_.bndwidhi_ = reinterpret_cast<::commonmodule::PhaseSPS*>(p);
  }
  return _impl_.bndwidhi_;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_bndwidhi()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_bndwidhi();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndwidhi(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwidhi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.bndwidhi_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
}

// .commonmodule.PhaseSPS BndWidLo = 4;
inline bool RegulatorEventAndStatusATCC::has_bndwidlo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bndwidlo_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_bndwidlo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPS* p = _impl_.bndwidlo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::bndwidlo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
  return _internal_bndwidlo();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndwidlo(
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwidlo_);
  }
  _impl_.bndwidlo_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_bndwidlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::PhaseSPS* released = _impl_.bndwidlo_;
  _impl_.bndwidlo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_bndwidlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::PhaseSPS* temp = _impl_.bndwidlo_;
  _impl_.bndwidlo_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_bndwidlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bndwidlo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPS>(GetArena());
    _impl_.bndwidlo_ = reinterpret_cast<::commonmodule::PhaseSPS*>(p);
  }
  return _impl_.bndwidlo_;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_bndwidlo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_bndwidlo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndwidlo(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bndwidlo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.bndwidlo_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
}

// .commonmodule.PhaseSPS DirCtlRev = 5;
inline bool RegulatorEventAndStatusATCC::has_dirctlrev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirctlrev_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_dirctlrev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPS* p = _impl_.dirctlrev_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::dirctlrev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
  return _internal_dirctlrev();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_dirctlrev(
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirctlrev_);
  }
  _impl_.dirctlrev_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_dirctlrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::PhaseSPS* released = _impl_.dirctlrev_;
  _impl_.dirctlrev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_dirctlrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::PhaseSPS* temp = _impl_.dirctlrev_;
  _impl_.dirctlrev_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_dirctlrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirctlrev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPS>(GetArena());
    _impl_.dirctlrev_ = reinterpret_cast<::commonmodule::PhaseSPS*>(p);
  }
  return _impl_.dirctlrev_;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_dirctlrev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_dirctlrev();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_dirctlrev(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirctlrev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.dirctlrev_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
}

// .commonmodule.PhaseSPS DirIndt = 6;
inline bool RegulatorEventAndStatusATCC::has_dirindt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirindt_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_dirindt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPS* p = _impl_.dirindt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::dirindt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
  return _internal_dirindt();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_dirindt(
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirindt_);
  }
  _impl_.dirindt_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_dirindt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::PhaseSPS* released = _impl_.dirindt_;
  _impl_.dirindt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_dirindt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::PhaseSPS* temp = _impl_.dirindt_;
  _impl_.dirindt_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_dirindt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirindt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPS>(GetArena());
    _impl_.dirindt_ = reinterpret_cast<::commonmodule::PhaseSPS*>(p);
  }
  return _impl_.dirindt_;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_dirindt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_dirindt();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_dirindt(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirindt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.dirindt_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
}

// .commonmodule.PhaseSPS DirRev = 7;
inline bool RegulatorEventAndStatusATCC::has_dirrev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirrev_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_dirrev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPS* p = _impl_.dirrev_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::dirrev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
  return _internal_dirrev();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_dirrev(
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirrev_);
  }
  _impl_.dirrev_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_dirrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::PhaseSPS* released = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_dirrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.DirRev)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::commonmodule::PhaseSPS* temp = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_dirrev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirrev_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPS>(GetArena());
    _impl_.dirrev_ = reinterpret_cast<::commonmodule::PhaseSPS*>(p);
  }
  return _impl_.dirrev_;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_dirrev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_dirrev();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_dirrev(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirrev_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.dirrev_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
}

// .commonmodule.ASG LDCR = 8;
inline bool RegulatorEventAndStatusATCC::has_ldcr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ldcr_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_ldcr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.ldcr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::ldcr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  return _internal_ldcr();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_ldcr(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcr_);
  }
  _impl_.ldcr_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_ldcr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::ASG* released = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_ldcr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.LDCR)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::commonmodule::ASG* temp = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_ldcr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ldcr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.ldcr_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.ldcr_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_ldcr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::commonmodule::ASG* _msg = _internal_mutable_ldcr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ldcr(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.ldcr_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
}

// .commonmodule.ASG LDCX = 9;
inline bool RegulatorEventAndStatusATCC::has_ldcx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ldcx_ != nullptr);
  return value;
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_ldcx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ASG* p = _impl_.ldcx_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::ldcx() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  return _internal_ldcx();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_ldcx(
    ::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcx_);
  }
  _impl_.ldcx_ = reinterpret_cast<::commonmodule::ASG*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_ldcx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::ASG* released = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ASG* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_ldcx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.LDCX)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::commonmodule::ASG* temp = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_ldcx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ldcx_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ASG>(GetArena());
    _impl_.ldcx_ = reinterpret_cast<::commonmodule::ASG*>(p);
  }
  return _impl_.ldcx_;
}
inline ::commonmodule::ASG* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_ldcx()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::commonmodule::ASG* _msg = _internal_mutable_ldcx();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ldcx(::commonmodule::ASG* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ldcx_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.ldcx_ = reinterpret_cast<::commonmodule::ASG*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
}

// .commonmodule.StatusSPS ParOp = 10;
inline bool RegulatorEventAndStatusATCC::has_parop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parop_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::_internal_parop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.parop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::parop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  return _internal_parop();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_parop(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parop_);
  }
  _impl_.parop_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_parop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::StatusSPS* released = _impl_.parop_;
  _impl_.parop_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_parop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.ParOp)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::commonmodule::StatusSPS* temp = _impl_.parop_;
  _impl_.parop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_parop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parop_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.parop_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.parop_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_parop()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_parop();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_parop(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parop_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.parop_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
}

// .commonmodule.RampRate rampRates = 11;
inline bool RegulatorEventAndStatusATCC::has_ramprates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ramprates_ != nullptr);
  return value;
}
inline const ::commonmodule::RampRate& RegulatorEventAndStatusATCC::_internal_ramprates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& RegulatorEventAndStatusATCC::ramprates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
  return _internal_ramprates();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::RampRate* released = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::RampRate* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.rampRates)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_ramprates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ramprates_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::RampRate>(GetArena());
    _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(p);
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_ramprates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ramprates(::commonmodule::RampRate* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ramprates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.ramprates_ = reinterpret_cast<::commonmodule::RampRate*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
}

// .commonmodule.Optional_StateKind state = 12;
inline bool RegulatorEventAndStatusATCC::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::commonmodule::Optional_StateKind& RegulatorEventAndStatusATCC::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& RegulatorEventAndStatusATCC::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.state)
  return _internal_state();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::commonmodule::Optional_StateKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.state)
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::Optional_StateKind* released = _impl_.state_;
  _impl_.state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.state)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Optional_StateKind>(GetArena());
    _impl_.state_ = reinterpret_cast<::commonmodule::Optional_StateKind*>(p);
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.state)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_state(::commonmodule::Optional_StateKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.state_ = reinterpret_cast<::commonmodule::Optional_StateKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.state)
}

// .commonmodule.StatusINC StDlTmms = 13;
inline bool RegulatorEventAndStatusATCC::has_stdltmms() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stdltmms_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusINC& RegulatorEventAndStatusATCC::_internal_stdltmms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusINC* p = _impl_.stdltmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINC&>(::commonmodule::_StatusINC_default_instance_);
}
inline const ::commonmodule::StatusINC& RegulatorEventAndStatusATCC::stdltmms() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
  return _internal_stdltmms();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_stdltmms(
    ::commonmodule::StatusINC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stdltmms_);
  }
  _impl_.stdltmms_ = reinterpret_cast<::commonmodule::StatusINC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
}
inline ::commonmodule::StatusINC* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_stdltmms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::StatusINC* released = _impl_.stdltmms_;
  _impl_.stdltmms_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusINC* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_stdltmms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::commonmodule::StatusINC* temp = _impl_.stdltmms_;
  _impl_.stdltmms_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINC* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_stdltmms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stdltmms_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusINC>(GetArena());
    _impl_.stdltmms_ = reinterpret_cast<::commonmodule::StatusINC*>(p);
  }
  return _impl_.stdltmms_;
}
inline ::commonmodule::StatusINC* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_stdltmms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00001000u;
  ::commonmodule::StatusINC* _msg = _internal_mutable_stdltmms();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_stdltmms(::commonmodule::StatusINC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stdltmms_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.stdltmms_ = reinterpret_cast<::commonmodule::StatusINC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
}

// .commonmodule.StatusSPS TapOpErr = 14;
inline bool RegulatorEventAndStatusATCC::has_tapoperr() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tapoperr_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::_internal_tapoperr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.tapoperr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::tapoperr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  return _internal_tapoperr();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_tapoperr(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tapoperr_);
  }
  _impl_.tapoperr_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_tapoperr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::commonmodule::StatusSPS* released = _impl_.tapoperr_;
  _impl_.tapoperr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_tapoperr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::commonmodule::StatusSPS* temp = _impl_.tapoperr_;
  _impl_.tapoperr_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_tapoperr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tapoperr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.tapoperr_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.tapoperr_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_tapoperr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00002000u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_tapoperr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_tapoperr(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tapoperr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }

  _impl_.tapoperr_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
}

// .commonmodule.PhaseINS TapPos = 15;
inline bool RegulatorEventAndStatusATCC::has_tappos() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tappos_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseINS& RegulatorEventAndStatusATCC::_internal_tappos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseINS* p = _impl_.tappos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseINS&>(::commonmodule::_PhaseINS_default_instance_);
}
inline const ::commonmodule::PhaseINS& RegulatorEventAndStatusATCC::tappos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  return _internal_tappos();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_tappos(
    ::commonmodule::PhaseINS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tappos_);
  }
  _impl_.tappos_ = reinterpret_cast<::commonmodule::PhaseINS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
}
inline ::commonmodule::PhaseINS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_tappos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::commonmodule::PhaseINS* released = _impl_.tappos_;
  _impl_.tappos_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseINS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_tappos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.TapPos)

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::commonmodule::PhaseINS* temp = _impl_.tappos_;
  _impl_.tappos_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseINS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_tappos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tappos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseINS>(GetArena());
    _impl_.tappos_ = reinterpret_cast<::commonmodule::PhaseINS*>(p);
  }
  return _impl_.tappos_;
}
inline ::commonmodule::PhaseINS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_tappos()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00004000u;
  ::commonmodule::PhaseINS* _msg = _internal_mutable_tappos();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_tappos(::commonmodule::PhaseINS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tappos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }

  _impl_.tappos_ = reinterpret_cast<::commonmodule::PhaseINS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
}

// .commonmodule.PhaseSPS VolLmtHi = 16;
inline bool RegulatorEventAndStatusATCC::has_vollmthi() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vollmthi_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_vollmthi() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPS* p = _impl_.vollmthi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::vollmthi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
  return _internal_vollmthi();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_vollmthi(
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmthi_);
  }
  _impl_.vollmthi_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_vollmthi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::commonmodule::PhaseSPS* released = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_vollmthi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::commonmodule::PhaseSPS* temp = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_vollmthi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vollmthi_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPS>(GetArena());
    _impl_.vollmthi_ = reinterpret_cast<::commonmodule::PhaseSPS*>(p);
  }
  return _impl_.vollmthi_;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_vollmthi()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00008000u;
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_vollmthi();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_vollmthi(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmthi_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.vollmthi_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
}

// .commonmodule.PhaseSPS VolLmtLo = 17;
inline bool RegulatorEventAndStatusATCC::has_vollmtlo() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vollmtlo_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_vollmtlo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseSPS* p = _impl_.vollmtlo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::vollmtlo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
  return _internal_vollmtlo();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_vollmtlo(
    ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtlo_);
  }
  _impl_.vollmtlo_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_vollmtlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::commonmodule::PhaseSPS* released = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_vollmtlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::commonmodule::PhaseSPS* temp = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_vollmtlo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vollmtlo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseSPS>(GetArena());
    _impl_.vollmtlo_ = reinterpret_cast<::commonmodule::PhaseSPS*>(p);
  }
  return _impl_.vollmtlo_;
}
inline ::commonmodule::PhaseSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_vollmtlo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00010000u;
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_vollmtlo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_vollmtlo(::commonmodule::PhaseSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtlo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }

  _impl_.vollmtlo_ = reinterpret_cast<::commonmodule::PhaseSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
}

// .commonmodule.PhaseAPC VolSpt = 18;
inline bool RegulatorEventAndStatusATCC::has_volspt() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volspt_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseAPC& RegulatorEventAndStatusATCC::_internal_volspt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseAPC* p = _impl_.volspt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorEventAndStatusATCC::volspt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
  return _internal_volspt();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_volspt(
    ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volspt_);
  }
  _impl_.volspt_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_volspt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::commonmodule::PhaseAPC* released = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_volspt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::commonmodule::PhaseAPC* temp = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_volspt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.volspt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseAPC>(GetArena());
    _impl_.volspt_ = reinterpret_cast<::commonmodule::PhaseAPC*>(p);
  }
  return _impl_.volspt_;
}
inline ::commonmodule::PhaseAPC* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_volspt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00020000u;
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_volspt();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_volspt(::commonmodule::PhaseAPC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volspt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }

  _impl_.volspt_ = reinterpret_cast<::commonmodule::PhaseAPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
}

// .commonmodule.StatusSPS voltageSetPointEnabled = 19;
inline bool RegulatorEventAndStatusATCC::has_voltagesetpointenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voltagesetpointenabled_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::_internal_voltagesetpointenabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusSPS* p = _impl_.voltagesetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::voltagesetpointenabled() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
  return _internal_voltagesetpointenabled();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_voltagesetpointenabled(
    ::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  _impl_.voltagesetpointenabled_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_voltagesetpointenabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::commonmodule::StatusSPS* released = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_voltagesetpointenabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::commonmodule::StatusSPS* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_voltagesetpointenabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.voltagesetpointenabled_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusSPS>(GetArena());
    _impl_.voltagesetpointenabled_ = reinterpret_cast<::commonmodule::StatusSPS*>(p);
  }
  return _impl_.voltagesetpointenabled_;
}
inline ::commonmodule::StatusSPS* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_voltagesetpointenabled()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00040000u;
  ::commonmodule::StatusSPS* _msg = _internal_mutable_voltagesetpointenabled();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.voltagesetpointenabled_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }

  _impl_.voltagesetpointenabled_ = reinterpret_cast<::commonmodule::StatusSPS*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
}

// .commonmodule.Optional_DirectionModeKind DirMod = 20;
inline bool RegulatorEventAndStatusATCC::has_dirmod() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirmod_ != nullptr);
  return value;
}
inline const ::commonmodule::Optional_DirectionModeKind& RegulatorEventAndStatusATCC::_internal_dirmod() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Optional_DirectionModeKind* p = _impl_.dirmod_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_DirectionModeKind&>(::commonmodule::_Optional_DirectionModeKind_default_instance_);
}
inline const ::commonmodule::Optional_DirectionModeKind& RegulatorEventAndStatusATCC::dirmod() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.DirMod)
  return _internal_dirmod();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_dirmod(
    ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirmod_);
  }
  _impl_.dirmod_ = reinterpret_cast<::commonmodule::Optional_DirectionModeKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirMod)
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_dirmod() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::commonmodule::Optional_DirectionModeKind* released = _impl_.dirmod_;
  _impl_.dirmod_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_dirmod() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.DirMod)

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::commonmodule::Optional_DirectionModeKind* temp = _impl_.dirmod_;
  _impl_.dirmod_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_dirmod() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dirmod_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Optional_DirectionModeKind>(GetArena());
    _impl_.dirmod_ = reinterpret_cast<::commonmodule::Optional_DirectionModeKind*>(p);
  }
  return _impl_.dirmod_;
}
inline ::commonmodule::Optional_DirectionModeKind* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_dirmod()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00080000u;
  ::commonmodule::Optional_DirectionModeKind* _msg = _internal_mutable_dirmod();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.DirMod)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_dirmod(::commonmodule::Optional_DirectionModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dirmod_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }

  _impl_.dirmod_ = reinterpret_cast<::commonmodule::Optional_DirectionModeKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirMod)
}

// .commonmodule.Optional_VoltLimitModeKind VolLmtMode = 21;
inline bool RegulatorEventAndStatusATCC::has_vollmtmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vollmtmode_ != nullptr);
  return value;
}
inline const ::commonmodule::Optional_VoltLimitModeKind& RegulatorEventAndStatusATCC::_internal_vollmtmode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::Optional_VoltLimitModeKind* p = _impl_.vollmtmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_VoltLimitModeKind&>(::commonmodule::_Optional_VoltLimitModeKind_default_instance_);
}
inline const ::commonmodule::Optional_VoltLimitModeKind& RegulatorEventAndStatusATCC::vollmtmode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.VolLmtMode)
  return _internal_vollmtmode();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_vollmtmode(
    ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtmode_);
  }
  _impl_.vollmtmode_ = reinterpret_cast<::commonmodule::Optional_VoltLimitModeKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtMode)
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::release_vollmtmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::commonmodule::Optional_VoltLimitModeKind* released = _impl_.vollmtmode_;
  _impl_.vollmtmode_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE RegulatorEventAndStatusATCC::unsafe_arena_release_vollmtmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.VolLmtMode)

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::commonmodule::Optional_VoltLimitModeKind* temp = _impl_.vollmtmode_;
  _impl_.vollmtmode_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::_internal_mutable_vollmtmode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vollmtmode_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::Optional_VoltLimitModeKind>(GetArena());
    _impl_.vollmtmode_ = reinterpret_cast<::commonmodule::Optional_VoltLimitModeKind*>(p);
  }
  return _impl_.vollmtmode_;
}
inline ::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NONNULL RegulatorEventAndStatusATCC::mutable_vollmtmode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00100000u;
  ::commonmodule::Optional_VoltLimitModeKind* _msg = _internal_mutable_vollmtmode();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.VolLmtMode)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vollmtmode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }

  _impl_.vollmtmode_ = reinterpret_cast<::commonmodule::Optional_VoltLimitModeKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtMode)
}

// -------------------------------------------------------------------

// RegulatorEventAndStatusANCR

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEventAndStatusANCR::has_logicalnodeforeventandstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logicalnodeforeventandstatus_ != nullptr);
  return value;
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& RegulatorEventAndStatusANCR::_internal_logicalnodeforeventandstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& RegulatorEventAndStatusANCR::logicalnodeforeventandstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void RegulatorEventAndStatusANCR::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE RegulatorEventAndStatusANCR::release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* released = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE RegulatorEventAndStatusANCR::unsafe_arena_release_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL RegulatorEventAndStatusANCR::_internal_mutable_logicalnodeforeventandstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::LogicalNodeForEventAndStatus>(GetArena());
    _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(p);
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NONNULL RegulatorEventAndStatusANCR::mutable_logicalnodeforeventandstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  return _msg;
}
inline void RegulatorEventAndStatusANCR::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.logicalnodeforeventandstatus_ = reinterpret_cast<::commonmodule::LogicalNodeForEventAndStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool RegulatorEventAndStatusANCR::has_dynamictest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dynamictest_ != nullptr);
  return value;
}
inline const ::commonmodule::ENS_DynamicTestKind& RegulatorEventAndStatusANCR::_internal_dynamictest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& RegulatorEventAndStatusANCR::dynamictest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  return _internal_dynamictest();
}
inline void RegulatorEventAndStatusANCR::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = reinterpret_cast<::commonmodule::ENS_DynamicTestKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE RegulatorEventAndStatusANCR::release_dynamictest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ENS_DynamicTestKind* released = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE RegulatorEventAndStatusANCR::unsafe_arena_release_dynamictest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NONNULL RegulatorEventAndStatusANCR::_internal_mutable_dynamictest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ENS_DynamicTestKind>(GetArena());
    _impl_.dynamictest_ = reinterpret_cast<::commonmodule::ENS_DynamicTestKind*>(p);
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* PROTOBUF_NONNULL RegulatorEventAndStatusANCR::mutable_dynamictest()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  return _msg;
}
inline void RegulatorEventAndStatusANCR::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dynamictest_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dynamictest_ = reinterpret_cast<::commonmodule::ENS_DynamicTestKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
}

// .regulatormodule.RegulatorEventAndStatusATCC PointStatus = 3;
inline bool RegulatorEventAndStatusANCR::has_pointstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pointstatus_ != nullptr);
  return value;
}
inline void RegulatorEventAndStatusANCR::clear_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pointstatus_ != nullptr) _impl_.pointstatus_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::regulatormodule::RegulatorEventAndStatusATCC& RegulatorEventAndStatusANCR::_internal_pointstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorEventAndStatusATCC* p = _impl_.pointstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusATCC&>(::regulatormodule::_RegulatorEventAndStatusATCC_default_instance_);
}
inline const ::regulatormodule::RegulatorEventAndStatusATCC& RegulatorEventAndStatusANCR::pointstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  return _internal_pointstatus();
}
inline void RegulatorEventAndStatusANCR::unsafe_arena_set_allocated_pointstatus(
    ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pointstatus_);
  }
  _impl_.pointstatus_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusATCC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE RegulatorEventAndStatusANCR::release_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorEventAndStatusATCC* released = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE RegulatorEventAndStatusANCR::unsafe_arena_release_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorEventAndStatusATCC* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NONNULL RegulatorEventAndStatusANCR::_internal_mutable_pointstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pointstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorEventAndStatusATCC>(GetArena());
    _impl_.pointstatus_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusATCC*>(p);
  }
  return _impl_.pointstatus_;
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NONNULL RegulatorEventAndStatusANCR::mutable_pointstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::regulatormodule::RegulatorEventAndStatusATCC* _msg = _internal_mutable_pointstatus();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  return _msg;
}
inline void RegulatorEventAndStatusANCR::set_allocated_pointstatus(::regulatormodule::RegulatorEventAndStatusATCC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pointstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.pointstatus_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusATCC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
}

// -------------------------------------------------------------------

// RegulatorEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEvent::has_eventvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::EventValue& RegulatorEvent::_internal_eventvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& RegulatorEvent::eventvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEvent.eventValue)
  return _internal_eventvalue();
}
inline void RegulatorEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = reinterpret_cast<::commonmodule::EventValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEvent.eventValue)
}
inline ::commonmodule::EventValue* PROTOBUF_NULLABLE RegulatorEvent::release_eventvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventValue* released = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::EventValue* PROTOBUF_NULLABLE RegulatorEvent::unsafe_arena_release_eventvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEvent.eventValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* PROTOBUF_NONNULL RegulatorEvent::_internal_mutable_eventvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::EventValue>(GetArena());
    _impl_.eventvalue_ = reinterpret_cast<::commonmodule::EventValue*>(p);
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* PROTOBUF_NONNULL RegulatorEvent::mutable_eventvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEvent.eventValue)
  return _msg;
}
inline void RegulatorEvent::set_allocated_eventvalue(::commonmodule::EventValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.eventvalue_ = reinterpret_cast<::commonmodule::EventValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEvent.eventValue)
}

// .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
inline bool RegulatorEvent::has_regulatoreventandstatusancr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatoreventandstatusancr_ != nullptr);
  return value;
}
inline void RegulatorEvent::clear_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatoreventandstatusancr_ != nullptr) _impl_.regulatoreventandstatusancr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorEvent::_internal_regulatoreventandstatusancr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorEventAndStatusANCR* p = _impl_.regulatoreventandstatusancr_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusANCR&>(::regulatormodule::_RegulatorEventAndStatusANCR_default_instance_);
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorEvent::regulatoreventandstatusancr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  return _internal_regulatoreventandstatusancr();
}
inline void RegulatorEvent::unsafe_arena_set_allocated_regulatoreventandstatusancr(
    ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatoreventandstatusancr_);
  }
  _impl_.regulatoreventandstatusancr_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusANCR*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE RegulatorEvent::release_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorEventAndStatusANCR* released = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE RegulatorEvent::unsafe_arena_release_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL RegulatorEvent::_internal_mutable_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatoreventandstatusancr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorEventAndStatusANCR>(GetArena());
    _impl_.regulatoreventandstatusancr_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusANCR*>(p);
  }
  return _impl_.regulatoreventandstatusancr_;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL RegulatorEvent::mutable_regulatoreventandstatusancr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorEventAndStatusANCR* _msg = _internal_mutable_regulatoreventandstatusancr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  return _msg;
}
inline void RegulatorEvent::set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatoreventandstatusancr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatoreventandstatusancr_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusANCR*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
}

// -------------------------------------------------------------------

// RegulatorEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEventProfile::has_eventmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::EventMessageInfo& RegulatorEventProfile::_internal_eventmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& RegulatorEventProfile::eventmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void RegulatorEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = reinterpret_cast<::commonmodule::EventMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE RegulatorEventProfile::release_eventmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventMessageInfo* released = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE RegulatorEventProfile::unsafe_arena_release_eventmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.eventMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL RegulatorEventProfile::_internal_mutable_eventmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::EventMessageInfo>(GetArena());
    _impl_.eventmessageinfo_ = reinterpret_cast<::commonmodule::EventMessageInfo*>(p);
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* PROTOBUF_NONNULL RegulatorEventProfile::mutable_eventmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  return _msg;
}
inline void RegulatorEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.eventmessageinfo_ = reinterpret_cast<::commonmodule::EventMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.eventMessageInfo)
}

// .regulatormodule.RegulatorEvent regulatorEvent = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventProfile::has_regulatorevent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorevent_ != nullptr);
  return value;
}
inline void RegulatorEventProfile::clear_regulatorevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorevent_ != nullptr) _impl_.regulatorevent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorEvent& RegulatorEventProfile::_internal_regulatorevent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorEvent* p = _impl_.regulatorevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEvent&>(::regulatormodule::_RegulatorEvent_default_instance_);
}
inline const ::regulatormodule::RegulatorEvent& RegulatorEventProfile::regulatorevent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.regulatorEvent)
  return _internal_regulatorevent();
}
inline void RegulatorEventProfile::unsafe_arena_set_allocated_regulatorevent(
    ::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorevent_);
  }
  _impl_.regulatorevent_ = reinterpret_cast<::regulatormodule::RegulatorEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventProfile.regulatorEvent)
}
inline ::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE RegulatorEventProfile::release_regulatorevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorEvent* released = _impl_.regulatorevent_;
  _impl_.regulatorevent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE RegulatorEventProfile::unsafe_arena_release_regulatorevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.regulatorEvent)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorEvent* temp = _impl_.regulatorevent_;
  _impl_.regulatorevent_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEvent* PROTOBUF_NONNULL RegulatorEventProfile::_internal_mutable_regulatorevent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorevent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorEvent>(GetArena());
    _impl_.regulatorevent_ = reinterpret_cast<::regulatormodule::RegulatorEvent*>(p);
  }
  return _impl_.regulatorevent_;
}
inline ::regulatormodule::RegulatorEvent* PROTOBUF_NONNULL RegulatorEventProfile::mutable_regulatorevent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorEvent* _msg = _internal_mutable_regulatorevent();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.regulatorEvent)
  return _msg;
}
inline void RegulatorEventProfile::set_allocated_regulatorevent(::regulatormodule::RegulatorEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorevent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatorevent_ = reinterpret_cast<::regulatormodule::RegulatorEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.regulatorEvent)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventProfile::has_regulatorsystem() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorsystem_ != nullptr);
  return value;
}
inline void RegulatorEventProfile::clear_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ != nullptr) _impl_.regulatorsystem_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorEventProfile::_internal_regulatorsystem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorEventProfile::regulatorsystem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorEventProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorEventProfile::release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* released = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorEventProfile::unsafe_arena_release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.regulatorSystem)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorEventProfile::_internal_mutable_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorSystem>(GetArena());
    _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(p);
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorEventProfile::mutable_regulatorsystem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorEventProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorReading::has_conductingequipmentterminalreading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conductingequipmentterminalreading_ != nullptr);
  return value;
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& RegulatorReading::_internal_conductingequipmentterminalreading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& RegulatorReading::conductingequipmentterminalreading() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void RegulatorReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = reinterpret_cast<::commonmodule::ConductingEquipmentTerminalReading*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE RegulatorReading::release_conductingequipmentterminalreading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipmentTerminalReading* released = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE RegulatorReading::unsafe_arena_release_conductingequipmentterminalreading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL RegulatorReading::_internal_mutable_conductingequipmentterminalreading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ConductingEquipmentTerminalReading>(GetArena());
    _impl_.conductingequipmentterminalreading_ = reinterpret_cast<::commonmodule::ConductingEquipmentTerminalReading*>(p);
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NONNULL RegulatorReading::mutable_conductingequipmentterminalreading()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void RegulatorReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.conductingequipmentterminalreading_ = reinterpret_cast<::commonmodule::ConductingEquipmentTerminalReading*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool RegulatorReading::has_phasemmtn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.phasemmtn_ != nullptr);
  return value;
}
inline const ::commonmodule::PhaseMMTN& RegulatorReading::_internal_phasemmtn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& RegulatorReading::phasemmtn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void RegulatorReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = reinterpret_cast<::commonmodule::PhaseMMTN*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE RegulatorReading::release_phasemmtn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::PhaseMMTN* released = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE RegulatorReading::unsafe_arena_release_phasemmtn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.phaseMMTN)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL RegulatorReading::_internal_mutable_phasemmtn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::PhaseMMTN>(GetArena());
    _impl_.phasemmtn_ = reinterpret_cast<::commonmodule::PhaseMMTN*>(p);
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* PROTOBUF_NONNULL RegulatorReading::mutable_phasemmtn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.phaseMMTN)
  return _msg;
}
inline void RegulatorReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.phasemmtn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.phasemmtn_ = reinterpret_cast<::commonmodule::PhaseMMTN*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool RegulatorReading::has_readingmmtr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmmtr_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMMTR& RegulatorReading::_internal_readingmmtr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& RegulatorReading::readingmmtr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void RegulatorReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = reinterpret_cast<::commonmodule::ReadingMMTR*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE RegulatorReading::release_readingmmtr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ReadingMMTR* released = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE RegulatorReading::unsafe_arena_release_readingmmtr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.readingMMTR)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL RegulatorReading::_internal_mutable_readingmmtr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMMTR>(GetArena());
    _impl_.readingmmtr_ = reinterpret_cast<::commonmodule::ReadingMMTR*>(p);
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* PROTOBUF_NONNULL RegulatorReading::mutable_readingmmtr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.readingMMTR)
  return _msg;
}
inline void RegulatorReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmtr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.readingmmtr_ = reinterpret_cast<::commonmodule::ReadingMMTR*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool RegulatorReading::has_readingmmxu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmmxu_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::_internal_readingmmxu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::readingmmxu() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void RegulatorReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE RegulatorReading::release_readingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ReadingMMXU* released = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE RegulatorReading::unsafe_arena_release_readingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.readingMMXU)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL RegulatorReading::_internal_mutable_readingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMMXU>(GetArena());
    _impl_.readingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(p);
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL RegulatorReading::mutable_readingmmxu()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.readingMMXU)
  return _msg;
}
inline void RegulatorReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmxu_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.readingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.readingMMXU)
}

// .commonmodule.ReadingMMXU secondaryReadingMMXU = 5;
inline bool RegulatorReading::has_secondaryreadingmmxu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.secondaryreadingmmxu_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::_internal_secondaryreadingmmxu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMMXU* p = _impl_.secondaryreadingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::secondaryreadingmmxu() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.secondaryReadingMMXU)
  return _internal_secondaryreadingmmxu();
}
inline void RegulatorReading::unsafe_arena_set_allocated_secondaryreadingmmxu(
    ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondaryreadingmmxu_);
  }
  _impl_.secondaryreadingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.secondaryReadingMMXU)
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE RegulatorReading::release_secondaryreadingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ReadingMMXU* released = _impl_.secondaryreadingmmxu_;
  _impl_.secondaryreadingmmxu_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE RegulatorReading::unsafe_arena_release_secondaryreadingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.secondaryReadingMMXU)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::commonmodule::ReadingMMXU* temp = _impl_.secondaryreadingmmxu_;
  _impl_.secondaryreadingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL RegulatorReading::_internal_mutable_secondaryreadingmmxu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secondaryreadingmmxu_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMMXU>(GetArena());
    _impl_.secondaryreadingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(p);
  }
  return _impl_.secondaryreadingmmxu_;
}
inline ::commonmodule::ReadingMMXU* PROTOBUF_NONNULL RegulatorReading::mutable_secondaryreadingmmxu()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_secondaryreadingmmxu();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.secondaryReadingMMXU)
  return _msg;
}
inline void RegulatorReading::set_allocated_secondaryreadingmmxu(::commonmodule::ReadingMMXU* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondaryreadingmmxu_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.secondaryreadingmmxu_ = reinterpret_cast<::commonmodule::ReadingMMXU*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.secondaryReadingMMXU)
}

// .commonmodule.ReadingMMDC readingMMDC = 6;
inline bool RegulatorReading::has_readingmmdc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmmdc_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMMDC& RegulatorReading::_internal_readingmmdc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMMDC* p = _impl_.readingmmdc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMDC&>(::commonmodule::_ReadingMMDC_default_instance_);
}
inline const ::commonmodule::ReadingMMDC& RegulatorReading::readingmmdc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.readingMMDC)
  return _internal_readingmmdc();
}
inline void RegulatorReading::unsafe_arena_set_allocated_readingmmdc(
    ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmdc_);
  }
  _impl_.readingmmdc_ = reinterpret_cast<::commonmodule::ReadingMMDC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.readingMMDC)
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE RegulatorReading::release_readingmmdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::ReadingMMDC* released = _impl_.readingmmdc_;
  _impl_.readingmmdc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE RegulatorReading::unsafe_arena_release_readingmmdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.readingMMDC)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::commonmodule::ReadingMMDC* temp = _impl_.readingmmdc_;
  _impl_.readingmmdc_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL RegulatorReading::_internal_mutable_readingmmdc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmmdc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMMDC>(GetArena());
    _impl_.readingmmdc_ = reinterpret_cast<::commonmodule::ReadingMMDC*>(p);
  }
  return _impl_.readingmmdc_;
}
inline ::commonmodule::ReadingMMDC* PROTOBUF_NONNULL RegulatorReading::mutable_readingmmdc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::commonmodule::ReadingMMDC* _msg = _internal_mutable_readingmmdc();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.readingMMDC)
  return _msg;
}
inline void RegulatorReading::set_allocated_readingmmdc(::commonmodule::ReadingMMDC* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmmdc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.readingmmdc_ = reinterpret_cast<::commonmodule::ReadingMMDC*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.readingMMDC)
}

// -------------------------------------------------------------------

// RegulatorReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorReadingProfile::has_readingmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.readingmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::ReadingMessageInfo& RegulatorReadingProfile::_internal_readingmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& RegulatorReadingProfile::readingmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void RegulatorReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = reinterpret_cast<::commonmodule::ReadingMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE RegulatorReadingProfile::release_readingmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ReadingMessageInfo* released = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE RegulatorReadingProfile::unsafe_arena_release_readingmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReadingProfile.readingMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL RegulatorReadingProfile::_internal_mutable_readingmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::ReadingMessageInfo>(GetArena());
    _impl_.readingmessageinfo_ = reinterpret_cast<::commonmodule::ReadingMessageInfo*>(p);
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* PROTOBUF_NONNULL RegulatorReadingProfile::mutable_readingmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  return _msg;
}
inline void RegulatorReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.readingmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.readingmessageinfo_ = reinterpret_cast<::commonmodule::ReadingMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
}

// repeated .regulatormodule.RegulatorReading regulatorReading = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
inline int RegulatorReadingProfile::_internal_regulatorreading_size() const {
  return _internal_regulatorreading().size();
}
inline int RegulatorReadingProfile::regulatorreading_size() const {
  return _internal_regulatorreading_size();
}
inline void RegulatorReadingProfile::clear_regulatorreading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.regulatorreading_.Clear();
}
inline ::regulatormodule::RegulatorReading* PROTOBUF_NONNULL RegulatorReadingProfile::mutable_regulatorreading(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _internal_mutable_regulatorreading()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>* PROTOBUF_NONNULL RegulatorReadingProfile::mutable_regulatorreading()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:regulatormodule.RegulatorReadingProfile.regulatorReading)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_regulatorreading();
}
inline const ::regulatormodule::RegulatorReading& RegulatorReadingProfile::regulatorreading(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _internal_regulatorreading().Get(index);
}
inline ::regulatormodule::RegulatorReading* PROTOBUF_NONNULL RegulatorReadingProfile::add_regulatorreading()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::regulatormodule::RegulatorReading* _add = _internal_mutable_regulatorreading()->Add();
  // @@protoc_insertion_point(field_add:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>& RegulatorReadingProfile::regulatorreading() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _internal_regulatorreading();
}
inline const ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>&
RegulatorReadingProfile::_internal_regulatorreading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.regulatorreading_;
}
inline ::google::protobuf::RepeatedPtrField<::regulatormodule::RegulatorReading>* PROTOBUF_NONNULL
RegulatorReadingProfile::_internal_mutable_regulatorreading() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.regulatorreading_;
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorReadingProfile::has_regulatorsystem() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorsystem_ != nullptr);
  return value;
}
inline void RegulatorReadingProfile::clear_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ != nullptr) _impl_.regulatorsystem_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorReadingProfile::_internal_regulatorsystem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorReadingProfile::regulatorsystem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorReadingProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReadingProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorReadingProfile::release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorSystem* released = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorReadingProfile::unsafe_arena_release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReadingProfile.regulatorSystem)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorReadingProfile::_internal_mutable_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorSystem>(GetArena());
    _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(p);
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorReadingProfile::mutable_regulatorsystem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorReadingProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReadingProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorStatus::has_statusvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statusvalue_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusValue& RegulatorStatus::_internal_statusvalue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& RegulatorStatus::statusvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatus.statusValue)
  return _internal_statusvalue();
}
inline void RegulatorStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = reinterpret_cast<::commonmodule::StatusValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatus.statusValue)
}
inline ::commonmodule::StatusValue* PROTOBUF_NULLABLE RegulatorStatus::release_statusvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusValue* released = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusValue* PROTOBUF_NULLABLE RegulatorStatus::unsafe_arena_release_statusvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatus.statusValue)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* PROTOBUF_NONNULL RegulatorStatus::_internal_mutable_statusvalue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusValue>(GetArena());
    _impl_.statusvalue_ = reinterpret_cast<::commonmodule::StatusValue*>(p);
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* PROTOBUF_NONNULL RegulatorStatus::mutable_statusvalue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatus.statusValue)
  return _msg;
}
inline void RegulatorStatus::set_allocated_statusvalue(::commonmodule::StatusValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.statusvalue_ = reinterpret_cast<::commonmodule::StatusValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatus.statusValue)
}

// .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
inline bool RegulatorStatus::has_regulatoreventandstatusancr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatoreventandstatusancr_ != nullptr);
  return value;
}
inline void RegulatorStatus::clear_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatoreventandstatusancr_ != nullptr) _impl_.regulatoreventandstatusancr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorStatus::_internal_regulatoreventandstatusancr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorEventAndStatusANCR* p = _impl_.regulatoreventandstatusancr_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusANCR&>(::regulatormodule::_RegulatorEventAndStatusANCR_default_instance_);
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorStatus::regulatoreventandstatusancr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  return _internal_regulatoreventandstatusancr();
}
inline void RegulatorStatus::unsafe_arena_set_allocated_regulatoreventandstatusancr(
    ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatoreventandstatusancr_);
  }
  _impl_.regulatoreventandstatusancr_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusANCR*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE RegulatorStatus::release_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorEventAndStatusANCR* released = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE RegulatorStatus::unsafe_arena_release_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL RegulatorStatus::_internal_mutable_regulatoreventandstatusancr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatoreventandstatusancr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorEventAndStatusANCR>(GetArena());
    _impl_.regulatoreventandstatusancr_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusANCR*>(p);
  }
  return _impl_.regulatoreventandstatusancr_;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NONNULL RegulatorStatus::mutable_regulatoreventandstatusancr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorEventAndStatusANCR* _msg = _internal_mutable_regulatoreventandstatusancr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  return _msg;
}
inline void RegulatorStatus::set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatoreventandstatusancr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatoreventandstatusancr_ = reinterpret_cast<::regulatormodule::RegulatorEventAndStatusANCR*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
}

// -------------------------------------------------------------------

// RegulatorStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorStatusProfile::has_statusmessageinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statusmessageinfo_ != nullptr);
  return value;
}
inline const ::commonmodule::StatusMessageInfo& RegulatorStatusProfile::_internal_statusmessageinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& RegulatorStatusProfile::statusmessageinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void RegulatorStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = reinterpret_cast<::commonmodule::StatusMessageInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE RegulatorStatusProfile::release_statusmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusMessageInfo* released = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE RegulatorStatusProfile::unsafe_arena_release_statusmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.statusMessageInfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL RegulatorStatusProfile::_internal_mutable_statusmessageinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::commonmodule::StatusMessageInfo>(GetArena());
    _impl_.statusmessageinfo_ = reinterpret_cast<::commonmodule::StatusMessageInfo*>(p);
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* PROTOBUF_NONNULL RegulatorStatusProfile::mutable_statusmessageinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  return _msg;
}
inline void RegulatorStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statusmessageinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.statusmessageinfo_ = reinterpret_cast<::commonmodule::StatusMessageInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
}

// .regulatormodule.RegulatorStatus regulatorStatus = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatusProfile::has_regulatorstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorstatus_ != nullptr);
  return value;
}
inline void RegulatorStatusProfile::clear_regulatorstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorstatus_ != nullptr) _impl_.regulatorstatus_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::regulatormodule::RegulatorStatus& RegulatorStatusProfile::_internal_regulatorstatus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorStatus* p = _impl_.regulatorstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorStatus&>(::regulatormodule::_RegulatorStatus_default_instance_);
}
inline const ::regulatormodule::RegulatorStatus& RegulatorStatusProfile::regulatorstatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  return _internal_regulatorstatus();
}
inline void RegulatorStatusProfile::unsafe_arena_set_allocated_regulatorstatus(
    ::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorstatus_);
  }
  _impl_.regulatorstatus_ = reinterpret_cast<::regulatormodule::RegulatorStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorStatus)
}
inline ::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE RegulatorStatusProfile::release_regulatorstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorStatus* released = _impl_.regulatorstatus_;
  _impl_.regulatorstatus_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE RegulatorStatusProfile::unsafe_arena_release_regulatorstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.regulatorStatus)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::regulatormodule::RegulatorStatus* temp = _impl_.regulatorstatus_;
  _impl_.regulatorstatus_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorStatus* PROTOBUF_NONNULL RegulatorStatusProfile::_internal_mutable_regulatorstatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorstatus_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorStatus>(GetArena());
    _impl_.regulatorstatus_ = reinterpret_cast<::regulatormodule::RegulatorStatus*>(p);
  }
  return _impl_.regulatorstatus_;
}
inline ::regulatormodule::RegulatorStatus* PROTOBUF_NONNULL RegulatorStatusProfile::mutable_regulatorstatus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::regulatormodule::RegulatorStatus* _msg = _internal_mutable_regulatorstatus();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  return _msg;
}
inline void RegulatorStatusProfile::set_allocated_regulatorstatus(::regulatormodule::RegulatorStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorstatus_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.regulatorstatus_ = reinterpret_cast<::regulatormodule::RegulatorStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorStatus)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatusProfile::has_regulatorsystem() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regulatorsystem_ != nullptr);
  return value;
}
inline void RegulatorStatusProfile::clear_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ != nullptr) _impl_.regulatorsystem_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorStatusProfile::_internal_regulatorsystem() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorStatusProfile::regulatorsystem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorStatusProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorStatusProfile::release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* released = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE RegulatorStatusProfile::unsafe_arena_release_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.regulatorSystem)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorStatusProfile::_internal_mutable_regulatorsystem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::regulatormodule::RegulatorSystem>(GetArena());
    _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(p);
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* PROTOBUF_NONNULL RegulatorStatusProfile::mutable_regulatorsystem()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorStatusProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regulatorsystem_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.regulatorsystem_ = reinterpret_cast<::regulatormodule::RegulatorSystem*>(value);
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorSystem)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace regulatormodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // regulatormodule_2fregulatormodule_2eproto_2epb_2eh
