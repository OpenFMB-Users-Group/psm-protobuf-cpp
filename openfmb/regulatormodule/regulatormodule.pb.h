// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: regulatormodule/regulatormodule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_regulatormodule_2fregulatormodule_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_regulatormodule_2fregulatormodule_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "uml.pb.h"
#include "commonmodule/commonmodule.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_regulatormodule_2fregulatormodule_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_regulatormodule_2fregulatormodule_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_regulatormodule_2fregulatormodule_2eproto;
namespace regulatormodule {
class DirectionalATCC;
struct DirectionalATCCDefaultTypeInternal;
extern DirectionalATCCDefaultTypeInternal _DirectionalATCC_default_instance_;
class RegulatorCSG;
struct RegulatorCSGDefaultTypeInternal;
extern RegulatorCSGDefaultTypeInternal _RegulatorCSG_default_instance_;
class RegulatorControl;
struct RegulatorControlDefaultTypeInternal;
extern RegulatorControlDefaultTypeInternal _RegulatorControl_default_instance_;
class RegulatorControlATCC;
struct RegulatorControlATCCDefaultTypeInternal;
extern RegulatorControlATCCDefaultTypeInternal _RegulatorControlATCC_default_instance_;
class RegulatorControlFSCC;
struct RegulatorControlFSCCDefaultTypeInternal;
extern RegulatorControlFSCCDefaultTypeInternal _RegulatorControlFSCC_default_instance_;
class RegulatorControlProfile;
struct RegulatorControlProfileDefaultTypeInternal;
extern RegulatorControlProfileDefaultTypeInternal _RegulatorControlProfile_default_instance_;
class RegulatorControlScheduleFSCH;
struct RegulatorControlScheduleFSCHDefaultTypeInternal;
extern RegulatorControlScheduleFSCHDefaultTypeInternal _RegulatorControlScheduleFSCH_default_instance_;
class RegulatorDiscreteControl;
struct RegulatorDiscreteControlDefaultTypeInternal;
extern RegulatorDiscreteControlDefaultTypeInternal _RegulatorDiscreteControl_default_instance_;
class RegulatorDiscreteControlProfile;
struct RegulatorDiscreteControlProfileDefaultTypeInternal;
extern RegulatorDiscreteControlProfileDefaultTypeInternal _RegulatorDiscreteControlProfile_default_instance_;
class RegulatorEvent;
struct RegulatorEventDefaultTypeInternal;
extern RegulatorEventDefaultTypeInternal _RegulatorEvent_default_instance_;
class RegulatorEventAndStatusANCR;
struct RegulatorEventAndStatusANCRDefaultTypeInternal;
extern RegulatorEventAndStatusANCRDefaultTypeInternal _RegulatorEventAndStatusANCR_default_instance_;
class RegulatorEventAndStatusATCC;
struct RegulatorEventAndStatusATCCDefaultTypeInternal;
extern RegulatorEventAndStatusATCCDefaultTypeInternal _RegulatorEventAndStatusATCC_default_instance_;
class RegulatorEventProfile;
struct RegulatorEventProfileDefaultTypeInternal;
extern RegulatorEventProfileDefaultTypeInternal _RegulatorEventProfile_default_instance_;
class RegulatorPoint;
struct RegulatorPointDefaultTypeInternal;
extern RegulatorPointDefaultTypeInternal _RegulatorPoint_default_instance_;
class RegulatorReading;
struct RegulatorReadingDefaultTypeInternal;
extern RegulatorReadingDefaultTypeInternal _RegulatorReading_default_instance_;
class RegulatorReadingProfile;
struct RegulatorReadingProfileDefaultTypeInternal;
extern RegulatorReadingProfileDefaultTypeInternal _RegulatorReadingProfile_default_instance_;
class RegulatorStatus;
struct RegulatorStatusDefaultTypeInternal;
extern RegulatorStatusDefaultTypeInternal _RegulatorStatus_default_instance_;
class RegulatorStatusProfile;
struct RegulatorStatusProfileDefaultTypeInternal;
extern RegulatorStatusProfileDefaultTypeInternal _RegulatorStatusProfile_default_instance_;
class RegulatorSystem;
struct RegulatorSystemDefaultTypeInternal;
extern RegulatorSystemDefaultTypeInternal _RegulatorSystem_default_instance_;
}  // namespace regulatormodule
PROTOBUF_NAMESPACE_OPEN
template <>
::regulatormodule::DirectionalATCC* Arena::CreateMaybeMessage<::regulatormodule::DirectionalATCC>(Arena*);
template <>
::regulatormodule::RegulatorCSG* Arena::CreateMaybeMessage<::regulatormodule::RegulatorCSG>(Arena*);
template <>
::regulatormodule::RegulatorControl* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControl>(Arena*);
template <>
::regulatormodule::RegulatorControlATCC* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlATCC>(Arena*);
template <>
::regulatormodule::RegulatorControlFSCC* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlFSCC>(Arena*);
template <>
::regulatormodule::RegulatorControlProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlProfile>(Arena*);
template <>
::regulatormodule::RegulatorControlScheduleFSCH* Arena::CreateMaybeMessage<::regulatormodule::RegulatorControlScheduleFSCH>(Arena*);
template <>
::regulatormodule::RegulatorDiscreteControl* Arena::CreateMaybeMessage<::regulatormodule::RegulatorDiscreteControl>(Arena*);
template <>
::regulatormodule::RegulatorDiscreteControlProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorDiscreteControlProfile>(Arena*);
template <>
::regulatormodule::RegulatorEvent* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEvent>(Arena*);
template <>
::regulatormodule::RegulatorEventAndStatusANCR* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusANCR>(Arena*);
template <>
::regulatormodule::RegulatorEventAndStatusATCC* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusATCC>(Arena*);
template <>
::regulatormodule::RegulatorEventProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorEventProfile>(Arena*);
template <>
::regulatormodule::RegulatorPoint* Arena::CreateMaybeMessage<::regulatormodule::RegulatorPoint>(Arena*);
template <>
::regulatormodule::RegulatorReading* Arena::CreateMaybeMessage<::regulatormodule::RegulatorReading>(Arena*);
template <>
::regulatormodule::RegulatorReadingProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorReadingProfile>(Arena*);
template <>
::regulatormodule::RegulatorStatus* Arena::CreateMaybeMessage<::regulatormodule::RegulatorStatus>(Arena*);
template <>
::regulatormodule::RegulatorStatusProfile* Arena::CreateMaybeMessage<::regulatormodule::RegulatorStatusProfile>(Arena*);
template <>
::regulatormodule::RegulatorSystem* Arena::CreateMaybeMessage<::regulatormodule::RegulatorSystem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace regulatormodule {

// ===================================================================


// -------------------------------------------------------------------

class DirectionalATCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.DirectionalATCC) */ {
 public:
  inline DirectionalATCC() : DirectionalATCC(nullptr) {}
  ~DirectionalATCC() override;
  explicit PROTOBUF_CONSTEXPR DirectionalATCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionalATCC(const DirectionalATCC& from);
  DirectionalATCC(DirectionalATCC&& from) noexcept
    : DirectionalATCC() {
    *this = ::std::move(from);
  }

  inline DirectionalATCC& operator=(const DirectionalATCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionalATCC& operator=(DirectionalATCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectionalATCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionalATCC* internal_default_instance() {
    return reinterpret_cast<const DirectionalATCC*>(
               &_DirectionalATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DirectionalATCC& a, DirectionalATCC& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionalATCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionalATCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionalATCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionalATCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectionalATCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirectionalATCC& from) {
    DirectionalATCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectionalATCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.DirectionalATCC";
  }
  protected:
  explicit DirectionalATCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBndWidFieldNumber = 1,
    kCtlDlTmmsFieldNumber = 2,
    kLDCRFieldNumber = 3,
    kLDCXFieldNumber = 4,
    kVolSptFieldNumber = 5,
    kVoltageSetPointEnabledFieldNumber = 6,
  };
  // .commonmodule.PhaseAPC BndWid = 1;
  bool has_bndwid() const;
  private:
  bool _internal_has_bndwid() const;

  public:
  void clear_bndwid() ;
  const ::commonmodule::PhaseAPC& bndwid() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_bndwid();
  ::commonmodule::PhaseAPC* mutable_bndwid();
  void set_allocated_bndwid(::commonmodule::PhaseAPC* bndwid);
  private:
  const ::commonmodule::PhaseAPC& _internal_bndwid() const;
  ::commonmodule::PhaseAPC* _internal_mutable_bndwid();
  public:
  void unsafe_arena_set_allocated_bndwid(
      ::commonmodule::PhaseAPC* bndwid);
  ::commonmodule::PhaseAPC* unsafe_arena_release_bndwid();
  // .commonmodule.PhaseISC CtlDlTmms = 2;
  bool has_ctldltmms() const;
  private:
  bool _internal_has_ctldltmms() const;

  public:
  void clear_ctldltmms() ;
  const ::commonmodule::PhaseISC& ctldltmms() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseISC* release_ctldltmms();
  ::commonmodule::PhaseISC* mutable_ctldltmms();
  void set_allocated_ctldltmms(::commonmodule::PhaseISC* ctldltmms);
  private:
  const ::commonmodule::PhaseISC& _internal_ctldltmms() const;
  ::commonmodule::PhaseISC* _internal_mutable_ctldltmms();
  public:
  void unsafe_arena_set_allocated_ctldltmms(
      ::commonmodule::PhaseISC* ctldltmms);
  ::commonmodule::PhaseISC* unsafe_arena_release_ctldltmms();
  // .commonmodule.PhaseAPC LDCR = 3;
  bool has_ldcr() const;
  private:
  bool _internal_has_ldcr() const;

  public:
  void clear_ldcr() ;
  const ::commonmodule::PhaseAPC& ldcr() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_ldcr();
  ::commonmodule::PhaseAPC* mutable_ldcr();
  void set_allocated_ldcr(::commonmodule::PhaseAPC* ldcr);
  private:
  const ::commonmodule::PhaseAPC& _internal_ldcr() const;
  ::commonmodule::PhaseAPC* _internal_mutable_ldcr();
  public:
  void unsafe_arena_set_allocated_ldcr(
      ::commonmodule::PhaseAPC* ldcr);
  ::commonmodule::PhaseAPC* unsafe_arena_release_ldcr();
  // .commonmodule.PhaseAPC LDCX = 4;
  bool has_ldcx() const;
  private:
  bool _internal_has_ldcx() const;

  public:
  void clear_ldcx() ;
  const ::commonmodule::PhaseAPC& ldcx() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_ldcx();
  ::commonmodule::PhaseAPC* mutable_ldcx();
  void set_allocated_ldcx(::commonmodule::PhaseAPC* ldcx);
  private:
  const ::commonmodule::PhaseAPC& _internal_ldcx() const;
  ::commonmodule::PhaseAPC* _internal_mutable_ldcx();
  public:
  void unsafe_arena_set_allocated_ldcx(
      ::commonmodule::PhaseAPC* ldcx);
  ::commonmodule::PhaseAPC* unsafe_arena_release_ldcx();
  // .commonmodule.PhaseAPC VolSpt = 5;
  bool has_volspt() const;
  private:
  bool _internal_has_volspt() const;

  public:
  void clear_volspt() ;
  const ::commonmodule::PhaseAPC& volspt() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_volspt();
  ::commonmodule::PhaseAPC* mutable_volspt();
  void set_allocated_volspt(::commonmodule::PhaseAPC* volspt);
  private:
  const ::commonmodule::PhaseAPC& _internal_volspt() const;
  ::commonmodule::PhaseAPC* _internal_mutable_volspt();
  public:
  void unsafe_arena_set_allocated_volspt(
      ::commonmodule::PhaseAPC* volspt);
  ::commonmodule::PhaseAPC* unsafe_arena_release_volspt();
  // .commonmodule.PhaseDPC voltageSetPointEnabled = 6;
  bool has_voltagesetpointenabled() const;
  private:
  bool _internal_has_voltagesetpointenabled() const;

  public:
  void clear_voltagesetpointenabled() ;
  const ::commonmodule::PhaseDPC& voltagesetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseDPC* release_voltagesetpointenabled();
  ::commonmodule::PhaseDPC* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::PhaseDPC* voltagesetpointenabled);
  private:
  const ::commonmodule::PhaseDPC& _internal_voltagesetpointenabled() const;
  ::commonmodule::PhaseDPC* _internal_mutable_voltagesetpointenabled();
  public:
  void unsafe_arena_set_allocated_voltagesetpointenabled(
      ::commonmodule::PhaseDPC* voltagesetpointenabled);
  ::commonmodule::PhaseDPC* unsafe_arena_release_voltagesetpointenabled();
  // @@protoc_insertion_point(class_scope:regulatormodule.DirectionalATCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::PhaseAPC* bndwid_;
    ::commonmodule::PhaseISC* ctldltmms_;
    ::commonmodule::PhaseAPC* ldcr_;
    ::commonmodule::PhaseAPC* ldcx_;
    ::commonmodule::PhaseAPC* volspt_;
    ::commonmodule::PhaseDPC* voltagesetpointenabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorControlATCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlATCC) */ {
 public:
  inline RegulatorControlATCC() : RegulatorControlATCC(nullptr) {}
  ~RegulatorControlATCC() override;
  explicit PROTOBUF_CONSTEXPR RegulatorControlATCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorControlATCC(const RegulatorControlATCC& from);
  RegulatorControlATCC(RegulatorControlATCC&& from) noexcept
    : RegulatorControlATCC() {
    *this = ::std::move(from);
  }

  inline RegulatorControlATCC& operator=(const RegulatorControlATCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlATCC& operator=(RegulatorControlATCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlATCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorControlATCC* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlATCC*>(
               &_RegulatorControlATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegulatorControlATCC& a, RegulatorControlATCC& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorControlATCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlATCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlATCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorControlATCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorControlATCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorControlATCC& from) {
    RegulatorControlATCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlATCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorControlATCC";
  }
  protected:
  explicit RegulatorControlATCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForControlFieldNumber = 1,
    kDirFwdFieldNumber = 2,
    kDirModeFieldNumber = 3,
    kDirRevFieldNumber = 4,
    kDirThdFieldNumber = 5,
    kParOpFieldNumber = 6,
    kRampRatesFieldNumber = 7,
    kStateFieldNumber = 8,
    kTapOpLFieldNumber = 9,
    kTapOpRFieldNumber = 10,
    kVolLmtHiFieldNumber = 11,
    kVolLmtLoFieldNumber = 12,
    kVolLmtModeFieldNumber = 13,
  };
  // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforcontrol() const;
  private:
  bool _internal_has_logicalnodeforcontrol() const;

  public:
  void clear_logicalnodeforcontrol() ;
  const ::commonmodule::LogicalNodeForControl& logicalnodeforcontrol() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForControl* release_logicalnodeforcontrol();
  ::commonmodule::LogicalNodeForControl* mutable_logicalnodeforcontrol();
  void set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  private:
  const ::commonmodule::LogicalNodeForControl& _internal_logicalnodeforcontrol() const;
  ::commonmodule::LogicalNodeForControl* _internal_mutable_logicalnodeforcontrol();
  public:
  void unsafe_arena_set_allocated_logicalnodeforcontrol(
      ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol);
  ::commonmodule::LogicalNodeForControl* unsafe_arena_release_logicalnodeforcontrol();
  // .regulatormodule.DirectionalATCC DirFwd = 2;
  bool has_dirfwd() const;
  private:
  bool _internal_has_dirfwd() const;

  public:
  void clear_dirfwd() ;
  const ::regulatormodule::DirectionalATCC& dirfwd() const;
  PROTOBUF_NODISCARD ::regulatormodule::DirectionalATCC* release_dirfwd();
  ::regulatormodule::DirectionalATCC* mutable_dirfwd();
  void set_allocated_dirfwd(::regulatormodule::DirectionalATCC* dirfwd);
  private:
  const ::regulatormodule::DirectionalATCC& _internal_dirfwd() const;
  ::regulatormodule::DirectionalATCC* _internal_mutable_dirfwd();
  public:
  void unsafe_arena_set_allocated_dirfwd(
      ::regulatormodule::DirectionalATCC* dirfwd);
  ::regulatormodule::DirectionalATCC* unsafe_arena_release_dirfwd();
  // .commonmodule.Optional_DirectionModeKind DirMode = 3;
  bool has_dirmode() const;
  private:
  bool _internal_has_dirmode() const;

  public:
  void clear_dirmode() ;
  const ::commonmodule::Optional_DirectionModeKind& dirmode() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_DirectionModeKind* release_dirmode();
  ::commonmodule::Optional_DirectionModeKind* mutable_dirmode();
  void set_allocated_dirmode(::commonmodule::Optional_DirectionModeKind* dirmode);
  private:
  const ::commonmodule::Optional_DirectionModeKind& _internal_dirmode() const;
  ::commonmodule::Optional_DirectionModeKind* _internal_mutable_dirmode();
  public:
  void unsafe_arena_set_allocated_dirmode(
      ::commonmodule::Optional_DirectionModeKind* dirmode);
  ::commonmodule::Optional_DirectionModeKind* unsafe_arena_release_dirmode();
  // .regulatormodule.DirectionalATCC DirRev = 4;
  bool has_dirrev() const;
  private:
  bool _internal_has_dirrev() const;

  public:
  void clear_dirrev() ;
  const ::regulatormodule::DirectionalATCC& dirrev() const;
  PROTOBUF_NODISCARD ::regulatormodule::DirectionalATCC* release_dirrev();
  ::regulatormodule::DirectionalATCC* mutable_dirrev();
  void set_allocated_dirrev(::regulatormodule::DirectionalATCC* dirrev);
  private:
  const ::regulatormodule::DirectionalATCC& _internal_dirrev() const;
  ::regulatormodule::DirectionalATCC* _internal_mutable_dirrev();
  public:
  void unsafe_arena_set_allocated_dirrev(
      ::regulatormodule::DirectionalATCC* dirrev);
  ::regulatormodule::DirectionalATCC* unsafe_arena_release_dirrev();
  // .commonmodule.PhaseAPC DirThd = 5;
  bool has_dirthd() const;
  private:
  bool _internal_has_dirthd() const;

  public:
  void clear_dirthd() ;
  const ::commonmodule::PhaseAPC& dirthd() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_dirthd();
  ::commonmodule::PhaseAPC* mutable_dirthd();
  void set_allocated_dirthd(::commonmodule::PhaseAPC* dirthd);
  private:
  const ::commonmodule::PhaseAPC& _internal_dirthd() const;
  ::commonmodule::PhaseAPC* _internal_mutable_dirthd();
  public:
  void unsafe_arena_set_allocated_dirthd(
      ::commonmodule::PhaseAPC* dirthd);
  ::commonmodule::PhaseAPC* unsafe_arena_release_dirthd();
  // .commonmodule.PhaseSPC ParOp = 6;
  bool has_parop() const;
  private:
  bool _internal_has_parop() const;

  public:
  void clear_parop() ;
  const ::commonmodule::PhaseSPC& parop() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPC* release_parop();
  ::commonmodule::PhaseSPC* mutable_parop();
  void set_allocated_parop(::commonmodule::PhaseSPC* parop);
  private:
  const ::commonmodule::PhaseSPC& _internal_parop() const;
  ::commonmodule::PhaseSPC* _internal_mutable_parop();
  public:
  void unsafe_arena_set_allocated_parop(
      ::commonmodule::PhaseSPC* parop);
  ::commonmodule::PhaseSPC* unsafe_arena_release_parop();
  // .commonmodule.RampRate rampRates = 7;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.Optional_StateKind state = 8;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // .commonmodule.PhaseSPC TapOpL = 9;
  bool has_tapopl() const;
  private:
  bool _internal_has_tapopl() const;

  public:
  void clear_tapopl() ;
  const ::commonmodule::PhaseSPC& tapopl() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPC* release_tapopl();
  ::commonmodule::PhaseSPC* mutable_tapopl();
  void set_allocated_tapopl(::commonmodule::PhaseSPC* tapopl);
  private:
  const ::commonmodule::PhaseSPC& _internal_tapopl() const;
  ::commonmodule::PhaseSPC* _internal_mutable_tapopl();
  public:
  void unsafe_arena_set_allocated_tapopl(
      ::commonmodule::PhaseSPC* tapopl);
  ::commonmodule::PhaseSPC* unsafe_arena_release_tapopl();
  // .commonmodule.PhaseSPC TapOpR = 10;
  bool has_tapopr() const;
  private:
  bool _internal_has_tapopr() const;

  public:
  void clear_tapopr() ;
  const ::commonmodule::PhaseSPC& tapopr() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPC* release_tapopr();
  ::commonmodule::PhaseSPC* mutable_tapopr();
  void set_allocated_tapopr(::commonmodule::PhaseSPC* tapopr);
  private:
  const ::commonmodule::PhaseSPC& _internal_tapopr() const;
  ::commonmodule::PhaseSPC* _internal_mutable_tapopr();
  public:
  void unsafe_arena_set_allocated_tapopr(
      ::commonmodule::PhaseSPC* tapopr);
  ::commonmodule::PhaseSPC* unsafe_arena_release_tapopr();
  // .commonmodule.PhaseAPC VolLmtHi = 11;
  bool has_vollmthi() const;
  private:
  bool _internal_has_vollmthi() const;

  public:
  void clear_vollmthi() ;
  const ::commonmodule::PhaseAPC& vollmthi() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_vollmthi();
  ::commonmodule::PhaseAPC* mutable_vollmthi();
  void set_allocated_vollmthi(::commonmodule::PhaseAPC* vollmthi);
  private:
  const ::commonmodule::PhaseAPC& _internal_vollmthi() const;
  ::commonmodule::PhaseAPC* _internal_mutable_vollmthi();
  public:
  void unsafe_arena_set_allocated_vollmthi(
      ::commonmodule::PhaseAPC* vollmthi);
  ::commonmodule::PhaseAPC* unsafe_arena_release_vollmthi();
  // .commonmodule.PhaseAPC VolLmtLo = 12;
  bool has_vollmtlo() const;
  private:
  bool _internal_has_vollmtlo() const;

  public:
  void clear_vollmtlo() ;
  const ::commonmodule::PhaseAPC& vollmtlo() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_vollmtlo();
  ::commonmodule::PhaseAPC* mutable_vollmtlo();
  void set_allocated_vollmtlo(::commonmodule::PhaseAPC* vollmtlo);
  private:
  const ::commonmodule::PhaseAPC& _internal_vollmtlo() const;
  ::commonmodule::PhaseAPC* _internal_mutable_vollmtlo();
  public:
  void unsafe_arena_set_allocated_vollmtlo(
      ::commonmodule::PhaseAPC* vollmtlo);
  ::commonmodule::PhaseAPC* unsafe_arena_release_vollmtlo();
  // .commonmodule.Optional_VoltLimitModeKind VolLmtMode = 13;
  bool has_vollmtmode() const;
  private:
  bool _internal_has_vollmtmode() const;

  public:
  void clear_vollmtmode() ;
  const ::commonmodule::Optional_VoltLimitModeKind& vollmtmode() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_VoltLimitModeKind* release_vollmtmode();
  ::commonmodule::Optional_VoltLimitModeKind* mutable_vollmtmode();
  void set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* vollmtmode);
  private:
  const ::commonmodule::Optional_VoltLimitModeKind& _internal_vollmtmode() const;
  ::commonmodule::Optional_VoltLimitModeKind* _internal_mutable_vollmtmode();
  public:
  void unsafe_arena_set_allocated_vollmtmode(
      ::commonmodule::Optional_VoltLimitModeKind* vollmtmode);
  ::commonmodule::Optional_VoltLimitModeKind* unsafe_arena_release_vollmtmode();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlATCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol_;
    ::regulatormodule::DirectionalATCC* dirfwd_;
    ::commonmodule::Optional_DirectionModeKind* dirmode_;
    ::regulatormodule::DirectionalATCC* dirrev_;
    ::commonmodule::PhaseAPC* dirthd_;
    ::commonmodule::PhaseSPC* parop_;
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::Optional_StateKind* state_;
    ::commonmodule::PhaseSPC* tapopl_;
    ::commonmodule::PhaseSPC* tapopr_;
    ::commonmodule::PhaseAPC* vollmthi_;
    ::commonmodule::PhaseAPC* vollmtlo_;
    ::commonmodule::Optional_VoltLimitModeKind* vollmtmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorPoint) */ {
 public:
  inline RegulatorPoint() : RegulatorPoint(nullptr) {}
  ~RegulatorPoint() override;
  explicit PROTOBUF_CONSTEXPR RegulatorPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorPoint(const RegulatorPoint& from);
  RegulatorPoint(RegulatorPoint&& from) noexcept
    : RegulatorPoint() {
    *this = ::std::move(from);
  }

  inline RegulatorPoint& operator=(const RegulatorPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorPoint& operator=(RegulatorPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorPoint* internal_default_instance() {
    return reinterpret_cast<const RegulatorPoint*>(
               &_RegulatorPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegulatorPoint& a, RegulatorPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorPoint& from) {
    RegulatorPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorPoint";
  }
  protected:
  explicit RegulatorPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFieldNumber = 1,
    kStartTimeFieldNumber = 8,
  };
  // .regulatormodule.RegulatorControlATCC control = 1;
  bool has_control() const;
  private:
  bool _internal_has_control() const;

  public:
  void clear_control() ;
  const ::regulatormodule::RegulatorControlATCC& control() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorControlATCC* release_control();
  ::regulatormodule::RegulatorControlATCC* mutable_control();
  void set_allocated_control(::regulatormodule::RegulatorControlATCC* control);
  private:
  const ::regulatormodule::RegulatorControlATCC& _internal_control() const;
  ::regulatormodule::RegulatorControlATCC* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::regulatormodule::RegulatorControlATCC* control);
  ::regulatormodule::RegulatorControlATCC* unsafe_arena_release_control();
  // .commonmodule.Timestamp startTime = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;

  public:
  void clear_starttime() ;
  const ::commonmodule::Timestamp& starttime() const;
  PROTOBUF_NODISCARD ::commonmodule::Timestamp* release_starttime();
  ::commonmodule::Timestamp* mutable_starttime();
  void set_allocated_starttime(::commonmodule::Timestamp* starttime);
  private:
  const ::commonmodule::Timestamp& _internal_starttime() const;
  ::commonmodule::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::commonmodule::Timestamp* starttime);
  ::commonmodule::Timestamp* unsafe_arena_release_starttime();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::regulatormodule::RegulatorControlATCC* control_;
    ::commonmodule::Timestamp* starttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorCSG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorCSG) */ {
 public:
  inline RegulatorCSG() : RegulatorCSG(nullptr) {}
  ~RegulatorCSG() override;
  explicit PROTOBUF_CONSTEXPR RegulatorCSG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorCSG(const RegulatorCSG& from);
  RegulatorCSG(RegulatorCSG&& from) noexcept
    : RegulatorCSG() {
    *this = ::std::move(from);
  }

  inline RegulatorCSG& operator=(const RegulatorCSG& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorCSG& operator=(RegulatorCSG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorCSG& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorCSG* internal_default_instance() {
    return reinterpret_cast<const RegulatorCSG*>(
               &_RegulatorCSG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegulatorCSG& a, RegulatorCSG& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorCSG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorCSG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorCSG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorCSG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorCSG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorCSG& from) {
    RegulatorCSG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorCSG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorCSG";
  }
  protected:
  explicit RegulatorCSG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrvPtsFieldNumber = 1,
  };
  // repeated .regulatormodule.RegulatorPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  int crvpts_size() const;
  private:
  int _internal_crvpts_size() const;

  public:
  void clear_crvpts() ;
  ::regulatormodule::RegulatorPoint* mutable_crvpts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorPoint >*
      mutable_crvpts();
  private:
  const ::regulatormodule::RegulatorPoint& _internal_crvpts(int index) const;
  ::regulatormodule::RegulatorPoint* _internal_add_crvpts();
  public:
  const ::regulatormodule::RegulatorPoint& crvpts(int index) const;
  ::regulatormodule::RegulatorPoint* add_crvpts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorPoint >&
      crvpts() const;
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorCSG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorPoint > crvpts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorControlScheduleFSCH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlScheduleFSCH) */ {
 public:
  inline RegulatorControlScheduleFSCH() : RegulatorControlScheduleFSCH(nullptr) {}
  ~RegulatorControlScheduleFSCH() override;
  explicit PROTOBUF_CONSTEXPR RegulatorControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorControlScheduleFSCH(const RegulatorControlScheduleFSCH& from);
  RegulatorControlScheduleFSCH(RegulatorControlScheduleFSCH&& from) noexcept
    : RegulatorControlScheduleFSCH() {
    *this = ::std::move(from);
  }

  inline RegulatorControlScheduleFSCH& operator=(const RegulatorControlScheduleFSCH& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlScheduleFSCH& operator=(RegulatorControlScheduleFSCH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlScheduleFSCH& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorControlScheduleFSCH* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlScheduleFSCH*>(
               &_RegulatorControlScheduleFSCH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegulatorControlScheduleFSCH& a, RegulatorControlScheduleFSCH& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorControlScheduleFSCH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlScheduleFSCH* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlScheduleFSCH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorControlScheduleFSCH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorControlScheduleFSCH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorControlScheduleFSCH& from) {
    RegulatorControlScheduleFSCH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlScheduleFSCH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorControlScheduleFSCH";
  }
  protected:
  explicit RegulatorControlScheduleFSCH(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValDCSGFieldNumber = 1,
  };
  // .regulatormodule.RegulatorCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_valdcsg() const;
  private:
  bool _internal_has_valdcsg() const;

  public:
  void clear_valdcsg() ;
  const ::regulatormodule::RegulatorCSG& valdcsg() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorCSG* release_valdcsg();
  ::regulatormodule::RegulatorCSG* mutable_valdcsg();
  void set_allocated_valdcsg(::regulatormodule::RegulatorCSG* valdcsg);
  private:
  const ::regulatormodule::RegulatorCSG& _internal_valdcsg() const;
  ::regulatormodule::RegulatorCSG* _internal_mutable_valdcsg();
  public:
  void unsafe_arena_set_allocated_valdcsg(
      ::regulatormodule::RegulatorCSG* valdcsg);
  ::regulatormodule::RegulatorCSG* unsafe_arena_release_valdcsg();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlScheduleFSCH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::regulatormodule::RegulatorCSG* valdcsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorControlFSCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlFSCC) */ {
 public:
  inline RegulatorControlFSCC() : RegulatorControlFSCC(nullptr) {}
  ~RegulatorControlFSCC() override;
  explicit PROTOBUF_CONSTEXPR RegulatorControlFSCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorControlFSCC(const RegulatorControlFSCC& from);
  RegulatorControlFSCC(RegulatorControlFSCC&& from) noexcept
    : RegulatorControlFSCC() {
    *this = ::std::move(from);
  }

  inline RegulatorControlFSCC& operator=(const RegulatorControlFSCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlFSCC& operator=(RegulatorControlFSCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlFSCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorControlFSCC* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlFSCC*>(
               &_RegulatorControlFSCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegulatorControlFSCC& a, RegulatorControlFSCC& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorControlFSCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlFSCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlFSCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorControlFSCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorControlFSCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorControlFSCC& from) {
    RegulatorControlFSCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlFSCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorControlFSCC";
  }
  protected:
  explicit RegulatorControlFSCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlFSCCFieldNumber = 1,
    kRegulatorControlScheduleFSCHFieldNumber = 2,
  };
  // .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
  bool has_controlfscc() const;
  private:
  bool _internal_has_controlfscc() const;

  public:
  void clear_controlfscc() ;
  const ::commonmodule::ControlFSCC& controlfscc() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlFSCC* release_controlfscc();
  ::commonmodule::ControlFSCC* mutable_controlfscc();
  void set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc);
  private:
  const ::commonmodule::ControlFSCC& _internal_controlfscc() const;
  ::commonmodule::ControlFSCC* _internal_mutable_controlfscc();
  public:
  void unsafe_arena_set_allocated_controlfscc(
      ::commonmodule::ControlFSCC* controlfscc);
  ::commonmodule::ControlFSCC* unsafe_arena_release_controlfscc();
  // .regulatormodule.RegulatorControlScheduleFSCH regulatorControlScheduleFSCH = 2;
  bool has_regulatorcontrolschedulefsch() const;
  private:
  bool _internal_has_regulatorcontrolschedulefsch() const;

  public:
  void clear_regulatorcontrolschedulefsch() ;
  const ::regulatormodule::RegulatorControlScheduleFSCH& regulatorcontrolschedulefsch() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorControlScheduleFSCH* release_regulatorcontrolschedulefsch();
  ::regulatormodule::RegulatorControlScheduleFSCH* mutable_regulatorcontrolschedulefsch();
  void set_allocated_regulatorcontrolschedulefsch(::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch);
  private:
  const ::regulatormodule::RegulatorControlScheduleFSCH& _internal_regulatorcontrolschedulefsch() const;
  ::regulatormodule::RegulatorControlScheduleFSCH* _internal_mutable_regulatorcontrolschedulefsch();
  public:
  void unsafe_arena_set_allocated_regulatorcontrolschedulefsch(
      ::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch);
  ::regulatormodule::RegulatorControlScheduleFSCH* unsafe_arena_release_regulatorcontrolschedulefsch();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlFSCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlFSCC* controlfscc_;
    ::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControl) */ {
 public:
  inline RegulatorControl() : RegulatorControl(nullptr) {}
  ~RegulatorControl() override;
  explicit PROTOBUF_CONSTEXPR RegulatorControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorControl(const RegulatorControl& from);
  RegulatorControl(RegulatorControl&& from) noexcept
    : RegulatorControl() {
    *this = ::std::move(from);
  }

  inline RegulatorControl& operator=(const RegulatorControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControl& operator=(RegulatorControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorControl* internal_default_instance() {
    return reinterpret_cast<const RegulatorControl*>(
               &_RegulatorControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegulatorControl& a, RegulatorControl& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorControl& from) {
    RegulatorControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorControl";
  }
  protected:
  explicit RegulatorControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kRegulatorControlFSCCFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .regulatormodule.RegulatorControlFSCC regulatorControlFSCC = 3;
  bool has_regulatorcontrolfscc() const;
  private:
  bool _internal_has_regulatorcontrolfscc() const;

  public:
  void clear_regulatorcontrolfscc() ;
  const ::regulatormodule::RegulatorControlFSCC& regulatorcontrolfscc() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorControlFSCC* release_regulatorcontrolfscc();
  ::regulatormodule::RegulatorControlFSCC* mutable_regulatorcontrolfscc();
  void set_allocated_regulatorcontrolfscc(::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc);
  private:
  const ::regulatormodule::RegulatorControlFSCC& _internal_regulatorcontrolfscc() const;
  ::regulatormodule::RegulatorControlFSCC* _internal_mutable_regulatorcontrolfscc();
  public:
  void unsafe_arena_set_allocated_regulatorcontrolfscc(
      ::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc);
  ::regulatormodule::RegulatorControlFSCC* unsafe_arena_release_regulatorcontrolfscc();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorSystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorSystem) */ {
 public:
  inline RegulatorSystem() : RegulatorSystem(nullptr) {}
  ~RegulatorSystem() override;
  explicit PROTOBUF_CONSTEXPR RegulatorSystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorSystem(const RegulatorSystem& from);
  RegulatorSystem(RegulatorSystem&& from) noexcept
    : RegulatorSystem() {
    *this = ::std::move(from);
  }

  inline RegulatorSystem& operator=(const RegulatorSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorSystem& operator=(RegulatorSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorSystem* internal_default_instance() {
    return reinterpret_cast<const RegulatorSystem*>(
               &_RegulatorSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegulatorSystem& a, RegulatorSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorSystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorSystem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorSystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorSystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorSystem& from) {
    RegulatorSystem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorSystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorSystem";
  }
  protected:
  explicit RegulatorSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentFieldNumber = 1,
  };
  // .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipment() const;
  private:
  bool _internal_has_conductingequipment() const;

  public:
  void clear_conductingequipment() ;
  const ::commonmodule::ConductingEquipment& conductingequipment() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipment* release_conductingequipment();
  ::commonmodule::ConductingEquipment* mutable_conductingequipment();
  void set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment);
  private:
  const ::commonmodule::ConductingEquipment& _internal_conductingequipment() const;
  ::commonmodule::ConductingEquipment* _internal_mutable_conductingequipment();
  public:
  void unsafe_arena_set_allocated_conductingequipment(
      ::commonmodule::ConductingEquipment* conductingequipment);
  ::commonmodule::ConductingEquipment* unsafe_arena_release_conductingequipment();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipment* conductingequipment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorControlProfile) */ {
 public:
  inline RegulatorControlProfile() : RegulatorControlProfile(nullptr) {}
  ~RegulatorControlProfile() override;
  explicit PROTOBUF_CONSTEXPR RegulatorControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorControlProfile(const RegulatorControlProfile& from);
  RegulatorControlProfile(RegulatorControlProfile&& from) noexcept
    : RegulatorControlProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorControlProfile& operator=(const RegulatorControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorControlProfile& operator=(RegulatorControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorControlProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorControlProfile*>(
               &_RegulatorControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RegulatorControlProfile& a, RegulatorControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorControlProfile& from) {
    RegulatorControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorControlProfile";
  }
  protected:
  explicit RegulatorControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kRegulatorControlFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .regulatormodule.RegulatorControl regulatorControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorcontrol() const;
  private:
  bool _internal_has_regulatorcontrol() const;

  public:
  void clear_regulatorcontrol() ;
  const ::regulatormodule::RegulatorControl& regulatorcontrol() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorControl* release_regulatorcontrol();
  ::regulatormodule::RegulatorControl* mutable_regulatorcontrol();
  void set_allocated_regulatorcontrol(::regulatormodule::RegulatorControl* regulatorcontrol);
  private:
  const ::regulatormodule::RegulatorControl& _internal_regulatorcontrol() const;
  ::regulatormodule::RegulatorControl* _internal_mutable_regulatorcontrol();
  public:
  void unsafe_arena_set_allocated_regulatorcontrol(
      ::regulatormodule::RegulatorControl* regulatorcontrol);
  ::regulatormodule::RegulatorControl* unsafe_arena_release_regulatorcontrol();
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  private:
  bool _internal_has_regulatorsystem() const;

  public:
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);
  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* _internal_mutable_regulatorsystem();
  public:
  void unsafe_arena_set_allocated_regulatorsystem(
      ::regulatormodule::RegulatorSystem* regulatorsystem);
  ::regulatormodule::RegulatorSystem* unsafe_arena_release_regulatorsystem();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::regulatormodule::RegulatorControl* regulatorcontrol_;
    ::regulatormodule::RegulatorSystem* regulatorsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorDiscreteControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorDiscreteControl) */ {
 public:
  inline RegulatorDiscreteControl() : RegulatorDiscreteControl(nullptr) {}
  ~RegulatorDiscreteControl() override;
  explicit PROTOBUF_CONSTEXPR RegulatorDiscreteControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorDiscreteControl(const RegulatorDiscreteControl& from);
  RegulatorDiscreteControl(RegulatorDiscreteControl&& from) noexcept
    : RegulatorDiscreteControl() {
    *this = ::std::move(from);
  }

  inline RegulatorDiscreteControl& operator=(const RegulatorDiscreteControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorDiscreteControl& operator=(RegulatorDiscreteControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorDiscreteControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorDiscreteControl* internal_default_instance() {
    return reinterpret_cast<const RegulatorDiscreteControl*>(
               &_RegulatorDiscreteControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RegulatorDiscreteControl& a, RegulatorDiscreteControl& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorDiscreteControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorDiscreteControl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorDiscreteControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorDiscreteControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorDiscreteControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorDiscreteControl& from) {
    RegulatorDiscreteControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorDiscreteControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorDiscreteControl";
  }
  protected:
  explicit RegulatorDiscreteControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlValueFieldNumber = 1,
    kCheckFieldNumber = 2,
    kRegulatorControlATCCFieldNumber = 3,
  };
  // .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
  bool has_controlvalue() const;
  private:
  bool _internal_has_controlvalue() const;

  public:
  void clear_controlvalue() ;
  const ::commonmodule::ControlValue& controlvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlValue* release_controlvalue();
  ::commonmodule::ControlValue* mutable_controlvalue();
  void set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue);
  private:
  const ::commonmodule::ControlValue& _internal_controlvalue() const;
  ::commonmodule::ControlValue* _internal_mutable_controlvalue();
  public:
  void unsafe_arena_set_allocated_controlvalue(
      ::commonmodule::ControlValue* controlvalue);
  ::commonmodule::ControlValue* unsafe_arena_release_controlvalue();
  // .commonmodule.CheckConditions check = 2;
  bool has_check() const;
  private:
  bool _internal_has_check() const;

  public:
  void clear_check() ;
  const ::commonmodule::CheckConditions& check() const;
  PROTOBUF_NODISCARD ::commonmodule::CheckConditions* release_check();
  ::commonmodule::CheckConditions* mutable_check();
  void set_allocated_check(::commonmodule::CheckConditions* check);
  private:
  const ::commonmodule::CheckConditions& _internal_check() const;
  ::commonmodule::CheckConditions* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::commonmodule::CheckConditions* check);
  ::commonmodule::CheckConditions* unsafe_arena_release_check();
  // .regulatormodule.RegulatorControlATCC regulatorControlATCC = 3;
  bool has_regulatorcontrolatcc() const;
  private:
  bool _internal_has_regulatorcontrolatcc() const;

  public:
  void clear_regulatorcontrolatcc() ;
  const ::regulatormodule::RegulatorControlATCC& regulatorcontrolatcc() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorControlATCC* release_regulatorcontrolatcc();
  ::regulatormodule::RegulatorControlATCC* mutable_regulatorcontrolatcc();
  void set_allocated_regulatorcontrolatcc(::regulatormodule::RegulatorControlATCC* regulatorcontrolatcc);
  private:
  const ::regulatormodule::RegulatorControlATCC& _internal_regulatorcontrolatcc() const;
  ::regulatormodule::RegulatorControlATCC* _internal_mutable_regulatorcontrolatcc();
  public:
  void unsafe_arena_set_allocated_regulatorcontrolatcc(
      ::regulatormodule::RegulatorControlATCC* regulatorcontrolatcc);
  ::regulatormodule::RegulatorControlATCC* unsafe_arena_release_regulatorcontrolatcc();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorDiscreteControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlValue* controlvalue_;
    ::commonmodule::CheckConditions* check_;
    ::regulatormodule::RegulatorControlATCC* regulatorcontrolatcc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorDiscreteControlProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorDiscreteControlProfile) */ {
 public:
  inline RegulatorDiscreteControlProfile() : RegulatorDiscreteControlProfile(nullptr) {}
  ~RegulatorDiscreteControlProfile() override;
  explicit PROTOBUF_CONSTEXPR RegulatorDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorDiscreteControlProfile(const RegulatorDiscreteControlProfile& from);
  RegulatorDiscreteControlProfile(RegulatorDiscreteControlProfile&& from) noexcept
    : RegulatorDiscreteControlProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorDiscreteControlProfile& operator=(const RegulatorDiscreteControlProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorDiscreteControlProfile& operator=(RegulatorDiscreteControlProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorDiscreteControlProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorDiscreteControlProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorDiscreteControlProfile*>(
               &_RegulatorDiscreteControlProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RegulatorDiscreteControlProfile& a, RegulatorDiscreteControlProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorDiscreteControlProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorDiscreteControlProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorDiscreteControlProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorDiscreteControlProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorDiscreteControlProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorDiscreteControlProfile& from) {
    RegulatorDiscreteControlProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorDiscreteControlProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorDiscreteControlProfile";
  }
  protected:
  explicit RegulatorDiscreteControlProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlMessageInfoFieldNumber = 1,
    kRegulatorDiscreteControlFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_controlmessageinfo() const;
  private:
  bool _internal_has_controlmessageinfo() const;

  public:
  void clear_controlmessageinfo() ;
  const ::commonmodule::ControlMessageInfo& controlmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ControlMessageInfo* release_controlmessageinfo();
  ::commonmodule::ControlMessageInfo* mutable_controlmessageinfo();
  void set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo);
  private:
  const ::commonmodule::ControlMessageInfo& _internal_controlmessageinfo() const;
  ::commonmodule::ControlMessageInfo* _internal_mutable_controlmessageinfo();
  public:
  void unsafe_arena_set_allocated_controlmessageinfo(
      ::commonmodule::ControlMessageInfo* controlmessageinfo);
  ::commonmodule::ControlMessageInfo* unsafe_arena_release_controlmessageinfo();
  // .regulatormodule.RegulatorDiscreteControl regulatorDiscreteControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatordiscretecontrol() const;
  private:
  bool _internal_has_regulatordiscretecontrol() const;

  public:
  void clear_regulatordiscretecontrol() ;
  const ::regulatormodule::RegulatorDiscreteControl& regulatordiscretecontrol() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorDiscreteControl* release_regulatordiscretecontrol();
  ::regulatormodule::RegulatorDiscreteControl* mutable_regulatordiscretecontrol();
  void set_allocated_regulatordiscretecontrol(::regulatormodule::RegulatorDiscreteControl* regulatordiscretecontrol);
  private:
  const ::regulatormodule::RegulatorDiscreteControl& _internal_regulatordiscretecontrol() const;
  ::regulatormodule::RegulatorDiscreteControl* _internal_mutable_regulatordiscretecontrol();
  public:
  void unsafe_arena_set_allocated_regulatordiscretecontrol(
      ::regulatormodule::RegulatorDiscreteControl* regulatordiscretecontrol);
  ::regulatormodule::RegulatorDiscreteControl* unsafe_arena_release_regulatordiscretecontrol();
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  private:
  bool _internal_has_regulatorsystem() const;

  public:
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);
  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* _internal_mutable_regulatorsystem();
  public:
  void unsafe_arena_set_allocated_regulatorsystem(
      ::regulatormodule::RegulatorSystem* regulatorsystem);
  ::regulatormodule::RegulatorSystem* unsafe_arena_release_regulatorsystem();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorDiscreteControlProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ControlMessageInfo* controlmessageinfo_;
    ::regulatormodule::RegulatorDiscreteControl* regulatordiscretecontrol_;
    ::regulatormodule::RegulatorSystem* regulatorsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorEventAndStatusATCC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventAndStatusATCC) */ {
 public:
  inline RegulatorEventAndStatusATCC() : RegulatorEventAndStatusATCC(nullptr) {}
  ~RegulatorEventAndStatusATCC() override;
  explicit PROTOBUF_CONSTEXPR RegulatorEventAndStatusATCC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorEventAndStatusATCC(const RegulatorEventAndStatusATCC& from);
  RegulatorEventAndStatusATCC(RegulatorEventAndStatusATCC&& from) noexcept
    : RegulatorEventAndStatusATCC() {
    *this = ::std::move(from);
  }

  inline RegulatorEventAndStatusATCC& operator=(const RegulatorEventAndStatusATCC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEventAndStatusATCC& operator=(RegulatorEventAndStatusATCC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEventAndStatusATCC& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorEventAndStatusATCC* internal_default_instance() {
    return reinterpret_cast<const RegulatorEventAndStatusATCC*>(
               &_RegulatorEventAndStatusATCC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RegulatorEventAndStatusATCC& a, RegulatorEventAndStatusATCC& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorEventAndStatusATCC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEventAndStatusATCC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEventAndStatusATCC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorEventAndStatusATCC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorEventAndStatusATCC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorEventAndStatusATCC& from) {
    RegulatorEventAndStatusATCC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEventAndStatusATCC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorEventAndStatusATCC";
  }
  protected:
  explicit RegulatorEventAndStatusATCC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBndCtrFieldNumber = 1,
    kBndWidFieldNumber = 2,
    kBndWidHiFieldNumber = 3,
    kBndWidLoFieldNumber = 4,
    kDirCtlRevFieldNumber = 5,
    kDirIndtFieldNumber = 6,
    kDirRevFieldNumber = 7,
    kLDCRFieldNumber = 8,
    kLDCXFieldNumber = 9,
    kParOpFieldNumber = 10,
    kRampRatesFieldNumber = 11,
    kStateFieldNumber = 12,
    kStDlTmmsFieldNumber = 13,
    kTapOpErrFieldNumber = 14,
    kTapPosFieldNumber = 15,
    kVolLmtHiFieldNumber = 16,
    kVolLmtLoFieldNumber = 17,
    kVolSptFieldNumber = 18,
    kVoltageSetPointEnabledFieldNumber = 19,
  };
  // .commonmodule.ASG BndCtr = 1;
  bool has_bndctr() const;
  private:
  bool _internal_has_bndctr() const;

  public:
  void clear_bndctr() ;
  const ::commonmodule::ASG& bndctr() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_bndctr();
  ::commonmodule::ASG* mutable_bndctr();
  void set_allocated_bndctr(::commonmodule::ASG* bndctr);
  private:
  const ::commonmodule::ASG& _internal_bndctr() const;
  ::commonmodule::ASG* _internal_mutable_bndctr();
  public:
  void unsafe_arena_set_allocated_bndctr(
      ::commonmodule::ASG* bndctr);
  ::commonmodule::ASG* unsafe_arena_release_bndctr();
  // .commonmodule.ASG BndWid = 2;
  bool has_bndwid() const;
  private:
  bool _internal_has_bndwid() const;

  public:
  void clear_bndwid() ;
  const ::commonmodule::ASG& bndwid() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_bndwid();
  ::commonmodule::ASG* mutable_bndwid();
  void set_allocated_bndwid(::commonmodule::ASG* bndwid);
  private:
  const ::commonmodule::ASG& _internal_bndwid() const;
  ::commonmodule::ASG* _internal_mutable_bndwid();
  public:
  void unsafe_arena_set_allocated_bndwid(
      ::commonmodule::ASG* bndwid);
  ::commonmodule::ASG* unsafe_arena_release_bndwid();
  // .commonmodule.PhaseSPS BndWidHi = 3;
  bool has_bndwidhi() const;
  private:
  bool _internal_has_bndwidhi() const;

  public:
  void clear_bndwidhi() ;
  const ::commonmodule::PhaseSPS& bndwidhi() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_bndwidhi();
  ::commonmodule::PhaseSPS* mutable_bndwidhi();
  void set_allocated_bndwidhi(::commonmodule::PhaseSPS* bndwidhi);
  private:
  const ::commonmodule::PhaseSPS& _internal_bndwidhi() const;
  ::commonmodule::PhaseSPS* _internal_mutable_bndwidhi();
  public:
  void unsafe_arena_set_allocated_bndwidhi(
      ::commonmodule::PhaseSPS* bndwidhi);
  ::commonmodule::PhaseSPS* unsafe_arena_release_bndwidhi();
  // .commonmodule.PhaseSPS BndWidLo = 4;
  bool has_bndwidlo() const;
  private:
  bool _internal_has_bndwidlo() const;

  public:
  void clear_bndwidlo() ;
  const ::commonmodule::PhaseSPS& bndwidlo() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_bndwidlo();
  ::commonmodule::PhaseSPS* mutable_bndwidlo();
  void set_allocated_bndwidlo(::commonmodule::PhaseSPS* bndwidlo);
  private:
  const ::commonmodule::PhaseSPS& _internal_bndwidlo() const;
  ::commonmodule::PhaseSPS* _internal_mutable_bndwidlo();
  public:
  void unsafe_arena_set_allocated_bndwidlo(
      ::commonmodule::PhaseSPS* bndwidlo);
  ::commonmodule::PhaseSPS* unsafe_arena_release_bndwidlo();
  // .commonmodule.PhaseSPS DirCtlRev = 5;
  bool has_dirctlrev() const;
  private:
  bool _internal_has_dirctlrev() const;

  public:
  void clear_dirctlrev() ;
  const ::commonmodule::PhaseSPS& dirctlrev() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_dirctlrev();
  ::commonmodule::PhaseSPS* mutable_dirctlrev();
  void set_allocated_dirctlrev(::commonmodule::PhaseSPS* dirctlrev);
  private:
  const ::commonmodule::PhaseSPS& _internal_dirctlrev() const;
  ::commonmodule::PhaseSPS* _internal_mutable_dirctlrev();
  public:
  void unsafe_arena_set_allocated_dirctlrev(
      ::commonmodule::PhaseSPS* dirctlrev);
  ::commonmodule::PhaseSPS* unsafe_arena_release_dirctlrev();
  // .commonmodule.PhaseSPS DirIndt = 6;
  bool has_dirindt() const;
  private:
  bool _internal_has_dirindt() const;

  public:
  void clear_dirindt() ;
  const ::commonmodule::PhaseSPS& dirindt() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_dirindt();
  ::commonmodule::PhaseSPS* mutable_dirindt();
  void set_allocated_dirindt(::commonmodule::PhaseSPS* dirindt);
  private:
  const ::commonmodule::PhaseSPS& _internal_dirindt() const;
  ::commonmodule::PhaseSPS* _internal_mutable_dirindt();
  public:
  void unsafe_arena_set_allocated_dirindt(
      ::commonmodule::PhaseSPS* dirindt);
  ::commonmodule::PhaseSPS* unsafe_arena_release_dirindt();
  // .commonmodule.PhaseSPS DirRev = 7;
  bool has_dirrev() const;
  private:
  bool _internal_has_dirrev() const;

  public:
  void clear_dirrev() ;
  const ::commonmodule::PhaseSPS& dirrev() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_dirrev();
  ::commonmodule::PhaseSPS* mutable_dirrev();
  void set_allocated_dirrev(::commonmodule::PhaseSPS* dirrev);
  private:
  const ::commonmodule::PhaseSPS& _internal_dirrev() const;
  ::commonmodule::PhaseSPS* _internal_mutable_dirrev();
  public:
  void unsafe_arena_set_allocated_dirrev(
      ::commonmodule::PhaseSPS* dirrev);
  ::commonmodule::PhaseSPS* unsafe_arena_release_dirrev();
  // .commonmodule.ASG LDCR = 8;
  bool has_ldcr() const;
  private:
  bool _internal_has_ldcr() const;

  public:
  void clear_ldcr() ;
  const ::commonmodule::ASG& ldcr() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_ldcr();
  ::commonmodule::ASG* mutable_ldcr();
  void set_allocated_ldcr(::commonmodule::ASG* ldcr);
  private:
  const ::commonmodule::ASG& _internal_ldcr() const;
  ::commonmodule::ASG* _internal_mutable_ldcr();
  public:
  void unsafe_arena_set_allocated_ldcr(
      ::commonmodule::ASG* ldcr);
  ::commonmodule::ASG* unsafe_arena_release_ldcr();
  // .commonmodule.ASG LDCX = 9;
  bool has_ldcx() const;
  private:
  bool _internal_has_ldcx() const;

  public:
  void clear_ldcx() ;
  const ::commonmodule::ASG& ldcx() const;
  PROTOBUF_NODISCARD ::commonmodule::ASG* release_ldcx();
  ::commonmodule::ASG* mutable_ldcx();
  void set_allocated_ldcx(::commonmodule::ASG* ldcx);
  private:
  const ::commonmodule::ASG& _internal_ldcx() const;
  ::commonmodule::ASG* _internal_mutable_ldcx();
  public:
  void unsafe_arena_set_allocated_ldcx(
      ::commonmodule::ASG* ldcx);
  ::commonmodule::ASG* unsafe_arena_release_ldcx();
  // .commonmodule.StatusSPS ParOp = 10;
  bool has_parop() const;
  private:
  bool _internal_has_parop() const;

  public:
  void clear_parop() ;
  const ::commonmodule::StatusSPS& parop() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_parop();
  ::commonmodule::StatusSPS* mutable_parop();
  void set_allocated_parop(::commonmodule::StatusSPS* parop);
  private:
  const ::commonmodule::StatusSPS& _internal_parop() const;
  ::commonmodule::StatusSPS* _internal_mutable_parop();
  public:
  void unsafe_arena_set_allocated_parop(
      ::commonmodule::StatusSPS* parop);
  ::commonmodule::StatusSPS* unsafe_arena_release_parop();
  // .commonmodule.RampRate rampRates = 11;
  bool has_ramprates() const;
  private:
  bool _internal_has_ramprates() const;

  public:
  void clear_ramprates() ;
  const ::commonmodule::RampRate& ramprates() const;
  PROTOBUF_NODISCARD ::commonmodule::RampRate* release_ramprates();
  ::commonmodule::RampRate* mutable_ramprates();
  void set_allocated_ramprates(::commonmodule::RampRate* ramprates);
  private:
  const ::commonmodule::RampRate& _internal_ramprates() const;
  ::commonmodule::RampRate* _internal_mutable_ramprates();
  public:
  void unsafe_arena_set_allocated_ramprates(
      ::commonmodule::RampRate* ramprates);
  ::commonmodule::RampRate* unsafe_arena_release_ramprates();
  // .commonmodule.Optional_StateKind state = 12;
  bool has_state() const;
  private:
  bool _internal_has_state() const;

  public:
  void clear_state() ;
  const ::commonmodule::Optional_StateKind& state() const;
  PROTOBUF_NODISCARD ::commonmodule::Optional_StateKind* release_state();
  ::commonmodule::Optional_StateKind* mutable_state();
  void set_allocated_state(::commonmodule::Optional_StateKind* state);
  private:
  const ::commonmodule::Optional_StateKind& _internal_state() const;
  ::commonmodule::Optional_StateKind* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::commonmodule::Optional_StateKind* state);
  ::commonmodule::Optional_StateKind* unsafe_arena_release_state();
  // .commonmodule.StatusINC StDlTmms = 13;
  bool has_stdltmms() const;
  private:
  bool _internal_has_stdltmms() const;

  public:
  void clear_stdltmms() ;
  const ::commonmodule::StatusINC& stdltmms() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusINC* release_stdltmms();
  ::commonmodule::StatusINC* mutable_stdltmms();
  void set_allocated_stdltmms(::commonmodule::StatusINC* stdltmms);
  private:
  const ::commonmodule::StatusINC& _internal_stdltmms() const;
  ::commonmodule::StatusINC* _internal_mutable_stdltmms();
  public:
  void unsafe_arena_set_allocated_stdltmms(
      ::commonmodule::StatusINC* stdltmms);
  ::commonmodule::StatusINC* unsafe_arena_release_stdltmms();
  // .commonmodule.StatusSPS TapOpErr = 14;
  bool has_tapoperr() const;
  private:
  bool _internal_has_tapoperr() const;

  public:
  void clear_tapoperr() ;
  const ::commonmodule::StatusSPS& tapoperr() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_tapoperr();
  ::commonmodule::StatusSPS* mutable_tapoperr();
  void set_allocated_tapoperr(::commonmodule::StatusSPS* tapoperr);
  private:
  const ::commonmodule::StatusSPS& _internal_tapoperr() const;
  ::commonmodule::StatusSPS* _internal_mutable_tapoperr();
  public:
  void unsafe_arena_set_allocated_tapoperr(
      ::commonmodule::StatusSPS* tapoperr);
  ::commonmodule::StatusSPS* unsafe_arena_release_tapoperr();
  // .commonmodule.PhaseINS TapPos = 15;
  bool has_tappos() const;
  private:
  bool _internal_has_tappos() const;

  public:
  void clear_tappos() ;
  const ::commonmodule::PhaseINS& tappos() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseINS* release_tappos();
  ::commonmodule::PhaseINS* mutable_tappos();
  void set_allocated_tappos(::commonmodule::PhaseINS* tappos);
  private:
  const ::commonmodule::PhaseINS& _internal_tappos() const;
  ::commonmodule::PhaseINS* _internal_mutable_tappos();
  public:
  void unsafe_arena_set_allocated_tappos(
      ::commonmodule::PhaseINS* tappos);
  ::commonmodule::PhaseINS* unsafe_arena_release_tappos();
  // .commonmodule.PhaseSPS VolLmtHi = 16;
  bool has_vollmthi() const;
  private:
  bool _internal_has_vollmthi() const;

  public:
  void clear_vollmthi() ;
  const ::commonmodule::PhaseSPS& vollmthi() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_vollmthi();
  ::commonmodule::PhaseSPS* mutable_vollmthi();
  void set_allocated_vollmthi(::commonmodule::PhaseSPS* vollmthi);
  private:
  const ::commonmodule::PhaseSPS& _internal_vollmthi() const;
  ::commonmodule::PhaseSPS* _internal_mutable_vollmthi();
  public:
  void unsafe_arena_set_allocated_vollmthi(
      ::commonmodule::PhaseSPS* vollmthi);
  ::commonmodule::PhaseSPS* unsafe_arena_release_vollmthi();
  // .commonmodule.PhaseSPS VolLmtLo = 17;
  bool has_vollmtlo() const;
  private:
  bool _internal_has_vollmtlo() const;

  public:
  void clear_vollmtlo() ;
  const ::commonmodule::PhaseSPS& vollmtlo() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseSPS* release_vollmtlo();
  ::commonmodule::PhaseSPS* mutable_vollmtlo();
  void set_allocated_vollmtlo(::commonmodule::PhaseSPS* vollmtlo);
  private:
  const ::commonmodule::PhaseSPS& _internal_vollmtlo() const;
  ::commonmodule::PhaseSPS* _internal_mutable_vollmtlo();
  public:
  void unsafe_arena_set_allocated_vollmtlo(
      ::commonmodule::PhaseSPS* vollmtlo);
  ::commonmodule::PhaseSPS* unsafe_arena_release_vollmtlo();
  // .commonmodule.PhaseAPC VolSpt = 18;
  bool has_volspt() const;
  private:
  bool _internal_has_volspt() const;

  public:
  void clear_volspt() ;
  const ::commonmodule::PhaseAPC& volspt() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseAPC* release_volspt();
  ::commonmodule::PhaseAPC* mutable_volspt();
  void set_allocated_volspt(::commonmodule::PhaseAPC* volspt);
  private:
  const ::commonmodule::PhaseAPC& _internal_volspt() const;
  ::commonmodule::PhaseAPC* _internal_mutable_volspt();
  public:
  void unsafe_arena_set_allocated_volspt(
      ::commonmodule::PhaseAPC* volspt);
  ::commonmodule::PhaseAPC* unsafe_arena_release_volspt();
  // .commonmodule.StatusSPS voltageSetPointEnabled = 19;
  bool has_voltagesetpointenabled() const;
  private:
  bool _internal_has_voltagesetpointenabled() const;

  public:
  void clear_voltagesetpointenabled() ;
  const ::commonmodule::StatusSPS& voltagesetpointenabled() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusSPS* release_voltagesetpointenabled();
  ::commonmodule::StatusSPS* mutable_voltagesetpointenabled();
  void set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* voltagesetpointenabled);
  private:
  const ::commonmodule::StatusSPS& _internal_voltagesetpointenabled() const;
  ::commonmodule::StatusSPS* _internal_mutable_voltagesetpointenabled();
  public:
  void unsafe_arena_set_allocated_voltagesetpointenabled(
      ::commonmodule::StatusSPS* voltagesetpointenabled);
  ::commonmodule::StatusSPS* unsafe_arena_release_voltagesetpointenabled();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventAndStatusATCC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ASG* bndctr_;
    ::commonmodule::ASG* bndwid_;
    ::commonmodule::PhaseSPS* bndwidhi_;
    ::commonmodule::PhaseSPS* bndwidlo_;
    ::commonmodule::PhaseSPS* dirctlrev_;
    ::commonmodule::PhaseSPS* dirindt_;
    ::commonmodule::PhaseSPS* dirrev_;
    ::commonmodule::ASG* ldcr_;
    ::commonmodule::ASG* ldcx_;
    ::commonmodule::StatusSPS* parop_;
    ::commonmodule::RampRate* ramprates_;
    ::commonmodule::Optional_StateKind* state_;
    ::commonmodule::StatusINC* stdltmms_;
    ::commonmodule::StatusSPS* tapoperr_;
    ::commonmodule::PhaseINS* tappos_;
    ::commonmodule::PhaseSPS* vollmthi_;
    ::commonmodule::PhaseSPS* vollmtlo_;
    ::commonmodule::PhaseAPC* volspt_;
    ::commonmodule::StatusSPS* voltagesetpointenabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorEventAndStatusANCR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventAndStatusANCR) */ {
 public:
  inline RegulatorEventAndStatusANCR() : RegulatorEventAndStatusANCR(nullptr) {}
  ~RegulatorEventAndStatusANCR() override;
  explicit PROTOBUF_CONSTEXPR RegulatorEventAndStatusANCR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorEventAndStatusANCR(const RegulatorEventAndStatusANCR& from);
  RegulatorEventAndStatusANCR(RegulatorEventAndStatusANCR&& from) noexcept
    : RegulatorEventAndStatusANCR() {
    *this = ::std::move(from);
  }

  inline RegulatorEventAndStatusANCR& operator=(const RegulatorEventAndStatusANCR& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEventAndStatusANCR& operator=(RegulatorEventAndStatusANCR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEventAndStatusANCR& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorEventAndStatusANCR* internal_default_instance() {
    return reinterpret_cast<const RegulatorEventAndStatusANCR*>(
               &_RegulatorEventAndStatusANCR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RegulatorEventAndStatusANCR& a, RegulatorEventAndStatusANCR& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorEventAndStatusANCR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEventAndStatusANCR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEventAndStatusANCR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorEventAndStatusANCR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorEventAndStatusANCR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorEventAndStatusANCR& from) {
    RegulatorEventAndStatusANCR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEventAndStatusANCR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorEventAndStatusANCR";
  }
  protected:
  explicit RegulatorEventAndStatusANCR(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalNodeForEventAndStatusFieldNumber = 1,
    kDynamicTestFieldNumber = 2,
    kPointStatusFieldNumber = 3,
  };
  // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
  bool has_logicalnodeforeventandstatus() const;
  private:
  bool _internal_has_logicalnodeforeventandstatus() const;

  public:
  void clear_logicalnodeforeventandstatus() ;
  const ::commonmodule::LogicalNodeForEventAndStatus& logicalnodeforeventandstatus() const;
  PROTOBUF_NODISCARD ::commonmodule::LogicalNodeForEventAndStatus* release_logicalnodeforeventandstatus();
  ::commonmodule::LogicalNodeForEventAndStatus* mutable_logicalnodeforeventandstatus();
  void set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  private:
  const ::commonmodule::LogicalNodeForEventAndStatus& _internal_logicalnodeforeventandstatus() const;
  ::commonmodule::LogicalNodeForEventAndStatus* _internal_mutable_logicalnodeforeventandstatus();
  public:
  void unsafe_arena_set_allocated_logicalnodeforeventandstatus(
      ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus);
  ::commonmodule::LogicalNodeForEventAndStatus* unsafe_arena_release_logicalnodeforeventandstatus();
  // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
  bool has_dynamictest() const;
  private:
  bool _internal_has_dynamictest() const;

  public:
  void clear_dynamictest() ;
  const ::commonmodule::ENS_DynamicTestKind& dynamictest() const;
  PROTOBUF_NODISCARD ::commonmodule::ENS_DynamicTestKind* release_dynamictest();
  ::commonmodule::ENS_DynamicTestKind* mutable_dynamictest();
  void set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest);
  private:
  const ::commonmodule::ENS_DynamicTestKind& _internal_dynamictest() const;
  ::commonmodule::ENS_DynamicTestKind* _internal_mutable_dynamictest();
  public:
  void unsafe_arena_set_allocated_dynamictest(
      ::commonmodule::ENS_DynamicTestKind* dynamictest);
  ::commonmodule::ENS_DynamicTestKind* unsafe_arena_release_dynamictest();
  // .regulatormodule.RegulatorEventAndStatusATCC PointStatus = 3;
  bool has_pointstatus() const;
  private:
  bool _internal_has_pointstatus() const;

  public:
  void clear_pointstatus() ;
  const ::regulatormodule::RegulatorEventAndStatusATCC& pointstatus() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorEventAndStatusATCC* release_pointstatus();
  ::regulatormodule::RegulatorEventAndStatusATCC* mutable_pointstatus();
  void set_allocated_pointstatus(::regulatormodule::RegulatorEventAndStatusATCC* pointstatus);
  private:
  const ::regulatormodule::RegulatorEventAndStatusATCC& _internal_pointstatus() const;
  ::regulatormodule::RegulatorEventAndStatusATCC* _internal_mutable_pointstatus();
  public:
  void unsafe_arena_set_allocated_pointstatus(
      ::regulatormodule::RegulatorEventAndStatusATCC* pointstatus);
  ::regulatormodule::RegulatorEventAndStatusATCC* unsafe_arena_release_pointstatus();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventAndStatusANCR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus_;
    ::commonmodule::ENS_DynamicTestKind* dynamictest_;
    ::regulatormodule::RegulatorEventAndStatusATCC* pointstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEvent) */ {
 public:
  inline RegulatorEvent() : RegulatorEvent(nullptr) {}
  ~RegulatorEvent() override;
  explicit PROTOBUF_CONSTEXPR RegulatorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorEvent(const RegulatorEvent& from);
  RegulatorEvent(RegulatorEvent&& from) noexcept
    : RegulatorEvent() {
    *this = ::std::move(from);
  }

  inline RegulatorEvent& operator=(const RegulatorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEvent& operator=(RegulatorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorEvent* internal_default_instance() {
    return reinterpret_cast<const RegulatorEvent*>(
               &_RegulatorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RegulatorEvent& a, RegulatorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorEvent& from) {
    RegulatorEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorEvent";
  }
  protected:
  explicit RegulatorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventValueFieldNumber = 1,
    kRegulatorEventAndStatusANCRFieldNumber = 2,
  };
  // .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
  bool has_eventvalue() const;
  private:
  bool _internal_has_eventvalue() const;

  public:
  void clear_eventvalue() ;
  const ::commonmodule::EventValue& eventvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::EventValue* release_eventvalue();
  ::commonmodule::EventValue* mutable_eventvalue();
  void set_allocated_eventvalue(::commonmodule::EventValue* eventvalue);
  private:
  const ::commonmodule::EventValue& _internal_eventvalue() const;
  ::commonmodule::EventValue* _internal_mutable_eventvalue();
  public:
  void unsafe_arena_set_allocated_eventvalue(
      ::commonmodule::EventValue* eventvalue);
  ::commonmodule::EventValue* unsafe_arena_release_eventvalue();
  // .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
  bool has_regulatoreventandstatusancr() const;
  private:
  bool _internal_has_regulatoreventandstatusancr() const;

  public:
  void clear_regulatoreventandstatusancr() ;
  const ::regulatormodule::RegulatorEventAndStatusANCR& regulatoreventandstatusancr() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorEventAndStatusANCR* release_regulatoreventandstatusancr();
  ::regulatormodule::RegulatorEventAndStatusANCR* mutable_regulatoreventandstatusancr();
  void set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr);
  private:
  const ::regulatormodule::RegulatorEventAndStatusANCR& _internal_regulatoreventandstatusancr() const;
  ::regulatormodule::RegulatorEventAndStatusANCR* _internal_mutable_regulatoreventandstatusancr();
  public:
  void unsafe_arena_set_allocated_regulatoreventandstatusancr(
      ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr);
  ::regulatormodule::RegulatorEventAndStatusANCR* unsafe_arena_release_regulatoreventandstatusancr();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventValue* eventvalue_;
    ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorEventProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorEventProfile) */ {
 public:
  inline RegulatorEventProfile() : RegulatorEventProfile(nullptr) {}
  ~RegulatorEventProfile() override;
  explicit PROTOBUF_CONSTEXPR RegulatorEventProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorEventProfile(const RegulatorEventProfile& from);
  RegulatorEventProfile(RegulatorEventProfile&& from) noexcept
    : RegulatorEventProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorEventProfile& operator=(const RegulatorEventProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorEventProfile& operator=(RegulatorEventProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorEventProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorEventProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorEventProfile*>(
               &_RegulatorEventProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RegulatorEventProfile& a, RegulatorEventProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorEventProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorEventProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorEventProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorEventProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorEventProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorEventProfile& from) {
    RegulatorEventProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorEventProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorEventProfile";
  }
  protected:
  explicit RegulatorEventProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventMessageInfoFieldNumber = 1,
    kRegulatorEventFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_eventmessageinfo() const;
  private:
  bool _internal_has_eventmessageinfo() const;

  public:
  void clear_eventmessageinfo() ;
  const ::commonmodule::EventMessageInfo& eventmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::EventMessageInfo* release_eventmessageinfo();
  ::commonmodule::EventMessageInfo* mutable_eventmessageinfo();
  void set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo);
  private:
  const ::commonmodule::EventMessageInfo& _internal_eventmessageinfo() const;
  ::commonmodule::EventMessageInfo* _internal_mutable_eventmessageinfo();
  public:
  void unsafe_arena_set_allocated_eventmessageinfo(
      ::commonmodule::EventMessageInfo* eventmessageinfo);
  ::commonmodule::EventMessageInfo* unsafe_arena_release_eventmessageinfo();
  // .regulatormodule.RegulatorEvent regulatorEvent = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorevent() const;
  private:
  bool _internal_has_regulatorevent() const;

  public:
  void clear_regulatorevent() ;
  const ::regulatormodule::RegulatorEvent& regulatorevent() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorEvent* release_regulatorevent();
  ::regulatormodule::RegulatorEvent* mutable_regulatorevent();
  void set_allocated_regulatorevent(::regulatormodule::RegulatorEvent* regulatorevent);
  private:
  const ::regulatormodule::RegulatorEvent& _internal_regulatorevent() const;
  ::regulatormodule::RegulatorEvent* _internal_mutable_regulatorevent();
  public:
  void unsafe_arena_set_allocated_regulatorevent(
      ::regulatormodule::RegulatorEvent* regulatorevent);
  ::regulatormodule::RegulatorEvent* unsafe_arena_release_regulatorevent();
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  private:
  bool _internal_has_regulatorsystem() const;

  public:
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);
  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* _internal_mutable_regulatorsystem();
  public:
  void unsafe_arena_set_allocated_regulatorsystem(
      ::regulatormodule::RegulatorSystem* regulatorsystem);
  ::regulatormodule::RegulatorSystem* unsafe_arena_release_regulatorsystem();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorEventProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::EventMessageInfo* eventmessageinfo_;
    ::regulatormodule::RegulatorEvent* regulatorevent_;
    ::regulatormodule::RegulatorSystem* regulatorsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorReading final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorReading) */ {
 public:
  inline RegulatorReading() : RegulatorReading(nullptr) {}
  ~RegulatorReading() override;
  explicit PROTOBUF_CONSTEXPR RegulatorReading(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorReading(const RegulatorReading& from);
  RegulatorReading(RegulatorReading&& from) noexcept
    : RegulatorReading() {
    *this = ::std::move(from);
  }

  inline RegulatorReading& operator=(const RegulatorReading& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorReading& operator=(RegulatorReading&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorReading& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorReading* internal_default_instance() {
    return reinterpret_cast<const RegulatorReading*>(
               &_RegulatorReading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RegulatorReading& a, RegulatorReading& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorReading* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorReading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorReading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorReading>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorReading& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorReading& from) {
    RegulatorReading::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorReading* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorReading";
  }
  protected:
  explicit RegulatorReading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConductingEquipmentTerminalReadingFieldNumber = 1,
    kPhaseMMTNFieldNumber = 2,
    kReadingMMTRFieldNumber = 3,
    kReadingMMXUFieldNumber = 4,
    kSecondaryReadingMMXUFieldNumber = 5,
  };
  // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
  bool has_conductingequipmentterminalreading() const;
  private:
  bool _internal_has_conductingequipmentterminalreading() const;

  public:
  void clear_conductingequipmentterminalreading() ;
  const ::commonmodule::ConductingEquipmentTerminalReading& conductingequipmentterminalreading() const;
  PROTOBUF_NODISCARD ::commonmodule::ConductingEquipmentTerminalReading* release_conductingequipmentterminalreading();
  ::commonmodule::ConductingEquipmentTerminalReading* mutable_conductingequipmentterminalreading();
  void set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  private:
  const ::commonmodule::ConductingEquipmentTerminalReading& _internal_conductingequipmentterminalreading() const;
  ::commonmodule::ConductingEquipmentTerminalReading* _internal_mutable_conductingequipmentterminalreading();
  public:
  void unsafe_arena_set_allocated_conductingequipmentterminalreading(
      ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading);
  ::commonmodule::ConductingEquipmentTerminalReading* unsafe_arena_release_conductingequipmentterminalreading();
  // .commonmodule.PhaseMMTN phaseMMTN = 2;
  bool has_phasemmtn() const;
  private:
  bool _internal_has_phasemmtn() const;

  public:
  void clear_phasemmtn() ;
  const ::commonmodule::PhaseMMTN& phasemmtn() const;
  PROTOBUF_NODISCARD ::commonmodule::PhaseMMTN* release_phasemmtn();
  ::commonmodule::PhaseMMTN* mutable_phasemmtn();
  void set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn);
  private:
  const ::commonmodule::PhaseMMTN& _internal_phasemmtn() const;
  ::commonmodule::PhaseMMTN* _internal_mutable_phasemmtn();
  public:
  void unsafe_arena_set_allocated_phasemmtn(
      ::commonmodule::PhaseMMTN* phasemmtn);
  ::commonmodule::PhaseMMTN* unsafe_arena_release_phasemmtn();
  // .commonmodule.ReadingMMTR readingMMTR = 3;
  bool has_readingmmtr() const;
  private:
  bool _internal_has_readingmmtr() const;

  public:
  void clear_readingmmtr() ;
  const ::commonmodule::ReadingMMTR& readingmmtr() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMTR* release_readingmmtr();
  ::commonmodule::ReadingMMTR* mutable_readingmmtr();
  void set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr);
  private:
  const ::commonmodule::ReadingMMTR& _internal_readingmmtr() const;
  ::commonmodule::ReadingMMTR* _internal_mutable_readingmmtr();
  public:
  void unsafe_arena_set_allocated_readingmmtr(
      ::commonmodule::ReadingMMTR* readingmmtr);
  ::commonmodule::ReadingMMTR* unsafe_arena_release_readingmmtr();
  // .commonmodule.ReadingMMXU readingMMXU = 4;
  bool has_readingmmxu() const;
  private:
  bool _internal_has_readingmmxu() const;

  public:
  void clear_readingmmxu() ;
  const ::commonmodule::ReadingMMXU& readingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_readingmmxu();
  ::commonmodule::ReadingMMXU* mutable_readingmmxu();
  void set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_readingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_readingmmxu();
  public:
  void unsafe_arena_set_allocated_readingmmxu(
      ::commonmodule::ReadingMMXU* readingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_readingmmxu();
  // .commonmodule.ReadingMMXU secondaryReadingMMXU = 5;
  bool has_secondaryreadingmmxu() const;
  private:
  bool _internal_has_secondaryreadingmmxu() const;

  public:
  void clear_secondaryreadingmmxu() ;
  const ::commonmodule::ReadingMMXU& secondaryreadingmmxu() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMMXU* release_secondaryreadingmmxu();
  ::commonmodule::ReadingMMXU* mutable_secondaryreadingmmxu();
  void set_allocated_secondaryreadingmmxu(::commonmodule::ReadingMMXU* secondaryreadingmmxu);
  private:
  const ::commonmodule::ReadingMMXU& _internal_secondaryreadingmmxu() const;
  ::commonmodule::ReadingMMXU* _internal_mutable_secondaryreadingmmxu();
  public:
  void unsafe_arena_set_allocated_secondaryreadingmmxu(
      ::commonmodule::ReadingMMXU* secondaryreadingmmxu);
  ::commonmodule::ReadingMMXU* unsafe_arena_release_secondaryreadingmmxu();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorReading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading_;
    ::commonmodule::PhaseMMTN* phasemmtn_;
    ::commonmodule::ReadingMMTR* readingmmtr_;
    ::commonmodule::ReadingMMXU* readingmmxu_;
    ::commonmodule::ReadingMMXU* secondaryreadingmmxu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorReadingProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorReadingProfile) */ {
 public:
  inline RegulatorReadingProfile() : RegulatorReadingProfile(nullptr) {}
  ~RegulatorReadingProfile() override;
  explicit PROTOBUF_CONSTEXPR RegulatorReadingProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorReadingProfile(const RegulatorReadingProfile& from);
  RegulatorReadingProfile(RegulatorReadingProfile&& from) noexcept
    : RegulatorReadingProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorReadingProfile& operator=(const RegulatorReadingProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorReadingProfile& operator=(RegulatorReadingProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorReadingProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorReadingProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorReadingProfile*>(
               &_RegulatorReadingProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RegulatorReadingProfile& a, RegulatorReadingProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorReadingProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorReadingProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorReadingProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorReadingProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorReadingProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorReadingProfile& from) {
    RegulatorReadingProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorReadingProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorReadingProfile";
  }
  protected:
  explicit RegulatorReadingProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegulatorReadingFieldNumber = 2,
    kReadingMessageInfoFieldNumber = 1,
    kRegulatorSystemFieldNumber = 3,
  };
  // repeated .regulatormodule.RegulatorReading regulatorReading = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
  int regulatorreading_size() const;
  private:
  int _internal_regulatorreading_size() const;

  public:
  void clear_regulatorreading() ;
  ::regulatormodule::RegulatorReading* mutable_regulatorreading(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorReading >*
      mutable_regulatorreading();
  private:
  const ::regulatormodule::RegulatorReading& _internal_regulatorreading(int index) const;
  ::regulatormodule::RegulatorReading* _internal_add_regulatorreading();
  public:
  const ::regulatormodule::RegulatorReading& regulatorreading(int index) const;
  ::regulatormodule::RegulatorReading* add_regulatorreading();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorReading >&
      regulatorreading() const;
  // .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_readingmessageinfo() const;
  private:
  bool _internal_has_readingmessageinfo() const;

  public:
  void clear_readingmessageinfo() ;
  const ::commonmodule::ReadingMessageInfo& readingmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::ReadingMessageInfo* release_readingmessageinfo();
  ::commonmodule::ReadingMessageInfo* mutable_readingmessageinfo();
  void set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo);
  private:
  const ::commonmodule::ReadingMessageInfo& _internal_readingmessageinfo() const;
  ::commonmodule::ReadingMessageInfo* _internal_mutable_readingmessageinfo();
  public:
  void unsafe_arena_set_allocated_readingmessageinfo(
      ::commonmodule::ReadingMessageInfo* readingmessageinfo);
  ::commonmodule::ReadingMessageInfo* unsafe_arena_release_readingmessageinfo();
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  private:
  bool _internal_has_regulatorsystem() const;

  public:
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);
  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* _internal_mutable_regulatorsystem();
  public:
  void unsafe_arena_set_allocated_regulatorsystem(
      ::regulatormodule::RegulatorSystem* regulatorsystem);
  ::regulatormodule::RegulatorSystem* unsafe_arena_release_regulatorsystem();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorReadingProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorReading > regulatorreading_;
    ::commonmodule::ReadingMessageInfo* readingmessageinfo_;
    ::regulatormodule::RegulatorSystem* regulatorsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorStatus) */ {
 public:
  inline RegulatorStatus() : RegulatorStatus(nullptr) {}
  ~RegulatorStatus() override;
  explicit PROTOBUF_CONSTEXPR RegulatorStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorStatus(const RegulatorStatus& from);
  RegulatorStatus(RegulatorStatus&& from) noexcept
    : RegulatorStatus() {
    *this = ::std::move(from);
  }

  inline RegulatorStatus& operator=(const RegulatorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorStatus& operator=(RegulatorStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorStatus* internal_default_instance() {
    return reinterpret_cast<const RegulatorStatus*>(
               &_RegulatorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RegulatorStatus& a, RegulatorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorStatus& from) {
    RegulatorStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorStatus";
  }
  protected:
  explicit RegulatorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusValueFieldNumber = 1,
    kRegulatorEventAndStatusANCRFieldNumber = 2,
  };
  // .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
  bool has_statusvalue() const;
  private:
  bool _internal_has_statusvalue() const;

  public:
  void clear_statusvalue() ;
  const ::commonmodule::StatusValue& statusvalue() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusValue* release_statusvalue();
  ::commonmodule::StatusValue* mutable_statusvalue();
  void set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue);
  private:
  const ::commonmodule::StatusValue& _internal_statusvalue() const;
  ::commonmodule::StatusValue* _internal_mutable_statusvalue();
  public:
  void unsafe_arena_set_allocated_statusvalue(
      ::commonmodule::StatusValue* statusvalue);
  ::commonmodule::StatusValue* unsafe_arena_release_statusvalue();
  // .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
  bool has_regulatoreventandstatusancr() const;
  private:
  bool _internal_has_regulatoreventandstatusancr() const;

  public:
  void clear_regulatoreventandstatusancr() ;
  const ::regulatormodule::RegulatorEventAndStatusANCR& regulatoreventandstatusancr() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorEventAndStatusANCR* release_regulatoreventandstatusancr();
  ::regulatormodule::RegulatorEventAndStatusANCR* mutable_regulatoreventandstatusancr();
  void set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr);
  private:
  const ::regulatormodule::RegulatorEventAndStatusANCR& _internal_regulatoreventandstatusancr() const;
  ::regulatormodule::RegulatorEventAndStatusANCR* _internal_mutable_regulatoreventandstatusancr();
  public:
  void unsafe_arena_set_allocated_regulatoreventandstatusancr(
      ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr);
  ::regulatormodule::RegulatorEventAndStatusANCR* unsafe_arena_release_regulatoreventandstatusancr();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusValue* statusvalue_;
    ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};// -------------------------------------------------------------------

class RegulatorStatusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:regulatormodule.RegulatorStatusProfile) */ {
 public:
  inline RegulatorStatusProfile() : RegulatorStatusProfile(nullptr) {}
  ~RegulatorStatusProfile() override;
  explicit PROTOBUF_CONSTEXPR RegulatorStatusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorStatusProfile(const RegulatorStatusProfile& from);
  RegulatorStatusProfile(RegulatorStatusProfile&& from) noexcept
    : RegulatorStatusProfile() {
    *this = ::std::move(from);
  }

  inline RegulatorStatusProfile& operator=(const RegulatorStatusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorStatusProfile& operator=(RegulatorStatusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorStatusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorStatusProfile* internal_default_instance() {
    return reinterpret_cast<const RegulatorStatusProfile*>(
               &_RegulatorStatusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RegulatorStatusProfile& a, RegulatorStatusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorStatusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorStatusProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorStatusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorStatusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorStatusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorStatusProfile& from) {
    RegulatorStatusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorStatusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "regulatormodule.RegulatorStatusProfile";
  }
  protected:
  explicit RegulatorStatusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusMessageInfoFieldNumber = 1,
    kRegulatorStatusFieldNumber = 2,
    kRegulatorSystemFieldNumber = 3,
  };
  // .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
  bool has_statusmessageinfo() const;
  private:
  bool _internal_has_statusmessageinfo() const;

  public:
  void clear_statusmessageinfo() ;
  const ::commonmodule::StatusMessageInfo& statusmessageinfo() const;
  PROTOBUF_NODISCARD ::commonmodule::StatusMessageInfo* release_statusmessageinfo();
  ::commonmodule::StatusMessageInfo* mutable_statusmessageinfo();
  void set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo);
  private:
  const ::commonmodule::StatusMessageInfo& _internal_statusmessageinfo() const;
  ::commonmodule::StatusMessageInfo* _internal_mutable_statusmessageinfo();
  public:
  void unsafe_arena_set_allocated_statusmessageinfo(
      ::commonmodule::StatusMessageInfo* statusmessageinfo);
  ::commonmodule::StatusMessageInfo* unsafe_arena_release_statusmessageinfo();
  // .regulatormodule.RegulatorStatus regulatorStatus = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorstatus() const;
  private:
  bool _internal_has_regulatorstatus() const;

  public:
  void clear_regulatorstatus() ;
  const ::regulatormodule::RegulatorStatus& regulatorstatus() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorStatus* release_regulatorstatus();
  ::regulatormodule::RegulatorStatus* mutable_regulatorstatus();
  void set_allocated_regulatorstatus(::regulatormodule::RegulatorStatus* regulatorstatus);
  private:
  const ::regulatormodule::RegulatorStatus& _internal_regulatorstatus() const;
  ::regulatormodule::RegulatorStatus* _internal_mutable_regulatorstatus();
  public:
  void unsafe_arena_set_allocated_regulatorstatus(
      ::regulatormodule::RegulatorStatus* regulatorstatus);
  ::regulatormodule::RegulatorStatus* unsafe_arena_release_regulatorstatus();
  // .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
  bool has_regulatorsystem() const;
  private:
  bool _internal_has_regulatorsystem() const;

  public:
  void clear_regulatorsystem() ;
  const ::regulatormodule::RegulatorSystem& regulatorsystem() const;
  PROTOBUF_NODISCARD ::regulatormodule::RegulatorSystem* release_regulatorsystem();
  ::regulatormodule::RegulatorSystem* mutable_regulatorsystem();
  void set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem);
  private:
  const ::regulatormodule::RegulatorSystem& _internal_regulatorsystem() const;
  ::regulatormodule::RegulatorSystem* _internal_mutable_regulatorsystem();
  public:
  void unsafe_arena_set_allocated_regulatorsystem(
      ::regulatormodule::RegulatorSystem* regulatorsystem);
  ::regulatormodule::RegulatorSystem* unsafe_arena_release_regulatorsystem();
  // @@protoc_insertion_point(class_scope:regulatormodule.RegulatorStatusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::commonmodule::StatusMessageInfo* statusmessageinfo_;
    ::regulatormodule::RegulatorStatus* regulatorstatus_;
    ::regulatormodule::RegulatorSystem* regulatorsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_regulatormodule_2fregulatormodule_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DirectionalATCC

// .commonmodule.PhaseAPC BndWid = 1;
inline bool DirectionalATCC::_internal_has_bndwid() const {
  return this != internal_default_instance() && _impl_.bndwid_ != nullptr;
}
inline bool DirectionalATCC::has_bndwid() const {
  return _internal_has_bndwid();
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_bndwid() const {
  const ::commonmodule::PhaseAPC* p = _impl_.bndwid_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::bndwid() const {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.BndWid)
  return _internal_bndwid();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_bndwid(
    ::commonmodule::PhaseAPC* bndwid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwid_);
  }
  _impl_.bndwid_ = bndwid;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.BndWid)
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::release_bndwid() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::unsafe_arena_release_bndwid() {
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.BndWid)
  
  ::commonmodule::PhaseAPC* temp = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::_internal_mutable_bndwid() {
  
  if (_impl_.bndwid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.bndwid_ = p;
  }
  return _impl_.bndwid_;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::mutable_bndwid() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_bndwid();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.BndWid)
  return _msg;
}
inline void DirectionalATCC::set_allocated_bndwid(::commonmodule::PhaseAPC* bndwid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwid_);
  }
  if (bndwid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bndwid));
    if (message_arena != submessage_arena) {
      bndwid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bndwid, submessage_arena);
    }

  } else {

  }
  _impl_.bndwid_ = bndwid;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.BndWid)
}

// .commonmodule.PhaseISC CtlDlTmms = 2;
inline bool DirectionalATCC::_internal_has_ctldltmms() const {
  return this != internal_default_instance() && _impl_.ctldltmms_ != nullptr;
}
inline bool DirectionalATCC::has_ctldltmms() const {
  return _internal_has_ctldltmms();
}
inline const ::commonmodule::PhaseISC& DirectionalATCC::_internal_ctldltmms() const {
  const ::commonmodule::PhaseISC* p = _impl_.ctldltmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseISC&>(
      ::commonmodule::_PhaseISC_default_instance_);
}
inline const ::commonmodule::PhaseISC& DirectionalATCC::ctldltmms() const {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.CtlDlTmms)
  return _internal_ctldltmms();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_ctldltmms(
    ::commonmodule::PhaseISC* ctldltmms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ctldltmms_);
  }
  _impl_.ctldltmms_ = ctldltmms;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.CtlDlTmms)
}
inline ::commonmodule::PhaseISC* DirectionalATCC::release_ctldltmms() {
  
  ::commonmodule::PhaseISC* temp = _impl_.ctldltmms_;
  _impl_.ctldltmms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseISC* DirectionalATCC::unsafe_arena_release_ctldltmms() {
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.CtlDlTmms)
  
  ::commonmodule::PhaseISC* temp = _impl_.ctldltmms_;
  _impl_.ctldltmms_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseISC* DirectionalATCC::_internal_mutable_ctldltmms() {
  
  if (_impl_.ctldltmms_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseISC>(GetArenaForAllocation());
    _impl_.ctldltmms_ = p;
  }
  return _impl_.ctldltmms_;
}
inline ::commonmodule::PhaseISC* DirectionalATCC::mutable_ctldltmms() {
  ::commonmodule::PhaseISC* _msg = _internal_mutable_ctldltmms();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.CtlDlTmms)
  return _msg;
}
inline void DirectionalATCC::set_allocated_ctldltmms(::commonmodule::PhaseISC* ctldltmms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ctldltmms_);
  }
  if (ctldltmms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ctldltmms));
    if (message_arena != submessage_arena) {
      ctldltmms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ctldltmms, submessage_arena);
    }

  } else {

  }
  _impl_.ctldltmms_ = ctldltmms;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.CtlDlTmms)
}

// .commonmodule.PhaseAPC LDCR = 3;
inline bool DirectionalATCC::_internal_has_ldcr() const {
  return this != internal_default_instance() && _impl_.ldcr_ != nullptr;
}
inline bool DirectionalATCC::has_ldcr() const {
  return _internal_has_ldcr();
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_ldcr() const {
  const ::commonmodule::PhaseAPC* p = _impl_.ldcr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::ldcr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.LDCR)
  return _internal_ldcr();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_ldcr(
    ::commonmodule::PhaseAPC* ldcr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcr_);
  }
  _impl_.ldcr_ = ldcr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.LDCR)
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::release_ldcr() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::unsafe_arena_release_ldcr() {
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.LDCR)
  
  ::commonmodule::PhaseAPC* temp = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::_internal_mutable_ldcr() {
  
  if (_impl_.ldcr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.ldcr_ = p;
  }
  return _impl_.ldcr_;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::mutable_ldcr() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_ldcr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.LDCR)
  return _msg;
}
inline void DirectionalATCC::set_allocated_ldcr(::commonmodule::PhaseAPC* ldcr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcr_);
  }
  if (ldcr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldcr));
    if (message_arena != submessage_arena) {
      ldcr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldcr, submessage_arena);
    }

  } else {

  }
  _impl_.ldcr_ = ldcr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.LDCR)
}

// .commonmodule.PhaseAPC LDCX = 4;
inline bool DirectionalATCC::_internal_has_ldcx() const {
  return this != internal_default_instance() && _impl_.ldcx_ != nullptr;
}
inline bool DirectionalATCC::has_ldcx() const {
  return _internal_has_ldcx();
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_ldcx() const {
  const ::commonmodule::PhaseAPC* p = _impl_.ldcx_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::ldcx() const {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.LDCX)
  return _internal_ldcx();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_ldcx(
    ::commonmodule::PhaseAPC* ldcx) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcx_);
  }
  _impl_.ldcx_ = ldcx;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.LDCX)
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::release_ldcx() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::unsafe_arena_release_ldcx() {
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.LDCX)
  
  ::commonmodule::PhaseAPC* temp = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::_internal_mutable_ldcx() {
  
  if (_impl_.ldcx_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.ldcx_ = p;
  }
  return _impl_.ldcx_;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::mutable_ldcx() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_ldcx();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.LDCX)
  return _msg;
}
inline void DirectionalATCC::set_allocated_ldcx(::commonmodule::PhaseAPC* ldcx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcx_);
  }
  if (ldcx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldcx));
    if (message_arena != submessage_arena) {
      ldcx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldcx, submessage_arena);
    }

  } else {

  }
  _impl_.ldcx_ = ldcx;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.LDCX)
}

// .commonmodule.PhaseAPC VolSpt = 5;
inline bool DirectionalATCC::_internal_has_volspt() const {
  return this != internal_default_instance() && _impl_.volspt_ != nullptr;
}
inline bool DirectionalATCC::has_volspt() const {
  return _internal_has_volspt();
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::_internal_volspt() const {
  const ::commonmodule::PhaseAPC* p = _impl_.volspt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& DirectionalATCC::volspt() const {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.VolSpt)
  return _internal_volspt();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_volspt(
    ::commonmodule::PhaseAPC* volspt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volspt_);
  }
  _impl_.volspt_ = volspt;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.VolSpt)
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::release_volspt() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::unsafe_arena_release_volspt() {
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.VolSpt)
  
  ::commonmodule::PhaseAPC* temp = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::_internal_mutable_volspt() {
  
  if (_impl_.volspt_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.volspt_ = p;
  }
  return _impl_.volspt_;
}
inline ::commonmodule::PhaseAPC* DirectionalATCC::mutable_volspt() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_volspt();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.VolSpt)
  return _msg;
}
inline void DirectionalATCC::set_allocated_volspt(::commonmodule::PhaseAPC* volspt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volspt_);
  }
  if (volspt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volspt));
    if (message_arena != submessage_arena) {
      volspt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volspt, submessage_arena);
    }

  } else {

  }
  _impl_.volspt_ = volspt;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.VolSpt)
}

// .commonmodule.PhaseDPC voltageSetPointEnabled = 6;
inline bool DirectionalATCC::_internal_has_voltagesetpointenabled() const {
  return this != internal_default_instance() && _impl_.voltagesetpointenabled_ != nullptr;
}
inline bool DirectionalATCC::has_voltagesetpointenabled() const {
  return _internal_has_voltagesetpointenabled();
}
inline const ::commonmodule::PhaseDPC& DirectionalATCC::_internal_voltagesetpointenabled() const {
  const ::commonmodule::PhaseDPC* p = _impl_.voltagesetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseDPC&>(
      ::commonmodule::_PhaseDPC_default_instance_);
}
inline const ::commonmodule::PhaseDPC& DirectionalATCC::voltagesetpointenabled() const {
  // @@protoc_insertion_point(field_get:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
  return _internal_voltagesetpointenabled();
}
inline void DirectionalATCC::unsafe_arena_set_allocated_voltagesetpointenabled(
    ::commonmodule::PhaseDPC* voltagesetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
}
inline ::commonmodule::PhaseDPC* DirectionalATCC::release_voltagesetpointenabled() {
  
  ::commonmodule::PhaseDPC* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseDPC* DirectionalATCC::unsafe_arena_release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
  
  ::commonmodule::PhaseDPC* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseDPC* DirectionalATCC::_internal_mutable_voltagesetpointenabled() {
  
  if (_impl_.voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseDPC>(GetArenaForAllocation());
    _impl_.voltagesetpointenabled_ = p;
  }
  return _impl_.voltagesetpointenabled_;
}
inline ::commonmodule::PhaseDPC* DirectionalATCC::mutable_voltagesetpointenabled() {
  ::commonmodule::PhaseDPC* _msg = _internal_mutable_voltagesetpointenabled();
  // @@protoc_insertion_point(field_mutable:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
  return _msg;
}
inline void DirectionalATCC::set_allocated_voltagesetpointenabled(::commonmodule::PhaseDPC* voltagesetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesetpointenabled));
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.DirectionalATCC.voltageSetPointEnabled)
}

// -------------------------------------------------------------------

// RegulatorControlATCC

// .commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlATCC::_internal_has_logicalnodeforcontrol() const {
  return this != internal_default_instance() && _impl_.logicalnodeforcontrol_ != nullptr;
}
inline bool RegulatorControlATCC::has_logicalnodeforcontrol() const {
  return _internal_has_logicalnodeforcontrol();
}
inline const ::commonmodule::LogicalNodeForControl& RegulatorControlATCC::_internal_logicalnodeforcontrol() const {
  const ::commonmodule::LogicalNodeForControl* p = _impl_.logicalnodeforcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForControl&>(
      ::commonmodule::_LogicalNodeForControl_default_instance_);
}
inline const ::commonmodule::LogicalNodeForControl& RegulatorControlATCC::logicalnodeforcontrol() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
  return _internal_logicalnodeforcontrol();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_logicalnodeforcontrol(
    ::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
}
inline ::commonmodule::LogicalNodeForControl* RegulatorControlATCC::release_logicalnodeforcontrol() {
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* RegulatorControlATCC::unsafe_arena_release_logicalnodeforcontrol() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
  
  ::commonmodule::LogicalNodeForControl* temp = _impl_.logicalnodeforcontrol_;
  _impl_.logicalnodeforcontrol_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForControl* RegulatorControlATCC::_internal_mutable_logicalnodeforcontrol() {
  
  if (_impl_.logicalnodeforcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForControl>(GetArenaForAllocation());
    _impl_.logicalnodeforcontrol_ = p;
  }
  return _impl_.logicalnodeforcontrol_;
}
inline ::commonmodule::LogicalNodeForControl* RegulatorControlATCC::mutable_logicalnodeforcontrol() {
  ::commonmodule::LogicalNodeForControl* _msg = _internal_mutable_logicalnodeforcontrol();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_logicalnodeforcontrol(::commonmodule::LogicalNodeForControl* logicalnodeforcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforcontrol_);
  }
  if (logicalnodeforcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforcontrol));
    if (message_arena != submessage_arena) {
      logicalnodeforcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforcontrol_ = logicalnodeforcontrol;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.logicalNodeForControl)
}

// .regulatormodule.DirectionalATCC DirFwd = 2;
inline bool RegulatorControlATCC::_internal_has_dirfwd() const {
  return this != internal_default_instance() && _impl_.dirfwd_ != nullptr;
}
inline bool RegulatorControlATCC::has_dirfwd() const {
  return _internal_has_dirfwd();
}
inline void RegulatorControlATCC::clear_dirfwd() {
  if (GetArenaForAllocation() == nullptr && _impl_.dirfwd_ != nullptr) {
    delete _impl_.dirfwd_;
  }
  _impl_.dirfwd_ = nullptr;
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::_internal_dirfwd() const {
  const ::regulatormodule::DirectionalATCC* p = _impl_.dirfwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::DirectionalATCC&>(
      ::regulatormodule::_DirectionalATCC_default_instance_);
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::dirfwd() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirFwd)
  return _internal_dirfwd();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirfwd(
    ::regulatormodule::DirectionalATCC* dirfwd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirfwd_);
  }
  _impl_.dirfwd_ = dirfwd;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirFwd)
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::release_dirfwd() {
  
  ::regulatormodule::DirectionalATCC* temp = _impl_.dirfwd_;
  _impl_.dirfwd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::unsafe_arena_release_dirfwd() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirFwd)
  
  ::regulatormodule::DirectionalATCC* temp = _impl_.dirfwd_;
  _impl_.dirfwd_ = nullptr;
  return temp;
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::_internal_mutable_dirfwd() {
  
  if (_impl_.dirfwd_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::DirectionalATCC>(GetArenaForAllocation());
    _impl_.dirfwd_ = p;
  }
  return _impl_.dirfwd_;
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::mutable_dirfwd() {
  ::regulatormodule::DirectionalATCC* _msg = _internal_mutable_dirfwd();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirFwd)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirfwd(::regulatormodule::DirectionalATCC* dirfwd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dirfwd_;
  }
  if (dirfwd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dirfwd);
    if (message_arena != submessage_arena) {
      dirfwd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirfwd, submessage_arena);
    }

  } else {

  }
  _impl_.dirfwd_ = dirfwd;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirFwd)
}

// .commonmodule.Optional_DirectionModeKind DirMode = 3;
inline bool RegulatorControlATCC::_internal_has_dirmode() const {
  return this != internal_default_instance() && _impl_.dirmode_ != nullptr;
}
inline bool RegulatorControlATCC::has_dirmode() const {
  return _internal_has_dirmode();
}
inline const ::commonmodule::Optional_DirectionModeKind& RegulatorControlATCC::_internal_dirmode() const {
  const ::commonmodule::Optional_DirectionModeKind* p = _impl_.dirmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_DirectionModeKind&>(
      ::commonmodule::_Optional_DirectionModeKind_default_instance_);
}
inline const ::commonmodule::Optional_DirectionModeKind& RegulatorControlATCC::dirmode() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirMode)
  return _internal_dirmode();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirmode(
    ::commonmodule::Optional_DirectionModeKind* dirmode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirmode_);
  }
  _impl_.dirmode_ = dirmode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirMode)
}
inline ::commonmodule::Optional_DirectionModeKind* RegulatorControlATCC::release_dirmode() {
  
  ::commonmodule::Optional_DirectionModeKind* temp = _impl_.dirmode_;
  _impl_.dirmode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_DirectionModeKind* RegulatorControlATCC::unsafe_arena_release_dirmode() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirMode)
  
  ::commonmodule::Optional_DirectionModeKind* temp = _impl_.dirmode_;
  _impl_.dirmode_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_DirectionModeKind* RegulatorControlATCC::_internal_mutable_dirmode() {
  
  if (_impl_.dirmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_DirectionModeKind>(GetArenaForAllocation());
    _impl_.dirmode_ = p;
  }
  return _impl_.dirmode_;
}
inline ::commonmodule::Optional_DirectionModeKind* RegulatorControlATCC::mutable_dirmode() {
  ::commonmodule::Optional_DirectionModeKind* _msg = _internal_mutable_dirmode();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirMode)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirmode(::commonmodule::Optional_DirectionModeKind* dirmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirmode_);
  }
  if (dirmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirmode));
    if (message_arena != submessage_arena) {
      dirmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirmode, submessage_arena);
    }

  } else {

  }
  _impl_.dirmode_ = dirmode;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirMode)
}

// .regulatormodule.DirectionalATCC DirRev = 4;
inline bool RegulatorControlATCC::_internal_has_dirrev() const {
  return this != internal_default_instance() && _impl_.dirrev_ != nullptr;
}
inline bool RegulatorControlATCC::has_dirrev() const {
  return _internal_has_dirrev();
}
inline void RegulatorControlATCC::clear_dirrev() {
  if (GetArenaForAllocation() == nullptr && _impl_.dirrev_ != nullptr) {
    delete _impl_.dirrev_;
  }
  _impl_.dirrev_ = nullptr;
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::_internal_dirrev() const {
  const ::regulatormodule::DirectionalATCC* p = _impl_.dirrev_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::DirectionalATCC&>(
      ::regulatormodule::_DirectionalATCC_default_instance_);
}
inline const ::regulatormodule::DirectionalATCC& RegulatorControlATCC::dirrev() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirRev)
  return _internal_dirrev();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirrev(
    ::regulatormodule::DirectionalATCC* dirrev) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirrev_);
  }
  _impl_.dirrev_ = dirrev;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirRev)
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::release_dirrev() {
  
  ::regulatormodule::DirectionalATCC* temp = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::unsafe_arena_release_dirrev() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirRev)
  
  ::regulatormodule::DirectionalATCC* temp = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
  return temp;
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::_internal_mutable_dirrev() {
  
  if (_impl_.dirrev_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::DirectionalATCC>(GetArenaForAllocation());
    _impl_.dirrev_ = p;
  }
  return _impl_.dirrev_;
}
inline ::regulatormodule::DirectionalATCC* RegulatorControlATCC::mutable_dirrev() {
  ::regulatormodule::DirectionalATCC* _msg = _internal_mutable_dirrev();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirRev)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirrev(::regulatormodule::DirectionalATCC* dirrev) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dirrev_;
  }
  if (dirrev) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dirrev);
    if (message_arena != submessage_arena) {
      dirrev = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirrev, submessage_arena);
    }

  } else {

  }
  _impl_.dirrev_ = dirrev;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirRev)
}

// .commonmodule.PhaseAPC DirThd = 5;
inline bool RegulatorControlATCC::_internal_has_dirthd() const {
  return this != internal_default_instance() && _impl_.dirthd_ != nullptr;
}
inline bool RegulatorControlATCC::has_dirthd() const {
  return _internal_has_dirthd();
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::_internal_dirthd() const {
  const ::commonmodule::PhaseAPC* p = _impl_.dirthd_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::dirthd() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.DirThd)
  return _internal_dirthd();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_dirthd(
    ::commonmodule::PhaseAPC* dirthd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirthd_);
  }
  _impl_.dirthd_ = dirthd;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.DirThd)
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::release_dirthd() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.dirthd_;
  _impl_.dirthd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::unsafe_arena_release_dirthd() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.DirThd)
  
  ::commonmodule::PhaseAPC* temp = _impl_.dirthd_;
  _impl_.dirthd_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::_internal_mutable_dirthd() {
  
  if (_impl_.dirthd_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.dirthd_ = p;
  }
  return _impl_.dirthd_;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::mutable_dirthd() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_dirthd();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.DirThd)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_dirthd(::commonmodule::PhaseAPC* dirthd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirthd_);
  }
  if (dirthd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirthd));
    if (message_arena != submessage_arena) {
      dirthd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirthd, submessage_arena);
    }

  } else {

  }
  _impl_.dirthd_ = dirthd;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.DirThd)
}

// .commonmodule.PhaseSPC ParOp = 6;
inline bool RegulatorControlATCC::_internal_has_parop() const {
  return this != internal_default_instance() && _impl_.parop_ != nullptr;
}
inline bool RegulatorControlATCC::has_parop() const {
  return _internal_has_parop();
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::_internal_parop() const {
  const ::commonmodule::PhaseSPC* p = _impl_.parop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPC&>(
      ::commonmodule::_PhaseSPC_default_instance_);
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::parop() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.ParOp)
  return _internal_parop();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_parop(
    ::commonmodule::PhaseSPC* parop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parop_);
  }
  _impl_.parop_ = parop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.ParOp)
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::release_parop() {
  
  ::commonmodule::PhaseSPC* temp = _impl_.parop_;
  _impl_.parop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::unsafe_arena_release_parop() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.ParOp)
  
  ::commonmodule::PhaseSPC* temp = _impl_.parop_;
  _impl_.parop_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::_internal_mutable_parop() {
  
  if (_impl_.parop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPC>(GetArenaForAllocation());
    _impl_.parop_ = p;
  }
  return _impl_.parop_;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::mutable_parop() {
  ::commonmodule::PhaseSPC* _msg = _internal_mutable_parop();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.ParOp)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_parop(::commonmodule::PhaseSPC* parop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parop_);
  }
  if (parop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parop));
    if (message_arena != submessage_arena) {
      parop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parop, submessage_arena);
    }

  } else {

  }
  _impl_.parop_ = parop;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.ParOp)
}

// .commonmodule.RampRate rampRates = 7;
inline bool RegulatorControlATCC::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool RegulatorControlATCC::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& RegulatorControlATCC::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& RegulatorControlATCC::ramprates() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.rampRates)
  return _internal_ramprates();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.rampRates)
}
inline ::commonmodule::RampRate* RegulatorControlATCC::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* RegulatorControlATCC::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* RegulatorControlATCC::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* RegulatorControlATCC::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.rampRates)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.rampRates)
}

// .commonmodule.Optional_StateKind state = 8;
inline bool RegulatorControlATCC::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool RegulatorControlATCC::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& RegulatorControlATCC::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& RegulatorControlATCC::state() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.state)
  return _internal_state();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.state)
}
inline ::commonmodule::Optional_StateKind* RegulatorControlATCC::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* RegulatorControlATCC::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* RegulatorControlATCC::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* RegulatorControlATCC::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.state)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.state)
}

// .commonmodule.PhaseSPC TapOpL = 9;
inline bool RegulatorControlATCC::_internal_has_tapopl() const {
  return this != internal_default_instance() && _impl_.tapopl_ != nullptr;
}
inline bool RegulatorControlATCC::has_tapopl() const {
  return _internal_has_tapopl();
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::_internal_tapopl() const {
  const ::commonmodule::PhaseSPC* p = _impl_.tapopl_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPC&>(
      ::commonmodule::_PhaseSPC_default_instance_);
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::tapopl() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.TapOpL)
  return _internal_tapopl();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_tapopl(
    ::commonmodule::PhaseSPC* tapopl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tapopl_);
  }
  _impl_.tapopl_ = tapopl;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.TapOpL)
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::release_tapopl() {
  
  ::commonmodule::PhaseSPC* temp = _impl_.tapopl_;
  _impl_.tapopl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::unsafe_arena_release_tapopl() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.TapOpL)
  
  ::commonmodule::PhaseSPC* temp = _impl_.tapopl_;
  _impl_.tapopl_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::_internal_mutable_tapopl() {
  
  if (_impl_.tapopl_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPC>(GetArenaForAllocation());
    _impl_.tapopl_ = p;
  }
  return _impl_.tapopl_;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::mutable_tapopl() {
  ::commonmodule::PhaseSPC* _msg = _internal_mutable_tapopl();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.TapOpL)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_tapopl(::commonmodule::PhaseSPC* tapopl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tapopl_);
  }
  if (tapopl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tapopl));
    if (message_arena != submessage_arena) {
      tapopl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tapopl, submessage_arena);
    }

  } else {

  }
  _impl_.tapopl_ = tapopl;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.TapOpL)
}

// .commonmodule.PhaseSPC TapOpR = 10;
inline bool RegulatorControlATCC::_internal_has_tapopr() const {
  return this != internal_default_instance() && _impl_.tapopr_ != nullptr;
}
inline bool RegulatorControlATCC::has_tapopr() const {
  return _internal_has_tapopr();
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::_internal_tapopr() const {
  const ::commonmodule::PhaseSPC* p = _impl_.tapopr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPC&>(
      ::commonmodule::_PhaseSPC_default_instance_);
}
inline const ::commonmodule::PhaseSPC& RegulatorControlATCC::tapopr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.TapOpR)
  return _internal_tapopr();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_tapopr(
    ::commonmodule::PhaseSPC* tapopr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tapopr_);
  }
  _impl_.tapopr_ = tapopr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.TapOpR)
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::release_tapopr() {
  
  ::commonmodule::PhaseSPC* temp = _impl_.tapopr_;
  _impl_.tapopr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::unsafe_arena_release_tapopr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.TapOpR)
  
  ::commonmodule::PhaseSPC* temp = _impl_.tapopr_;
  _impl_.tapopr_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::_internal_mutable_tapopr() {
  
  if (_impl_.tapopr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPC>(GetArenaForAllocation());
    _impl_.tapopr_ = p;
  }
  return _impl_.tapopr_;
}
inline ::commonmodule::PhaseSPC* RegulatorControlATCC::mutable_tapopr() {
  ::commonmodule::PhaseSPC* _msg = _internal_mutable_tapopr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.TapOpR)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_tapopr(::commonmodule::PhaseSPC* tapopr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tapopr_);
  }
  if (tapopr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tapopr));
    if (message_arena != submessage_arena) {
      tapopr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tapopr, submessage_arena);
    }

  } else {

  }
  _impl_.tapopr_ = tapopr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.TapOpR)
}

// .commonmodule.PhaseAPC VolLmtHi = 11;
inline bool RegulatorControlATCC::_internal_has_vollmthi() const {
  return this != internal_default_instance() && _impl_.vollmthi_ != nullptr;
}
inline bool RegulatorControlATCC::has_vollmthi() const {
  return _internal_has_vollmthi();
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::_internal_vollmthi() const {
  const ::commonmodule::PhaseAPC* p = _impl_.vollmthi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::vollmthi() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.VolLmtHi)
  return _internal_vollmthi();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_vollmthi(
    ::commonmodule::PhaseAPC* vollmthi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmthi_);
  }
  _impl_.vollmthi_ = vollmthi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtHi)
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::release_vollmthi() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::unsafe_arena_release_vollmthi() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.VolLmtHi)
  
  ::commonmodule::PhaseAPC* temp = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::_internal_mutable_vollmthi() {
  
  if (_impl_.vollmthi_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.vollmthi_ = p;
  }
  return _impl_.vollmthi_;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::mutable_vollmthi() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_vollmthi();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.VolLmtHi)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_vollmthi(::commonmodule::PhaseAPC* vollmthi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmthi_);
  }
  if (vollmthi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vollmthi));
    if (message_arena != submessage_arena) {
      vollmthi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vollmthi, submessage_arena);
    }

  } else {

  }
  _impl_.vollmthi_ = vollmthi;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtHi)
}

// .commonmodule.PhaseAPC VolLmtLo = 12;
inline bool RegulatorControlATCC::_internal_has_vollmtlo() const {
  return this != internal_default_instance() && _impl_.vollmtlo_ != nullptr;
}
inline bool RegulatorControlATCC::has_vollmtlo() const {
  return _internal_has_vollmtlo();
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::_internal_vollmtlo() const {
  const ::commonmodule::PhaseAPC* p = _impl_.vollmtlo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorControlATCC::vollmtlo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.VolLmtLo)
  return _internal_vollmtlo();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_vollmtlo(
    ::commonmodule::PhaseAPC* vollmtlo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmtlo_);
  }
  _impl_.vollmtlo_ = vollmtlo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtLo)
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::release_vollmtlo() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::unsafe_arena_release_vollmtlo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.VolLmtLo)
  
  ::commonmodule::PhaseAPC* temp = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::_internal_mutable_vollmtlo() {
  
  if (_impl_.vollmtlo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.vollmtlo_ = p;
  }
  return _impl_.vollmtlo_;
}
inline ::commonmodule::PhaseAPC* RegulatorControlATCC::mutable_vollmtlo() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_vollmtlo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.VolLmtLo)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_vollmtlo(::commonmodule::PhaseAPC* vollmtlo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmtlo_);
  }
  if (vollmtlo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vollmtlo));
    if (message_arena != submessage_arena) {
      vollmtlo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vollmtlo, submessage_arena);
    }

  } else {

  }
  _impl_.vollmtlo_ = vollmtlo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtLo)
}

// .commonmodule.Optional_VoltLimitModeKind VolLmtMode = 13;
inline bool RegulatorControlATCC::_internal_has_vollmtmode() const {
  return this != internal_default_instance() && _impl_.vollmtmode_ != nullptr;
}
inline bool RegulatorControlATCC::has_vollmtmode() const {
  return _internal_has_vollmtmode();
}
inline const ::commonmodule::Optional_VoltLimitModeKind& RegulatorControlATCC::_internal_vollmtmode() const {
  const ::commonmodule::Optional_VoltLimitModeKind* p = _impl_.vollmtmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_VoltLimitModeKind&>(
      ::commonmodule::_Optional_VoltLimitModeKind_default_instance_);
}
inline const ::commonmodule::Optional_VoltLimitModeKind& RegulatorControlATCC::vollmtmode() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlATCC.VolLmtMode)
  return _internal_vollmtmode();
}
inline void RegulatorControlATCC::unsafe_arena_set_allocated_vollmtmode(
    ::commonmodule::Optional_VoltLimitModeKind* vollmtmode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmtmode_);
  }
  _impl_.vollmtmode_ = vollmtmode;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtMode)
}
inline ::commonmodule::Optional_VoltLimitModeKind* RegulatorControlATCC::release_vollmtmode() {
  
  ::commonmodule::Optional_VoltLimitModeKind* temp = _impl_.vollmtmode_;
  _impl_.vollmtmode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_VoltLimitModeKind* RegulatorControlATCC::unsafe_arena_release_vollmtmode() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlATCC.VolLmtMode)
  
  ::commonmodule::Optional_VoltLimitModeKind* temp = _impl_.vollmtmode_;
  _impl_.vollmtmode_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_VoltLimitModeKind* RegulatorControlATCC::_internal_mutable_vollmtmode() {
  
  if (_impl_.vollmtmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_VoltLimitModeKind>(GetArenaForAllocation());
    _impl_.vollmtmode_ = p;
  }
  return _impl_.vollmtmode_;
}
inline ::commonmodule::Optional_VoltLimitModeKind* RegulatorControlATCC::mutable_vollmtmode() {
  ::commonmodule::Optional_VoltLimitModeKind* _msg = _internal_mutable_vollmtmode();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlATCC.VolLmtMode)
  return _msg;
}
inline void RegulatorControlATCC::set_allocated_vollmtmode(::commonmodule::Optional_VoltLimitModeKind* vollmtmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmtmode_);
  }
  if (vollmtmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vollmtmode));
    if (message_arena != submessage_arena) {
      vollmtmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vollmtmode, submessage_arena);
    }

  } else {

  }
  _impl_.vollmtmode_ = vollmtmode;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlATCC.VolLmtMode)
}

// -------------------------------------------------------------------

// RegulatorPoint

// .regulatormodule.RegulatorControlATCC control = 1;
inline bool RegulatorPoint::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool RegulatorPoint::has_control() const {
  return _internal_has_control();
}
inline void RegulatorPoint::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorPoint::_internal_control() const {
  const ::regulatormodule::RegulatorControlATCC* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlATCC&>(
      ::regulatormodule::_RegulatorControlATCC_default_instance_);
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorPoint::control() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.control)
  return _internal_control();
}
inline void RegulatorPoint::unsafe_arena_set_allocated_control(
    ::regulatormodule::RegulatorControlATCC* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorPoint.control)
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorPoint::release_control() {
  
  ::regulatormodule::RegulatorControlATCC* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorPoint::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.control)
  
  ::regulatormodule::RegulatorControlATCC* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorPoint::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControlATCC>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorPoint::mutable_control() {
  ::regulatormodule::RegulatorControlATCC* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.control)
  return _msg;
}
inline void RegulatorPoint::set_allocated_control(::regulatormodule::RegulatorControlATCC* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }

  } else {

  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.control)
}

// .commonmodule.Timestamp startTime = 8 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorPoint::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool RegulatorPoint::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::commonmodule::Timestamp& RegulatorPoint::_internal_starttime() const {
  const ::commonmodule::Timestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Timestamp&>(
      ::commonmodule::_Timestamp_default_instance_);
}
inline const ::commonmodule::Timestamp& RegulatorPoint::starttime() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorPoint.startTime)
  return _internal_starttime();
}
inline void RegulatorPoint::unsafe_arena_set_allocated_starttime(
    ::commonmodule::Timestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorPoint.startTime)
}
inline ::commonmodule::Timestamp* RegulatorPoint::release_starttime() {
  
  ::commonmodule::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Timestamp* RegulatorPoint::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorPoint.startTime)
  
  ::commonmodule::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::commonmodule::Timestamp* RegulatorPoint::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Timestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::commonmodule::Timestamp* RegulatorPoint::mutable_starttime() {
  ::commonmodule::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorPoint.startTime)
  return _msg;
}
inline void RegulatorPoint::set_allocated_starttime(::commonmodule::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }

  } else {

  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorPoint.startTime)
}

// -------------------------------------------------------------------

// RegulatorCSG

// repeated .regulatormodule.RegulatorPoint crvPts = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline int RegulatorCSG::_internal_crvpts_size() const {
  return _impl_.crvpts_.size();
}
inline int RegulatorCSG::crvpts_size() const {
  return _internal_crvpts_size();
}
inline void RegulatorCSG::clear_crvpts() {
  _impl_.crvpts_.Clear();
}
inline ::regulatormodule::RegulatorPoint* RegulatorCSG::mutable_crvpts(int index) {
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorCSG.crvPts)
  return _impl_.crvpts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorPoint >*
RegulatorCSG::mutable_crvpts() {
  // @@protoc_insertion_point(field_mutable_list:regulatormodule.RegulatorCSG.crvPts)
  return &_impl_.crvpts_;
}
inline const ::regulatormodule::RegulatorPoint& RegulatorCSG::_internal_crvpts(int index) const {
  return _impl_.crvpts_.Get(index);
}
inline const ::regulatormodule::RegulatorPoint& RegulatorCSG::crvpts(int index) const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorCSG.crvPts)
  return _internal_crvpts(index);
}
inline ::regulatormodule::RegulatorPoint* RegulatorCSG::_internal_add_crvpts() {
  return _impl_.crvpts_.Add();
}
inline ::regulatormodule::RegulatorPoint* RegulatorCSG::add_crvpts() {
  ::regulatormodule::RegulatorPoint* _add = _internal_add_crvpts();
  // @@protoc_insertion_point(field_add:regulatormodule.RegulatorCSG.crvPts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorPoint >&
RegulatorCSG::crvpts() const {
  // @@protoc_insertion_point(field_list:regulatormodule.RegulatorCSG.crvPts)
  return _impl_.crvpts_;
}

// -------------------------------------------------------------------

// RegulatorControlScheduleFSCH

// .regulatormodule.RegulatorCSG ValDCSG = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlScheduleFSCH::_internal_has_valdcsg() const {
  return this != internal_default_instance() && _impl_.valdcsg_ != nullptr;
}
inline bool RegulatorControlScheduleFSCH::has_valdcsg() const {
  return _internal_has_valdcsg();
}
inline void RegulatorControlScheduleFSCH::clear_valdcsg() {
  if (GetArenaForAllocation() == nullptr && _impl_.valdcsg_ != nullptr) {
    delete _impl_.valdcsg_;
  }
  _impl_.valdcsg_ = nullptr;
}
inline const ::regulatormodule::RegulatorCSG& RegulatorControlScheduleFSCH::_internal_valdcsg() const {
  const ::regulatormodule::RegulatorCSG* p = _impl_.valdcsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorCSG&>(
      ::regulatormodule::_RegulatorCSG_default_instance_);
}
inline const ::regulatormodule::RegulatorCSG& RegulatorControlScheduleFSCH::valdcsg() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  return _internal_valdcsg();
}
inline void RegulatorControlScheduleFSCH::unsafe_arena_set_allocated_valdcsg(
    ::regulatormodule::RegulatorCSG* valdcsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valdcsg_);
  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
}
inline ::regulatormodule::RegulatorCSG* RegulatorControlScheduleFSCH::release_valdcsg() {
  
  ::regulatormodule::RegulatorCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorCSG* RegulatorControlScheduleFSCH::unsafe_arena_release_valdcsg() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  
  ::regulatormodule::RegulatorCSG* temp = _impl_.valdcsg_;
  _impl_.valdcsg_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorCSG* RegulatorControlScheduleFSCH::_internal_mutable_valdcsg() {
  
  if (_impl_.valdcsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorCSG>(GetArenaForAllocation());
    _impl_.valdcsg_ = p;
  }
  return _impl_.valdcsg_;
}
inline ::regulatormodule::RegulatorCSG* RegulatorControlScheduleFSCH::mutable_valdcsg() {
  ::regulatormodule::RegulatorCSG* _msg = _internal_mutable_valdcsg();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
  return _msg;
}
inline void RegulatorControlScheduleFSCH::set_allocated_valdcsg(::regulatormodule::RegulatorCSG* valdcsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.valdcsg_;
  }
  if (valdcsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(valdcsg);
    if (message_arena != submessage_arena) {
      valdcsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valdcsg, submessage_arena);
    }

  } else {

  }
  _impl_.valdcsg_ = valdcsg;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlScheduleFSCH.ValDCSG)
}

// -------------------------------------------------------------------

// RegulatorControlFSCC

// .commonmodule.ControlFSCC controlFSCC = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlFSCC::_internal_has_controlfscc() const {
  return this != internal_default_instance() && _impl_.controlfscc_ != nullptr;
}
inline bool RegulatorControlFSCC::has_controlfscc() const {
  return _internal_has_controlfscc();
}
inline const ::commonmodule::ControlFSCC& RegulatorControlFSCC::_internal_controlfscc() const {
  const ::commonmodule::ControlFSCC* p = _impl_.controlfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlFSCC&>(
      ::commonmodule::_ControlFSCC_default_instance_);
}
inline const ::commonmodule::ControlFSCC& RegulatorControlFSCC::controlfscc() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlFSCC.controlFSCC)
  return _internal_controlfscc();
}
inline void RegulatorControlFSCC::unsafe_arena_set_allocated_controlfscc(
    ::commonmodule::ControlFSCC* controlfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlFSCC.controlFSCC)
}
inline ::commonmodule::ControlFSCC* RegulatorControlFSCC::release_controlfscc() {
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlFSCC* RegulatorControlFSCC::unsafe_arena_release_controlfscc() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlFSCC.controlFSCC)
  
  ::commonmodule::ControlFSCC* temp = _impl_.controlfscc_;
  _impl_.controlfscc_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlFSCC* RegulatorControlFSCC::_internal_mutable_controlfscc() {
  
  if (_impl_.controlfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlFSCC>(GetArenaForAllocation());
    _impl_.controlfscc_ = p;
  }
  return _impl_.controlfscc_;
}
inline ::commonmodule::ControlFSCC* RegulatorControlFSCC::mutable_controlfscc() {
  ::commonmodule::ControlFSCC* _msg = _internal_mutable_controlfscc();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlFSCC.controlFSCC)
  return _msg;
}
inline void RegulatorControlFSCC::set_allocated_controlfscc(::commonmodule::ControlFSCC* controlfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlfscc_);
  }
  if (controlfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlfscc));
    if (message_arena != submessage_arena) {
      controlfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlfscc, submessage_arena);
    }

  } else {

  }
  _impl_.controlfscc_ = controlfscc;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlFSCC.controlFSCC)
}

// .regulatormodule.RegulatorControlScheduleFSCH regulatorControlScheduleFSCH = 2;
inline bool RegulatorControlFSCC::_internal_has_regulatorcontrolschedulefsch() const {
  return this != internal_default_instance() && _impl_.regulatorcontrolschedulefsch_ != nullptr;
}
inline bool RegulatorControlFSCC::has_regulatorcontrolschedulefsch() const {
  return _internal_has_regulatorcontrolschedulefsch();
}
inline void RegulatorControlFSCC::clear_regulatorcontrolschedulefsch() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorcontrolschedulefsch_ != nullptr) {
    delete _impl_.regulatorcontrolschedulefsch_;
  }
  _impl_.regulatorcontrolschedulefsch_ = nullptr;
}
inline const ::regulatormodule::RegulatorControlScheduleFSCH& RegulatorControlFSCC::_internal_regulatorcontrolschedulefsch() const {
  const ::regulatormodule::RegulatorControlScheduleFSCH* p = _impl_.regulatorcontrolschedulefsch_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlScheduleFSCH&>(
      ::regulatormodule::_RegulatorControlScheduleFSCH_default_instance_);
}
inline const ::regulatormodule::RegulatorControlScheduleFSCH& RegulatorControlFSCC::regulatorcontrolschedulefsch() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  return _internal_regulatorcontrolschedulefsch();
}
inline void RegulatorControlFSCC::unsafe_arena_set_allocated_regulatorcontrolschedulefsch(
    ::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorcontrolschedulefsch_);
  }
  _impl_.regulatorcontrolschedulefsch_ = regulatorcontrolschedulefsch;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* RegulatorControlFSCC::release_regulatorcontrolschedulefsch() {
  
  ::regulatormodule::RegulatorControlScheduleFSCH* temp = _impl_.regulatorcontrolschedulefsch_;
  _impl_.regulatorcontrolschedulefsch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* RegulatorControlFSCC::unsafe_arena_release_regulatorcontrolschedulefsch() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  
  ::regulatormodule::RegulatorControlScheduleFSCH* temp = _impl_.regulatorcontrolschedulefsch_;
  _impl_.regulatorcontrolschedulefsch_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* RegulatorControlFSCC::_internal_mutable_regulatorcontrolschedulefsch() {
  
  if (_impl_.regulatorcontrolschedulefsch_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControlScheduleFSCH>(GetArenaForAllocation());
    _impl_.regulatorcontrolschedulefsch_ = p;
  }
  return _impl_.regulatorcontrolschedulefsch_;
}
inline ::regulatormodule::RegulatorControlScheduleFSCH* RegulatorControlFSCC::mutable_regulatorcontrolschedulefsch() {
  ::regulatormodule::RegulatorControlScheduleFSCH* _msg = _internal_mutable_regulatorcontrolschedulefsch();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
  return _msg;
}
inline void RegulatorControlFSCC::set_allocated_regulatorcontrolschedulefsch(::regulatormodule::RegulatorControlScheduleFSCH* regulatorcontrolschedulefsch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorcontrolschedulefsch_;
  }
  if (regulatorcontrolschedulefsch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorcontrolschedulefsch);
    if (message_arena != submessage_arena) {
      regulatorcontrolschedulefsch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorcontrolschedulefsch, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorcontrolschedulefsch_ = regulatorcontrolschedulefsch;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlFSCC.regulatorControlScheduleFSCH)
}

// -------------------------------------------------------------------

// RegulatorControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool RegulatorControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& RegulatorControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& RegulatorControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.controlValue)
  return _internal_controlvalue();
}
inline void RegulatorControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControl.controlValue)
}
inline ::commonmodule::ControlValue* RegulatorControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* RegulatorControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* RegulatorControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* RegulatorControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.controlValue)
  return _msg;
}
inline void RegulatorControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool RegulatorControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool RegulatorControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& RegulatorControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& RegulatorControl::check() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.check)
  return _internal_check();
}
inline void RegulatorControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControl.check)
}
inline ::commonmodule::CheckConditions* RegulatorControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* RegulatorControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* RegulatorControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* RegulatorControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.check)
  return _msg;
}
inline void RegulatorControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.check)
}

// .regulatormodule.RegulatorControlFSCC regulatorControlFSCC = 3;
inline bool RegulatorControl::_internal_has_regulatorcontrolfscc() const {
  return this != internal_default_instance() && _impl_.regulatorcontrolfscc_ != nullptr;
}
inline bool RegulatorControl::has_regulatorcontrolfscc() const {
  return _internal_has_regulatorcontrolfscc();
}
inline void RegulatorControl::clear_regulatorcontrolfscc() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorcontrolfscc_ != nullptr) {
    delete _impl_.regulatorcontrolfscc_;
  }
  _impl_.regulatorcontrolfscc_ = nullptr;
}
inline const ::regulatormodule::RegulatorControlFSCC& RegulatorControl::_internal_regulatorcontrolfscc() const {
  const ::regulatormodule::RegulatorControlFSCC* p = _impl_.regulatorcontrolfscc_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlFSCC&>(
      ::regulatormodule::_RegulatorControlFSCC_default_instance_);
}
inline const ::regulatormodule::RegulatorControlFSCC& RegulatorControl::regulatorcontrolfscc() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControl.regulatorControlFSCC)
  return _internal_regulatorcontrolfscc();
}
inline void RegulatorControl::unsafe_arena_set_allocated_regulatorcontrolfscc(
    ::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorcontrolfscc_);
  }
  _impl_.regulatorcontrolfscc_ = regulatorcontrolfscc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControl.regulatorControlFSCC)
}
inline ::regulatormodule::RegulatorControlFSCC* RegulatorControl::release_regulatorcontrolfscc() {
  
  ::regulatormodule::RegulatorControlFSCC* temp = _impl_.regulatorcontrolfscc_;
  _impl_.regulatorcontrolfscc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorControlFSCC* RegulatorControl::unsafe_arena_release_regulatorcontrolfscc() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControl.regulatorControlFSCC)
  
  ::regulatormodule::RegulatorControlFSCC* temp = _impl_.regulatorcontrolfscc_;
  _impl_.regulatorcontrolfscc_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlFSCC* RegulatorControl::_internal_mutable_regulatorcontrolfscc() {
  
  if (_impl_.regulatorcontrolfscc_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControlFSCC>(GetArenaForAllocation());
    _impl_.regulatorcontrolfscc_ = p;
  }
  return _impl_.regulatorcontrolfscc_;
}
inline ::regulatormodule::RegulatorControlFSCC* RegulatorControl::mutable_regulatorcontrolfscc() {
  ::regulatormodule::RegulatorControlFSCC* _msg = _internal_mutable_regulatorcontrolfscc();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControl.regulatorControlFSCC)
  return _msg;
}
inline void RegulatorControl::set_allocated_regulatorcontrolfscc(::regulatormodule::RegulatorControlFSCC* regulatorcontrolfscc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorcontrolfscc_;
  }
  if (regulatorcontrolfscc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorcontrolfscc);
    if (message_arena != submessage_arena) {
      regulatorcontrolfscc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorcontrolfscc, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorcontrolfscc_ = regulatorcontrolfscc;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControl.regulatorControlFSCC)
}

// -------------------------------------------------------------------

// RegulatorSystem

// .commonmodule.ConductingEquipment conductingEquipment = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorSystem::_internal_has_conductingequipment() const {
  return this != internal_default_instance() && _impl_.conductingequipment_ != nullptr;
}
inline bool RegulatorSystem::has_conductingequipment() const {
  return _internal_has_conductingequipment();
}
inline const ::commonmodule::ConductingEquipment& RegulatorSystem::_internal_conductingequipment() const {
  const ::commonmodule::ConductingEquipment* p = _impl_.conductingequipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipment&>(
      ::commonmodule::_ConductingEquipment_default_instance_);
}
inline const ::commonmodule::ConductingEquipment& RegulatorSystem::conductingequipment() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorSystem.conductingEquipment)
  return _internal_conductingequipment();
}
inline void RegulatorSystem::unsafe_arena_set_allocated_conductingequipment(
    ::commonmodule::ConductingEquipment* conductingequipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorSystem.conductingEquipment)
}
inline ::commonmodule::ConductingEquipment* RegulatorSystem::release_conductingequipment() {
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipment* RegulatorSystem::unsafe_arena_release_conductingequipment() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorSystem.conductingEquipment)
  
  ::commonmodule::ConductingEquipment* temp = _impl_.conductingequipment_;
  _impl_.conductingequipment_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipment* RegulatorSystem::_internal_mutable_conductingequipment() {
  
  if (_impl_.conductingequipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipment>(GetArenaForAllocation());
    _impl_.conductingequipment_ = p;
  }
  return _impl_.conductingequipment_;
}
inline ::commonmodule::ConductingEquipment* RegulatorSystem::mutable_conductingequipment() {
  ::commonmodule::ConductingEquipment* _msg = _internal_mutable_conductingequipment();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorSystem.conductingEquipment)
  return _msg;
}
inline void RegulatorSystem::set_allocated_conductingequipment(::commonmodule::ConductingEquipment* conductingequipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipment_);
  }
  if (conductingequipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipment));
    if (message_arena != submessage_arena) {
      conductingequipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipment, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipment_ = conductingequipment;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorSystem.conductingEquipment)
}

// -------------------------------------------------------------------

// RegulatorControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool RegulatorControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& RegulatorControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& RegulatorControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void RegulatorControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* RegulatorControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* RegulatorControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* RegulatorControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* RegulatorControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.controlMessageInfo)
  return _msg;
}
inline void RegulatorControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.controlMessageInfo)
}

// .regulatormodule.RegulatorControl regulatorControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlProfile::_internal_has_regulatorcontrol() const {
  return this != internal_default_instance() && _impl_.regulatorcontrol_ != nullptr;
}
inline bool RegulatorControlProfile::has_regulatorcontrol() const {
  return _internal_has_regulatorcontrol();
}
inline void RegulatorControlProfile::clear_regulatorcontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorcontrol_ != nullptr) {
    delete _impl_.regulatorcontrol_;
  }
  _impl_.regulatorcontrol_ = nullptr;
}
inline const ::regulatormodule::RegulatorControl& RegulatorControlProfile::_internal_regulatorcontrol() const {
  const ::regulatormodule::RegulatorControl* p = _impl_.regulatorcontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControl&>(
      ::regulatormodule::_RegulatorControl_default_instance_);
}
inline const ::regulatormodule::RegulatorControl& RegulatorControlProfile::regulatorcontrol() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.regulatorControl)
  return _internal_regulatorcontrol();
}
inline void RegulatorControlProfile::unsafe_arena_set_allocated_regulatorcontrol(
    ::regulatormodule::RegulatorControl* regulatorcontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorcontrol_);
  }
  _impl_.regulatorcontrol_ = regulatorcontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlProfile.regulatorControl)
}
inline ::regulatormodule::RegulatorControl* RegulatorControlProfile::release_regulatorcontrol() {
  
  ::regulatormodule::RegulatorControl* temp = _impl_.regulatorcontrol_;
  _impl_.regulatorcontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorControl* RegulatorControlProfile::unsafe_arena_release_regulatorcontrol() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.regulatorControl)
  
  ::regulatormodule::RegulatorControl* temp = _impl_.regulatorcontrol_;
  _impl_.regulatorcontrol_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControl* RegulatorControlProfile::_internal_mutable_regulatorcontrol() {
  
  if (_impl_.regulatorcontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControl>(GetArenaForAllocation());
    _impl_.regulatorcontrol_ = p;
  }
  return _impl_.regulatorcontrol_;
}
inline ::regulatormodule::RegulatorControl* RegulatorControlProfile::mutable_regulatorcontrol() {
  ::regulatormodule::RegulatorControl* _msg = _internal_mutable_regulatorcontrol();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.regulatorControl)
  return _msg;
}
inline void RegulatorControlProfile::set_allocated_regulatorcontrol(::regulatormodule::RegulatorControl* regulatorcontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorcontrol_;
  }
  if (regulatorcontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorcontrol);
    if (message_arena != submessage_arena) {
      regulatorcontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorcontrol, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorcontrol_ = regulatorcontrol;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.regulatorControl)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorControlProfile::_internal_has_regulatorsystem() const {
  return this != internal_default_instance() && _impl_.regulatorsystem_ != nullptr;
}
inline bool RegulatorControlProfile::has_regulatorsystem() const {
  return _internal_has_regulatorsystem();
}
inline void RegulatorControlProfile::clear_regulatorsystem() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorsystem_ != nullptr) {
    delete _impl_.regulatorsystem_;
  }
  _impl_.regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorControlProfile::_internal_regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(
      ::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorControlProfile::regulatorsystem() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorControlProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorControlProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* regulatorsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorControlProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* RegulatorControlProfile::release_regulatorsystem() {
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorControlProfile::unsafe_arena_release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorControlProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorControlProfile::_internal_mutable_regulatorsystem() {
  
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaForAllocation());
    _impl_.regulatorsystem_ = p;
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* RegulatorControlProfile::mutable_regulatorsystem() {
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorControlProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorControlProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorsystem_;
  }
  if (regulatorsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorsystem);
    if (message_arena != submessage_arena) {
      regulatorsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorControlProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorDiscreteControl

// .commonmodule.ControlValue controlValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorDiscreteControl::_internal_has_controlvalue() const {
  return this != internal_default_instance() && _impl_.controlvalue_ != nullptr;
}
inline bool RegulatorDiscreteControl::has_controlvalue() const {
  return _internal_has_controlvalue();
}
inline const ::commonmodule::ControlValue& RegulatorDiscreteControl::_internal_controlvalue() const {
  const ::commonmodule::ControlValue* p = _impl_.controlvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlValue&>(
      ::commonmodule::_ControlValue_default_instance_);
}
inline const ::commonmodule::ControlValue& RegulatorDiscreteControl::controlvalue() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControl.controlValue)
  return _internal_controlvalue();
}
inline void RegulatorDiscreteControl::unsafe_arena_set_allocated_controlvalue(
    ::commonmodule::ControlValue* controlvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControl.controlValue)
}
inline ::commonmodule::ControlValue* RegulatorDiscreteControl::release_controlvalue() {
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlValue* RegulatorDiscreteControl::unsafe_arena_release_controlvalue() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControl.controlValue)
  
  ::commonmodule::ControlValue* temp = _impl_.controlvalue_;
  _impl_.controlvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlValue* RegulatorDiscreteControl::_internal_mutable_controlvalue() {
  
  if (_impl_.controlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlValue>(GetArenaForAllocation());
    _impl_.controlvalue_ = p;
  }
  return _impl_.controlvalue_;
}
inline ::commonmodule::ControlValue* RegulatorDiscreteControl::mutable_controlvalue() {
  ::commonmodule::ControlValue* _msg = _internal_mutable_controlvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControl.controlValue)
  return _msg;
}
inline void RegulatorDiscreteControl::set_allocated_controlvalue(::commonmodule::ControlValue* controlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlvalue_);
  }
  if (controlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlvalue));
    if (message_arena != submessage_arena) {
      controlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlvalue, submessage_arena);
    }

  } else {

  }
  _impl_.controlvalue_ = controlvalue;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControl.controlValue)
}

// .commonmodule.CheckConditions check = 2;
inline bool RegulatorDiscreteControl::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool RegulatorDiscreteControl::has_check() const {
  return _internal_has_check();
}
inline const ::commonmodule::CheckConditions& RegulatorDiscreteControl::_internal_check() const {
  const ::commonmodule::CheckConditions* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::CheckConditions&>(
      ::commonmodule::_CheckConditions_default_instance_);
}
inline const ::commonmodule::CheckConditions& RegulatorDiscreteControl::check() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControl.check)
  return _internal_check();
}
inline void RegulatorDiscreteControl::unsafe_arena_set_allocated_check(
    ::commonmodule::CheckConditions* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControl.check)
}
inline ::commonmodule::CheckConditions* RegulatorDiscreteControl::release_check() {
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::CheckConditions* RegulatorDiscreteControl::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControl.check)
  
  ::commonmodule::CheckConditions* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::commonmodule::CheckConditions* RegulatorDiscreteControl::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::CheckConditions>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::commonmodule::CheckConditions* RegulatorDiscreteControl::mutable_check() {
  ::commonmodule::CheckConditions* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControl.check)
  return _msg;
}
inline void RegulatorDiscreteControl::set_allocated_check(::commonmodule::CheckConditions* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check));
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }

  } else {

  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControl.check)
}

// .regulatormodule.RegulatorControlATCC regulatorControlATCC = 3;
inline bool RegulatorDiscreteControl::_internal_has_regulatorcontrolatcc() const {
  return this != internal_default_instance() && _impl_.regulatorcontrolatcc_ != nullptr;
}
inline bool RegulatorDiscreteControl::has_regulatorcontrolatcc() const {
  return _internal_has_regulatorcontrolatcc();
}
inline void RegulatorDiscreteControl::clear_regulatorcontrolatcc() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorcontrolatcc_ != nullptr) {
    delete _impl_.regulatorcontrolatcc_;
  }
  _impl_.regulatorcontrolatcc_ = nullptr;
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorDiscreteControl::_internal_regulatorcontrolatcc() const {
  const ::regulatormodule::RegulatorControlATCC* p = _impl_.regulatorcontrolatcc_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorControlATCC&>(
      ::regulatormodule::_RegulatorControlATCC_default_instance_);
}
inline const ::regulatormodule::RegulatorControlATCC& RegulatorDiscreteControl::regulatorcontrolatcc() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
  return _internal_regulatorcontrolatcc();
}
inline void RegulatorDiscreteControl::unsafe_arena_set_allocated_regulatorcontrolatcc(
    ::regulatormodule::RegulatorControlATCC* regulatorcontrolatcc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorcontrolatcc_);
  }
  _impl_.regulatorcontrolatcc_ = regulatorcontrolatcc;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorDiscreteControl::release_regulatorcontrolatcc() {
  
  ::regulatormodule::RegulatorControlATCC* temp = _impl_.regulatorcontrolatcc_;
  _impl_.regulatorcontrolatcc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorDiscreteControl::unsafe_arena_release_regulatorcontrolatcc() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
  
  ::regulatormodule::RegulatorControlATCC* temp = _impl_.regulatorcontrolatcc_;
  _impl_.regulatorcontrolatcc_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorDiscreteControl::_internal_mutable_regulatorcontrolatcc() {
  
  if (_impl_.regulatorcontrolatcc_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorControlATCC>(GetArenaForAllocation());
    _impl_.regulatorcontrolatcc_ = p;
  }
  return _impl_.regulatorcontrolatcc_;
}
inline ::regulatormodule::RegulatorControlATCC* RegulatorDiscreteControl::mutable_regulatorcontrolatcc() {
  ::regulatormodule::RegulatorControlATCC* _msg = _internal_mutable_regulatorcontrolatcc();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
  return _msg;
}
inline void RegulatorDiscreteControl::set_allocated_regulatorcontrolatcc(::regulatormodule::RegulatorControlATCC* regulatorcontrolatcc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorcontrolatcc_;
  }
  if (regulatorcontrolatcc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorcontrolatcc);
    if (message_arena != submessage_arena) {
      regulatorcontrolatcc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorcontrolatcc, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorcontrolatcc_ = regulatorcontrolatcc;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControl.regulatorControlATCC)
}

// -------------------------------------------------------------------

// RegulatorDiscreteControlProfile

// .commonmodule.ControlMessageInfo controlMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorDiscreteControlProfile::_internal_has_controlmessageinfo() const {
  return this != internal_default_instance() && _impl_.controlmessageinfo_ != nullptr;
}
inline bool RegulatorDiscreteControlProfile::has_controlmessageinfo() const {
  return _internal_has_controlmessageinfo();
}
inline const ::commonmodule::ControlMessageInfo& RegulatorDiscreteControlProfile::_internal_controlmessageinfo() const {
  const ::commonmodule::ControlMessageInfo* p = _impl_.controlmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ControlMessageInfo&>(
      ::commonmodule::_ControlMessageInfo_default_instance_);
}
inline const ::commonmodule::ControlMessageInfo& RegulatorDiscreteControlProfile::controlmessageinfo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
  return _internal_controlmessageinfo();
}
inline void RegulatorDiscreteControlProfile::unsafe_arena_set_allocated_controlmessageinfo(
    ::commonmodule::ControlMessageInfo* controlmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
}
inline ::commonmodule::ControlMessageInfo* RegulatorDiscreteControlProfile::release_controlmessageinfo() {
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ControlMessageInfo* RegulatorDiscreteControlProfile::unsafe_arena_release_controlmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
  
  ::commonmodule::ControlMessageInfo* temp = _impl_.controlmessageinfo_;
  _impl_.controlmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ControlMessageInfo* RegulatorDiscreteControlProfile::_internal_mutable_controlmessageinfo() {
  
  if (_impl_.controlmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ControlMessageInfo>(GetArenaForAllocation());
    _impl_.controlmessageinfo_ = p;
  }
  return _impl_.controlmessageinfo_;
}
inline ::commonmodule::ControlMessageInfo* RegulatorDiscreteControlProfile::mutable_controlmessageinfo() {
  ::commonmodule::ControlMessageInfo* _msg = _internal_mutable_controlmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
  return _msg;
}
inline void RegulatorDiscreteControlProfile::set_allocated_controlmessageinfo(::commonmodule::ControlMessageInfo* controlmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.controlmessageinfo_);
  }
  if (controlmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controlmessageinfo));
    if (message_arena != submessage_arena) {
      controlmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.controlmessageinfo_ = controlmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.controlMessageInfo)
}

// .regulatormodule.RegulatorDiscreteControl regulatorDiscreteControl = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorDiscreteControlProfile::_internal_has_regulatordiscretecontrol() const {
  return this != internal_default_instance() && _impl_.regulatordiscretecontrol_ != nullptr;
}
inline bool RegulatorDiscreteControlProfile::has_regulatordiscretecontrol() const {
  return _internal_has_regulatordiscretecontrol();
}
inline void RegulatorDiscreteControlProfile::clear_regulatordiscretecontrol() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatordiscretecontrol_ != nullptr) {
    delete _impl_.regulatordiscretecontrol_;
  }
  _impl_.regulatordiscretecontrol_ = nullptr;
}
inline const ::regulatormodule::RegulatorDiscreteControl& RegulatorDiscreteControlProfile::_internal_regulatordiscretecontrol() const {
  const ::regulatormodule::RegulatorDiscreteControl* p = _impl_.regulatordiscretecontrol_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorDiscreteControl&>(
      ::regulatormodule::_RegulatorDiscreteControl_default_instance_);
}
inline const ::regulatormodule::RegulatorDiscreteControl& RegulatorDiscreteControlProfile::regulatordiscretecontrol() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
  return _internal_regulatordiscretecontrol();
}
inline void RegulatorDiscreteControlProfile::unsafe_arena_set_allocated_regulatordiscretecontrol(
    ::regulatormodule::RegulatorDiscreteControl* regulatordiscretecontrol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatordiscretecontrol_);
  }
  _impl_.regulatordiscretecontrol_ = regulatordiscretecontrol;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
}
inline ::regulatormodule::RegulatorDiscreteControl* RegulatorDiscreteControlProfile::release_regulatordiscretecontrol() {
  
  ::regulatormodule::RegulatorDiscreteControl* temp = _impl_.regulatordiscretecontrol_;
  _impl_.regulatordiscretecontrol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorDiscreteControl* RegulatorDiscreteControlProfile::unsafe_arena_release_regulatordiscretecontrol() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
  
  ::regulatormodule::RegulatorDiscreteControl* temp = _impl_.regulatordiscretecontrol_;
  _impl_.regulatordiscretecontrol_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorDiscreteControl* RegulatorDiscreteControlProfile::_internal_mutable_regulatordiscretecontrol() {
  
  if (_impl_.regulatordiscretecontrol_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorDiscreteControl>(GetArenaForAllocation());
    _impl_.regulatordiscretecontrol_ = p;
  }
  return _impl_.regulatordiscretecontrol_;
}
inline ::regulatormodule::RegulatorDiscreteControl* RegulatorDiscreteControlProfile::mutable_regulatordiscretecontrol() {
  ::regulatormodule::RegulatorDiscreteControl* _msg = _internal_mutable_regulatordiscretecontrol();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
  return _msg;
}
inline void RegulatorDiscreteControlProfile::set_allocated_regulatordiscretecontrol(::regulatormodule::RegulatorDiscreteControl* regulatordiscretecontrol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatordiscretecontrol_;
  }
  if (regulatordiscretecontrol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatordiscretecontrol);
    if (message_arena != submessage_arena) {
      regulatordiscretecontrol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatordiscretecontrol, submessage_arena);
    }

  } else {

  }
  _impl_.regulatordiscretecontrol_ = regulatordiscretecontrol;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorDiscreteControl)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorDiscreteControlProfile::_internal_has_regulatorsystem() const {
  return this != internal_default_instance() && _impl_.regulatorsystem_ != nullptr;
}
inline bool RegulatorDiscreteControlProfile::has_regulatorsystem() const {
  return _internal_has_regulatorsystem();
}
inline void RegulatorDiscreteControlProfile::clear_regulatorsystem() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorsystem_ != nullptr) {
    delete _impl_.regulatorsystem_;
  }
  _impl_.regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorDiscreteControlProfile::_internal_regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(
      ::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorDiscreteControlProfile::regulatorsystem() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorDiscreteControlProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* regulatorsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* RegulatorDiscreteControlProfile::release_regulatorsystem() {
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorDiscreteControlProfile::unsafe_arena_release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorDiscreteControlProfile::_internal_mutable_regulatorsystem() {
  
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaForAllocation());
    _impl_.regulatorsystem_ = p;
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* RegulatorDiscreteControlProfile::mutable_regulatorsystem() {
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorDiscreteControlProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorsystem_;
  }
  if (regulatorsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorsystem);
    if (message_arena != submessage_arena) {
      regulatorsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorDiscreteControlProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorEventAndStatusATCC

// .commonmodule.ASG BndCtr = 1;
inline bool RegulatorEventAndStatusATCC::_internal_has_bndctr() const {
  return this != internal_default_instance() && _impl_.bndctr_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_bndctr() const {
  return _internal_has_bndctr();
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_bndctr() const {
  const ::commonmodule::ASG* p = _impl_.bndctr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::bndctr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  return _internal_bndctr();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndctr(
    ::commonmodule::ASG* bndctr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndctr_);
  }
  _impl_.bndctr_ = bndctr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_bndctr() {
  
  ::commonmodule::ASG* temp = _impl_.bndctr_;
  _impl_.bndctr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::unsafe_arena_release_bndctr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  
  ::commonmodule::ASG* temp = _impl_.bndctr_;
  _impl_.bndctr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::_internal_mutable_bndctr() {
  
  if (_impl_.bndctr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.bndctr_ = p;
  }
  return _impl_.bndctr_;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_bndctr() {
  ::commonmodule::ASG* _msg = _internal_mutable_bndctr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndctr(::commonmodule::ASG* bndctr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndctr_);
  }
  if (bndctr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bndctr));
    if (message_arena != submessage_arena) {
      bndctr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bndctr, submessage_arena);
    }

  } else {

  }
  _impl_.bndctr_ = bndctr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndCtr)
}

// .commonmodule.ASG BndWid = 2;
inline bool RegulatorEventAndStatusATCC::_internal_has_bndwid() const {
  return this != internal_default_instance() && _impl_.bndwid_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_bndwid() const {
  return _internal_has_bndwid();
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_bndwid() const {
  const ::commonmodule::ASG* p = _impl_.bndwid_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::bndwid() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  return _internal_bndwid();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndwid(
    ::commonmodule::ASG* bndwid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwid_);
  }
  _impl_.bndwid_ = bndwid;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_bndwid() {
  
  ::commonmodule::ASG* temp = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::unsafe_arena_release_bndwid() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  
  ::commonmodule::ASG* temp = _impl_.bndwid_;
  _impl_.bndwid_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::_internal_mutable_bndwid() {
  
  if (_impl_.bndwid_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.bndwid_ = p;
  }
  return _impl_.bndwid_;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_bndwid() {
  ::commonmodule::ASG* _msg = _internal_mutable_bndwid();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndwid(::commonmodule::ASG* bndwid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwid_);
  }
  if (bndwid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bndwid));
    if (message_arena != submessage_arena) {
      bndwid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bndwid, submessage_arena);
    }

  } else {

  }
  _impl_.bndwid_ = bndwid;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWid)
}

// .commonmodule.PhaseSPS BndWidHi = 3;
inline bool RegulatorEventAndStatusATCC::_internal_has_bndwidhi() const {
  return this != internal_default_instance() && _impl_.bndwidhi_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_bndwidhi() const {
  return _internal_has_bndwidhi();
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_bndwidhi() const {
  const ::commonmodule::PhaseSPS* p = _impl_.bndwidhi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::bndwidhi() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
  return _internal_bndwidhi();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndwidhi(
    ::commonmodule::PhaseSPS* bndwidhi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwidhi_);
  }
  _impl_.bndwidhi_ = bndwidhi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::release_bndwidhi() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.bndwidhi_;
  _impl_.bndwidhi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_bndwidhi() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
  
  ::commonmodule::PhaseSPS* temp = _impl_.bndwidhi_;
  _impl_.bndwidhi_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::_internal_mutable_bndwidhi() {
  
  if (_impl_.bndwidhi_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.bndwidhi_ = p;
  }
  return _impl_.bndwidhi_;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::mutable_bndwidhi() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_bndwidhi();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndwidhi(::commonmodule::PhaseSPS* bndwidhi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwidhi_);
  }
  if (bndwidhi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bndwidhi));
    if (message_arena != submessage_arena) {
      bndwidhi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bndwidhi, submessage_arena);
    }

  } else {

  }
  _impl_.bndwidhi_ = bndwidhi;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidHi)
}

// .commonmodule.PhaseSPS BndWidLo = 4;
inline bool RegulatorEventAndStatusATCC::_internal_has_bndwidlo() const {
  return this != internal_default_instance() && _impl_.bndwidlo_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_bndwidlo() const {
  return _internal_has_bndwidlo();
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_bndwidlo() const {
  const ::commonmodule::PhaseSPS* p = _impl_.bndwidlo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::bndwidlo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
  return _internal_bndwidlo();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_bndwidlo(
    ::commonmodule::PhaseSPS* bndwidlo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwidlo_);
  }
  _impl_.bndwidlo_ = bndwidlo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::release_bndwidlo() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.bndwidlo_;
  _impl_.bndwidlo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_bndwidlo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
  
  ::commonmodule::PhaseSPS* temp = _impl_.bndwidlo_;
  _impl_.bndwidlo_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::_internal_mutable_bndwidlo() {
  
  if (_impl_.bndwidlo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.bndwidlo_ = p;
  }
  return _impl_.bndwidlo_;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::mutable_bndwidlo() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_bndwidlo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_bndwidlo(::commonmodule::PhaseSPS* bndwidlo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bndwidlo_);
  }
  if (bndwidlo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bndwidlo));
    if (message_arena != submessage_arena) {
      bndwidlo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bndwidlo, submessage_arena);
    }

  } else {

  }
  _impl_.bndwidlo_ = bndwidlo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.BndWidLo)
}

// .commonmodule.PhaseSPS DirCtlRev = 5;
inline bool RegulatorEventAndStatusATCC::_internal_has_dirctlrev() const {
  return this != internal_default_instance() && _impl_.dirctlrev_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_dirctlrev() const {
  return _internal_has_dirctlrev();
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_dirctlrev() const {
  const ::commonmodule::PhaseSPS* p = _impl_.dirctlrev_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::dirctlrev() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
  return _internal_dirctlrev();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_dirctlrev(
    ::commonmodule::PhaseSPS* dirctlrev) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirctlrev_);
  }
  _impl_.dirctlrev_ = dirctlrev;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::release_dirctlrev() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.dirctlrev_;
  _impl_.dirctlrev_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_dirctlrev() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
  
  ::commonmodule::PhaseSPS* temp = _impl_.dirctlrev_;
  _impl_.dirctlrev_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::_internal_mutable_dirctlrev() {
  
  if (_impl_.dirctlrev_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.dirctlrev_ = p;
  }
  return _impl_.dirctlrev_;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::mutable_dirctlrev() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_dirctlrev();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_dirctlrev(::commonmodule::PhaseSPS* dirctlrev) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirctlrev_);
  }
  if (dirctlrev) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirctlrev));
    if (message_arena != submessage_arena) {
      dirctlrev = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirctlrev, submessage_arena);
    }

  } else {

  }
  _impl_.dirctlrev_ = dirctlrev;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirCtlRev)
}

// .commonmodule.PhaseSPS DirIndt = 6;
inline bool RegulatorEventAndStatusATCC::_internal_has_dirindt() const {
  return this != internal_default_instance() && _impl_.dirindt_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_dirindt() const {
  return _internal_has_dirindt();
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_dirindt() const {
  const ::commonmodule::PhaseSPS* p = _impl_.dirindt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::dirindt() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
  return _internal_dirindt();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_dirindt(
    ::commonmodule::PhaseSPS* dirindt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirindt_);
  }
  _impl_.dirindt_ = dirindt;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::release_dirindt() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.dirindt_;
  _impl_.dirindt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_dirindt() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
  
  ::commonmodule::PhaseSPS* temp = _impl_.dirindt_;
  _impl_.dirindt_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::_internal_mutable_dirindt() {
  
  if (_impl_.dirindt_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.dirindt_ = p;
  }
  return _impl_.dirindt_;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::mutable_dirindt() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_dirindt();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_dirindt(::commonmodule::PhaseSPS* dirindt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirindt_);
  }
  if (dirindt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirindt));
    if (message_arena != submessage_arena) {
      dirindt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirindt, submessage_arena);
    }

  } else {

  }
  _impl_.dirindt_ = dirindt;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirIndt)
}

// .commonmodule.PhaseSPS DirRev = 7;
inline bool RegulatorEventAndStatusATCC::_internal_has_dirrev() const {
  return this != internal_default_instance() && _impl_.dirrev_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_dirrev() const {
  return _internal_has_dirrev();
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_dirrev() const {
  const ::commonmodule::PhaseSPS* p = _impl_.dirrev_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::dirrev() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
  return _internal_dirrev();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_dirrev(
    ::commonmodule::PhaseSPS* dirrev) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirrev_);
  }
  _impl_.dirrev_ = dirrev;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::release_dirrev() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_dirrev() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
  
  ::commonmodule::PhaseSPS* temp = _impl_.dirrev_;
  _impl_.dirrev_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::_internal_mutable_dirrev() {
  
  if (_impl_.dirrev_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.dirrev_ = p;
  }
  return _impl_.dirrev_;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::mutable_dirrev() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_dirrev();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_dirrev(::commonmodule::PhaseSPS* dirrev) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirrev_);
  }
  if (dirrev) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirrev));
    if (message_arena != submessage_arena) {
      dirrev = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirrev, submessage_arena);
    }

  } else {

  }
  _impl_.dirrev_ = dirrev;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.DirRev)
}

// .commonmodule.ASG LDCR = 8;
inline bool RegulatorEventAndStatusATCC::_internal_has_ldcr() const {
  return this != internal_default_instance() && _impl_.ldcr_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_ldcr() const {
  return _internal_has_ldcr();
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_ldcr() const {
  const ::commonmodule::ASG* p = _impl_.ldcr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::ldcr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  return _internal_ldcr();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_ldcr(
    ::commonmodule::ASG* ldcr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcr_);
  }
  _impl_.ldcr_ = ldcr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_ldcr() {
  
  ::commonmodule::ASG* temp = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::unsafe_arena_release_ldcr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  
  ::commonmodule::ASG* temp = _impl_.ldcr_;
  _impl_.ldcr_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::_internal_mutable_ldcr() {
  
  if (_impl_.ldcr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.ldcr_ = p;
  }
  return _impl_.ldcr_;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_ldcr() {
  ::commonmodule::ASG* _msg = _internal_mutable_ldcr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ldcr(::commonmodule::ASG* ldcr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcr_);
  }
  if (ldcr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldcr));
    if (message_arena != submessage_arena) {
      ldcr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldcr, submessage_arena);
    }

  } else {

  }
  _impl_.ldcr_ = ldcr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCR)
}

// .commonmodule.ASG LDCX = 9;
inline bool RegulatorEventAndStatusATCC::_internal_has_ldcx() const {
  return this != internal_default_instance() && _impl_.ldcx_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_ldcx() const {
  return _internal_has_ldcx();
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::_internal_ldcx() const {
  const ::commonmodule::ASG* p = _impl_.ldcx_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ASG&>(
      ::commonmodule::_ASG_default_instance_);
}
inline const ::commonmodule::ASG& RegulatorEventAndStatusATCC::ldcx() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  return _internal_ldcx();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_ldcx(
    ::commonmodule::ASG* ldcx) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcx_);
  }
  _impl_.ldcx_ = ldcx;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::release_ldcx() {
  
  ::commonmodule::ASG* temp = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::unsafe_arena_release_ldcx() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  
  ::commonmodule::ASG* temp = _impl_.ldcx_;
  _impl_.ldcx_ = nullptr;
  return temp;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::_internal_mutable_ldcx() {
  
  if (_impl_.ldcx_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ASG>(GetArenaForAllocation());
    _impl_.ldcx_ = p;
  }
  return _impl_.ldcx_;
}
inline ::commonmodule::ASG* RegulatorEventAndStatusATCC::mutable_ldcx() {
  ::commonmodule::ASG* _msg = _internal_mutable_ldcx();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ldcx(::commonmodule::ASG* ldcx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ldcx_);
  }
  if (ldcx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldcx));
    if (message_arena != submessage_arena) {
      ldcx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldcx, submessage_arena);
    }

  } else {

  }
  _impl_.ldcx_ = ldcx;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.LDCX)
}

// .commonmodule.StatusSPS ParOp = 10;
inline bool RegulatorEventAndStatusATCC::_internal_has_parop() const {
  return this != internal_default_instance() && _impl_.parop_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_parop() const {
  return _internal_has_parop();
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::_internal_parop() const {
  const ::commonmodule::StatusSPS* p = _impl_.parop_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::parop() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  return _internal_parop();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_parop(
    ::commonmodule::StatusSPS* parop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parop_);
  }
  _impl_.parop_ = parop;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::release_parop() {
  
  ::commonmodule::StatusSPS* temp = _impl_.parop_;
  _impl_.parop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_parop() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  
  ::commonmodule::StatusSPS* temp = _impl_.parop_;
  _impl_.parop_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::_internal_mutable_parop() {
  
  if (_impl_.parop_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.parop_ = p;
  }
  return _impl_.parop_;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::mutable_parop() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_parop();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_parop(::commonmodule::StatusSPS* parop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parop_);
  }
  if (parop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parop));
    if (message_arena != submessage_arena) {
      parop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parop, submessage_arena);
    }

  } else {

  }
  _impl_.parop_ = parop;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.ParOp)
}

// .commonmodule.RampRate rampRates = 11;
inline bool RegulatorEventAndStatusATCC::_internal_has_ramprates() const {
  return this != internal_default_instance() && _impl_.ramprates_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_ramprates() const {
  return _internal_has_ramprates();
}
inline const ::commonmodule::RampRate& RegulatorEventAndStatusATCC::_internal_ramprates() const {
  const ::commonmodule::RampRate* p = _impl_.ramprates_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::RampRate&>(
      ::commonmodule::_RampRate_default_instance_);
}
inline const ::commonmodule::RampRate& RegulatorEventAndStatusATCC::ramprates() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
  return _internal_ramprates();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_ramprates(
    ::commonmodule::RampRate* ramprates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
}
inline ::commonmodule::RampRate* RegulatorEventAndStatusATCC::release_ramprates() {
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::RampRate* RegulatorEventAndStatusATCC::unsafe_arena_release_ramprates() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
  
  ::commonmodule::RampRate* temp = _impl_.ramprates_;
  _impl_.ramprates_ = nullptr;
  return temp;
}
inline ::commonmodule::RampRate* RegulatorEventAndStatusATCC::_internal_mutable_ramprates() {
  
  if (_impl_.ramprates_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::RampRate>(GetArenaForAllocation());
    _impl_.ramprates_ = p;
  }
  return _impl_.ramprates_;
}
inline ::commonmodule::RampRate* RegulatorEventAndStatusATCC::mutable_ramprates() {
  ::commonmodule::RampRate* _msg = _internal_mutable_ramprates();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_ramprates(::commonmodule::RampRate* ramprates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ramprates_);
  }
  if (ramprates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ramprates));
    if (message_arena != submessage_arena) {
      ramprates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ramprates, submessage_arena);
    }

  } else {

  }
  _impl_.ramprates_ = ramprates;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.rampRates)
}

// .commonmodule.Optional_StateKind state = 12;
inline bool RegulatorEventAndStatusATCC::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_state() const {
  return _internal_has_state();
}
inline const ::commonmodule::Optional_StateKind& RegulatorEventAndStatusATCC::_internal_state() const {
  const ::commonmodule::Optional_StateKind* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::Optional_StateKind&>(
      ::commonmodule::_Optional_StateKind_default_instance_);
}
inline const ::commonmodule::Optional_StateKind& RegulatorEventAndStatusATCC::state() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.state)
  return _internal_state();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_state(
    ::commonmodule::Optional_StateKind* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.state)
}
inline ::commonmodule::Optional_StateKind* RegulatorEventAndStatusATCC::release_state() {
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::Optional_StateKind* RegulatorEventAndStatusATCC::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.state)
  
  ::commonmodule::Optional_StateKind* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::commonmodule::Optional_StateKind* RegulatorEventAndStatusATCC::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::Optional_StateKind>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::commonmodule::Optional_StateKind* RegulatorEventAndStatusATCC::mutable_state() {
  ::commonmodule::Optional_StateKind* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.state)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_state(::commonmodule::Optional_StateKind* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }

  } else {

  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.state)
}

// .commonmodule.StatusINC StDlTmms = 13;
inline bool RegulatorEventAndStatusATCC::_internal_has_stdltmms() const {
  return this != internal_default_instance() && _impl_.stdltmms_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_stdltmms() const {
  return _internal_has_stdltmms();
}
inline const ::commonmodule::StatusINC& RegulatorEventAndStatusATCC::_internal_stdltmms() const {
  const ::commonmodule::StatusINC* p = _impl_.stdltmms_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusINC&>(
      ::commonmodule::_StatusINC_default_instance_);
}
inline const ::commonmodule::StatusINC& RegulatorEventAndStatusATCC::stdltmms() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
  return _internal_stdltmms();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_stdltmms(
    ::commonmodule::StatusINC* stdltmms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stdltmms_);
  }
  _impl_.stdltmms_ = stdltmms;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
}
inline ::commonmodule::StatusINC* RegulatorEventAndStatusATCC::release_stdltmms() {
  
  ::commonmodule::StatusINC* temp = _impl_.stdltmms_;
  _impl_.stdltmms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusINC* RegulatorEventAndStatusATCC::unsafe_arena_release_stdltmms() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
  
  ::commonmodule::StatusINC* temp = _impl_.stdltmms_;
  _impl_.stdltmms_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusINC* RegulatorEventAndStatusATCC::_internal_mutable_stdltmms() {
  
  if (_impl_.stdltmms_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusINC>(GetArenaForAllocation());
    _impl_.stdltmms_ = p;
  }
  return _impl_.stdltmms_;
}
inline ::commonmodule::StatusINC* RegulatorEventAndStatusATCC::mutable_stdltmms() {
  ::commonmodule::StatusINC* _msg = _internal_mutable_stdltmms();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_stdltmms(::commonmodule::StatusINC* stdltmms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stdltmms_);
  }
  if (stdltmms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stdltmms));
    if (message_arena != submessage_arena) {
      stdltmms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stdltmms, submessage_arena);
    }

  } else {

  }
  _impl_.stdltmms_ = stdltmms;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.StDlTmms)
}

// .commonmodule.StatusSPS TapOpErr = 14;
inline bool RegulatorEventAndStatusATCC::_internal_has_tapoperr() const {
  return this != internal_default_instance() && _impl_.tapoperr_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_tapoperr() const {
  return _internal_has_tapoperr();
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::_internal_tapoperr() const {
  const ::commonmodule::StatusSPS* p = _impl_.tapoperr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::tapoperr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  return _internal_tapoperr();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_tapoperr(
    ::commonmodule::StatusSPS* tapoperr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tapoperr_);
  }
  _impl_.tapoperr_ = tapoperr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::release_tapoperr() {
  
  ::commonmodule::StatusSPS* temp = _impl_.tapoperr_;
  _impl_.tapoperr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_tapoperr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  
  ::commonmodule::StatusSPS* temp = _impl_.tapoperr_;
  _impl_.tapoperr_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::_internal_mutable_tapoperr() {
  
  if (_impl_.tapoperr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.tapoperr_ = p;
  }
  return _impl_.tapoperr_;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::mutable_tapoperr() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_tapoperr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_tapoperr(::commonmodule::StatusSPS* tapoperr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tapoperr_);
  }
  if (tapoperr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tapoperr));
    if (message_arena != submessage_arena) {
      tapoperr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tapoperr, submessage_arena);
    }

  } else {

  }
  _impl_.tapoperr_ = tapoperr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapOpErr)
}

// .commonmodule.PhaseINS TapPos = 15;
inline bool RegulatorEventAndStatusATCC::_internal_has_tappos() const {
  return this != internal_default_instance() && _impl_.tappos_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_tappos() const {
  return _internal_has_tappos();
}
inline const ::commonmodule::PhaseINS& RegulatorEventAndStatusATCC::_internal_tappos() const {
  const ::commonmodule::PhaseINS* p = _impl_.tappos_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseINS&>(
      ::commonmodule::_PhaseINS_default_instance_);
}
inline const ::commonmodule::PhaseINS& RegulatorEventAndStatusATCC::tappos() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  return _internal_tappos();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_tappos(
    ::commonmodule::PhaseINS* tappos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tappos_);
  }
  _impl_.tappos_ = tappos;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
}
inline ::commonmodule::PhaseINS* RegulatorEventAndStatusATCC::release_tappos() {
  
  ::commonmodule::PhaseINS* temp = _impl_.tappos_;
  _impl_.tappos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseINS* RegulatorEventAndStatusATCC::unsafe_arena_release_tappos() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  
  ::commonmodule::PhaseINS* temp = _impl_.tappos_;
  _impl_.tappos_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseINS* RegulatorEventAndStatusATCC::_internal_mutable_tappos() {
  
  if (_impl_.tappos_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseINS>(GetArenaForAllocation());
    _impl_.tappos_ = p;
  }
  return _impl_.tappos_;
}
inline ::commonmodule::PhaseINS* RegulatorEventAndStatusATCC::mutable_tappos() {
  ::commonmodule::PhaseINS* _msg = _internal_mutable_tappos();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_tappos(::commonmodule::PhaseINS* tappos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tappos_);
  }
  if (tappos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tappos));
    if (message_arena != submessage_arena) {
      tappos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tappos, submessage_arena);
    }

  } else {

  }
  _impl_.tappos_ = tappos;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.TapPos)
}

// .commonmodule.PhaseSPS VolLmtHi = 16;
inline bool RegulatorEventAndStatusATCC::_internal_has_vollmthi() const {
  return this != internal_default_instance() && _impl_.vollmthi_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_vollmthi() const {
  return _internal_has_vollmthi();
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_vollmthi() const {
  const ::commonmodule::PhaseSPS* p = _impl_.vollmthi_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::vollmthi() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
  return _internal_vollmthi();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_vollmthi(
    ::commonmodule::PhaseSPS* vollmthi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmthi_);
  }
  _impl_.vollmthi_ = vollmthi;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::release_vollmthi() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_vollmthi() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
  
  ::commonmodule::PhaseSPS* temp = _impl_.vollmthi_;
  _impl_.vollmthi_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::_internal_mutable_vollmthi() {
  
  if (_impl_.vollmthi_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.vollmthi_ = p;
  }
  return _impl_.vollmthi_;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::mutable_vollmthi() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_vollmthi();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_vollmthi(::commonmodule::PhaseSPS* vollmthi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmthi_);
  }
  if (vollmthi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vollmthi));
    if (message_arena != submessage_arena) {
      vollmthi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vollmthi, submessage_arena);
    }

  } else {

  }
  _impl_.vollmthi_ = vollmthi;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtHi)
}

// .commonmodule.PhaseSPS VolLmtLo = 17;
inline bool RegulatorEventAndStatusATCC::_internal_has_vollmtlo() const {
  return this != internal_default_instance() && _impl_.vollmtlo_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_vollmtlo() const {
  return _internal_has_vollmtlo();
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::_internal_vollmtlo() const {
  const ::commonmodule::PhaseSPS* p = _impl_.vollmtlo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseSPS&>(
      ::commonmodule::_PhaseSPS_default_instance_);
}
inline const ::commonmodule::PhaseSPS& RegulatorEventAndStatusATCC::vollmtlo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
  return _internal_vollmtlo();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_vollmtlo(
    ::commonmodule::PhaseSPS* vollmtlo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmtlo_);
  }
  _impl_.vollmtlo_ = vollmtlo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::release_vollmtlo() {
  
  ::commonmodule::PhaseSPS* temp = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_vollmtlo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
  
  ::commonmodule::PhaseSPS* temp = _impl_.vollmtlo_;
  _impl_.vollmtlo_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::_internal_mutable_vollmtlo() {
  
  if (_impl_.vollmtlo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseSPS>(GetArenaForAllocation());
    _impl_.vollmtlo_ = p;
  }
  return _impl_.vollmtlo_;
}
inline ::commonmodule::PhaseSPS* RegulatorEventAndStatusATCC::mutable_vollmtlo() {
  ::commonmodule::PhaseSPS* _msg = _internal_mutable_vollmtlo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_vollmtlo(::commonmodule::PhaseSPS* vollmtlo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vollmtlo_);
  }
  if (vollmtlo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vollmtlo));
    if (message_arena != submessage_arena) {
      vollmtlo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vollmtlo, submessage_arena);
    }

  } else {

  }
  _impl_.vollmtlo_ = vollmtlo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolLmtLo)
}

// .commonmodule.PhaseAPC VolSpt = 18;
inline bool RegulatorEventAndStatusATCC::_internal_has_volspt() const {
  return this != internal_default_instance() && _impl_.volspt_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_volspt() const {
  return _internal_has_volspt();
}
inline const ::commonmodule::PhaseAPC& RegulatorEventAndStatusATCC::_internal_volspt() const {
  const ::commonmodule::PhaseAPC* p = _impl_.volspt_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseAPC&>(
      ::commonmodule::_PhaseAPC_default_instance_);
}
inline const ::commonmodule::PhaseAPC& RegulatorEventAndStatusATCC::volspt() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
  return _internal_volspt();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_volspt(
    ::commonmodule::PhaseAPC* volspt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volspt_);
  }
  _impl_.volspt_ = volspt;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
}
inline ::commonmodule::PhaseAPC* RegulatorEventAndStatusATCC::release_volspt() {
  
  ::commonmodule::PhaseAPC* temp = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorEventAndStatusATCC::unsafe_arena_release_volspt() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
  
  ::commonmodule::PhaseAPC* temp = _impl_.volspt_;
  _impl_.volspt_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseAPC* RegulatorEventAndStatusATCC::_internal_mutable_volspt() {
  
  if (_impl_.volspt_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseAPC>(GetArenaForAllocation());
    _impl_.volspt_ = p;
  }
  return _impl_.volspt_;
}
inline ::commonmodule::PhaseAPC* RegulatorEventAndStatusATCC::mutable_volspt() {
  ::commonmodule::PhaseAPC* _msg = _internal_mutable_volspt();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_volspt(::commonmodule::PhaseAPC* volspt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volspt_);
  }
  if (volspt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volspt));
    if (message_arena != submessage_arena) {
      volspt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volspt, submessage_arena);
    }

  } else {

  }
  _impl_.volspt_ = volspt;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.VolSpt)
}

// .commonmodule.StatusSPS voltageSetPointEnabled = 19;
inline bool RegulatorEventAndStatusATCC::_internal_has_voltagesetpointenabled() const {
  return this != internal_default_instance() && _impl_.voltagesetpointenabled_ != nullptr;
}
inline bool RegulatorEventAndStatusATCC::has_voltagesetpointenabled() const {
  return _internal_has_voltagesetpointenabled();
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::_internal_voltagesetpointenabled() const {
  const ::commonmodule::StatusSPS* p = _impl_.voltagesetpointenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusSPS&>(
      ::commonmodule::_StatusSPS_default_instance_);
}
inline const ::commonmodule::StatusSPS& RegulatorEventAndStatusATCC::voltagesetpointenabled() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
  return _internal_voltagesetpointenabled();
}
inline void RegulatorEventAndStatusATCC::unsafe_arena_set_allocated_voltagesetpointenabled(
    ::commonmodule::StatusSPS* voltagesetpointenabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::release_voltagesetpointenabled() {
  
  ::commonmodule::StatusSPS* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::unsafe_arena_release_voltagesetpointenabled() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
  
  ::commonmodule::StatusSPS* temp = _impl_.voltagesetpointenabled_;
  _impl_.voltagesetpointenabled_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::_internal_mutable_voltagesetpointenabled() {
  
  if (_impl_.voltagesetpointenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusSPS>(GetArenaForAllocation());
    _impl_.voltagesetpointenabled_ = p;
  }
  return _impl_.voltagesetpointenabled_;
}
inline ::commonmodule::StatusSPS* RegulatorEventAndStatusATCC::mutable_voltagesetpointenabled() {
  ::commonmodule::StatusSPS* _msg = _internal_mutable_voltagesetpointenabled();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
  return _msg;
}
inline void RegulatorEventAndStatusATCC::set_allocated_voltagesetpointenabled(::commonmodule::StatusSPS* voltagesetpointenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voltagesetpointenabled_);
  }
  if (voltagesetpointenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesetpointenabled));
    if (message_arena != submessage_arena) {
      voltagesetpointenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesetpointenabled, submessage_arena);
    }

  } else {

  }
  _impl_.voltagesetpointenabled_ = voltagesetpointenabled;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusATCC.voltageSetPointEnabled)
}

// -------------------------------------------------------------------

// RegulatorEventAndStatusANCR

// .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEventAndStatusANCR::_internal_has_logicalnodeforeventandstatus() const {
  return this != internal_default_instance() && _impl_.logicalnodeforeventandstatus_ != nullptr;
}
inline bool RegulatorEventAndStatusANCR::has_logicalnodeforeventandstatus() const {
  return _internal_has_logicalnodeforeventandstatus();
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& RegulatorEventAndStatusANCR::_internal_logicalnodeforeventandstatus() const {
  const ::commonmodule::LogicalNodeForEventAndStatus* p = _impl_.logicalnodeforeventandstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::LogicalNodeForEventAndStatus&>(
      ::commonmodule::_LogicalNodeForEventAndStatus_default_instance_);
}
inline const ::commonmodule::LogicalNodeForEventAndStatus& RegulatorEventAndStatusANCR::logicalnodeforeventandstatus() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  return _internal_logicalnodeforeventandstatus();
}
inline void RegulatorEventAndStatusANCR::unsafe_arena_set_allocated_logicalnodeforeventandstatus(
    ::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
}
inline ::commonmodule::LogicalNodeForEventAndStatus* RegulatorEventAndStatusANCR::release_logicalnodeforeventandstatus() {
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* RegulatorEventAndStatusANCR::unsafe_arena_release_logicalnodeforeventandstatus() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  
  ::commonmodule::LogicalNodeForEventAndStatus* temp = _impl_.logicalnodeforeventandstatus_;
  _impl_.logicalnodeforeventandstatus_ = nullptr;
  return temp;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* RegulatorEventAndStatusANCR::_internal_mutable_logicalnodeforeventandstatus() {
  
  if (_impl_.logicalnodeforeventandstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::LogicalNodeForEventAndStatus>(GetArenaForAllocation());
    _impl_.logicalnodeforeventandstatus_ = p;
  }
  return _impl_.logicalnodeforeventandstatus_;
}
inline ::commonmodule::LogicalNodeForEventAndStatus* RegulatorEventAndStatusANCR::mutable_logicalnodeforeventandstatus() {
  ::commonmodule::LogicalNodeForEventAndStatus* _msg = _internal_mutable_logicalnodeforeventandstatus();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
  return _msg;
}
inline void RegulatorEventAndStatusANCR::set_allocated_logicalnodeforeventandstatus(::commonmodule::LogicalNodeForEventAndStatus* logicalnodeforeventandstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logicalnodeforeventandstatus_);
  }
  if (logicalnodeforeventandstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logicalnodeforeventandstatus));
    if (message_arena != submessage_arena) {
      logicalnodeforeventandstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logicalnodeforeventandstatus, submessage_arena);
    }

  } else {

  }
  _impl_.logicalnodeforeventandstatus_ = logicalnodeforeventandstatus;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.logicalNodeForEventAndStatus)
}

// .commonmodule.ENS_DynamicTestKind DynamicTest = 2;
inline bool RegulatorEventAndStatusANCR::_internal_has_dynamictest() const {
  return this != internal_default_instance() && _impl_.dynamictest_ != nullptr;
}
inline bool RegulatorEventAndStatusANCR::has_dynamictest() const {
  return _internal_has_dynamictest();
}
inline const ::commonmodule::ENS_DynamicTestKind& RegulatorEventAndStatusANCR::_internal_dynamictest() const {
  const ::commonmodule::ENS_DynamicTestKind* p = _impl_.dynamictest_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ENS_DynamicTestKind&>(
      ::commonmodule::_ENS_DynamicTestKind_default_instance_);
}
inline const ::commonmodule::ENS_DynamicTestKind& RegulatorEventAndStatusANCR::dynamictest() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  return _internal_dynamictest();
}
inline void RegulatorEventAndStatusANCR::unsafe_arena_set_allocated_dynamictest(
    ::commonmodule::ENS_DynamicTestKind* dynamictest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
}
inline ::commonmodule::ENS_DynamicTestKind* RegulatorEventAndStatusANCR::release_dynamictest() {
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* RegulatorEventAndStatusANCR::unsafe_arena_release_dynamictest() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  
  ::commonmodule::ENS_DynamicTestKind* temp = _impl_.dynamictest_;
  _impl_.dynamictest_ = nullptr;
  return temp;
}
inline ::commonmodule::ENS_DynamicTestKind* RegulatorEventAndStatusANCR::_internal_mutable_dynamictest() {
  
  if (_impl_.dynamictest_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ENS_DynamicTestKind>(GetArenaForAllocation());
    _impl_.dynamictest_ = p;
  }
  return _impl_.dynamictest_;
}
inline ::commonmodule::ENS_DynamicTestKind* RegulatorEventAndStatusANCR::mutable_dynamictest() {
  ::commonmodule::ENS_DynamicTestKind* _msg = _internal_mutable_dynamictest();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
  return _msg;
}
inline void RegulatorEventAndStatusANCR::set_allocated_dynamictest(::commonmodule::ENS_DynamicTestKind* dynamictest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dynamictest_);
  }
  if (dynamictest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamictest));
    if (message_arena != submessage_arena) {
      dynamictest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamictest, submessage_arena);
    }

  } else {

  }
  _impl_.dynamictest_ = dynamictest;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.DynamicTest)
}

// .regulatormodule.RegulatorEventAndStatusATCC PointStatus = 3;
inline bool RegulatorEventAndStatusANCR::_internal_has_pointstatus() const {
  return this != internal_default_instance() && _impl_.pointstatus_ != nullptr;
}
inline bool RegulatorEventAndStatusANCR::has_pointstatus() const {
  return _internal_has_pointstatus();
}
inline void RegulatorEventAndStatusANCR::clear_pointstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.pointstatus_ != nullptr) {
    delete _impl_.pointstatus_;
  }
  _impl_.pointstatus_ = nullptr;
}
inline const ::regulatormodule::RegulatorEventAndStatusATCC& RegulatorEventAndStatusANCR::_internal_pointstatus() const {
  const ::regulatormodule::RegulatorEventAndStatusATCC* p = _impl_.pointstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusATCC&>(
      ::regulatormodule::_RegulatorEventAndStatusATCC_default_instance_);
}
inline const ::regulatormodule::RegulatorEventAndStatusATCC& RegulatorEventAndStatusANCR::pointstatus() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  return _internal_pointstatus();
}
inline void RegulatorEventAndStatusANCR::unsafe_arena_set_allocated_pointstatus(
    ::regulatormodule::RegulatorEventAndStatusATCC* pointstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointstatus_);
  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* RegulatorEventAndStatusANCR::release_pointstatus() {
  
  ::regulatormodule::RegulatorEventAndStatusATCC* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* RegulatorEventAndStatusANCR::unsafe_arena_release_pointstatus() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  
  ::regulatormodule::RegulatorEventAndStatusATCC* temp = _impl_.pointstatus_;
  _impl_.pointstatus_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* RegulatorEventAndStatusANCR::_internal_mutable_pointstatus() {
  
  if (_impl_.pointstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusATCC>(GetArenaForAllocation());
    _impl_.pointstatus_ = p;
  }
  return _impl_.pointstatus_;
}
inline ::regulatormodule::RegulatorEventAndStatusATCC* RegulatorEventAndStatusANCR::mutable_pointstatus() {
  ::regulatormodule::RegulatorEventAndStatusATCC* _msg = _internal_mutable_pointstatus();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
  return _msg;
}
inline void RegulatorEventAndStatusANCR::set_allocated_pointstatus(::regulatormodule::RegulatorEventAndStatusATCC* pointstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pointstatus_;
  }
  if (pointstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pointstatus);
    if (message_arena != submessage_arena) {
      pointstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointstatus, submessage_arena);
    }

  } else {

  }
  _impl_.pointstatus_ = pointstatus;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventAndStatusANCR.PointStatus)
}

// -------------------------------------------------------------------

// RegulatorEvent

// .commonmodule.EventValue eventValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEvent::_internal_has_eventvalue() const {
  return this != internal_default_instance() && _impl_.eventvalue_ != nullptr;
}
inline bool RegulatorEvent::has_eventvalue() const {
  return _internal_has_eventvalue();
}
inline const ::commonmodule::EventValue& RegulatorEvent::_internal_eventvalue() const {
  const ::commonmodule::EventValue* p = _impl_.eventvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventValue&>(
      ::commonmodule::_EventValue_default_instance_);
}
inline const ::commonmodule::EventValue& RegulatorEvent::eventvalue() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEvent.eventValue)
  return _internal_eventvalue();
}
inline void RegulatorEvent::unsafe_arena_set_allocated_eventvalue(
    ::commonmodule::EventValue* eventvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEvent.eventValue)
}
inline ::commonmodule::EventValue* RegulatorEvent::release_eventvalue() {
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventValue* RegulatorEvent::unsafe_arena_release_eventvalue() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEvent.eventValue)
  
  ::commonmodule::EventValue* temp = _impl_.eventvalue_;
  _impl_.eventvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::EventValue* RegulatorEvent::_internal_mutable_eventvalue() {
  
  if (_impl_.eventvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventValue>(GetArenaForAllocation());
    _impl_.eventvalue_ = p;
  }
  return _impl_.eventvalue_;
}
inline ::commonmodule::EventValue* RegulatorEvent::mutable_eventvalue() {
  ::commonmodule::EventValue* _msg = _internal_mutable_eventvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEvent.eventValue)
  return _msg;
}
inline void RegulatorEvent::set_allocated_eventvalue(::commonmodule::EventValue* eventvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventvalue_);
  }
  if (eventvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventvalue));
    if (message_arena != submessage_arena) {
      eventvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventvalue, submessage_arena);
    }

  } else {

  }
  _impl_.eventvalue_ = eventvalue;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEvent.eventValue)
}

// .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
inline bool RegulatorEvent::_internal_has_regulatoreventandstatusancr() const {
  return this != internal_default_instance() && _impl_.regulatoreventandstatusancr_ != nullptr;
}
inline bool RegulatorEvent::has_regulatoreventandstatusancr() const {
  return _internal_has_regulatoreventandstatusancr();
}
inline void RegulatorEvent::clear_regulatoreventandstatusancr() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatoreventandstatusancr_ != nullptr) {
    delete _impl_.regulatoreventandstatusancr_;
  }
  _impl_.regulatoreventandstatusancr_ = nullptr;
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorEvent::_internal_regulatoreventandstatusancr() const {
  const ::regulatormodule::RegulatorEventAndStatusANCR* p = _impl_.regulatoreventandstatusancr_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusANCR&>(
      ::regulatormodule::_RegulatorEventAndStatusANCR_default_instance_);
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorEvent::regulatoreventandstatusancr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  return _internal_regulatoreventandstatusancr();
}
inline void RegulatorEvent::unsafe_arena_set_allocated_regulatoreventandstatusancr(
    ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatoreventandstatusancr_);
  }
  _impl_.regulatoreventandstatusancr_ = regulatoreventandstatusancr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorEvent::release_regulatoreventandstatusancr() {
  
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorEvent::unsafe_arena_release_regulatoreventandstatusancr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorEvent::_internal_mutable_regulatoreventandstatusancr() {
  
  if (_impl_.regulatoreventandstatusancr_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusANCR>(GetArenaForAllocation());
    _impl_.regulatoreventandstatusancr_ = p;
  }
  return _impl_.regulatoreventandstatusancr_;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorEvent::mutable_regulatoreventandstatusancr() {
  ::regulatormodule::RegulatorEventAndStatusANCR* _msg = _internal_mutable_regulatoreventandstatusancr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
  return _msg;
}
inline void RegulatorEvent::set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatoreventandstatusancr_;
  }
  if (regulatoreventandstatusancr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatoreventandstatusancr);
    if (message_arena != submessage_arena) {
      regulatoreventandstatusancr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatoreventandstatusancr, submessage_arena);
    }

  } else {

  }
  _impl_.regulatoreventandstatusancr_ = regulatoreventandstatusancr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEvent.regulatorEventAndStatusANCR)
}

// -------------------------------------------------------------------

// RegulatorEventProfile

// .commonmodule.EventMessageInfo eventMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorEventProfile::_internal_has_eventmessageinfo() const {
  return this != internal_default_instance() && _impl_.eventmessageinfo_ != nullptr;
}
inline bool RegulatorEventProfile::has_eventmessageinfo() const {
  return _internal_has_eventmessageinfo();
}
inline const ::commonmodule::EventMessageInfo& RegulatorEventProfile::_internal_eventmessageinfo() const {
  const ::commonmodule::EventMessageInfo* p = _impl_.eventmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::EventMessageInfo&>(
      ::commonmodule::_EventMessageInfo_default_instance_);
}
inline const ::commonmodule::EventMessageInfo& RegulatorEventProfile::eventmessageinfo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  return _internal_eventmessageinfo();
}
inline void RegulatorEventProfile::unsafe_arena_set_allocated_eventmessageinfo(
    ::commonmodule::EventMessageInfo* eventmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventProfile.eventMessageInfo)
}
inline ::commonmodule::EventMessageInfo* RegulatorEventProfile::release_eventmessageinfo() {
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::EventMessageInfo* RegulatorEventProfile::unsafe_arena_release_eventmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  
  ::commonmodule::EventMessageInfo* temp = _impl_.eventmessageinfo_;
  _impl_.eventmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::EventMessageInfo* RegulatorEventProfile::_internal_mutable_eventmessageinfo() {
  
  if (_impl_.eventmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::EventMessageInfo>(GetArenaForAllocation());
    _impl_.eventmessageinfo_ = p;
  }
  return _impl_.eventmessageinfo_;
}
inline ::commonmodule::EventMessageInfo* RegulatorEventProfile::mutable_eventmessageinfo() {
  ::commonmodule::EventMessageInfo* _msg = _internal_mutable_eventmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.eventMessageInfo)
  return _msg;
}
inline void RegulatorEventProfile::set_allocated_eventmessageinfo(::commonmodule::EventMessageInfo* eventmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmessageinfo_);
  }
  if (eventmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmessageinfo));
    if (message_arena != submessage_arena) {
      eventmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.eventmessageinfo_ = eventmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.eventMessageInfo)
}

// .regulatormodule.RegulatorEvent regulatorEvent = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventProfile::_internal_has_regulatorevent() const {
  return this != internal_default_instance() && _impl_.regulatorevent_ != nullptr;
}
inline bool RegulatorEventProfile::has_regulatorevent() const {
  return _internal_has_regulatorevent();
}
inline void RegulatorEventProfile::clear_regulatorevent() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorevent_ != nullptr) {
    delete _impl_.regulatorevent_;
  }
  _impl_.regulatorevent_ = nullptr;
}
inline const ::regulatormodule::RegulatorEvent& RegulatorEventProfile::_internal_regulatorevent() const {
  const ::regulatormodule::RegulatorEvent* p = _impl_.regulatorevent_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEvent&>(
      ::regulatormodule::_RegulatorEvent_default_instance_);
}
inline const ::regulatormodule::RegulatorEvent& RegulatorEventProfile::regulatorevent() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.regulatorEvent)
  return _internal_regulatorevent();
}
inline void RegulatorEventProfile::unsafe_arena_set_allocated_regulatorevent(
    ::regulatormodule::RegulatorEvent* regulatorevent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorevent_);
  }
  _impl_.regulatorevent_ = regulatorevent;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventProfile.regulatorEvent)
}
inline ::regulatormodule::RegulatorEvent* RegulatorEventProfile::release_regulatorevent() {
  
  ::regulatormodule::RegulatorEvent* temp = _impl_.regulatorevent_;
  _impl_.regulatorevent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorEvent* RegulatorEventProfile::unsafe_arena_release_regulatorevent() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.regulatorEvent)
  
  ::regulatormodule::RegulatorEvent* temp = _impl_.regulatorevent_;
  _impl_.regulatorevent_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEvent* RegulatorEventProfile::_internal_mutable_regulatorevent() {
  
  if (_impl_.regulatorevent_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEvent>(GetArenaForAllocation());
    _impl_.regulatorevent_ = p;
  }
  return _impl_.regulatorevent_;
}
inline ::regulatormodule::RegulatorEvent* RegulatorEventProfile::mutable_regulatorevent() {
  ::regulatormodule::RegulatorEvent* _msg = _internal_mutable_regulatorevent();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.regulatorEvent)
  return _msg;
}
inline void RegulatorEventProfile::set_allocated_regulatorevent(::regulatormodule::RegulatorEvent* regulatorevent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorevent_;
  }
  if (regulatorevent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorevent);
    if (message_arena != submessage_arena) {
      regulatorevent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorevent, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorevent_ = regulatorevent;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.regulatorEvent)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorEventProfile::_internal_has_regulatorsystem() const {
  return this != internal_default_instance() && _impl_.regulatorsystem_ != nullptr;
}
inline bool RegulatorEventProfile::has_regulatorsystem() const {
  return _internal_has_regulatorsystem();
}
inline void RegulatorEventProfile::clear_regulatorsystem() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorsystem_ != nullptr) {
    delete _impl_.regulatorsystem_;
  }
  _impl_.regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorEventProfile::_internal_regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(
      ::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorEventProfile::regulatorsystem() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorEventProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorEventProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* regulatorsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorEventProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* RegulatorEventProfile::release_regulatorsystem() {
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorEventProfile::unsafe_arena_release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorEventProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorEventProfile::_internal_mutable_regulatorsystem() {
  
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaForAllocation());
    _impl_.regulatorsystem_ = p;
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* RegulatorEventProfile::mutable_regulatorsystem() {
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorEventProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorEventProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorsystem_;
  }
  if (regulatorsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorsystem);
    if (message_arena != submessage_arena) {
      regulatorsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorEventProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorReading

// .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorReading::_internal_has_conductingequipmentterminalreading() const {
  return this != internal_default_instance() && _impl_.conductingequipmentterminalreading_ != nullptr;
}
inline bool RegulatorReading::has_conductingequipmentterminalreading() const {
  return _internal_has_conductingequipmentterminalreading();
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& RegulatorReading::_internal_conductingequipmentterminalreading() const {
  const ::commonmodule::ConductingEquipmentTerminalReading* p = _impl_.conductingequipmentterminalreading_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ConductingEquipmentTerminalReading&>(
      ::commonmodule::_ConductingEquipmentTerminalReading_default_instance_);
}
inline const ::commonmodule::ConductingEquipmentTerminalReading& RegulatorReading::conductingequipmentterminalreading() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  return _internal_conductingequipmentterminalreading();
}
inline void RegulatorReading::unsafe_arena_set_allocated_conductingequipmentterminalreading(
    ::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
}
inline ::commonmodule::ConductingEquipmentTerminalReading* RegulatorReading::release_conductingequipmentterminalreading() {
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* RegulatorReading::unsafe_arena_release_conductingequipmentterminalreading() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  
  ::commonmodule::ConductingEquipmentTerminalReading* temp = _impl_.conductingequipmentterminalreading_;
  _impl_.conductingequipmentterminalreading_ = nullptr;
  return temp;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* RegulatorReading::_internal_mutable_conductingequipmentterminalreading() {
  
  if (_impl_.conductingequipmentterminalreading_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ConductingEquipmentTerminalReading>(GetArenaForAllocation());
    _impl_.conductingequipmentterminalreading_ = p;
  }
  return _impl_.conductingequipmentterminalreading_;
}
inline ::commonmodule::ConductingEquipmentTerminalReading* RegulatorReading::mutable_conductingequipmentterminalreading() {
  ::commonmodule::ConductingEquipmentTerminalReading* _msg = _internal_mutable_conductingequipmentterminalreading();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
  return _msg;
}
inline void RegulatorReading::set_allocated_conductingequipmentterminalreading(::commonmodule::ConductingEquipmentTerminalReading* conductingequipmentterminalreading) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conductingequipmentterminalreading_);
  }
  if (conductingequipmentterminalreading) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conductingequipmentterminalreading));
    if (message_arena != submessage_arena) {
      conductingequipmentterminalreading = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conductingequipmentterminalreading, submessage_arena);
    }

  } else {

  }
  _impl_.conductingequipmentterminalreading_ = conductingequipmentterminalreading;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.conductingEquipmentTerminalReading)
}

// .commonmodule.PhaseMMTN phaseMMTN = 2;
inline bool RegulatorReading::_internal_has_phasemmtn() const {
  return this != internal_default_instance() && _impl_.phasemmtn_ != nullptr;
}
inline bool RegulatorReading::has_phasemmtn() const {
  return _internal_has_phasemmtn();
}
inline const ::commonmodule::PhaseMMTN& RegulatorReading::_internal_phasemmtn() const {
  const ::commonmodule::PhaseMMTN* p = _impl_.phasemmtn_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::PhaseMMTN&>(
      ::commonmodule::_PhaseMMTN_default_instance_);
}
inline const ::commonmodule::PhaseMMTN& RegulatorReading::phasemmtn() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.phaseMMTN)
  return _internal_phasemmtn();
}
inline void RegulatorReading::unsafe_arena_set_allocated_phasemmtn(
    ::commonmodule::PhaseMMTN* phasemmtn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.phaseMMTN)
}
inline ::commonmodule::PhaseMMTN* RegulatorReading::release_phasemmtn() {
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::PhaseMMTN* RegulatorReading::unsafe_arena_release_phasemmtn() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.phaseMMTN)
  
  ::commonmodule::PhaseMMTN* temp = _impl_.phasemmtn_;
  _impl_.phasemmtn_ = nullptr;
  return temp;
}
inline ::commonmodule::PhaseMMTN* RegulatorReading::_internal_mutable_phasemmtn() {
  
  if (_impl_.phasemmtn_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::PhaseMMTN>(GetArenaForAllocation());
    _impl_.phasemmtn_ = p;
  }
  return _impl_.phasemmtn_;
}
inline ::commonmodule::PhaseMMTN* RegulatorReading::mutable_phasemmtn() {
  ::commonmodule::PhaseMMTN* _msg = _internal_mutable_phasemmtn();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.phaseMMTN)
  return _msg;
}
inline void RegulatorReading::set_allocated_phasemmtn(::commonmodule::PhaseMMTN* phasemmtn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.phasemmtn_);
  }
  if (phasemmtn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phasemmtn));
    if (message_arena != submessage_arena) {
      phasemmtn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phasemmtn, submessage_arena);
    }

  } else {

  }
  _impl_.phasemmtn_ = phasemmtn;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.phaseMMTN)
}

// .commonmodule.ReadingMMTR readingMMTR = 3;
inline bool RegulatorReading::_internal_has_readingmmtr() const {
  return this != internal_default_instance() && _impl_.readingmmtr_ != nullptr;
}
inline bool RegulatorReading::has_readingmmtr() const {
  return _internal_has_readingmmtr();
}
inline const ::commonmodule::ReadingMMTR& RegulatorReading::_internal_readingmmtr() const {
  const ::commonmodule::ReadingMMTR* p = _impl_.readingmmtr_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMTR&>(
      ::commonmodule::_ReadingMMTR_default_instance_);
}
inline const ::commonmodule::ReadingMMTR& RegulatorReading::readingmmtr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.readingMMTR)
  return _internal_readingmmtr();
}
inline void RegulatorReading::unsafe_arena_set_allocated_readingmmtr(
    ::commonmodule::ReadingMMTR* readingmmtr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.readingMMTR)
}
inline ::commonmodule::ReadingMMTR* RegulatorReading::release_readingmmtr() {
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMTR* RegulatorReading::unsafe_arena_release_readingmmtr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.readingMMTR)
  
  ::commonmodule::ReadingMMTR* temp = _impl_.readingmmtr_;
  _impl_.readingmmtr_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMTR* RegulatorReading::_internal_mutable_readingmmtr() {
  
  if (_impl_.readingmmtr_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMTR>(GetArenaForAllocation());
    _impl_.readingmmtr_ = p;
  }
  return _impl_.readingmmtr_;
}
inline ::commonmodule::ReadingMMTR* RegulatorReading::mutable_readingmmtr() {
  ::commonmodule::ReadingMMTR* _msg = _internal_mutable_readingmmtr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.readingMMTR)
  return _msg;
}
inline void RegulatorReading::set_allocated_readingmmtr(::commonmodule::ReadingMMTR* readingmmtr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmtr_);
  }
  if (readingmmtr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmtr));
    if (message_arena != submessage_arena) {
      readingmmtr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmtr, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmtr_ = readingmmtr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.readingMMTR)
}

// .commonmodule.ReadingMMXU readingMMXU = 4;
inline bool RegulatorReading::_internal_has_readingmmxu() const {
  return this != internal_default_instance() && _impl_.readingmmxu_ != nullptr;
}
inline bool RegulatorReading::has_readingmmxu() const {
  return _internal_has_readingmmxu();
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::_internal_readingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.readingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::readingmmxu() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.readingMMXU)
  return _internal_readingmmxu();
}
inline void RegulatorReading::unsafe_arena_set_allocated_readingmmxu(
    ::commonmodule::ReadingMMXU* readingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.readingMMXU)
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::release_readingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::unsafe_arena_release_readingmmxu() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.readingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.readingmmxu_;
  _impl_.readingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::_internal_mutable_readingmmxu() {
  
  if (_impl_.readingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.readingmmxu_ = p;
  }
  return _impl_.readingmmxu_;
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::mutable_readingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_readingmmxu();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.readingMMXU)
  return _msg;
}
inline void RegulatorReading::set_allocated_readingmmxu(::commonmodule::ReadingMMXU* readingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmmxu_);
  }
  if (readingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmmxu));
    if (message_arena != submessage_arena) {
      readingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.readingmmxu_ = readingmmxu;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.readingMMXU)
}

// .commonmodule.ReadingMMXU secondaryReadingMMXU = 5;
inline bool RegulatorReading::_internal_has_secondaryreadingmmxu() const {
  return this != internal_default_instance() && _impl_.secondaryreadingmmxu_ != nullptr;
}
inline bool RegulatorReading::has_secondaryreadingmmxu() const {
  return _internal_has_secondaryreadingmmxu();
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::_internal_secondaryreadingmmxu() const {
  const ::commonmodule::ReadingMMXU* p = _impl_.secondaryreadingmmxu_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMMXU&>(
      ::commonmodule::_ReadingMMXU_default_instance_);
}
inline const ::commonmodule::ReadingMMXU& RegulatorReading::secondaryreadingmmxu() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReading.secondaryReadingMMXU)
  return _internal_secondaryreadingmmxu();
}
inline void RegulatorReading::unsafe_arena_set_allocated_secondaryreadingmmxu(
    ::commonmodule::ReadingMMXU* secondaryreadingmmxu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.secondaryreadingmmxu_);
  }
  _impl_.secondaryreadingmmxu_ = secondaryreadingmmxu;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReading.secondaryReadingMMXU)
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::release_secondaryreadingmmxu() {
  
  ::commonmodule::ReadingMMXU* temp = _impl_.secondaryreadingmmxu_;
  _impl_.secondaryreadingmmxu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::unsafe_arena_release_secondaryreadingmmxu() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReading.secondaryReadingMMXU)
  
  ::commonmodule::ReadingMMXU* temp = _impl_.secondaryreadingmmxu_;
  _impl_.secondaryreadingmmxu_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::_internal_mutable_secondaryreadingmmxu() {
  
  if (_impl_.secondaryreadingmmxu_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMMXU>(GetArenaForAllocation());
    _impl_.secondaryreadingmmxu_ = p;
  }
  return _impl_.secondaryreadingmmxu_;
}
inline ::commonmodule::ReadingMMXU* RegulatorReading::mutable_secondaryreadingmmxu() {
  ::commonmodule::ReadingMMXU* _msg = _internal_mutable_secondaryreadingmmxu();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReading.secondaryReadingMMXU)
  return _msg;
}
inline void RegulatorReading::set_allocated_secondaryreadingmmxu(::commonmodule::ReadingMMXU* secondaryreadingmmxu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.secondaryreadingmmxu_);
  }
  if (secondaryreadingmmxu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(secondaryreadingmmxu));
    if (message_arena != submessage_arena) {
      secondaryreadingmmxu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, secondaryreadingmmxu, submessage_arena);
    }

  } else {

  }
  _impl_.secondaryreadingmmxu_ = secondaryreadingmmxu;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReading.secondaryReadingMMXU)
}

// -------------------------------------------------------------------

// RegulatorReadingProfile

// .commonmodule.ReadingMessageInfo readingMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorReadingProfile::_internal_has_readingmessageinfo() const {
  return this != internal_default_instance() && _impl_.readingmessageinfo_ != nullptr;
}
inline bool RegulatorReadingProfile::has_readingmessageinfo() const {
  return _internal_has_readingmessageinfo();
}
inline const ::commonmodule::ReadingMessageInfo& RegulatorReadingProfile::_internal_readingmessageinfo() const {
  const ::commonmodule::ReadingMessageInfo* p = _impl_.readingmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::ReadingMessageInfo&>(
      ::commonmodule::_ReadingMessageInfo_default_instance_);
}
inline const ::commonmodule::ReadingMessageInfo& RegulatorReadingProfile::readingmessageinfo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  return _internal_readingmessageinfo();
}
inline void RegulatorReadingProfile::unsafe_arena_set_allocated_readingmessageinfo(
    ::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
}
inline ::commonmodule::ReadingMessageInfo* RegulatorReadingProfile::release_readingmessageinfo() {
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* RegulatorReadingProfile::unsafe_arena_release_readingmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  
  ::commonmodule::ReadingMessageInfo* temp = _impl_.readingmessageinfo_;
  _impl_.readingmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::ReadingMessageInfo* RegulatorReadingProfile::_internal_mutable_readingmessageinfo() {
  
  if (_impl_.readingmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::ReadingMessageInfo>(GetArenaForAllocation());
    _impl_.readingmessageinfo_ = p;
  }
  return _impl_.readingmessageinfo_;
}
inline ::commonmodule::ReadingMessageInfo* RegulatorReadingProfile::mutable_readingmessageinfo() {
  ::commonmodule::ReadingMessageInfo* _msg = _internal_mutable_readingmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
  return _msg;
}
inline void RegulatorReadingProfile::set_allocated_readingmessageinfo(::commonmodule::ReadingMessageInfo* readingmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.readingmessageinfo_);
  }
  if (readingmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(readingmessageinfo));
    if (message_arena != submessage_arena) {
      readingmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, readingmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.readingmessageinfo_ = readingmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReadingProfile.readingMessageInfo)
}

// repeated .regulatormodule.RegulatorReading regulatorReading = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1, (.uml.option_multiplicity_max) = 2];
inline int RegulatorReadingProfile::_internal_regulatorreading_size() const {
  return _impl_.regulatorreading_.size();
}
inline int RegulatorReadingProfile::regulatorreading_size() const {
  return _internal_regulatorreading_size();
}
inline void RegulatorReadingProfile::clear_regulatorreading() {
  _impl_.regulatorreading_.Clear();
}
inline ::regulatormodule::RegulatorReading* RegulatorReadingProfile::mutable_regulatorreading(int index) {
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _impl_.regulatorreading_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorReading >*
RegulatorReadingProfile::mutable_regulatorreading() {
  // @@protoc_insertion_point(field_mutable_list:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return &_impl_.regulatorreading_;
}
inline const ::regulatormodule::RegulatorReading& RegulatorReadingProfile::_internal_regulatorreading(int index) const {
  return _impl_.regulatorreading_.Get(index);
}
inline const ::regulatormodule::RegulatorReading& RegulatorReadingProfile::regulatorreading(int index) const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _internal_regulatorreading(index);
}
inline ::regulatormodule::RegulatorReading* RegulatorReadingProfile::_internal_add_regulatorreading() {
  return _impl_.regulatorreading_.Add();
}
inline ::regulatormodule::RegulatorReading* RegulatorReadingProfile::add_regulatorreading() {
  ::regulatormodule::RegulatorReading* _add = _internal_add_regulatorreading();
  // @@protoc_insertion_point(field_add:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::regulatormodule::RegulatorReading >&
RegulatorReadingProfile::regulatorreading() const {
  // @@protoc_insertion_point(field_list:regulatormodule.RegulatorReadingProfile.regulatorReading)
  return _impl_.regulatorreading_;
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorReadingProfile::_internal_has_regulatorsystem() const {
  return this != internal_default_instance() && _impl_.regulatorsystem_ != nullptr;
}
inline bool RegulatorReadingProfile::has_regulatorsystem() const {
  return _internal_has_regulatorsystem();
}
inline void RegulatorReadingProfile::clear_regulatorsystem() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorsystem_ != nullptr) {
    delete _impl_.regulatorsystem_;
  }
  _impl_.regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorReadingProfile::_internal_regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(
      ::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorReadingProfile::regulatorsystem() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorReadingProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* regulatorsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorReadingProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* RegulatorReadingProfile::release_regulatorsystem() {
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorReadingProfile::unsafe_arena_release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorReadingProfile::_internal_mutable_regulatorsystem() {
  
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaForAllocation());
    _impl_.regulatorsystem_ = p;
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* RegulatorReadingProfile::mutable_regulatorsystem() {
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorReadingProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorReadingProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorsystem_;
  }
  if (regulatorsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorsystem);
    if (message_arena != submessage_arena) {
      regulatorsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorReadingProfile.regulatorSystem)
}

// -------------------------------------------------------------------

// RegulatorStatus

// .commonmodule.StatusValue statusValue = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorStatus::_internal_has_statusvalue() const {
  return this != internal_default_instance() && _impl_.statusvalue_ != nullptr;
}
inline bool RegulatorStatus::has_statusvalue() const {
  return _internal_has_statusvalue();
}
inline const ::commonmodule::StatusValue& RegulatorStatus::_internal_statusvalue() const {
  const ::commonmodule::StatusValue* p = _impl_.statusvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusValue&>(
      ::commonmodule::_StatusValue_default_instance_);
}
inline const ::commonmodule::StatusValue& RegulatorStatus::statusvalue() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatus.statusValue)
  return _internal_statusvalue();
}
inline void RegulatorStatus::unsafe_arena_set_allocated_statusvalue(
    ::commonmodule::StatusValue* statusvalue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatus.statusValue)
}
inline ::commonmodule::StatusValue* RegulatorStatus::release_statusvalue() {
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusValue* RegulatorStatus::unsafe_arena_release_statusvalue() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatus.statusValue)
  
  ::commonmodule::StatusValue* temp = _impl_.statusvalue_;
  _impl_.statusvalue_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusValue* RegulatorStatus::_internal_mutable_statusvalue() {
  
  if (_impl_.statusvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusValue>(GetArenaForAllocation());
    _impl_.statusvalue_ = p;
  }
  return _impl_.statusvalue_;
}
inline ::commonmodule::StatusValue* RegulatorStatus::mutable_statusvalue() {
  ::commonmodule::StatusValue* _msg = _internal_mutable_statusvalue();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatus.statusValue)
  return _msg;
}
inline void RegulatorStatus::set_allocated_statusvalue(::commonmodule::StatusValue* statusvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusvalue_);
  }
  if (statusvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusvalue));
    if (message_arena != submessage_arena) {
      statusvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusvalue, submessage_arena);
    }

  } else {

  }
  _impl_.statusvalue_ = statusvalue;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatus.statusValue)
}

// .regulatormodule.RegulatorEventAndStatusANCR regulatorEventAndStatusANCR = 2;
inline bool RegulatorStatus::_internal_has_regulatoreventandstatusancr() const {
  return this != internal_default_instance() && _impl_.regulatoreventandstatusancr_ != nullptr;
}
inline bool RegulatorStatus::has_regulatoreventandstatusancr() const {
  return _internal_has_regulatoreventandstatusancr();
}
inline void RegulatorStatus::clear_regulatoreventandstatusancr() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatoreventandstatusancr_ != nullptr) {
    delete _impl_.regulatoreventandstatusancr_;
  }
  _impl_.regulatoreventandstatusancr_ = nullptr;
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorStatus::_internal_regulatoreventandstatusancr() const {
  const ::regulatormodule::RegulatorEventAndStatusANCR* p = _impl_.regulatoreventandstatusancr_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorEventAndStatusANCR&>(
      ::regulatormodule::_RegulatorEventAndStatusANCR_default_instance_);
}
inline const ::regulatormodule::RegulatorEventAndStatusANCR& RegulatorStatus::regulatoreventandstatusancr() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  return _internal_regulatoreventandstatusancr();
}
inline void RegulatorStatus::unsafe_arena_set_allocated_regulatoreventandstatusancr(
    ::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatoreventandstatusancr_);
  }
  _impl_.regulatoreventandstatusancr_ = regulatoreventandstatusancr;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorStatus::release_regulatoreventandstatusancr() {
  
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorStatus::unsafe_arena_release_regulatoreventandstatusancr() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  
  ::regulatormodule::RegulatorEventAndStatusANCR* temp = _impl_.regulatoreventandstatusancr_;
  _impl_.regulatoreventandstatusancr_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorStatus::_internal_mutable_regulatoreventandstatusancr() {
  
  if (_impl_.regulatoreventandstatusancr_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorEventAndStatusANCR>(GetArenaForAllocation());
    _impl_.regulatoreventandstatusancr_ = p;
  }
  return _impl_.regulatoreventandstatusancr_;
}
inline ::regulatormodule::RegulatorEventAndStatusANCR* RegulatorStatus::mutable_regulatoreventandstatusancr() {
  ::regulatormodule::RegulatorEventAndStatusANCR* _msg = _internal_mutable_regulatoreventandstatusancr();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
  return _msg;
}
inline void RegulatorStatus::set_allocated_regulatoreventandstatusancr(::regulatormodule::RegulatorEventAndStatusANCR* regulatoreventandstatusancr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatoreventandstatusancr_;
  }
  if (regulatoreventandstatusancr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatoreventandstatusancr);
    if (message_arena != submessage_arena) {
      regulatoreventandstatusancr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatoreventandstatusancr, submessage_arena);
    }

  } else {

  }
  _impl_.regulatoreventandstatusancr_ = regulatoreventandstatusancr;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatus.regulatorEventAndStatusANCR)
}

// -------------------------------------------------------------------

// RegulatorStatusProfile

// .commonmodule.StatusMessageInfo statusMessageInfo = 1 [(.uml.option_parent_message) = true];
inline bool RegulatorStatusProfile::_internal_has_statusmessageinfo() const {
  return this != internal_default_instance() && _impl_.statusmessageinfo_ != nullptr;
}
inline bool RegulatorStatusProfile::has_statusmessageinfo() const {
  return _internal_has_statusmessageinfo();
}
inline const ::commonmodule::StatusMessageInfo& RegulatorStatusProfile::_internal_statusmessageinfo() const {
  const ::commonmodule::StatusMessageInfo* p = _impl_.statusmessageinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::commonmodule::StatusMessageInfo&>(
      ::commonmodule::_StatusMessageInfo_default_instance_);
}
inline const ::commonmodule::StatusMessageInfo& RegulatorStatusProfile::statusmessageinfo() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  return _internal_statusmessageinfo();
}
inline void RegulatorStatusProfile::unsafe_arena_set_allocated_statusmessageinfo(
    ::commonmodule::StatusMessageInfo* statusmessageinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
}
inline ::commonmodule::StatusMessageInfo* RegulatorStatusProfile::release_statusmessageinfo() {
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commonmodule::StatusMessageInfo* RegulatorStatusProfile::unsafe_arena_release_statusmessageinfo() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  
  ::commonmodule::StatusMessageInfo* temp = _impl_.statusmessageinfo_;
  _impl_.statusmessageinfo_ = nullptr;
  return temp;
}
inline ::commonmodule::StatusMessageInfo* RegulatorStatusProfile::_internal_mutable_statusmessageinfo() {
  
  if (_impl_.statusmessageinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::commonmodule::StatusMessageInfo>(GetArenaForAllocation());
    _impl_.statusmessageinfo_ = p;
  }
  return _impl_.statusmessageinfo_;
}
inline ::commonmodule::StatusMessageInfo* RegulatorStatusProfile::mutable_statusmessageinfo() {
  ::commonmodule::StatusMessageInfo* _msg = _internal_mutable_statusmessageinfo();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
  return _msg;
}
inline void RegulatorStatusProfile::set_allocated_statusmessageinfo(::commonmodule::StatusMessageInfo* statusmessageinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statusmessageinfo_);
  }
  if (statusmessageinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statusmessageinfo));
    if (message_arena != submessage_arena) {
      statusmessageinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statusmessageinfo, submessage_arena);
    }

  } else {

  }
  _impl_.statusmessageinfo_ = statusmessageinfo;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.statusMessageInfo)
}

// .regulatormodule.RegulatorStatus regulatorStatus = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatusProfile::_internal_has_regulatorstatus() const {
  return this != internal_default_instance() && _impl_.regulatorstatus_ != nullptr;
}
inline bool RegulatorStatusProfile::has_regulatorstatus() const {
  return _internal_has_regulatorstatus();
}
inline void RegulatorStatusProfile::clear_regulatorstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorstatus_ != nullptr) {
    delete _impl_.regulatorstatus_;
  }
  _impl_.regulatorstatus_ = nullptr;
}
inline const ::regulatormodule::RegulatorStatus& RegulatorStatusProfile::_internal_regulatorstatus() const {
  const ::regulatormodule::RegulatorStatus* p = _impl_.regulatorstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorStatus&>(
      ::regulatormodule::_RegulatorStatus_default_instance_);
}
inline const ::regulatormodule::RegulatorStatus& RegulatorStatusProfile::regulatorstatus() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  return _internal_regulatorstatus();
}
inline void RegulatorStatusProfile::unsafe_arena_set_allocated_regulatorstatus(
    ::regulatormodule::RegulatorStatus* regulatorstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorstatus_);
  }
  _impl_.regulatorstatus_ = regulatorstatus;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorStatus)
}
inline ::regulatormodule::RegulatorStatus* RegulatorStatusProfile::release_regulatorstatus() {
  
  ::regulatormodule::RegulatorStatus* temp = _impl_.regulatorstatus_;
  _impl_.regulatorstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorStatus* RegulatorStatusProfile::unsafe_arena_release_regulatorstatus() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  
  ::regulatormodule::RegulatorStatus* temp = _impl_.regulatorstatus_;
  _impl_.regulatorstatus_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorStatus* RegulatorStatusProfile::_internal_mutable_regulatorstatus() {
  
  if (_impl_.regulatorstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorStatus>(GetArenaForAllocation());
    _impl_.regulatorstatus_ = p;
  }
  return _impl_.regulatorstatus_;
}
inline ::regulatormodule::RegulatorStatus* RegulatorStatusProfile::mutable_regulatorstatus() {
  ::regulatormodule::RegulatorStatus* _msg = _internal_mutable_regulatorstatus();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.regulatorStatus)
  return _msg;
}
inline void RegulatorStatusProfile::set_allocated_regulatorstatus(::regulatormodule::RegulatorStatus* regulatorstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorstatus_;
  }
  if (regulatorstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorstatus);
    if (message_arena != submessage_arena) {
      regulatorstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorstatus, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorstatus_ = regulatorstatus;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorStatus)
}

// .regulatormodule.RegulatorSystem regulatorSystem = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];
inline bool RegulatorStatusProfile::_internal_has_regulatorsystem() const {
  return this != internal_default_instance() && _impl_.regulatorsystem_ != nullptr;
}
inline bool RegulatorStatusProfile::has_regulatorsystem() const {
  return _internal_has_regulatorsystem();
}
inline void RegulatorStatusProfile::clear_regulatorsystem() {
  if (GetArenaForAllocation() == nullptr && _impl_.regulatorsystem_ != nullptr) {
    delete _impl_.regulatorsystem_;
  }
  _impl_.regulatorsystem_ = nullptr;
}
inline const ::regulatormodule::RegulatorSystem& RegulatorStatusProfile::_internal_regulatorsystem() const {
  const ::regulatormodule::RegulatorSystem* p = _impl_.regulatorsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::regulatormodule::RegulatorSystem&>(
      ::regulatormodule::_RegulatorSystem_default_instance_);
}
inline const ::regulatormodule::RegulatorSystem& RegulatorStatusProfile::regulatorsystem() const {
  // @@protoc_insertion_point(field_get:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  return _internal_regulatorsystem();
}
inline void RegulatorStatusProfile::unsafe_arena_set_allocated_regulatorsystem(
    ::regulatormodule::RegulatorSystem* regulatorsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regulatorsystem_);
  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorSystem)
}
inline ::regulatormodule::RegulatorSystem* RegulatorStatusProfile::release_regulatorsystem() {
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorStatusProfile::unsafe_arena_release_regulatorsystem() {
  // @@protoc_insertion_point(field_release:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  
  ::regulatormodule::RegulatorSystem* temp = _impl_.regulatorsystem_;
  _impl_.regulatorsystem_ = nullptr;
  return temp;
}
inline ::regulatormodule::RegulatorSystem* RegulatorStatusProfile::_internal_mutable_regulatorsystem() {
  
  if (_impl_.regulatorsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::regulatormodule::RegulatorSystem>(GetArenaForAllocation());
    _impl_.regulatorsystem_ = p;
  }
  return _impl_.regulatorsystem_;
}
inline ::regulatormodule::RegulatorSystem* RegulatorStatusProfile::mutable_regulatorsystem() {
  ::regulatormodule::RegulatorSystem* _msg = _internal_mutable_regulatorsystem();
  // @@protoc_insertion_point(field_mutable:regulatormodule.RegulatorStatusProfile.regulatorSystem)
  return _msg;
}
inline void RegulatorStatusProfile::set_allocated_regulatorsystem(::regulatormodule::RegulatorSystem* regulatorsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regulatorsystem_;
  }
  if (regulatorsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regulatorsystem);
    if (message_arena != submessage_arena) {
      regulatorsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regulatorsystem, submessage_arena);
    }

  } else {

  }
  _impl_.regulatorsystem_ = regulatorsystem;
  // @@protoc_insertion_point(field_set_allocated:regulatormodule.RegulatorStatusProfile.regulatorSystem)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace regulatormodule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_regulatormodule_2fregulatormodule_2eproto_2epb_2eh
